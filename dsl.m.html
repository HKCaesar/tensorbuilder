<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>tensorbuilder.dsl API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.dsl.Assert">Assert</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Assert_layer">Assert_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.NoGradient">NoGradient</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.NoGradient_layer">NoGradient_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Print">Print</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Print_layer">Print_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.abs">abs</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.abs_layer">abs_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.accumulate_n">accumulate_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.accumulate_n_layer">accumulate_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.acos">acos</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.acos_layer">acos_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add">add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_check_numerics_ops">add_check_numerics_ops</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_check_numerics_ops_layer">add_check_numerics_ops_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_layer">add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_n">add_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_n_layer">add_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_to_collection">add_to_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.add_to_collection_layer">add_to_collection_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.all_candidate_sampler">all_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.all_candidate_sampler_layer">all_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.all_variables">all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.all_variables_layer">all_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.applicative">applicative</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.arg_max">arg_max</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.arg_max_layer">arg_max_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.arg_min">arg_min</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.arg_min_layer">arg_min_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.argmax_layer">argmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.argmin_layer">argmin_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.as_dtype">as_dtype</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.as_dtype_layer">as_dtype_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.asin">asin</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.asin_layer">asin_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_equal">assert_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_equal_layer">assert_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_integer">assert_integer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_integer_layer">assert_integer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_less">assert_less</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_less_equal">assert_less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_less_equal_layer">assert_less_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_less_layer">assert_less_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_negative">assert_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_negative_layer">assert_negative_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_non_negative">assert_non_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_non_negative_layer">assert_non_negative_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_non_positive">assert_non_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_non_positive_layer">assert_non_positive_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_positive">assert_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_positive_layer">assert_positive_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_proper_iterable">assert_proper_iterable</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_proper_iterable_layer">assert_proper_iterable_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_rank">assert_rank</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_rank_at_least">assert_rank_at_least</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_rank_at_least_layer">assert_rank_at_least_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_rank_layer">assert_rank_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_type">assert_type</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_type_layer">assert_type_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_variables_initialized">assert_variables_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assert_variables_initialized_layer">assert_variables_initialized_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assign">assign</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assign_add">assign_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assign_add_layer">assign_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assign_layer">assign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assign_sub">assign_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.assign_sub_layer">assign_sub_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.atan">atan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.atan_layer">atan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.atrous_conv2d">atrous_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.atrous_conv2d_layer">atrous_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.audio_summary">audio_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.audio_summary_layer">audio_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.avg_pool">avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.avg_pool3d">avg_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.avg_pool3d_grad">avg_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.avg_pool3d_grad_layer">avg_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.avg_pool3d_layer">avg_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.avg_pool_layer">avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_cholesky">batch_cholesky</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_cholesky_layer">batch_cholesky_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_cholesky_solve">batch_cholesky_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_cholesky_solve_layer">batch_cholesky_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_fft">batch_fft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_fft2d">batch_fft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_fft2d_layer">batch_fft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_fft3d">batch_fft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_fft3d_layer">batch_fft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_fft_layer">batch_fft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_ifft">batch_ifft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_ifft2d">batch_ifft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_ifft2d_layer">batch_ifft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_ifft3d">batch_ifft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_ifft3d_layer">batch_ifft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_ifft_layer">batch_ifft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matmul_layer">batch_matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_band_part">batch_matrix_band_part</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_band_part_layer">batch_matrix_band_part_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_determinant">batch_matrix_determinant</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_determinant_layer">batch_matrix_determinant_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_diag">batch_matrix_diag</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_diag_layer">batch_matrix_diag_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_diag_part">batch_matrix_diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_diag_part_layer">batch_matrix_diag_part_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_inverse">batch_matrix_inverse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_inverse_layer">batch_matrix_inverse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_solve">batch_matrix_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_solve_layer">batch_matrix_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_solve_ls">batch_matrix_solve_ls</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_solve_ls_layer">batch_matrix_solve_ls_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_triangular_solve">batch_matrix_triangular_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_matrix_triangular_solve_layer">batch_matrix_triangular_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_norm_with_global_normalization">batch_norm_with_global_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_norm_with_global_normalization_layer">batch_norm_with_global_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_normalization">batch_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_normalization_layer">batch_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_self_adjoint_eig">batch_self_adjoint_eig</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_self_adjoint_eig_layer">batch_self_adjoint_eig_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_to_space">batch_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.batch_to_space_layer">batch_to_space_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bias_add">bias_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bias_add_grad">bias_add_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bias_add_grad_layer">bias_add_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bias_add_layer">bias_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bias_add_v1">bias_add_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bias_add_v1_layer">bias_add_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bidirectional_rnn">bidirectional_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bidirectional_rnn_layer">bidirectional_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bitcast">bitcast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.bitcast_layer">bitcast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.boolean_mask">boolean_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.boolean_mask_layer">boolean_mask_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.branch">branch</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.builders">builders</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.case">case</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.case_layer">case_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cast">cast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cast_layer">cast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ceil">ceil</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ceil_layer">ceil_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.check_numerics">check_numerics</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.check_numerics_layer">check_numerics_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cholesky">cholesky</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cholesky_layer">cholesky_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cholesky_solve">cholesky_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cholesky_solve_layer">cholesky_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_average_norm">clip_by_average_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_average_norm_layer">clip_by_average_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_global_norm">clip_by_global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_global_norm_layer">clip_by_global_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_norm">clip_by_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_norm_layer">clip_by_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_value">clip_by_value</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.clip_by_value_layer">clip_by_value_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.compile">compile</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.complex">complex</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.complex_abs">complex_abs</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.complex_abs_layer">complex_abs_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.complex_layer">complex_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.compute_accidental_hits">compute_accidental_hits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.compute_accidental_hits_layer">compute_accidental_hits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.concat">concat</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.concat_layer">concat_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cond">cond</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cond_layer">cond_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conj">conj</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conj_layer">conj_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.constant">constant</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.constant_initializer">constant_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.constant_initializer_layer">constant_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.constant_layer">constant_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.control_dependencies">control_dependencies</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.control_dependencies_layer">control_dependencies_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv1d">conv1d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv1d_layer">conv1d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d">conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_backprop_filter">conv2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_backprop_filter_layer">conv2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_backprop_input">conv2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_backprop_input_layer">conv2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_layer">conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_transpose">conv2d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv2d_transpose_layer">conv2d_transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv3d">conv3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv3d_backprop_filter">conv3d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv3d_backprop_filter_layer">conv3d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv3d_backprop_input">conv3d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv3d_backprop_input_layer">conv3d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.conv3d_layer">conv3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.convert_to_tensor">convert_to_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.convert_to_tensor_layer">convert_to_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.convert_to_tensor_or_indexed_slices">convert_to_tensor_or_indexed_slices</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.convert_to_tensor_or_indexed_slices_layer">convert_to_tensor_or_indexed_slices_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.convolution2d">convolution2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cos">cos</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cos_layer">cos_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.count_up_to">count_up_to</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.count_up_to_layer">count_up_to_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.create_partitioned_variables">create_partitioned_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.create_partitioned_variables_layer">create_partitioned_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cross">cross</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.cross_layer">cross_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.decode_csv">decode_csv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.decode_csv_layer">decode_csv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.decode_json_example">decode_json_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.decode_json_example_layer">decode_json_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.decode_raw">decode_raw</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.decode_raw_layer">decode_raw_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.delete_session_tensor">delete_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.delete_session_tensor_layer">delete_session_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depth_to_space">depth_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depth_to_space_layer">depth_to_space_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d">depthwise_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_layer">depthwise_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_native">depthwise_conv2d_native</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter">depthwise_conv2d_native_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter_layer">depthwise_conv2d_native_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_input">depthwise_conv2d_native_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_input_layer">depthwise_conv2d_native_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.depthwise_conv2d_native_layer">depthwise_conv2d_native_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.deserialize_many_sparse">deserialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.deserialize_many_sparse_layer">deserialize_many_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.device">device</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.device_layer">device_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.diag">diag</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.diag_layer">diag_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.diag_part">diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.diag_part_layer">diag_part_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.digamma">digamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.digamma_layer">digamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dilation2d">dilation2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dilation2d_backprop_filter">dilation2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dilation2d_backprop_filter_layer">dilation2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dilation2d_backprop_input">dilation2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dilation2d_backprop_input_layer">dilation2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dilation2d_layer">dilation2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.div">div</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.div_layer">div_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dropout">dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dropout_layer">dropout_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dynamic_partition">dynamic_partition</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dynamic_partition_layer">dynamic_partition_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dynamic_rnn">dynamic_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dynamic_rnn_layer">dynamic_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dynamic_stitch">dynamic_stitch</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.dynamic_stitch_layer">dynamic_stitch_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.edit_distance">edit_distance</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.edit_distance_layer">edit_distance_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.elu">elu</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.elu_layer">elu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.embedding_lookup">embedding_lookup</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.embedding_lookup_layer">embedding_lookup_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.embedding_lookup_sparse">embedding_lookup_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.embedding_lookup_sparse_layer">embedding_lookup_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.equal">equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.equal_layer">equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.erf">erf</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.erf_layer">erf_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.erfc">erfc</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.erfc_layer">erfc_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.erosion2d">erosion2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.erosion2d_layer">erosion2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.exp">exp</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.exp_layer">exp_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.expand_dims">expand_dims</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.expand_dims_layer">expand_dims_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.extract">extract</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.extract_image_patches">extract_image_patches</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.extract_image_patches_layer">extract_image_patches_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fft">fft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fft2d">fft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fft2d_layer">fft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fft3d">fft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fft3d_layer">fft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fft_layer">fft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fill">fill</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fill_layer">fill_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fixed_unigram_candidate_sampler">fixed_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fixed_unigram_candidate_sampler_layer">fixed_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.floor">floor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.floor_layer">floor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.floordiv">floordiv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.floordiv_layer">floordiv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.foldl">foldl</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.foldl_layer">foldl_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.foldr">foldr</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.foldr_layer">foldr_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.fully_connected">fully_connected</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.gather">gather</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.gather_layer">gather_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.gather_nd">gather_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.gather_nd_layer">gather_nd_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_collection">get_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_collection_layer">get_collection_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_collection_ref">get_collection_ref</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_collection_ref_layer">get_collection_ref_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_default_graph">get_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_default_graph_layer">get_default_graph_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_default_session">get_default_session</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_default_session_layer">get_default_session_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_seed">get_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_seed_layer">get_seed_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_session_handle">get_session_handle</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_session_handle_layer">get_session_handle_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_session_tensor">get_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_session_tensor_layer">get_session_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_variable">get_variable</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_variable_layer">get_variable_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_variable_scope">get_variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.get_variable_scope_layer">get_variable_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.global_norm">global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.global_norm_layer">global_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.gradients">gradients</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.gradients_layer">gradients_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.greater">greater</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.greater_equal">greater_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.greater_equal_layer">greater_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.greater_layer">greater_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.group">group</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.group_layer">group_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.histogram_fixed_width">histogram_fixed_width</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.histogram_fixed_width_layer">histogram_fixed_width_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.histogram_summary">histogram_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.histogram_summary_layer">histogram_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.identity">identity</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.identity_layer">identity_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ifft">ifft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ifft2d">ifft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ifft2d_layer">ifft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ifft3d">ifft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ifft3d_layer">ifft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ifft_layer">ifft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.igamma">igamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.igamma_layer">igamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.igammac">igammac</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.igammac_layer">igammac_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.imag">imag</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.imag_layer">imag_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.image_summary">image_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.image_summary_layer">image_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.import_graph_def">import_graph_def</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.import_graph_def_layer">import_graph_def_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.in_top_k">in_top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.in_top_k_layer">in_top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_all_tables">initialize_all_tables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_all_tables_layer">initialize_all_tables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_all_variables">initialize_all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_all_variables_layer">initialize_all_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_local_variables">initialize_local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_local_variables_layer">initialize_local_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_variables">initialize_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.initialize_variables_layer">initialize_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.inv">inv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.inv_layer">inv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.invert_permutation">invert_permutation</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.invert_permutation_layer">invert_permutation_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_finite">is_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_finite_layer">is_finite_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_inf">is_inf</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_inf_layer">is_inf_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_nan">is_nan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_nan_layer">is_nan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_non_decreasing">is_non_decreasing</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_non_decreasing_layer">is_non_decreasing_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_numeric_tensor">is_numeric_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_numeric_tensor_layer">is_numeric_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_strictly_increasing">is_strictly_increasing</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_strictly_increasing_layer">is_strictly_increasing_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_variable_initialized">is_variable_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.is_variable_initialized_layer">is_variable_initialized_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.l2_loss">l2_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.l2_loss_layer">l2_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.l2_normalize">l2_normalize</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.l2_normalize_layer">l2_normalize_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lbeta">lbeta</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lbeta_layer">lbeta_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.learned_unigram_candidate_sampler">learned_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.learned_unigram_candidate_sampler_layer">learned_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.less">less</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.less_equal">less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.less_equal_layer">less_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.less_layer">less_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lgamma">lgamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lgamma_layer">lgamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lin_space">lin_space</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lin_space_layer">lin_space_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.linspace_layer">linspace_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.list_diff">list_diff</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.list_diff_layer">list_diff_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.listdiff_layer">listdiff_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.load_file_system_library">load_file_system_library</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.load_file_system_library_layer">load_file_system_library_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.load_op_library">load_op_library</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.load_op_library_layer">load_op_library_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.local_response_normalization_layer">local_response_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.local_variables">local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.local_variables_layer">local_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.log">log</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.log_layer">log_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.log_softmax">log_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.log_softmax_layer">log_softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.log_uniform_candidate_sampler">log_uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.log_uniform_candidate_sampler_layer">log_uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_and">logical_and</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_and_layer">logical_and_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_not">logical_not</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_not_layer">logical_not_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_or">logical_or</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_or_layer">logical_or_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_xor">logical_xor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.logical_xor_layer">logical_xor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lrn">lrn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.lrn_layer">lrn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.make_all">make_all</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.make_all_layer">make_all_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.make_template">make_template</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.make_template_layer">make_template_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.map">map</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.map_each">map_each</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.map_fn">map_fn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.map_fn_layer">map_fn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matching_files">matching_files</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matching_files_layer">matching_files_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matmul">matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matmul_layer">matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_determinant">matrix_determinant</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_determinant_layer">matrix_determinant_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_inverse">matrix_inverse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_inverse_layer">matrix_inverse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_solve">matrix_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_solve_layer">matrix_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_solve_ls">matrix_solve_ls</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_solve_ls_layer">matrix_solve_ls_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_triangular_solve">matrix_triangular_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.matrix_triangular_solve_layer">matrix_triangular_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool">max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool3d">max_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool3d_grad">max_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool3d_grad_layer">max_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool3d_layer">max_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool_2d">max_pool_2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool_layer">max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool_with_argmax">max_pool_with_argmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.max_pool_with_argmax_layer">max_pool_with_argmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.maximum">maximum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.maximum_layer">maximum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.merge_all_summaries">merge_all_summaries</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.merge_all_summaries_layer">merge_all_summaries_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.merge_summary">merge_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.merge_summary_layer">merge_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.minimum">minimum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.minimum_layer">minimum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.mod">mod</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.mod_layer">mod_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.moments">moments</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.moments_layer">moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.moving_average_variables">moving_average_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.moving_average_variables_layer">moving_average_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.mul">mul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.mul_layer">mul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.multinomial">multinomial</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.multinomial_layer">multinomial_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.name_scope">name_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.name_scope_layer">name_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.nce_loss">nce_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.nce_loss_layer">nce_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.neg">neg</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.neg_layer">neg_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.no_op">no_op</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.no_op_layer">no_op_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.no_regularizer">no_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.no_regularizer_layer">no_regularizer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.normalize_moments">normalize_moments</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.normalize_moments_layer">normalize_moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.not_equal">not_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.not_equal_layer">not_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.one_hot">one_hot</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.one_hot_layer">one_hot_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ones">ones</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ones_initializer">ones_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ones_initializer_layer">ones_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ones_layer">ones_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ones_like">ones_like</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.ones_like_layer">ones_like_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.op_scope">op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.op_scope_layer">op_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pack">pack</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pack_layer">pack_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pad">pad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pad_layer">pad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.parse_example">parse_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.parse_example_layer">parse_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.parse_single_example">parse_single_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.parse_single_example_layer">parse_single_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.parse_single_sequence_example">parse_single_sequence_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.parse_single_sequence_example_layer">parse_single_sequence_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pipe">pipe</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.placeholder">placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.placeholder_layer">placeholder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.placeholder_with_default">placeholder_with_default</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.placeholder_with_default_layer">placeholder_with_default_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.polygamma">polygamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.polygamma_layer">polygamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pow">pow</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.pow_layer">pow_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.py_func">py_func</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.py_func_layer">py_func_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_crop">random_crop</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_crop_layer">random_crop_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_normal">random_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_normal_initializer">random_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_normal_initializer_layer">random_normal_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_normal_layer">random_normal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_shuffle">random_shuffle</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_shuffle_layer">random_shuffle_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_uniform">random_uniform</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_uniform_initializer">random_uniform_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_uniform_initializer_layer">random_uniform_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.random_uniform_layer">random_uniform_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.range">range</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.range_layer">range_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.rank">rank</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.rank_layer">rank_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.read_file">read_file</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.read_file_layer">read_file_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.real">real</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.real_layer">real_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce">reduce</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_all">reduce_all</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_all_layer">reduce_all_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_any">reduce_any</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_any_layer">reduce_any_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_join">reduce_join</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_join_layer">reduce_join_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_max">reduce_max</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_max_layer">reduce_max_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_mean">reduce_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_mean_layer">reduce_mean_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_min">reduce_min</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_min_layer">reduce_min_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_prod">reduce_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_prod_layer">reduce_prod_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_sum">reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reduce_sum_layer">reduce_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.register_tensor_conversion_function">register_tensor_conversion_function</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.register_tensor_conversion_function_layer">register_tensor_conversion_function_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.relu">relu</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.relu6">relu6</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.relu6_layer">relu6_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.relu_layer">relu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.report_uninitialized_variables">report_uninitialized_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.report_uninitialized_variables_layer">report_uninitialized_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reset_default_graph">reset_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reset_default_graph_layer">reset_default_graph_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reshape">reshape</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reshape_layer">reshape_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reverse">reverse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reverse_layer">reverse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reverse_sequence">reverse_sequence</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.reverse_sequence_layer">reverse_sequence_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.rnn">rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.rnn_layer">rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.round">round</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.round_layer">round_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.rsqrt">rsqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.rsqrt_layer">rsqrt_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sampled_softmax_loss">sampled_softmax_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sampled_softmax_loss_layer">sampled_softmax_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.saturate_cast">saturate_cast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.saturate_cast_layer">saturate_cast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scalar_mul">scalar_mul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scalar_mul_layer">scalar_mul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scalar_summary">scalar_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scalar_summary_layer">scalar_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scan">scan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scan_layer">scan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scatter_add">scatter_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scatter_add_layer">scatter_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scatter_sub">scatter_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scatter_sub_layer">scatter_sub_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scatter_update">scatter_update</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.scatter_update_layer">scatter_update_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_max">segment_max</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_max_layer">segment_max_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_mean">segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_mean_layer">segment_mean_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_min">segment_min</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_min_layer">segment_min_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_prod">segment_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_prod_layer">segment_prod_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_sum">segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.segment_sum_layer">segment_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.select">select</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.select_layer">select_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.self_adjoint_eig">self_adjoint_eig</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.self_adjoint_eig_layer">self_adjoint_eig_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.separable_conv2d">separable_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.separable_conv2d_layer">separable_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.serialize_many_sparse">serialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.serialize_many_sparse_layer">serialize_many_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.serialize_sparse">serialize_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.serialize_sparse_layer">serialize_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.set_random_seed">set_random_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.set_random_seed_layer">set_random_seed_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.shape">shape</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.shape_layer">shape_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.shape_n">shape_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.shape_n_layer">shape_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sigmoid">sigmoid</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sigmoid_cross_entropy_with_logits">sigmoid_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sigmoid_cross_entropy_with_logits_layer">sigmoid_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sigmoid_layer">sigmoid_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sign">sign</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sign_layer">sign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sin">sin</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sin_layer">sin_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.size">size</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.size_layer">size_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.slice">slice</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.slice_layer">slice_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softmax">softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softmax_cross_entropy_with_logits">softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softmax_cross_entropy_with_logits_layer">softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softmax_layer">softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softplus">softplus</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softplus_layer">softplus_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softsign">softsign</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.softsign_layer">softsign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.space_to_batch">space_to_batch</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.space_to_batch_layer">space_to_batch_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.space_to_depth">space_to_depth</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.space_to_depth_layer">space_to_depth_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_add">sparse_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_add_layer">sparse_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_concat">sparse_concat</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_concat_layer">sparse_concat_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_fill_empty_rows">sparse_fill_empty_rows</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_fill_empty_rows_layer">sparse_fill_empty_rows_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_mask">sparse_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_mask_layer">sparse_mask_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_matmul_layer">sparse_matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_merge">sparse_merge</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_merge_layer">sparse_merge_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_placeholder">sparse_placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_placeholder_layer">sparse_placeholder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_reduce_sum">sparse_reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_reduce_sum_layer">sparse_reduce_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_reorder">sparse_reorder</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_reorder_layer">sparse_reorder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_reset_shape">sparse_reset_shape</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_reset_shape_layer">sparse_reset_shape_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_retain">sparse_retain</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_retain_layer">sparse_retain_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_mean">sparse_segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_mean_grad">sparse_segment_mean_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_mean_grad_layer">sparse_segment_mean_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_mean_layer">sparse_segment_mean_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_sqrt_n">sparse_segment_sqrt_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_grad">sparse_segment_sqrt_n_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_grad_layer">sparse_segment_sqrt_n_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_layer">sparse_segment_sqrt_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_sum">sparse_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_segment_sum_layer">sparse_segment_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_softmax">sparse_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits">sparse_softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits_layer">sparse_softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_softmax_layer">sparse_softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_split">sparse_split</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_split_layer">sparse_split_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_tensor_dense_matmul">sparse_tensor_dense_matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_tensor_dense_matmul_layer">sparse_tensor_dense_matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_tensor_to_dense">sparse_tensor_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_tensor_to_dense_layer">sparse_tensor_to_dense_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_to_dense">sparse_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_to_dense_layer">sparse_to_dense_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_to_indicator">sparse_to_indicator</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sparse_to_indicator_layer">sparse_to_indicator_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.split">split</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.split_layer">split_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sqrt">sqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sqrt_layer">sqrt_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.square">square</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.square_layer">square_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.squared_difference">squared_difference</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.squared_difference_layer">squared_difference_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.squeeze">squeeze</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.squeeze_layer">squeeze_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.state_saving_rnn">state_saving_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.state_saving_rnn_layer">state_saving_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.stop_gradient">stop_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.stop_gradient_layer">stop_gradient_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_hash_bucket">string_to_hash_bucket</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_hash_bucket_fast">string_to_hash_bucket_fast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_hash_bucket_fast_layer">string_to_hash_bucket_fast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_hash_bucket_layer">string_to_hash_bucket_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_hash_bucket_strong">string_to_hash_bucket_strong</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_hash_bucket_strong_layer">string_to_hash_bucket_strong_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_number">string_to_number</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.string_to_number_layer">string_to_number_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sub">sub</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sub_layer">sub_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sufficient_statistics">sufficient_statistics</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.sufficient_statistics_layer">sufficient_statistics_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tan">tan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tan_layer">tan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tanh">tanh</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tanh_layer">tanh_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tensor">tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tensors">tensors</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.then">then</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tile">tile</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tile_layer">tile_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_bfloat16">to_bfloat16</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_bfloat16_layer">to_bfloat16_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_double">to_double</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_double_layer">to_double_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_float">to_float</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_float_layer">to_float_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_int32">to_int32</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_int32_layer">to_int32_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_int64">to_int64</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.to_int64_layer">to_int64_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.top_k">top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.top_k_layer">top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.trace">trace</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.trace_layer">trace_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.trainable_variables">trainable_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.trainable_variables_layer">trainable_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.transpose">transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.transpose_layer">transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.truediv">truediv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.truediv_layer">truediv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.truncated_normal">truncated_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.truncated_normal_initializer">truncated_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.truncated_normal_initializer_layer">truncated_normal_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.truncated_normal_layer">truncated_normal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tuple">tuple</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.tuple_layer">tuple_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.uniform_candidate_sampler">uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.uniform_candidate_sampler_layer">uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.uniform_unit_scaling_initializer">uniform_unit_scaling_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.uniform_unit_scaling_initializer_layer">uniform_unit_scaling_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unique">unique</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unique_layer">unique_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unique_with_counts">unique_with_counts</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unique_with_counts_layer">unique_with_counts_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unpack">unpack</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unpack_layer">unpack_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unsorted_segment_sum">unsorted_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.unsorted_segment_sum_layer">unsorted_segment_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.variable_axis_size_partitioner">variable_axis_size_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.variable_axis_size_partitioner_layer">variable_axis_size_partitioner_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.variable_op_scope">variable_op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.variable_op_scope_layer">variable_op_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.variable_scope">variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.variable_scope_layer">variable_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.verify_tensor_all_finite">verify_tensor_all_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.verify_tensor_all_finite_layer">verify_tensor_all_finite_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.weighted_cross_entropy_with_logits">weighted_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.weighted_cross_entropy_with_logits_layer">weighted_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.where">where</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.where_layer">where_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.while_loop">while_loop</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.while_loop_layer">while_loop_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.xw_plus_b">xw_plus_b</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.xw_plus_b_layer">xw_plus_b_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.xw_plus_b_v1">xw_plus_b_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.xw_plus_b_v1_layer">xw_plus_b_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zero_fraction">zero_fraction</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zero_fraction_layer">zero_fraction_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeros">zeros</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeros_initializer">zeros_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeros_initializer_layer">zeros_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeros_layer">zeros_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeros_like">zeros_like</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeros_like_layer">zeros_like_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeta">zeta</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.zeta_layer">zeta_layer</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#tensorbuilder.dsl.Applicative">Applicative</a></span>
        
          
  <ul>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.__init__">__init__</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.Assert">Assert</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.Assert_layer">Assert_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.NoGradient">NoGradient</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.NoGradient_layer">NoGradient_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.Print">Print</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.Print_layer">Print_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.abs">abs</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.abs_layer">abs_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.accumulate_n">accumulate_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.accumulate_n_layer">accumulate_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.acos">acos</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.acos_layer">acos_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add">add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_check_numerics_ops">add_check_numerics_ops</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_check_numerics_ops_layer">add_check_numerics_ops_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_layer">add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_n">add_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_n_layer">add_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_to_collection">add_to_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.add_to_collection_layer">add_to_collection_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.all_candidate_sampler">all_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.all_candidate_sampler_layer">all_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.all_variables">all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.all_variables_layer">all_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.arg_max">arg_max</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.arg_max_layer">arg_max_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.arg_min">arg_min</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.arg_min_layer">arg_min_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.argmax_layer">argmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.argmin_layer">argmin_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.as_dtype">as_dtype</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.as_dtype_layer">as_dtype_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.asin">asin</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.asin_layer">asin_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_equal">assert_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_equal_layer">assert_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_integer">assert_integer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_integer_layer">assert_integer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_less">assert_less</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_less_equal">assert_less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_less_equal_layer">assert_less_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_less_layer">assert_less_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_negative">assert_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_negative_layer">assert_negative_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_non_negative">assert_non_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_non_negative_layer">assert_non_negative_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_non_positive">assert_non_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_non_positive_layer">assert_non_positive_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_positive">assert_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_positive_layer">assert_positive_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_proper_iterable">assert_proper_iterable</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_proper_iterable_layer">assert_proper_iterable_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_rank">assert_rank</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_rank_at_least">assert_rank_at_least</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_rank_at_least_layer">assert_rank_at_least_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_rank_layer">assert_rank_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_type">assert_type</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_type_layer">assert_type_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_variables_initialized">assert_variables_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assert_variables_initialized_layer">assert_variables_initialized_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assign">assign</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assign_add">assign_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assign_add_layer">assign_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assign_layer">assign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assign_sub">assign_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.assign_sub_layer">assign_sub_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.atan">atan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.atan_layer">atan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.atrous_conv2d">atrous_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.atrous_conv2d_layer">atrous_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.audio_summary">audio_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.audio_summary_layer">audio_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.avg_pool">avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.avg_pool3d">avg_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.avg_pool3d_grad">avg_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.avg_pool3d_grad_layer">avg_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.avg_pool3d_layer">avg_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.avg_pool_layer">avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_cholesky">batch_cholesky</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_cholesky_layer">batch_cholesky_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_cholesky_solve">batch_cholesky_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_cholesky_solve_layer">batch_cholesky_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_fft">batch_fft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_fft2d">batch_fft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_fft2d_layer">batch_fft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_fft3d">batch_fft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_fft3d_layer">batch_fft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_fft_layer">batch_fft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_ifft">batch_ifft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_ifft2d">batch_ifft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_ifft2d_layer">batch_ifft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_ifft3d">batch_ifft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_ifft3d_layer">batch_ifft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_ifft_layer">batch_ifft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matmul_layer">batch_matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_band_part">batch_matrix_band_part</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_band_part_layer">batch_matrix_band_part_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_determinant">batch_matrix_determinant</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_determinant_layer">batch_matrix_determinant_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_diag">batch_matrix_diag</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_diag_layer">batch_matrix_diag_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_diag_part">batch_matrix_diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_diag_part_layer">batch_matrix_diag_part_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_inverse">batch_matrix_inverse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_inverse_layer">batch_matrix_inverse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_solve">batch_matrix_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_solve_layer">batch_matrix_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_solve_ls">batch_matrix_solve_ls</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_solve_ls_layer">batch_matrix_solve_ls_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_triangular_solve">batch_matrix_triangular_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_matrix_triangular_solve_layer">batch_matrix_triangular_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_norm_with_global_normalization">batch_norm_with_global_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_norm_with_global_normalization_layer">batch_norm_with_global_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_normalization">batch_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_normalization_layer">batch_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_self_adjoint_eig">batch_self_adjoint_eig</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_self_adjoint_eig_layer">batch_self_adjoint_eig_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_to_space">batch_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.batch_to_space_layer">batch_to_space_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bias_add">bias_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bias_add_grad">bias_add_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bias_add_grad_layer">bias_add_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bias_add_layer">bias_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bias_add_v1">bias_add_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bias_add_v1_layer">bias_add_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bidirectional_rnn">bidirectional_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bidirectional_rnn_layer">bidirectional_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bitcast">bitcast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.bitcast_layer">bitcast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.boolean_mask">boolean_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.boolean_mask_layer">boolean_mask_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.branch">branch</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.builders">builders</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.case">case</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.case_layer">case_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cast">cast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cast_layer">cast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ceil">ceil</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ceil_layer">ceil_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.check_numerics">check_numerics</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.check_numerics_layer">check_numerics_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cholesky">cholesky</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cholesky_layer">cholesky_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cholesky_solve">cholesky_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cholesky_solve_layer">cholesky_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_average_norm">clip_by_average_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_average_norm_layer">clip_by_average_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_global_norm">clip_by_global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_global_norm_layer">clip_by_global_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_norm">clip_by_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_norm_layer">clip_by_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_value">clip_by_value</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.clip_by_value_layer">clip_by_value_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.complex">complex</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.complex_abs">complex_abs</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.complex_abs_layer">complex_abs_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.complex_layer">complex_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.compose">compose</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.compute_accidental_hits">compute_accidental_hits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.compute_accidental_hits_layer">compute_accidental_hits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.concat">concat</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.concat_layer">concat_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cond">cond</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cond_layer">cond_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conj">conj</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conj_layer">conj_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.constant">constant</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.constant_initializer">constant_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.constant_initializer_layer">constant_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.constant_layer">constant_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.control_dependencies">control_dependencies</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.control_dependencies_layer">control_dependencies_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv1d">conv1d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv1d_layer">conv1d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d">conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_backprop_filter">conv2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_backprop_filter_layer">conv2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_backprop_input">conv2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_backprop_input_layer">conv2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_layer">conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_transpose">conv2d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv2d_transpose_layer">conv2d_transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv3d">conv3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv3d_backprop_filter">conv3d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv3d_backprop_filter_layer">conv3d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv3d_backprop_input">conv3d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv3d_backprop_input_layer">conv3d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.conv3d_layer">conv3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.convert_to_tensor">convert_to_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.convert_to_tensor_layer">convert_to_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.convert_to_tensor_or_indexed_slices">convert_to_tensor_or_indexed_slices</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.convert_to_tensor_or_indexed_slices_layer">convert_to_tensor_or_indexed_slices_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.convolution2d">convolution2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.copy">copy</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cos">cos</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cos_layer">cos_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.count_up_to">count_up_to</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.count_up_to_layer">count_up_to_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.create_partitioned_variables">create_partitioned_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.create_partitioned_variables_layer">create_partitioned_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cross">cross</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.cross_layer">cross_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.decode_csv">decode_csv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.decode_csv_layer">decode_csv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.decode_json_example">decode_json_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.decode_json_example_layer">decode_json_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.decode_raw">decode_raw</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.decode_raw_layer">decode_raw_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.delete_session_tensor">delete_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.delete_session_tensor_layer">delete_session_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depth_to_space">depth_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depth_to_space_layer">depth_to_space_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d">depthwise_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_layer">depthwise_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_native">depthwise_conv2d_native</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_filter">depthwise_conv2d_native_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_filter_layer">depthwise_conv2d_native_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_input">depthwise_conv2d_native_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_input_layer">depthwise_conv2d_native_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.depthwise_conv2d_native_layer">depthwise_conv2d_native_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.deserialize_many_sparse">deserialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.deserialize_many_sparse_layer">deserialize_many_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.device">device</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.device_layer">device_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.diag">diag</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.diag_layer">diag_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.diag_part">diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.diag_part_layer">diag_part_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.digamma">digamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.digamma_layer">digamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dilation2d">dilation2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dilation2d_backprop_filter">dilation2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dilation2d_backprop_filter_layer">dilation2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dilation2d_backprop_input">dilation2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dilation2d_backprop_input_layer">dilation2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dilation2d_layer">dilation2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.div">div</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.div_layer">div_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dropout">dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dropout_layer">dropout_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dynamic_partition">dynamic_partition</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dynamic_partition_layer">dynamic_partition_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dynamic_rnn">dynamic_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dynamic_rnn_layer">dynamic_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dynamic_stitch">dynamic_stitch</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.dynamic_stitch_layer">dynamic_stitch_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.edit_distance">edit_distance</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.edit_distance_layer">edit_distance_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.elu">elu</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.elu_layer">elu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.embedding_lookup">embedding_lookup</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.embedding_lookup_layer">embedding_lookup_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.embedding_lookup_sparse">embedding_lookup_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.embedding_lookup_sparse_layer">embedding_lookup_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.equal">equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.equal_layer">equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.erf">erf</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.erf_layer">erf_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.erfc">erfc</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.erfc_layer">erfc_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.erosion2d">erosion2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.erosion2d_layer">erosion2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.exp">exp</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.exp_layer">exp_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.expand_dims">expand_dims</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.expand_dims_layer">expand_dims_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.extract">extract</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.extract_image_patches">extract_image_patches</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.extract_image_patches_layer">extract_image_patches_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fft">fft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fft2d">fft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fft2d_layer">fft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fft3d">fft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fft3d_layer">fft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fft_layer">fft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fill">fill</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fill_layer">fill_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fixed_unigram_candidate_sampler">fixed_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fixed_unigram_candidate_sampler_layer">fixed_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.floor">floor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.floor_layer">floor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.floordiv">floordiv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.floordiv_layer">floordiv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.foldl">foldl</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.foldl_layer">foldl_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.foldr">foldr</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.foldr_layer">foldr_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.fully_connected">fully_connected</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.gather">gather</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.gather_layer">gather_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.gather_nd">gather_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.gather_nd_layer">gather_nd_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_collection">get_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_collection_layer">get_collection_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_collection_ref">get_collection_ref</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_collection_ref_layer">get_collection_ref_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_default_graph">get_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_default_graph_layer">get_default_graph_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_default_session">get_default_session</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_default_session_layer">get_default_session_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_seed">get_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_seed_layer">get_seed_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_session_handle">get_session_handle</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_session_handle_layer">get_session_handle_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_session_tensor">get_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_session_tensor_layer">get_session_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_variable">get_variable</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_variable_layer">get_variable_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_variable_scope">get_variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.get_variable_scope_layer">get_variable_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.global_norm">global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.global_norm_layer">global_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.gradients">gradients</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.gradients_layer">gradients_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.greater">greater</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.greater_equal">greater_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.greater_equal_layer">greater_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.greater_layer">greater_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.group">group</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.group_layer">group_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.histogram_fixed_width">histogram_fixed_width</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.histogram_fixed_width_layer">histogram_fixed_width_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.histogram_summary">histogram_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.histogram_summary_layer">histogram_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.identity">identity</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.identity_layer">identity_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ifft">ifft</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ifft2d">ifft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ifft2d_layer">ifft2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ifft3d">ifft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ifft3d_layer">ifft3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ifft_layer">ifft_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.igamma">igamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.igamma_layer">igamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.igammac">igammac</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.igammac_layer">igammac_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.imag">imag</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.imag_layer">imag_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.image_summary">image_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.image_summary_layer">image_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.import_graph_def">import_graph_def</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.import_graph_def_layer">import_graph_def_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.in_top_k">in_top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.in_top_k_layer">in_top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_all_tables">initialize_all_tables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_all_tables_layer">initialize_all_tables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_all_variables">initialize_all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_all_variables_layer">initialize_all_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_local_variables">initialize_local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_local_variables_layer">initialize_local_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_variables">initialize_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.initialize_variables_layer">initialize_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.inv">inv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.inv_layer">inv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.invert_permutation">invert_permutation</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.invert_permutation_layer">invert_permutation_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_finite">is_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_finite_layer">is_finite_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_inf">is_inf</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_inf_layer">is_inf_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_nan">is_nan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_nan_layer">is_nan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_non_decreasing">is_non_decreasing</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_non_decreasing_layer">is_non_decreasing_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_numeric_tensor">is_numeric_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_numeric_tensor_layer">is_numeric_tensor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_strictly_increasing">is_strictly_increasing</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_strictly_increasing_layer">is_strictly_increasing_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_variable_initialized">is_variable_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.is_variable_initialized_layer">is_variable_initialized_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.l2_loss">l2_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.l2_loss_layer">l2_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.l2_normalize">l2_normalize</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.l2_normalize_layer">l2_normalize_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lbeta">lbeta</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lbeta_layer">lbeta_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.learned_unigram_candidate_sampler">learned_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.learned_unigram_candidate_sampler_layer">learned_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.less">less</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.less_equal">less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.less_equal_layer">less_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.less_layer">less_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lgamma">lgamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lgamma_layer">lgamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lin_space">lin_space</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lin_space_layer">lin_space_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.linspace_layer">linspace_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.list_diff">list_diff</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.list_diff_layer">list_diff_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.listdiff_layer">listdiff_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.load_file_system_library">load_file_system_library</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.load_file_system_library_layer">load_file_system_library_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.load_op_library">load_op_library</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.load_op_library_layer">load_op_library_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.local_response_normalization_layer">local_response_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.local_variables">local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.local_variables_layer">local_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.log">log</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.log_layer">log_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.log_softmax">log_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.log_softmax_layer">log_softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.log_uniform_candidate_sampler">log_uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.log_uniform_candidate_sampler_layer">log_uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_and">logical_and</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_and_layer">logical_and_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_not">logical_not</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_not_layer">logical_not_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_or">logical_or</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_or_layer">logical_or_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_xor">logical_xor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.logical_xor_layer">logical_xor_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lrn">lrn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.lrn_layer">lrn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.make_all">make_all</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.make_all_layer">make_all_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.make_template">make_template</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.make_template_layer">make_template_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.map">map</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.map_each">map_each</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.map_fn">map_fn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.map_fn_layer">map_fn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matching_files">matching_files</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matching_files_layer">matching_files_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matmul">matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matmul_layer">matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_determinant">matrix_determinant</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_determinant_layer">matrix_determinant_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_inverse">matrix_inverse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_inverse_layer">matrix_inverse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_solve">matrix_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_solve_layer">matrix_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_solve_ls">matrix_solve_ls</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_solve_ls_layer">matrix_solve_ls_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_triangular_solve">matrix_triangular_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.matrix_triangular_solve_layer">matrix_triangular_solve_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool">max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool3d">max_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool3d_grad">max_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool3d_grad_layer">max_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool3d_layer">max_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool_2d">max_pool_2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool_layer">max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool_with_argmax">max_pool_with_argmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.max_pool_with_argmax_layer">max_pool_with_argmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.maximum">maximum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.maximum_layer">maximum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.merge_all_summaries">merge_all_summaries</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.merge_all_summaries_layer">merge_all_summaries_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.merge_summary">merge_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.merge_summary_layer">merge_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.minimum">minimum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.minimum_layer">minimum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.mod">mod</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.mod_layer">mod_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.moments">moments</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.moments_layer">moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.moving_average_variables">moving_average_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.moving_average_variables_layer">moving_average_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.mul">mul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.mul_layer">mul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.multinomial">multinomial</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.multinomial_layer">multinomial_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.name_scope">name_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.name_scope_layer">name_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.nce_loss">nce_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.nce_loss_layer">nce_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.neg">neg</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.neg_layer">neg_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.no_op">no_op</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.no_op_layer">no_op_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.no_regularizer">no_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.no_regularizer_layer">no_regularizer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.normalize_moments">normalize_moments</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.normalize_moments_layer">normalize_moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.not_equal">not_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.not_equal_layer">not_equal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.one_hot">one_hot</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.one_hot_layer">one_hot_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ones">ones</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ones_initializer">ones_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ones_initializer_layer">ones_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ones_layer">ones_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ones_like">ones_like</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.ones_like_layer">ones_like_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.op_scope">op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.op_scope_layer">op_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.pack">pack</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.pack_layer">pack_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.pad">pad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.pad_layer">pad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.parse_example">parse_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.parse_example_layer">parse_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.parse_single_example">parse_single_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.parse_single_example_layer">parse_single_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.parse_single_sequence_example">parse_single_sequence_example</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.parse_single_sequence_example_layer">parse_single_sequence_example_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.placeholder">placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.placeholder_layer">placeholder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.placeholder_with_default">placeholder_with_default</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.placeholder_with_default_layer">placeholder_with_default_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.polygamma">polygamma</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.polygamma_layer">polygamma_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.pow">pow</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.pow_layer">pow_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.py_func">py_func</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.py_func_layer">py_func_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_crop">random_crop</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_crop_layer">random_crop_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_normal">random_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_normal_initializer">random_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_normal_initializer_layer">random_normal_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_normal_layer">random_normal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_shuffle">random_shuffle</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_shuffle_layer">random_shuffle_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_uniform">random_uniform</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_uniform_initializer">random_uniform_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_uniform_initializer_layer">random_uniform_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.random_uniform_layer">random_uniform_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.range">range</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.range_layer">range_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.rank">rank</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.rank_layer">rank_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.read_file">read_file</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.read_file_layer">read_file_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.real">real</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.real_layer">real_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce">reduce</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_all">reduce_all</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_all_layer">reduce_all_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_any">reduce_any</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_any_layer">reduce_any_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_join">reduce_join</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_join_layer">reduce_join_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_max">reduce_max</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_max_layer">reduce_max_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_mean">reduce_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_mean_layer">reduce_mean_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_min">reduce_min</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_min_layer">reduce_min_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_prod">reduce_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_prod_layer">reduce_prod_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_sum">reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reduce_sum_layer">reduce_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.register_tensor_conversion_function">register_tensor_conversion_function</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.register_tensor_conversion_function_layer">register_tensor_conversion_function_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.relu">relu</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.relu6">relu6</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.relu6_layer">relu6_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.relu_layer">relu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.report_uninitialized_variables">report_uninitialized_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.report_uninitialized_variables_layer">report_uninitialized_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reset_default_graph">reset_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reset_default_graph_layer">reset_default_graph_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reshape">reshape</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reshape_layer">reshape_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reverse">reverse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reverse_layer">reverse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reverse_sequence">reverse_sequence</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.reverse_sequence_layer">reverse_sequence_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.rnn">rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.rnn_layer">rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.round">round</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.round_layer">round_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.rsqrt">rsqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.rsqrt_layer">rsqrt_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sampled_softmax_loss">sampled_softmax_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sampled_softmax_loss_layer">sampled_softmax_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.saturate_cast">saturate_cast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.saturate_cast_layer">saturate_cast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scalar_mul">scalar_mul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scalar_mul_layer">scalar_mul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scalar_summary">scalar_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scalar_summary_layer">scalar_summary_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scan">scan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scan_layer">scan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scatter_add">scatter_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scatter_add_layer">scatter_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scatter_sub">scatter_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scatter_sub_layer">scatter_sub_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scatter_update">scatter_update</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.scatter_update_layer">scatter_update_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_max">segment_max</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_max_layer">segment_max_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_mean">segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_mean_layer">segment_mean_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_min">segment_min</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_min_layer">segment_min_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_prod">segment_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_prod_layer">segment_prod_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_sum">segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.segment_sum_layer">segment_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.select">select</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.select_layer">select_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.self_adjoint_eig">self_adjoint_eig</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.self_adjoint_eig_layer">self_adjoint_eig_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.separable_conv2d">separable_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.separable_conv2d_layer">separable_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.serialize_many_sparse">serialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.serialize_many_sparse_layer">serialize_many_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.serialize_sparse">serialize_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.serialize_sparse_layer">serialize_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.set_random_seed">set_random_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.set_random_seed_layer">set_random_seed_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.shape">shape</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.shape_layer">shape_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.shape_n">shape_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.shape_n_layer">shape_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sigmoid">sigmoid</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sigmoid_cross_entropy_with_logits">sigmoid_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sigmoid_cross_entropy_with_logits_layer">sigmoid_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sigmoid_layer">sigmoid_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sign">sign</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sign_layer">sign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sin">sin</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sin_layer">sin_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.size">size</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.size_layer">size_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.slice">slice</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.slice_layer">slice_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softmax">softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softmax_cross_entropy_with_logits">softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softmax_cross_entropy_with_logits_layer">softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softmax_layer">softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softplus">softplus</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softplus_layer">softplus_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softsign">softsign</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.softsign_layer">softsign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.space_to_batch">space_to_batch</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.space_to_batch_layer">space_to_batch_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.space_to_depth">space_to_depth</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.space_to_depth_layer">space_to_depth_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_add">sparse_add</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_add_layer">sparse_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_concat">sparse_concat</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_concat_layer">sparse_concat_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_fill_empty_rows">sparse_fill_empty_rows</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_fill_empty_rows_layer">sparse_fill_empty_rows_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_mask">sparse_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_mask_layer">sparse_mask_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_matmul_layer">sparse_matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_merge">sparse_merge</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_merge_layer">sparse_merge_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_placeholder">sparse_placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_placeholder_layer">sparse_placeholder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_reduce_sum">sparse_reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_reduce_sum_layer">sparse_reduce_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_reorder">sparse_reorder</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_reorder_layer">sparse_reorder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_reset_shape">sparse_reset_shape</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_reset_shape_layer">sparse_reset_shape_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_retain">sparse_retain</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_retain_layer">sparse_retain_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_mean">sparse_segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_mean_grad">sparse_segment_mean_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_mean_grad_layer">sparse_segment_mean_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_mean_layer">sparse_segment_mean_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n">sparse_segment_sqrt_n</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n_grad">sparse_segment_sqrt_n_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n_grad_layer">sparse_segment_sqrt_n_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n_layer">sparse_segment_sqrt_n_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_sum">sparse_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_segment_sum_layer">sparse_segment_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_softmax">sparse_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_softmax_cross_entropy_with_logits">sparse_softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_softmax_cross_entropy_with_logits_layer">sparse_softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_softmax_layer">sparse_softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_split">sparse_split</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_split_layer">sparse_split_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_tensor_dense_matmul">sparse_tensor_dense_matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_tensor_dense_matmul_layer">sparse_tensor_dense_matmul_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_tensor_to_dense">sparse_tensor_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_tensor_to_dense_layer">sparse_tensor_to_dense_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_to_dense">sparse_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_to_dense_layer">sparse_to_dense_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_to_indicator">sparse_to_indicator</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sparse_to_indicator_layer">sparse_to_indicator_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.split">split</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.split_layer">split_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sqrt">sqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sqrt_layer">sqrt_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.square">square</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.square_layer">square_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.squared_difference">squared_difference</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.squared_difference_layer">squared_difference_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.squeeze">squeeze</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.squeeze_layer">squeeze_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.state_saving_rnn">state_saving_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.state_saving_rnn_layer">state_saving_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.stop_gradient">stop_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.stop_gradient_layer">stop_gradient_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_hash_bucket">string_to_hash_bucket</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_hash_bucket_fast">string_to_hash_bucket_fast</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_hash_bucket_fast_layer">string_to_hash_bucket_fast_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_hash_bucket_layer">string_to_hash_bucket_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_hash_bucket_strong">string_to_hash_bucket_strong</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_hash_bucket_strong_layer">string_to_hash_bucket_strong_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_number">string_to_number</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.string_to_number_layer">string_to_number_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sub">sub</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sub_layer">sub_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sufficient_statistics">sufficient_statistics</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.sufficient_statistics_layer">sufficient_statistics_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tan">tan</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tan_layer">tan_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tanh">tanh</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tanh_layer">tanh_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tensor">tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tensors">tensors</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.then">then</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tile">tile</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tile_layer">tile_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_bfloat16">to_bfloat16</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_bfloat16_layer">to_bfloat16_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_double">to_double</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_double_layer">to_double_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_float">to_float</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_float_layer">to_float_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_int32">to_int32</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_int32_layer">to_int32_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_int64">to_int64</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.to_int64_layer">to_int64_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.top_k">top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.top_k_layer">top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.trace">trace</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.trace_layer">trace_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.trainable_variables">trainable_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.trainable_variables_layer">trainable_variables_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.transpose">transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.transpose_layer">transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.truediv">truediv</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.truediv_layer">truediv_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.truncated_normal">truncated_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.truncated_normal_initializer">truncated_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.truncated_normal_initializer_layer">truncated_normal_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.truncated_normal_layer">truncated_normal_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tuple">tuple</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.tuple_layer">tuple_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.uniform_candidate_sampler">uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.uniform_candidate_sampler_layer">uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.uniform_unit_scaling_initializer">uniform_unit_scaling_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.uniform_unit_scaling_initializer_layer">uniform_unit_scaling_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unique">unique</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unique_layer">unique_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unique_with_counts">unique_with_counts</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unique_with_counts_layer">unique_with_counts_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unpack">unpack</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unpack_layer">unpack_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unsorted_segment_sum">unsorted_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.unsorted_segment_sum_layer">unsorted_segment_sum_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.variable_axis_size_partitioner">variable_axis_size_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.variable_axis_size_partitioner_layer">variable_axis_size_partitioner_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.variable_op_scope">variable_op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.variable_op_scope_layer">variable_op_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.variable_scope">variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.variable_scope_layer">variable_scope_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.verify_tensor_all_finite">verify_tensor_all_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.verify_tensor_all_finite_layer">verify_tensor_all_finite_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.weighted_cross_entropy_with_logits">weighted_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.weighted_cross_entropy_with_logits_layer">weighted_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.where">where</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.where_layer">where_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.while_loop">while_loop</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.while_loop_layer">while_loop_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.xw_plus_b">xw_plus_b</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.xw_plus_b_layer">xw_plus_b_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.xw_plus_b_v1">xw_plus_b_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.xw_plus_b_v1_layer">xw_plus_b_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zero_fraction">zero_fraction</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zero_fraction_layer">zero_fraction_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeros">zeros</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeros_initializer">zeros_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeros_initializer_layer">zeros_initializer_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeros_layer">zeros_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeros_like">zeros_like</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeros_like_layer">zeros_like_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeta">zeta</a></li>
    <li class="mono"><a href="#tensorbuilder.dsl.Applicative.zeta_layer">zeta_layer</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">tensorbuilder.dsl</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">utils</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">tensorbuilder</span> <span class="kn">as</span> <span class="nn">tb</span>

<span class="c1">#######################</span>
<span class="c1">### FUNCTOR</span>
<span class="c1">#######################</span>
<span class="k">class</span> <span class="nc">Applicative</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for Applicative&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Applicative</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function of type `a -&gt; b`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a compy of the applicative&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@tb.immutable</span>
    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="n">_compose2</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">applicative</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1">#######################</span>
<span class="c1">### FUNCTIONS</span>
<span class="c1">#######################</span>

<span class="k">def</span> <span class="nf">_compose2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="n">_identity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">_compose_reversed</span><span class="p">(</span><span class="n">functions</span><span class="p">):</span>
    <span class="n">functions</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[:]</span>
    <span class="n">functions</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_compose2</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span> <span class="n">_identity</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sequence_function</span><span class="p">(</span><span class="n">tuple_ast</span><span class="p">):</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="k">for</span> <span class="n">ast</span> <span class="ow">in</span> <span class="n">tuple_ast</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">_compose_reversed</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_branch_function</span><span class="p">(</span><span class="n">list_ast</span><span class="p">):</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="k">for</span> <span class="n">ast</span> <span class="ow">in</span> <span class="n">list_ast</span> <span class="p">]</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">builder</span><span class="p">:</span> <span class="n">builder</span><span class="o">.</span><span class="n">branch</span><span class="p">(</span><span class="k">lambda</span> <span class="n">builder</span><span class="p">:</span> <span class="p">[</span> <span class="n">f</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span> <span class="p">])</span>

<span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">ast</span><span class="p">):</span>
    <span class="c1">#if type(ast) is tuple:</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_branch_function</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ast</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sequence_function</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
        <span class="c1">#raise Exception(&quot;Element has to be either a tuple for sequential operations, a list for branching, or a function from a builder to a builder, got %s, %s&quot; % (type(ast), type(ast) is tuple))</span>

<span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="o">*</span><span class="n">ast</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>


<span class="c1">#######################</span>
<span class="c1">### CODE GENERATION</span>
<span class="c1">#######################</span>

<span class="n">_builder_excluded</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">_builder_methods</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">Builder</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span> <span class="ow">and</span> <span class="n">_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_builder_excluded</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="s2">&quot;Builder&quot;</span><span class="p">,</span> <span class="n">_name</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="n">_tree_excluded</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;connect_layer&quot;</span> <span class="p">]</span> <span class="c1">#, &quot;tensors&quot;, &quot;builders&quot;]</span>
<span class="k">def</span> <span class="nf">_builder_tree_methods</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">BuilderTree</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span> <span class="ow">and</span> <span class="n">_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_tree_excluded</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="s2">&quot;BuilderTree&quot;</span><span class="p">,</span> <span class="n">_name</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>


<span class="k">for</span> <span class="n">_module_name</span><span class="p">,</span> <span class="n">_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">_builder_methods</span><span class="p">(),</span> <span class="n">_builder_tree_methods</span><span class="p">()):</span>
    <span class="n">_f_signature</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_method_sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">_f_docs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getdoc</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">exec</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>


<span class="s2">def {0}(*args, **kwargs):</span>
<span class="s2">	</span><span class="se">\&quot;\&quot;\&quot;</span><span class="s2"></span>
<span class="s2">THIS FUNCTION IS AUTOMATICALLY GENERATED</span>

<span class="s2">This function accepts the same arguments as `{3}.{0}` but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all \*args and \*\*kwargs to `{3}.{0}`. The returned function is an `tensorbuilder.dsl.Applicative`, so you can use all the methods defined by this class.</span>

<span class="s2">** utils of `{3}.{0}`**</span>

<span class="s2">	def {1}</span>


<span class="s2">	</span><span class="se">\&quot;\&quot;\&quot;</span><span class="s2"></span>

<span class="s2">	return Applicative(lambda builder: builder.{0}(*args, **kwargs))</span>


<span class="s2">@tb.immutable</span>
<span class="s2">def __{0}(app, *args, **kwargs):</span>
<span class="s2">    </span><span class="se">\&quot;\&quot;\&quot;</span><span class="s2"></span>
<span class="s2">THIS METHOD IS AUTOMATICALLY GENERATED</span>

<span class="s2">This method accepts the same arguments as `{3}.{0}` but:</span>

<span class="s2">1. Forwards all of its arguments to `tensorbuilder.dsl.{0}`, this returns a function `g`.</span>
<span class="s2">2. Applies `tensorbuilder.dsl.Applicative.compose` over `g`, this roughly computes the composition `g` of `tensorbuilder.dsl.Applicative.f`.</span>

<span class="s2">So the result of this method is compose `tensorbuilder.dsl.{0}` with `tensorbuilder.dsl.Applicative.f`.</span>

<span class="s2">** utils of `{3}.{0}`**</span>

<span class="s2">	def {1}</span>

<span class="s2">	</span><span class="se">\&quot;\&quot;\&quot;</span><span class="s2"></span>
<span class="s2">    g = {0}(*args, **kwargs)</span>
<span class="s2">    return app.compose(g)</span>

<span class="s2">Applicative.{0} = __{0}</span>

<span class="s2"> 	&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_f_signature</span><span class="p">,</span> <span class="n">_f_docs</span><span class="p">,</span> <span class="n">_module_name</span><span class="p">))</span>


<span class="c1">#######################</span>
<span class="c1">### MONEKY PATCHING</span>
<span class="c1">#######################</span>
<span class="n">tb</span><span class="o">.</span><span class="n">Builder</span><span class="o">.</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">builder</span><span class="p">()</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span>
        <span class="n">connect_layer</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">),</span>
        <span class="p">[</span>
            <span class="n">connect_layer</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">)</span>
            <span class="o">.</span><span class="n">connect_layer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">)</span>
        <span class="p">,</span>
            <span class="n">connect_layer</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">connect_layer</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">),</span>
        <span class="p">[</span>
            <span class="n">connect_layer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">,</span>
            <span class="n">connect_layer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">tensors</span>
    <span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Assert">
    <p>def <span class="ident">Assert</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.Assert</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.Assert</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.Assert</code></strong></p>
<div class="codehilite"><pre><span></span>    def Assert(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Assert_layer">
    <p>def <span class="ident">Assert_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.Assert_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.Assert_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.Assert_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def Assert_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.NoGradient">
    <p>def <span class="ident">NoGradient</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.NoGradient</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.NoGradient</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.NoGradient</code></strong></p>
<div class="codehilite"><pre><span></span>    def NoGradient(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.NoGradient_layer">
    <p>def <span class="ident">NoGradient_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.NoGradient_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.NoGradient_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.NoGradient_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def NoGradient_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Print">
    <p>def <span class="ident">Print</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.Print</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.Print</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.Print</code></strong></p>
<div class="codehilite"><pre><span></span>    def Print(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Print_layer">
    <p>def <span class="ident">Print_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.Print_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.Print_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.Print_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def Print_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.abs">
    <p>def <span class="ident">abs</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.abs</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.abs</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.abs</code></strong></p>
<div class="codehilite"><pre><span></span>    def abs(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.abs_layer">
    <p>def <span class="ident">abs_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.abs_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.abs_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.abs_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def abs_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.accumulate_n">
    <p>def <span class="ident">accumulate_n</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.accumulate_n</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.accumulate_n</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.accumulate_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def accumulate_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.accumulate_n_layer">
    <p>def <span class="ident">accumulate_n_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.accumulate_n_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.accumulate_n_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.accumulate_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def accumulate_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.acos">
    <p>def <span class="ident">acos</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.acos</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.acos</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.acos</code></strong></p>
<div class="codehilite"><pre><span></span>    def acos(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.acos_layer">
    <p>def <span class="ident">acos_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.acos_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.acos_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.acos_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def acos_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add">
    <p>def <span class="ident">add</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.add</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.add</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.add</code></strong></p>
<div class="codehilite"><pre><span></span>    def add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_check_numerics_ops">
    <p>def <span class="ident">add_check_numerics_ops</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.add_check_numerics_ops</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.add_check_numerics_ops</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.add_check_numerics_ops</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_check_numerics_ops(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_check_numerics_ops_layer">
    <p>def <span class="ident">add_check_numerics_ops_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.add_check_numerics_ops_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.add_check_numerics_ops_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.add_check_numerics_ops_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_check_numerics_ops_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_layer">
    <p>def <span class="ident">add_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.add_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.add_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_n">
    <p>def <span class="ident">add_n</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.add_n</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.add_n</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.add_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_n_layer">
    <p>def <span class="ident">add_n_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.add_n_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.add_n_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.add_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_to_collection">
    <p>def <span class="ident">add_to_collection</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.add_to_collection</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.add_to_collection</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.add_to_collection</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_to_collection(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.add_to_collection_layer">
    <p>def <span class="ident">add_to_collection_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.add_to_collection_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.add_to_collection_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.add_to_collection_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_to_collection_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.all_candidate_sampler">
    <p>def <span class="ident">all_candidate_sampler</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.all_candidate_sampler</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.all_candidate_sampler</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.all_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.all_candidate_sampler_layer">
    <p>def <span class="ident">all_candidate_sampler_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.all_candidate_sampler_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.all_candidate_sampler_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.all_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.all_variables">
    <p>def <span class="ident">all_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.all_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.all_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.all_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.all_variables_layer">
    <p>def <span class="ident">all_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.all_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.all_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.all_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.applicative">
    <p>def <span class="ident">applicative</span>(</p><p>f)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.applicative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.applicative" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">applicative</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.arg_max">
    <p>def <span class="ident">arg_max</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.arg_max</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.arg_max</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.arg_max</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_max(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.arg_max_layer">
    <p>def <span class="ident">arg_max_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.arg_max_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.arg_max_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.arg_max_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_max_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.arg_min">
    <p>def <span class="ident">arg_min</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.arg_min</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.arg_min</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.arg_min</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_min(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.arg_min_layer">
    <p>def <span class="ident">arg_min_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.arg_min_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.arg_min_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.arg_min_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_min_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.argmax_layer">
    <p>def <span class="ident">argmax_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.argmax_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.argmax_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.argmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def argmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.argmin_layer">
    <p>def <span class="ident">argmin_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.argmin_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.argmin_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.argmin_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def argmin_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.as_dtype">
    <p>def <span class="ident">as_dtype</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.as_dtype</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.as_dtype</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.as_dtype</code></strong></p>
<div class="codehilite"><pre><span></span>    def as_dtype(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.as_dtype_layer">
    <p>def <span class="ident">as_dtype_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.as_dtype_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.as_dtype_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.as_dtype_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def as_dtype_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.asin">
    <p>def <span class="ident">asin</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.asin</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.asin</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.asin</code></strong></p>
<div class="codehilite"><pre><span></span>    def asin(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.asin_layer">
    <p>def <span class="ident">asin_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.asin_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.asin_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.asin_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def asin_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_equal">
    <p>def <span class="ident">assert_equal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_equal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_equal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_equal_layer">
    <p>def <span class="ident">assert_equal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_equal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_equal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_integer">
    <p>def <span class="ident">assert_integer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_integer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_integer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_integer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_integer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_integer_layer">
    <p>def <span class="ident">assert_integer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_integer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_integer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_integer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_integer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_less">
    <p>def <span class="ident">assert_less</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_less</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_less</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_less</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_less_equal">
    <p>def <span class="ident">assert_less_equal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_less_equal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_less_equal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_less_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_less_equal_layer">
    <p>def <span class="ident">assert_less_equal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_less_equal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_less_equal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_less_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_less_layer">
    <p>def <span class="ident">assert_less_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_less_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_less_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_less_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_negative">
    <p>def <span class="ident">assert_negative</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_negative</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_negative</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_negative</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_negative(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_negative_layer">
    <p>def <span class="ident">assert_negative_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_negative_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_negative_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_negative_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_negative_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_non_negative">
    <p>def <span class="ident">assert_non_negative</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_non_negative</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_non_negative</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_non_negative</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_negative(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_non_negative_layer">
    <p>def <span class="ident">assert_non_negative_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_non_negative_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_non_negative_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_non_negative_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_negative_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_non_positive">
    <p>def <span class="ident">assert_non_positive</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_non_positive</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_non_positive</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_non_positive</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_positive(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_non_positive_layer">
    <p>def <span class="ident">assert_non_positive_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_non_positive_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_non_positive_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_non_positive_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_positive_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_positive">
    <p>def <span class="ident">assert_positive</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_positive</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_positive</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_positive</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_positive(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_positive_layer">
    <p>def <span class="ident">assert_positive_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_positive_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_positive_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_positive_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_positive_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_proper_iterable">
    <p>def <span class="ident">assert_proper_iterable</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_proper_iterable</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_proper_iterable</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_proper_iterable</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_proper_iterable(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_proper_iterable_layer">
    <p>def <span class="ident">assert_proper_iterable_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_proper_iterable_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_proper_iterable_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_proper_iterable_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_proper_iterable_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_rank">
    <p>def <span class="ident">assert_rank</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_rank</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_rank</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_rank</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_rank_at_least">
    <p>def <span class="ident">assert_rank_at_least</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_rank_at_least</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_rank_at_least</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_rank_at_least</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank_at_least(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_rank_at_least_layer">
    <p>def <span class="ident">assert_rank_at_least_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_rank_at_least_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_rank_at_least_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_rank_at_least_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank_at_least_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_rank_layer">
    <p>def <span class="ident">assert_rank_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_rank_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_rank_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_rank_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_type">
    <p>def <span class="ident">assert_type</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_type</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_type</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_type</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_type(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_type_layer">
    <p>def <span class="ident">assert_type_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_type_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_type_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_type_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_type_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_variables_initialized">
    <p>def <span class="ident">assert_variables_initialized</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assert_variables_initialized</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assert_variables_initialized</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assert_variables_initialized</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_variables_initialized(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assert_variables_initialized_layer">
    <p>def <span class="ident">assert_variables_initialized_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assert_variables_initialized_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assert_variables_initialized_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assert_variables_initialized_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_variables_initialized_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assign">
    <p>def <span class="ident">assign</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assign</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assign</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assign</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assign_add">
    <p>def <span class="ident">assign_add</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assign_add</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assign_add</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assign_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assign_add_layer">
    <p>def <span class="ident">assign_add_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assign_add_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assign_add_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assign_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assign_layer">
    <p>def <span class="ident">assign_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assign_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assign_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assign_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assign_sub">
    <p>def <span class="ident">assign_sub</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.assign_sub</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.assign_sub</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.assign_sub</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_sub(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.assign_sub_layer">
    <p>def <span class="ident">assign_sub_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.assign_sub_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.assign_sub_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.assign_sub_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_sub_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.atan">
    <p>def <span class="ident">atan</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.atan</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.atan</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.atan</code></strong></p>
<div class="codehilite"><pre><span></span>    def atan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.atan_layer">
    <p>def <span class="ident">atan_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.atan_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.atan_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.atan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def atan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.atrous_conv2d">
    <p>def <span class="ident">atrous_conv2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.atrous_conv2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.atrous_conv2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.atrous_conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def atrous_conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.atrous_conv2d_layer">
    <p>def <span class="ident">atrous_conv2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.atrous_conv2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.atrous_conv2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.atrous_conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def atrous_conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.audio_summary">
    <p>def <span class="ident">audio_summary</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.audio_summary</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.audio_summary</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.audio_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def audio_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.audio_summary_layer">
    <p>def <span class="ident">audio_summary_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.audio_summary_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.audio_summary_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.audio_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def audio_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.avg_pool">
    <p>def <span class="ident">avg_pool</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.avg_pool</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.avg_pool</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.avg_pool</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.avg_pool3d">
    <p>def <span class="ident">avg_pool3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.avg_pool3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.avg_pool3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.avg_pool3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.avg_pool3d_grad">
    <p>def <span class="ident">avg_pool3d_grad</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.avg_pool3d_grad</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.avg_pool3d_grad</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.avg_pool3d_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.avg_pool3d_grad_layer">
    <p>def <span class="ident">avg_pool3d_grad_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.avg_pool3d_grad_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.avg_pool3d_grad_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.avg_pool3d_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.avg_pool3d_layer">
    <p>def <span class="ident">avg_pool3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.avg_pool3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.avg_pool3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.avg_pool3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.avg_pool_layer">
    <p>def <span class="ident">avg_pool_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.avg_pool_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.avg_pool_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.avg_pool_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_cholesky">
    <p>def <span class="ident">batch_cholesky</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_cholesky</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_cholesky</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_cholesky</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_cholesky_layer">
    <p>def <span class="ident">batch_cholesky_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_cholesky_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_cholesky_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_cholesky_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_cholesky_solve">
    <p>def <span class="ident">batch_cholesky_solve</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_cholesky_solve</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_cholesky_solve</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_cholesky_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_cholesky_solve_layer">
    <p>def <span class="ident">batch_cholesky_solve_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_cholesky_solve_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_cholesky_solve_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_cholesky_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_fft">
    <p>def <span class="ident">batch_fft</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_fft</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_fft</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_fft</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_fft2d">
    <p>def <span class="ident">batch_fft2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_fft2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_fft2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_fft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_fft2d_layer">
    <p>def <span class="ident">batch_fft2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_fft2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_fft2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_fft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_fft3d">
    <p>def <span class="ident">batch_fft3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_fft3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_fft3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_fft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_fft3d_layer">
    <p>def <span class="ident">batch_fft3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_fft3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_fft3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_fft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_fft_layer">
    <p>def <span class="ident">batch_fft_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_fft_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_fft_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_fft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_ifft">
    <p>def <span class="ident">batch_ifft</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_ifft</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_ifft</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_ifft</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_ifft2d">
    <p>def <span class="ident">batch_ifft2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_ifft2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_ifft2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_ifft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_ifft2d_layer">
    <p>def <span class="ident">batch_ifft2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_ifft2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_ifft2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_ifft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_ifft3d">
    <p>def <span class="ident">batch_ifft3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_ifft3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_ifft3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_ifft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_ifft3d_layer">
    <p>def <span class="ident">batch_ifft3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_ifft3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_ifft3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_ifft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_ifft_layer">
    <p>def <span class="ident">batch_ifft_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_ifft_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_ifft_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_ifft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matmul_layer">
    <p>def <span class="ident">batch_matmul_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matmul_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matmul_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_band_part">
    <p>def <span class="ident">batch_matrix_band_part</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_band_part</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_band_part</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_band_part</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_band_part(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_band_part_layer">
    <p>def <span class="ident">batch_matrix_band_part_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_band_part_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_band_part_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_band_part_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_band_part_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_determinant">
    <p>def <span class="ident">batch_matrix_determinant</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_determinant</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_determinant</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_determinant</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_determinant(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_determinant_layer">
    <p>def <span class="ident">batch_matrix_determinant_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_determinant_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_determinant_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_determinant_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_determinant_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_diag">
    <p>def <span class="ident">batch_matrix_diag</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_diag</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_diag</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_diag</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_diag_layer">
    <p>def <span class="ident">batch_matrix_diag_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_diag_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_diag_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_diag_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_diag_part">
    <p>def <span class="ident">batch_matrix_diag_part</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_diag_part</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_diag_part</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_diag_part</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag_part(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_diag_part_layer">
    <p>def <span class="ident">batch_matrix_diag_part_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_diag_part_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_diag_part_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_diag_part_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag_part_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_inverse">
    <p>def <span class="ident">batch_matrix_inverse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_inverse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_inverse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_inverse</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_inverse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_inverse_layer">
    <p>def <span class="ident">batch_matrix_inverse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_inverse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_inverse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_inverse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_inverse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_solve">
    <p>def <span class="ident">batch_matrix_solve</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_solve</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_solve</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_solve_layer">
    <p>def <span class="ident">batch_matrix_solve_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_solve_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_solve_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_solve_ls">
    <p>def <span class="ident">batch_matrix_solve_ls</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_solve_ls</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_solve_ls</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_solve_ls</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve_ls(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_solve_ls_layer">
    <p>def <span class="ident">batch_matrix_solve_ls_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_solve_ls_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_solve_ls_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_solve_ls_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve_ls_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_triangular_solve">
    <p>def <span class="ident">batch_matrix_triangular_solve</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_matrix_triangular_solve</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_matrix_triangular_solve</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_matrix_triangular_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_triangular_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_matrix_triangular_solve_layer">
    <p>def <span class="ident">batch_matrix_triangular_solve_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_matrix_triangular_solve_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_matrix_triangular_solve_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_triangular_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_triangular_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_norm_with_global_normalization">
    <p>def <span class="ident">batch_norm_with_global_normalization</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_norm_with_global_normalization</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_norm_with_global_normalization</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_norm_with_global_normalization</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_norm_with_global_normalization(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_norm_with_global_normalization_layer">
    <p>def <span class="ident">batch_norm_with_global_normalization_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_norm_with_global_normalization_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_norm_with_global_normalization_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_norm_with_global_normalization_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_norm_with_global_normalization_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_normalization">
    <p>def <span class="ident">batch_normalization</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_normalization</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_normalization</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_normalization</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_normalization(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_normalization_layer">
    <p>def <span class="ident">batch_normalization_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_normalization_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_normalization_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_normalization_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_normalization_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_self_adjoint_eig">
    <p>def <span class="ident">batch_self_adjoint_eig</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_self_adjoint_eig</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_self_adjoint_eig</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_self_adjoint_eig</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_self_adjoint_eig(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_self_adjoint_eig_layer">
    <p>def <span class="ident">batch_self_adjoint_eig_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_self_adjoint_eig_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_self_adjoint_eig_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_self_adjoint_eig_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_self_adjoint_eig_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_to_space">
    <p>def <span class="ident">batch_to_space</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.batch_to_space</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.batch_to_space</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.batch_to_space</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_to_space(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.batch_to_space_layer">
    <p>def <span class="ident">batch_to_space_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.batch_to_space_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.batch_to_space_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.batch_to_space_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_to_space_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bias_add">
    <p>def <span class="ident">bias_add</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.bias_add</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.bias_add</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.bias_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bias_add_grad">
    <p>def <span class="ident">bias_add_grad</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.bias_add_grad</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.bias_add_grad</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.bias_add_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bias_add_grad_layer">
    <p>def <span class="ident">bias_add_grad_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.bias_add_grad_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.bias_add_grad_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.bias_add_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bias_add_layer">
    <p>def <span class="ident">bias_add_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.bias_add_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.bias_add_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.bias_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bias_add_v1">
    <p>def <span class="ident">bias_add_v1</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.bias_add_v1</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.bias_add_v1</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.bias_add_v1</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_v1(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bias_add_v1_layer">
    <p>def <span class="ident">bias_add_v1_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.bias_add_v1_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.bias_add_v1_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.bias_add_v1_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_v1_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bidirectional_rnn">
    <p>def <span class="ident">bidirectional_rnn</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.bidirectional_rnn</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.bidirectional_rnn</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.bidirectional_rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def bidirectional_rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bidirectional_rnn_layer">
    <p>def <span class="ident">bidirectional_rnn_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.bidirectional_rnn_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.bidirectional_rnn_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.bidirectional_rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bidirectional_rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bitcast">
    <p>def <span class="ident">bitcast</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.bitcast</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.bitcast</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.bitcast</code></strong></p>
<div class="codehilite"><pre><span></span>    def bitcast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.bitcast_layer">
    <p>def <span class="ident">bitcast_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.bitcast_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.bitcast_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.bitcast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bitcast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.boolean_mask">
    <p>def <span class="ident">boolean_mask</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.boolean_mask</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.boolean_mask</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.boolean_mask</code></strong></p>
<div class="codehilite"><pre><span></span>    def boolean_mask(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.boolean_mask_layer">
    <p>def <span class="ident">boolean_mask_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.boolean_mask_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.boolean_mask_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.boolean_mask_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def boolean_mask_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.branch">
    <p>def <span class="ident">branch</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.branch</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.branch</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.branch</code></strong></p>
<div class="codehilite"><pre><span></span>    def branch(builder, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.builders">
    <p>def <span class="ident">builders</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.builders</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.builders</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.builders</code></strong></p>
<div class="codehilite"><pre><span></span>    def builders(self)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.case">
    <p>def <span class="ident">case</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.case</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.case</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.case</code></strong></p>
<div class="codehilite"><pre><span></span>    def case(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.case_layer">
    <p>def <span class="ident">case_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.case_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.case_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.case_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def case_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cast">
    <p>def <span class="ident">cast</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.cast</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.cast</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.cast</code></strong></p>
<div class="codehilite"><pre><span></span>    def cast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cast_layer">
    <p>def <span class="ident">cast_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.cast_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.cast_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.cast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ceil">
    <p>def <span class="ident">ceil</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ceil</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ceil</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ceil</code></strong></p>
<div class="codehilite"><pre><span></span>    def ceil(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ceil_layer">
    <p>def <span class="ident">ceil_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ceil_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ceil_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ceil_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ceil_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.check_numerics">
    <p>def <span class="ident">check_numerics</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.check_numerics</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.check_numerics</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.check_numerics</code></strong></p>
<div class="codehilite"><pre><span></span>    def check_numerics(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.check_numerics_layer">
    <p>def <span class="ident">check_numerics_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.check_numerics_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.check_numerics_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.check_numerics_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def check_numerics_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cholesky">
    <p>def <span class="ident">cholesky</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.cholesky</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.cholesky</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.cholesky</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cholesky_layer">
    <p>def <span class="ident">cholesky_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.cholesky_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.cholesky_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.cholesky_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cholesky_solve">
    <p>def <span class="ident">cholesky_solve</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.cholesky_solve</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.cholesky_solve</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.cholesky_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cholesky_solve_layer">
    <p>def <span class="ident">cholesky_solve_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.cholesky_solve_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.cholesky_solve_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.cholesky_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_average_norm">
    <p>def <span class="ident">clip_by_average_norm</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.clip_by_average_norm</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.clip_by_average_norm</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.clip_by_average_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_average_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_average_norm_layer">
    <p>def <span class="ident">clip_by_average_norm_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.clip_by_average_norm_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.clip_by_average_norm_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.clip_by_average_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_average_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_global_norm">
    <p>def <span class="ident">clip_by_global_norm</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.clip_by_global_norm</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.clip_by_global_norm</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.clip_by_global_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_global_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_global_norm_layer">
    <p>def <span class="ident">clip_by_global_norm_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.clip_by_global_norm_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.clip_by_global_norm_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.clip_by_global_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_global_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_norm">
    <p>def <span class="ident">clip_by_norm</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.clip_by_norm</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.clip_by_norm</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.clip_by_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_norm_layer">
    <p>def <span class="ident">clip_by_norm_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.clip_by_norm_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.clip_by_norm_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.clip_by_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_value">
    <p>def <span class="ident">clip_by_value</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.clip_by_value</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.clip_by_value</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.clip_by_value</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_value(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.clip_by_value_layer">
    <p>def <span class="ident">clip_by_value_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.clip_by_value_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.clip_by_value_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.clip_by_value_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_value_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.compile">
    <p>def <span class="ident">compile</span>(</p><p>ast)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.compile', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.compile" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">ast</span><span class="p">):</span>
    <span class="c1">#if type(ast) is tuple:</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_branch_function</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ast</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sequence_function</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.complex">
    <p>def <span class="ident">complex</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.complex</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.complex</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.complex</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.complex_abs">
    <p>def <span class="ident">complex_abs</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.complex_abs</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.complex_abs</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.complex_abs</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex_abs(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.complex_abs_layer">
    <p>def <span class="ident">complex_abs_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.complex_abs_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.complex_abs_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.complex_abs_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex_abs_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.complex_layer">
    <p>def <span class="ident">complex_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.complex_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.complex_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.complex_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.compute_accidental_hits">
    <p>def <span class="ident">compute_accidental_hits</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.compute_accidental_hits</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.compute_accidental_hits</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.compute_accidental_hits</code></strong></p>
<div class="codehilite"><pre><span></span>    def compute_accidental_hits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.compute_accidental_hits_layer">
    <p>def <span class="ident">compute_accidental_hits_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.compute_accidental_hits_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.compute_accidental_hits_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.compute_accidental_hits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def compute_accidental_hits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.concat">
    <p>def <span class="ident">concat</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.concat</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.concat</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.concat</code></strong></p>
<div class="codehilite"><pre><span></span>    def concat(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.concat_layer">
    <p>def <span class="ident">concat_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.concat_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.concat_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.concat_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def concat_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cond">
    <p>def <span class="ident">cond</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.cond</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.cond</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.cond</code></strong></p>
<div class="codehilite"><pre><span></span>    def cond(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cond_layer">
    <p>def <span class="ident">cond_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.cond_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.cond_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.cond_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cond_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conj">
    <p>def <span class="ident">conj</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conj</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conj</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conj</code></strong></p>
<div class="codehilite"><pre><span></span>    def conj(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conj_layer">
    <p>def <span class="ident">conj_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conj_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conj_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conj_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conj_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.constant">
    <p>def <span class="ident">constant</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.constant</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.constant</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.constant</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.constant_initializer">
    <p>def <span class="ident">constant_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.constant_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.constant_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.constant_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.constant_initializer_layer">
    <p>def <span class="ident">constant_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.constant_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.constant_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.constant_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.constant_layer">
    <p>def <span class="ident">constant_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.constant_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.constant_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.constant_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.control_dependencies">
    <p>def <span class="ident">control_dependencies</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.control_dependencies</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.control_dependencies</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.control_dependencies</code></strong></p>
<div class="codehilite"><pre><span></span>    def control_dependencies(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.control_dependencies_layer">
    <p>def <span class="ident">control_dependencies_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.control_dependencies_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.control_dependencies_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.control_dependencies_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def control_dependencies_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv1d">
    <p>def <span class="ident">conv1d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv1d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv1d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv1d</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv1d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv1d_layer">
    <p>def <span class="ident">conv1d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv1d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv1d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv1d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv1d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d">
    <p>def <span class="ident">conv2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_backprop_filter">
    <p>def <span class="ident">conv2d_backprop_filter</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv2d_backprop_filter</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv2d_backprop_filter</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv2d_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_backprop_filter_layer">
    <p>def <span class="ident">conv2d_backprop_filter_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv2d_backprop_filter_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv2d_backprop_filter_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv2d_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_backprop_input">
    <p>def <span class="ident">conv2d_backprop_input</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv2d_backprop_input</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv2d_backprop_input</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv2d_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_backprop_input_layer">
    <p>def <span class="ident">conv2d_backprop_input_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv2d_backprop_input_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv2d_backprop_input_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv2d_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_layer">
    <p>def <span class="ident">conv2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_transpose">
    <p>def <span class="ident">conv2d_transpose</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv2d_transpose</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv2d_transpose</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv2d_transpose</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_transpose(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv2d_transpose_layer">
    <p>def <span class="ident">conv2d_transpose_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv2d_transpose_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv2d_transpose_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv2d_transpose_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_transpose_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv3d">
    <p>def <span class="ident">conv3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv3d_backprop_filter">
    <p>def <span class="ident">conv3d_backprop_filter</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv3d_backprop_filter</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv3d_backprop_filter</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv3d_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv3d_backprop_filter_layer">
    <p>def <span class="ident">conv3d_backprop_filter_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv3d_backprop_filter_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv3d_backprop_filter_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv3d_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv3d_backprop_input">
    <p>def <span class="ident">conv3d_backprop_input</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.conv3d_backprop_input</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.conv3d_backprop_input</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.conv3d_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv3d_backprop_input_layer">
    <p>def <span class="ident">conv3d_backprop_input_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv3d_backprop_input_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv3d_backprop_input_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv3d_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.conv3d_layer">
    <p>def <span class="ident">conv3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.conv3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.conv3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.conv3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.convert_to_tensor">
    <p>def <span class="ident">convert_to_tensor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.convert_to_tensor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.convert_to_tensor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.convert_to_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.convert_to_tensor_layer">
    <p>def <span class="ident">convert_to_tensor_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.convert_to_tensor_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.convert_to_tensor_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.convert_to_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.convert_to_tensor_or_indexed_slices">
    <p>def <span class="ident">convert_to_tensor_or_indexed_slices</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.convert_to_tensor_or_indexed_slices</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.convert_to_tensor_or_indexed_slices</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.convert_to_tensor_or_indexed_slices</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor_or_indexed_slices(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.convert_to_tensor_or_indexed_slices_layer">
    <p>def <span class="ident">convert_to_tensor_or_indexed_slices_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.convert_to_tensor_or_indexed_slices_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.convert_to_tensor_or_indexed_slices_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.convert_to_tensor_or_indexed_slices_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor_or_indexed_slices_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.convolution2d">
    <p>def <span class="ident">convolution2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.convolution2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.convolution2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.convolution2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def convolution2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cos">
    <p>def <span class="ident">cos</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.cos</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.cos</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.cos</code></strong></p>
<div class="codehilite"><pre><span></span>    def cos(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cos_layer">
    <p>def <span class="ident">cos_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.cos_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.cos_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.cos_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cos_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.count_up_to">
    <p>def <span class="ident">count_up_to</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.count_up_to</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.count_up_to</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.count_up_to</code></strong></p>
<div class="codehilite"><pre><span></span>    def count_up_to(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.count_up_to_layer">
    <p>def <span class="ident">count_up_to_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.count_up_to_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.count_up_to_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.count_up_to_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def count_up_to_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.create_partitioned_variables">
    <p>def <span class="ident">create_partitioned_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.create_partitioned_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.create_partitioned_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.create_partitioned_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def create_partitioned_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.create_partitioned_variables_layer">
    <p>def <span class="ident">create_partitioned_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.create_partitioned_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.create_partitioned_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.create_partitioned_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def create_partitioned_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cross">
    <p>def <span class="ident">cross</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.cross</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.cross</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.cross</code></strong></p>
<div class="codehilite"><pre><span></span>    def cross(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.cross_layer">
    <p>def <span class="ident">cross_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.cross_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.cross_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.cross_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cross_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.decode_csv">
    <p>def <span class="ident">decode_csv</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.decode_csv</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.decode_csv</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.decode_csv</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_csv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.decode_csv_layer">
    <p>def <span class="ident">decode_csv_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.decode_csv_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.decode_csv_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.decode_csv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_csv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.decode_json_example">
    <p>def <span class="ident">decode_json_example</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.decode_json_example</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.decode_json_example</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.decode_json_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_json_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.decode_json_example_layer">
    <p>def <span class="ident">decode_json_example_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.decode_json_example_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.decode_json_example_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.decode_json_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_json_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.decode_raw">
    <p>def <span class="ident">decode_raw</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.decode_raw</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.decode_raw</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.decode_raw</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_raw(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.decode_raw_layer">
    <p>def <span class="ident">decode_raw_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.decode_raw_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.decode_raw_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.decode_raw_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_raw_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.delete_session_tensor">
    <p>def <span class="ident">delete_session_tensor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.delete_session_tensor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.delete_session_tensor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.delete_session_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def delete_session_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.delete_session_tensor_layer">
    <p>def <span class="ident">delete_session_tensor_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.delete_session_tensor_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.delete_session_tensor_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.delete_session_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def delete_session_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depth_to_space">
    <p>def <span class="ident">depth_to_space</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.depth_to_space</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.depth_to_space</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.depth_to_space</code></strong></p>
<div class="codehilite"><pre><span></span>    def depth_to_space(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depth_to_space_layer">
    <p>def <span class="ident">depth_to_space_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.depth_to_space_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.depth_to_space_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.depth_to_space_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depth_to_space_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d">
    <p>def <span class="ident">depthwise_conv2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.depthwise_conv2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.depthwise_conv2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.depthwise_conv2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.depthwise_conv2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_native">
    <p>def <span class="ident">depthwise_conv2d_native</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.depthwise_conv2d_native</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.depthwise_conv2d_native</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d_native</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.depthwise_conv2d_native_backprop_filter</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.depthwise_conv2d_native_backprop_filter</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d_native_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.depthwise_conv2d_native_backprop_filter_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.depthwise_conv2d_native_backprop_filter_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_native_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_native_backprop_input">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.depthwise_conv2d_native_backprop_input</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.depthwise_conv2d_native_backprop_input</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d_native_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_native_backprop_input_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.depthwise_conv2d_native_backprop_input_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.depthwise_conv2d_native_backprop_input_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_native_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.depthwise_conv2d_native_layer">
    <p>def <span class="ident">depthwise_conv2d_native_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.depthwise_conv2d_native_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.depthwise_conv2d_native_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_native_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.deserialize_many_sparse">
    <p>def <span class="ident">deserialize_many_sparse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.deserialize_many_sparse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.deserialize_many_sparse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.deserialize_many_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def deserialize_many_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.deserialize_many_sparse_layer">
    <p>def <span class="ident">deserialize_many_sparse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.deserialize_many_sparse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.deserialize_many_sparse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.deserialize_many_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def deserialize_many_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.device">
    <p>def <span class="ident">device</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.device</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.device</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.device</code></strong></p>
<div class="codehilite"><pre><span></span>    def device(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.device_layer">
    <p>def <span class="ident">device_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.device_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.device_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.device_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def device_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.diag">
    <p>def <span class="ident">diag</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.diag</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.diag</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.diag</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.diag_layer">
    <p>def <span class="ident">diag_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.diag_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.diag_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.diag_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.diag_part">
    <p>def <span class="ident">diag_part</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.diag_part</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.diag_part</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.diag_part</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag_part(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.diag_part_layer">
    <p>def <span class="ident">diag_part_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.diag_part_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.diag_part_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.diag_part_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag_part_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.digamma">
    <p>def <span class="ident">digamma</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.digamma</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.digamma</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.digamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def digamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.digamma_layer">
    <p>def <span class="ident">digamma_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.digamma_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.digamma_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.digamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def digamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dilation2d">
    <p>def <span class="ident">dilation2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dilation2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dilation2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dilation2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dilation2d_backprop_filter">
    <p>def <span class="ident">dilation2d_backprop_filter</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dilation2d_backprop_filter</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dilation2d_backprop_filter</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dilation2d_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dilation2d_backprop_filter_layer">
    <p>def <span class="ident">dilation2d_backprop_filter_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dilation2d_backprop_filter_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dilation2d_backprop_filter_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dilation2d_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dilation2d_backprop_input">
    <p>def <span class="ident">dilation2d_backprop_input</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dilation2d_backprop_input</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dilation2d_backprop_input</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dilation2d_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dilation2d_backprop_input_layer">
    <p>def <span class="ident">dilation2d_backprop_input_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dilation2d_backprop_input_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dilation2d_backprop_input_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dilation2d_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dilation2d_layer">
    <p>def <span class="ident">dilation2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dilation2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dilation2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dilation2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.div">
    <p>def <span class="ident">div</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.div</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.div</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.div</code></strong></p>
<div class="codehilite"><pre><span></span>    def div(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.div_layer">
    <p>def <span class="ident">div_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.div_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.div_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.div_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def div_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dropout">
    <p>def <span class="ident">dropout</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dropout</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dropout</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dropout</code></strong></p>
<div class="codehilite"><pre><span></span>    def dropout(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dropout_layer">
    <p>def <span class="ident">dropout_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dropout_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dropout_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dropout_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dropout_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dynamic_partition">
    <p>def <span class="ident">dynamic_partition</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dynamic_partition</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dynamic_partition</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dynamic_partition</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_partition(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dynamic_partition_layer">
    <p>def <span class="ident">dynamic_partition_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dynamic_partition_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dynamic_partition_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dynamic_partition_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_partition_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dynamic_rnn">
    <p>def <span class="ident">dynamic_rnn</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dynamic_rnn</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dynamic_rnn</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dynamic_rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dynamic_rnn_layer">
    <p>def <span class="ident">dynamic_rnn_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dynamic_rnn_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dynamic_rnn_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dynamic_rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dynamic_stitch">
    <p>def <span class="ident">dynamic_stitch</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.dynamic_stitch</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.dynamic_stitch</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.dynamic_stitch</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_stitch(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.dynamic_stitch_layer">
    <p>def <span class="ident">dynamic_stitch_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.dynamic_stitch_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.dynamic_stitch_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.dynamic_stitch_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_stitch_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.edit_distance">
    <p>def <span class="ident">edit_distance</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.edit_distance</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.edit_distance</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.edit_distance</code></strong></p>
<div class="codehilite"><pre><span></span>    def edit_distance(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.edit_distance_layer">
    <p>def <span class="ident">edit_distance_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.edit_distance_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.edit_distance_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.edit_distance_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def edit_distance_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.elu">
    <p>def <span class="ident">elu</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.elu</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.elu</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.elu</code></strong></p>
<div class="codehilite"><pre><span></span>    def elu(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.elu_layer">
    <p>def <span class="ident">elu_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.elu_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.elu_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.elu_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def elu_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.embedding_lookup">
    <p>def <span class="ident">embedding_lookup</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.embedding_lookup</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.embedding_lookup</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.embedding_lookup</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.embedding_lookup_layer">
    <p>def <span class="ident">embedding_lookup_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.embedding_lookup_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.embedding_lookup_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.embedding_lookup_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.embedding_lookup_sparse">
    <p>def <span class="ident">embedding_lookup_sparse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.embedding_lookup_sparse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.embedding_lookup_sparse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.embedding_lookup_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.embedding_lookup_sparse_layer">
    <p>def <span class="ident">embedding_lookup_sparse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.embedding_lookup_sparse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.embedding_lookup_sparse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.embedding_lookup_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.equal">
    <p>def <span class="ident">equal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.equal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.equal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.equal_layer">
    <p>def <span class="ident">equal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.equal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.equal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.erf">
    <p>def <span class="ident">erf</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.erf</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.erf</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.erf</code></strong></p>
<div class="codehilite"><pre><span></span>    def erf(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.erf_layer">
    <p>def <span class="ident">erf_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.erf_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.erf_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.erf_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def erf_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.erfc">
    <p>def <span class="ident">erfc</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.erfc</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.erfc</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.erfc</code></strong></p>
<div class="codehilite"><pre><span></span>    def erfc(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.erfc_layer">
    <p>def <span class="ident">erfc_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.erfc_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.erfc_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.erfc_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def erfc_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.erosion2d">
    <p>def <span class="ident">erosion2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.erosion2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.erosion2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.erosion2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def erosion2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.erosion2d_layer">
    <p>def <span class="ident">erosion2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.erosion2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.erosion2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.erosion2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def erosion2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.exp">
    <p>def <span class="ident">exp</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.exp</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.exp</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.exp</code></strong></p>
<div class="codehilite"><pre><span></span>    def exp(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.exp_layer">
    <p>def <span class="ident">exp_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.exp_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.exp_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.exp_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def exp_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.expand_dims">
    <p>def <span class="ident">expand_dims</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.expand_dims</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.expand_dims</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.expand_dims</code></strong></p>
<div class="codehilite"><pre><span></span>    def expand_dims(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.expand_dims_layer">
    <p>def <span class="ident">expand_dims_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.expand_dims_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.expand_dims_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.expand_dims_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def expand_dims_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.extract">
    <p>def <span class="ident">extract</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.extract</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.extract</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.extract</code></strong></p>
<div class="codehilite"><pre><span></span>    def extract(tree, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.extract_image_patches">
    <p>def <span class="ident">extract_image_patches</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.extract_image_patches</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.extract_image_patches</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.extract_image_patches</code></strong></p>
<div class="codehilite"><pre><span></span>    def extract_image_patches(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.extract_image_patches_layer">
    <p>def <span class="ident">extract_image_patches_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.extract_image_patches_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.extract_image_patches_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.extract_image_patches_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def extract_image_patches_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fft">
    <p>def <span class="ident">fft</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.fft</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.fft</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.fft</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fft2d">
    <p>def <span class="ident">fft2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.fft2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.fft2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.fft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fft2d_layer">
    <p>def <span class="ident">fft2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.fft2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.fft2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.fft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fft3d">
    <p>def <span class="ident">fft3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.fft3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.fft3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.fft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fft3d_layer">
    <p>def <span class="ident">fft3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.fft3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.fft3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.fft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fft_layer">
    <p>def <span class="ident">fft_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.fft_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.fft_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.fft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fill">
    <p>def <span class="ident">fill</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.fill</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.fill</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.fill</code></strong></p>
<div class="codehilite"><pre><span></span>    def fill(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fill_layer">
    <p>def <span class="ident">fill_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.fill_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.fill_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.fill_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fill_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fixed_unigram_candidate_sampler">
    <p>def <span class="ident">fixed_unigram_candidate_sampler</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.fixed_unigram_candidate_sampler</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.fixed_unigram_candidate_sampler</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.fixed_unigram_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def fixed_unigram_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fixed_unigram_candidate_sampler_layer">
    <p>def <span class="ident">fixed_unigram_candidate_sampler_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.fixed_unigram_candidate_sampler_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.fixed_unigram_candidate_sampler_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.fixed_unigram_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fixed_unigram_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.floor">
    <p>def <span class="ident">floor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.floor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.floor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.floor</code></strong></p>
<div class="codehilite"><pre><span></span>    def floor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.floor_layer">
    <p>def <span class="ident">floor_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.floor_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.floor_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.floor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def floor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.floordiv">
    <p>def <span class="ident">floordiv</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.floordiv</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.floordiv</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.floordiv</code></strong></p>
<div class="codehilite"><pre><span></span>    def floordiv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.floordiv_layer">
    <p>def <span class="ident">floordiv_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.floordiv_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.floordiv_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.floordiv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def floordiv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.foldl">
    <p>def <span class="ident">foldl</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.foldl</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.foldl</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.foldl</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldl(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.foldl_layer">
    <p>def <span class="ident">foldl_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.foldl_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.foldl_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.foldl_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldl_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.foldr">
    <p>def <span class="ident">foldr</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.foldr</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.foldr</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.foldr</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldr(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.foldr_layer">
    <p>def <span class="ident">foldr_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.foldr_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.foldr_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.foldr_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldr_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.fully_connected">
    <p>def <span class="ident">fully_connected</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.fully_connected</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.fully_connected</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.fully_connected</code></strong></p>
<div class="codehilite"><pre><span></span>    def fully_connected(tree, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.gather">
    <p>def <span class="ident">gather</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.gather</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.gather</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.gather</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.gather_layer">
    <p>def <span class="ident">gather_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.gather_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.gather_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.gather_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.gather_nd">
    <p>def <span class="ident">gather_nd</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.gather_nd</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.gather_nd</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.gather_nd</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather_nd(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.gather_nd_layer">
    <p>def <span class="ident">gather_nd_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.gather_nd_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.gather_nd_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.gather_nd_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather_nd_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_collection">
    <p>def <span class="ident">get_collection</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_collection</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_collection</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_collection</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_collection_layer">
    <p>def <span class="ident">get_collection_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_collection_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_collection_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_collection_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_collection_ref">
    <p>def <span class="ident">get_collection_ref</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_collection_ref</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_collection_ref</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_collection_ref</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection_ref(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_collection_ref_layer">
    <p>def <span class="ident">get_collection_ref_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_collection_ref_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_collection_ref_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_collection_ref_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection_ref_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_default_graph">
    <p>def <span class="ident">get_default_graph</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_default_graph</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_default_graph</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_default_graph</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_graph(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_default_graph_layer">
    <p>def <span class="ident">get_default_graph_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_default_graph_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_default_graph_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_default_graph_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_graph_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_default_session">
    <p>def <span class="ident">get_default_session</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_default_session</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_default_session</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_default_session</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_session(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_default_session_layer">
    <p>def <span class="ident">get_default_session_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_default_session_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_default_session_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_default_session_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_session_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_seed">
    <p>def <span class="ident">get_seed</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_seed</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_seed</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_seed</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_seed(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_seed_layer">
    <p>def <span class="ident">get_seed_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_seed_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_seed_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_seed_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_seed_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_session_handle">
    <p>def <span class="ident">get_session_handle</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_session_handle</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_session_handle</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_session_handle</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_handle(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_session_handle_layer">
    <p>def <span class="ident">get_session_handle_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_session_handle_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_session_handle_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_session_handle_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_handle_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_session_tensor">
    <p>def <span class="ident">get_session_tensor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_session_tensor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_session_tensor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_session_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_session_tensor_layer">
    <p>def <span class="ident">get_session_tensor_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_session_tensor_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_session_tensor_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_session_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_variable">
    <p>def <span class="ident">get_variable</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_variable</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_variable</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_variable</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_variable_layer">
    <p>def <span class="ident">get_variable_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_variable_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_variable_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_variable_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_variable_scope">
    <p>def <span class="ident">get_variable_scope</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.get_variable_scope</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.get_variable_scope</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.get_variable_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.get_variable_scope_layer">
    <p>def <span class="ident">get_variable_scope_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.get_variable_scope_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.get_variable_scope_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.get_variable_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.global_norm">
    <p>def <span class="ident">global_norm</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.global_norm</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.global_norm</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.global_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def global_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.global_norm_layer">
    <p>def <span class="ident">global_norm_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.global_norm_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.global_norm_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.global_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def global_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.gradients">
    <p>def <span class="ident">gradients</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.gradients</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.gradients</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.gradients</code></strong></p>
<div class="codehilite"><pre><span></span>    def gradients(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.gradients_layer">
    <p>def <span class="ident">gradients_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.gradients_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.gradients_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.gradients_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def gradients_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.greater">
    <p>def <span class="ident">greater</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.greater</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.greater</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.greater</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.greater_equal">
    <p>def <span class="ident">greater_equal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.greater_equal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.greater_equal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.greater_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.greater_equal_layer">
    <p>def <span class="ident">greater_equal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.greater_equal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.greater_equal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.greater_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.greater_layer">
    <p>def <span class="ident">greater_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.greater_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.greater_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.greater_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.group">
    <p>def <span class="ident">group</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.group</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.group</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.group</code></strong></p>
<div class="codehilite"><pre><span></span>    def group(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.group_layer">
    <p>def <span class="ident">group_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.group_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.group_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.group_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def group_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.histogram_fixed_width">
    <p>def <span class="ident">histogram_fixed_width</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.histogram_fixed_width</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.histogram_fixed_width</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.histogram_fixed_width</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_fixed_width(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.histogram_fixed_width_layer">
    <p>def <span class="ident">histogram_fixed_width_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.histogram_fixed_width_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.histogram_fixed_width_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.histogram_fixed_width_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_fixed_width_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.histogram_summary">
    <p>def <span class="ident">histogram_summary</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.histogram_summary</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.histogram_summary</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.histogram_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.histogram_summary_layer">
    <p>def <span class="ident">histogram_summary_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.histogram_summary_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.histogram_summary_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.histogram_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.identity">
    <p>def <span class="ident">identity</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.identity</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.identity</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.identity</code></strong></p>
<div class="codehilite"><pre><span></span>    def identity(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.identity_layer">
    <p>def <span class="ident">identity_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.identity_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.identity_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.identity_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def identity_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ifft">
    <p>def <span class="ident">ifft</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ifft</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ifft</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ifft</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ifft2d">
    <p>def <span class="ident">ifft2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ifft2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ifft2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ifft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ifft2d_layer">
    <p>def <span class="ident">ifft2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ifft2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ifft2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ifft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ifft3d">
    <p>def <span class="ident">ifft3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ifft3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ifft3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ifft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ifft3d_layer">
    <p>def <span class="ident">ifft3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ifft3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ifft3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ifft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ifft_layer">
    <p>def <span class="ident">ifft_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ifft_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ifft_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ifft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.igamma">
    <p>def <span class="ident">igamma</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.igamma</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.igamma</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.igamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def igamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.igamma_layer">
    <p>def <span class="ident">igamma_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.igamma_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.igamma_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.igamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def igamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.igammac">
    <p>def <span class="ident">igammac</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.igammac</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.igammac</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.igammac</code></strong></p>
<div class="codehilite"><pre><span></span>    def igammac(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.igammac_layer">
    <p>def <span class="ident">igammac_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.igammac_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.igammac_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.igammac_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def igammac_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.imag">
    <p>def <span class="ident">imag</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.imag</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.imag</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.imag</code></strong></p>
<div class="codehilite"><pre><span></span>    def imag(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.imag_layer">
    <p>def <span class="ident">imag_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.imag_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.imag_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.imag_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def imag_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.image_summary">
    <p>def <span class="ident">image_summary</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.image_summary</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.image_summary</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.image_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def image_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.image_summary_layer">
    <p>def <span class="ident">image_summary_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.image_summary_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.image_summary_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.image_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def image_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.import_graph_def">
    <p>def <span class="ident">import_graph_def</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.import_graph_def</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.import_graph_def</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.import_graph_def</code></strong></p>
<div class="codehilite"><pre><span></span>    def import_graph_def(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.import_graph_def_layer">
    <p>def <span class="ident">import_graph_def_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.import_graph_def_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.import_graph_def_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.import_graph_def_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def import_graph_def_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.in_top_k">
    <p>def <span class="ident">in_top_k</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.in_top_k</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.in_top_k</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.in_top_k</code></strong></p>
<div class="codehilite"><pre><span></span>    def in_top_k(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.in_top_k_layer">
    <p>def <span class="ident">in_top_k_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.in_top_k_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.in_top_k_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.in_top_k_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def in_top_k_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_all_tables">
    <p>def <span class="ident">initialize_all_tables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.initialize_all_tables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.initialize_all_tables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.initialize_all_tables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_tables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_all_tables_layer">
    <p>def <span class="ident">initialize_all_tables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.initialize_all_tables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.initialize_all_tables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.initialize_all_tables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_tables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_all_variables">
    <p>def <span class="ident">initialize_all_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.initialize_all_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.initialize_all_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.initialize_all_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_all_variables_layer">
    <p>def <span class="ident">initialize_all_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.initialize_all_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.initialize_all_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.initialize_all_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_local_variables">
    <p>def <span class="ident">initialize_local_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.initialize_local_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.initialize_local_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.initialize_local_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_local_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_local_variables_layer">
    <p>def <span class="ident">initialize_local_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.initialize_local_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.initialize_local_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.initialize_local_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_local_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_variables">
    <p>def <span class="ident">initialize_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.initialize_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.initialize_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.initialize_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.initialize_variables_layer">
    <p>def <span class="ident">initialize_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.initialize_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.initialize_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.initialize_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.inv">
    <p>def <span class="ident">inv</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.inv</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.inv</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.inv</code></strong></p>
<div class="codehilite"><pre><span></span>    def inv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.inv_layer">
    <p>def <span class="ident">inv_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.inv_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.inv_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.inv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def inv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.invert_permutation">
    <p>def <span class="ident">invert_permutation</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.invert_permutation</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.invert_permutation</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.invert_permutation</code></strong></p>
<div class="codehilite"><pre><span></span>    def invert_permutation(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.invert_permutation_layer">
    <p>def <span class="ident">invert_permutation_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.invert_permutation_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.invert_permutation_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.invert_permutation_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def invert_permutation_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_finite">
    <p>def <span class="ident">is_finite</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_finite</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_finite</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_finite</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_finite(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_finite_layer">
    <p>def <span class="ident">is_finite_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_finite_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_finite_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_finite_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_finite_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_inf">
    <p>def <span class="ident">is_inf</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_inf</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_inf</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_inf</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_inf(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_inf_layer">
    <p>def <span class="ident">is_inf_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_inf_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_inf_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_inf_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_inf_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_nan">
    <p>def <span class="ident">is_nan</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_nan</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_nan</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_nan</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_nan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_nan_layer">
    <p>def <span class="ident">is_nan_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_nan_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_nan_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_nan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_nan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_non_decreasing">
    <p>def <span class="ident">is_non_decreasing</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_non_decreasing</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_non_decreasing</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_non_decreasing</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_non_decreasing(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_non_decreasing_layer">
    <p>def <span class="ident">is_non_decreasing_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_non_decreasing_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_non_decreasing_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_non_decreasing_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_non_decreasing_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_numeric_tensor">
    <p>def <span class="ident">is_numeric_tensor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_numeric_tensor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_numeric_tensor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_numeric_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_numeric_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_numeric_tensor_layer">
    <p>def <span class="ident">is_numeric_tensor_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_numeric_tensor_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_numeric_tensor_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_numeric_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_numeric_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_strictly_increasing">
    <p>def <span class="ident">is_strictly_increasing</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_strictly_increasing</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_strictly_increasing</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_strictly_increasing</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_strictly_increasing(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_strictly_increasing_layer">
    <p>def <span class="ident">is_strictly_increasing_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_strictly_increasing_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_strictly_increasing_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_strictly_increasing_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_strictly_increasing_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_variable_initialized">
    <p>def <span class="ident">is_variable_initialized</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.is_variable_initialized</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.is_variable_initialized</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.is_variable_initialized</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_variable_initialized(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.is_variable_initialized_layer">
    <p>def <span class="ident">is_variable_initialized_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.is_variable_initialized_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.is_variable_initialized_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.is_variable_initialized_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_variable_initialized_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.l2_loss">
    <p>def <span class="ident">l2_loss</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.l2_loss</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.l2_loss</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.l2_loss</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_loss(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.l2_loss_layer">
    <p>def <span class="ident">l2_loss_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.l2_loss_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.l2_loss_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.l2_loss_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_loss_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.l2_normalize">
    <p>def <span class="ident">l2_normalize</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.l2_normalize</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.l2_normalize</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.l2_normalize</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_normalize(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.l2_normalize_layer">
    <p>def <span class="ident">l2_normalize_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.l2_normalize_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.l2_normalize_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.l2_normalize_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_normalize_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lbeta">
    <p>def <span class="ident">lbeta</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.lbeta</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.lbeta</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.lbeta</code></strong></p>
<div class="codehilite"><pre><span></span>    def lbeta(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lbeta_layer">
    <p>def <span class="ident">lbeta_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.lbeta_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.lbeta_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.lbeta_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lbeta_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.learned_unigram_candidate_sampler">
    <p>def <span class="ident">learned_unigram_candidate_sampler</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.learned_unigram_candidate_sampler</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.learned_unigram_candidate_sampler</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.learned_unigram_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def learned_unigram_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.learned_unigram_candidate_sampler_layer">
    <p>def <span class="ident">learned_unigram_candidate_sampler_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.learned_unigram_candidate_sampler_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.learned_unigram_candidate_sampler_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.learned_unigram_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def learned_unigram_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.less">
    <p>def <span class="ident">less</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.less</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.less</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.less</code></strong></p>
<div class="codehilite"><pre><span></span>    def less(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.less_equal">
    <p>def <span class="ident">less_equal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.less_equal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.less_equal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.less_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def less_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.less_equal_layer">
    <p>def <span class="ident">less_equal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.less_equal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.less_equal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.less_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def less_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.less_layer">
    <p>def <span class="ident">less_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.less_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.less_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.less_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def less_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lgamma">
    <p>def <span class="ident">lgamma</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.lgamma</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.lgamma</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.lgamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def lgamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lgamma_layer">
    <p>def <span class="ident">lgamma_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.lgamma_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.lgamma_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.lgamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lgamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lin_space">
    <p>def <span class="ident">lin_space</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.lin_space</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.lin_space</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.lin_space</code></strong></p>
<div class="codehilite"><pre><span></span>    def lin_space(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lin_space_layer">
    <p>def <span class="ident">lin_space_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.lin_space_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.lin_space_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.lin_space_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lin_space_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.linspace_layer">
    <p>def <span class="ident">linspace_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.linspace_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.linspace_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.linspace_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def linspace_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.list_diff">
    <p>def <span class="ident">list_diff</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.list_diff</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.list_diff</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.list_diff</code></strong></p>
<div class="codehilite"><pre><span></span>    def list_diff(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.list_diff_layer">
    <p>def <span class="ident">list_diff_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.list_diff_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.list_diff_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.list_diff_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def list_diff_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.listdiff_layer">
    <p>def <span class="ident">listdiff_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.listdiff_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.listdiff_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.listdiff_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def listdiff_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.load_file_system_library">
    <p>def <span class="ident">load_file_system_library</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.load_file_system_library</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.load_file_system_library</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.load_file_system_library</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_file_system_library(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.load_file_system_library_layer">
    <p>def <span class="ident">load_file_system_library_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.load_file_system_library_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.load_file_system_library_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.load_file_system_library_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_file_system_library_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.load_op_library">
    <p>def <span class="ident">load_op_library</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.load_op_library</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.load_op_library</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.load_op_library</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_op_library(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.load_op_library_layer">
    <p>def <span class="ident">load_op_library_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.load_op_library_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.load_op_library_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.load_op_library_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_op_library_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.local_response_normalization_layer">
    <p>def <span class="ident">local_response_normalization_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.local_response_normalization_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.local_response_normalization_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.local_response_normalization_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def local_response_normalization_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.local_variables">
    <p>def <span class="ident">local_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.local_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.local_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.local_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def local_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.local_variables_layer">
    <p>def <span class="ident">local_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.local_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.local_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.local_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def local_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.log">
    <p>def <span class="ident">log</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.log</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.log</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.log</code></strong></p>
<div class="codehilite"><pre><span></span>    def log(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.log_layer">
    <p>def <span class="ident">log_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.log_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.log_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.log_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.log_softmax">
    <p>def <span class="ident">log_softmax</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.log_softmax</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.log_softmax</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.log_softmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_softmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.log_softmax_layer">
    <p>def <span class="ident">log_softmax_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.log_softmax_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.log_softmax_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.log_softmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_softmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.log_uniform_candidate_sampler">
    <p>def <span class="ident">log_uniform_candidate_sampler</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.log_uniform_candidate_sampler</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.log_uniform_candidate_sampler</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.log_uniform_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_uniform_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.log_uniform_candidate_sampler_layer">
    <p>def <span class="ident">log_uniform_candidate_sampler_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.log_uniform_candidate_sampler_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.log_uniform_candidate_sampler_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.log_uniform_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_uniform_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_and">
    <p>def <span class="ident">logical_and</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.logical_and</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.logical_and</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.logical_and</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_and(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_and_layer">
    <p>def <span class="ident">logical_and_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.logical_and_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.logical_and_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.logical_and_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_and_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_not">
    <p>def <span class="ident">logical_not</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.logical_not</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.logical_not</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.logical_not</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_not(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_not_layer">
    <p>def <span class="ident">logical_not_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.logical_not_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.logical_not_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.logical_not_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_not_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_or">
    <p>def <span class="ident">logical_or</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.logical_or</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.logical_or</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.logical_or</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_or(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_or_layer">
    <p>def <span class="ident">logical_or_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.logical_or_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.logical_or_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.logical_or_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_or_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_xor">
    <p>def <span class="ident">logical_xor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.logical_xor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.logical_xor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.logical_xor</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_xor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.logical_xor_layer">
    <p>def <span class="ident">logical_xor_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.logical_xor_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.logical_xor_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.logical_xor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_xor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lrn">
    <p>def <span class="ident">lrn</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.lrn</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.lrn</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.lrn</code></strong></p>
<div class="codehilite"><pre><span></span>    def lrn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.lrn_layer">
    <p>def <span class="ident">lrn_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.lrn_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.lrn_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.lrn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lrn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.make_all">
    <p>def <span class="ident">make_all</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.make_all</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.make_all</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.make_all</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_all(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.make_all_layer">
    <p>def <span class="ident">make_all_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.make_all_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.make_all_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.make_all_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_all_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.make_template">
    <p>def <span class="ident">make_template</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.make_template</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.make_template</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.make_template</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_template(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.make_template_layer">
    <p>def <span class="ident">make_template_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.make_template_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.make_template_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.make_template_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_template_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.map">
    <p>def <span class="ident">map</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.map</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.map</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.map</code></strong></p>
<div class="codehilite"><pre><span></span>    def map(builder, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.map_each">
    <p>def <span class="ident">map_each</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.map_each</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.map_each</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.map_each</code></strong></p>
<div class="codehilite"><pre><span></span>    def map_each(tree, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.map_fn">
    <p>def <span class="ident">map_fn</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.map_fn</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.map_fn</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.map_fn</code></strong></p>
<div class="codehilite"><pre><span></span>    def map_fn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.map_fn_layer">
    <p>def <span class="ident">map_fn_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.map_fn_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.map_fn_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.map_fn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def map_fn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matching_files">
    <p>def <span class="ident">matching_files</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matching_files</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matching_files</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matching_files</code></strong></p>
<div class="codehilite"><pre><span></span>    def matching_files(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matching_files_layer">
    <p>def <span class="ident">matching_files_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matching_files_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matching_files_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matching_files_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matching_files_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matmul">
    <p>def <span class="ident">matmul</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matmul</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matmul</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matmul</code></strong></p>
<div class="codehilite"><pre><span></span>    def matmul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matmul_layer">
    <p>def <span class="ident">matmul_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matmul_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matmul_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_determinant">
    <p>def <span class="ident">matrix_determinant</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matrix_determinant</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matrix_determinant</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matrix_determinant</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_determinant(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_determinant_layer">
    <p>def <span class="ident">matrix_determinant_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matrix_determinant_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matrix_determinant_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matrix_determinant_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_determinant_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_inverse">
    <p>def <span class="ident">matrix_inverse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matrix_inverse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matrix_inverse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matrix_inverse</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_inverse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_inverse_layer">
    <p>def <span class="ident">matrix_inverse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matrix_inverse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matrix_inverse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matrix_inverse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_inverse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_solve">
    <p>def <span class="ident">matrix_solve</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matrix_solve</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matrix_solve</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matrix_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_solve_layer">
    <p>def <span class="ident">matrix_solve_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matrix_solve_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matrix_solve_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matrix_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_solve_ls">
    <p>def <span class="ident">matrix_solve_ls</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matrix_solve_ls</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matrix_solve_ls</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matrix_solve_ls</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve_ls(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_solve_ls_layer">
    <p>def <span class="ident">matrix_solve_ls_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matrix_solve_ls_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matrix_solve_ls_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matrix_solve_ls_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve_ls_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_triangular_solve">
    <p>def <span class="ident">matrix_triangular_solve</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.matrix_triangular_solve</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.matrix_triangular_solve</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.matrix_triangular_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_triangular_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.matrix_triangular_solve_layer">
    <p>def <span class="ident">matrix_triangular_solve_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.matrix_triangular_solve_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.matrix_triangular_solve_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.matrix_triangular_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_triangular_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool">
    <p>def <span class="ident">max_pool</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.max_pool</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.max_pool</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.max_pool</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool3d">
    <p>def <span class="ident">max_pool3d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.max_pool3d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.max_pool3d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.max_pool3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool3d_grad">
    <p>def <span class="ident">max_pool3d_grad</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.max_pool3d_grad</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.max_pool3d_grad</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.max_pool3d_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool3d_grad_layer">
    <p>def <span class="ident">max_pool3d_grad_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.max_pool3d_grad_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.max_pool3d_grad_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.max_pool3d_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool3d_layer">
    <p>def <span class="ident">max_pool3d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.max_pool3d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.max_pool3d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.max_pool3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool_2d">
    <p>def <span class="ident">max_pool_2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.max_pool_2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.max_pool_2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.max_pool_2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool_layer">
    <p>def <span class="ident">max_pool_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.max_pool_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.max_pool_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.max_pool_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool_with_argmax">
    <p>def <span class="ident">max_pool_with_argmax</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.max_pool_with_argmax</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.max_pool_with_argmax</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.max_pool_with_argmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_with_argmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.max_pool_with_argmax_layer">
    <p>def <span class="ident">max_pool_with_argmax_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.max_pool_with_argmax_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.max_pool_with_argmax_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.max_pool_with_argmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_with_argmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.maximum">
    <p>def <span class="ident">maximum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.maximum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.maximum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.maximum</code></strong></p>
<div class="codehilite"><pre><span></span>    def maximum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.maximum_layer">
    <p>def <span class="ident">maximum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.maximum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.maximum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.maximum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def maximum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.merge_all_summaries">
    <p>def <span class="ident">merge_all_summaries</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.merge_all_summaries</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.merge_all_summaries</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.merge_all_summaries</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_all_summaries(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.merge_all_summaries_layer">
    <p>def <span class="ident">merge_all_summaries_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.merge_all_summaries_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.merge_all_summaries_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.merge_all_summaries_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_all_summaries_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.merge_summary">
    <p>def <span class="ident">merge_summary</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.merge_summary</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.merge_summary</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.merge_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.merge_summary_layer">
    <p>def <span class="ident">merge_summary_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.merge_summary_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.merge_summary_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.merge_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.minimum">
    <p>def <span class="ident">minimum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.minimum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.minimum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.minimum</code></strong></p>
<div class="codehilite"><pre><span></span>    def minimum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.minimum_layer">
    <p>def <span class="ident">minimum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.minimum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.minimum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.minimum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def minimum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.mod">
    <p>def <span class="ident">mod</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.mod</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.mod</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.mod</code></strong></p>
<div class="codehilite"><pre><span></span>    def mod(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.mod_layer">
    <p>def <span class="ident">mod_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.mod_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.mod_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.mod_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def mod_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.moments">
    <p>def <span class="ident">moments</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.moments</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.moments</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.moments</code></strong></p>
<div class="codehilite"><pre><span></span>    def moments(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.moments_layer">
    <p>def <span class="ident">moments_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.moments_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.moments_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.moments_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def moments_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.moving_average_variables">
    <p>def <span class="ident">moving_average_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.moving_average_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.moving_average_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.moving_average_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def moving_average_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.moving_average_variables_layer">
    <p>def <span class="ident">moving_average_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.moving_average_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.moving_average_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.moving_average_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def moving_average_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.mul">
    <p>def <span class="ident">mul</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.mul</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.mul</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.mul</code></strong></p>
<div class="codehilite"><pre><span></span>    def mul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.mul_layer">
    <p>def <span class="ident">mul_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.mul_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.mul_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.mul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def mul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.multinomial">
    <p>def <span class="ident">multinomial</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.multinomial</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.multinomial</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.multinomial</code></strong></p>
<div class="codehilite"><pre><span></span>    def multinomial(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.multinomial_layer">
    <p>def <span class="ident">multinomial_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.multinomial_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.multinomial_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.multinomial_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def multinomial_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.name_scope">
    <p>def <span class="ident">name_scope</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.name_scope</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.name_scope</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.name_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def name_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.name_scope_layer">
    <p>def <span class="ident">name_scope_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.name_scope_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.name_scope_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.name_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def name_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.nce_loss">
    <p>def <span class="ident">nce_loss</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.nce_loss</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.nce_loss</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.nce_loss</code></strong></p>
<div class="codehilite"><pre><span></span>    def nce_loss(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.nce_loss_layer">
    <p>def <span class="ident">nce_loss_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.nce_loss_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.nce_loss_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.nce_loss_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def nce_loss_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.neg">
    <p>def <span class="ident">neg</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.neg</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.neg</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.neg</code></strong></p>
<div class="codehilite"><pre><span></span>    def neg(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.neg_layer">
    <p>def <span class="ident">neg_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.neg_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.neg_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.neg_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def neg_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.no_op">
    <p>def <span class="ident">no_op</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.no_op</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.no_op</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.no_op</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_op(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.no_op_layer">
    <p>def <span class="ident">no_op_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.no_op_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.no_op_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.no_op_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_op_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.no_regularizer">
    <p>def <span class="ident">no_regularizer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.no_regularizer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.no_regularizer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.no_regularizer</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_regularizer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.no_regularizer_layer">
    <p>def <span class="ident">no_regularizer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.no_regularizer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.no_regularizer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.no_regularizer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_regularizer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.normalize_moments">
    <p>def <span class="ident">normalize_moments</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.normalize_moments</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.normalize_moments</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.normalize_moments</code></strong></p>
<div class="codehilite"><pre><span></span>    def normalize_moments(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.normalize_moments_layer">
    <p>def <span class="ident">normalize_moments_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.normalize_moments_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.normalize_moments_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.normalize_moments_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def normalize_moments_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.not_equal">
    <p>def <span class="ident">not_equal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.not_equal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.not_equal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.not_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def not_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.not_equal_layer">
    <p>def <span class="ident">not_equal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.not_equal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.not_equal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.not_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def not_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.one_hot">
    <p>def <span class="ident">one_hot</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.one_hot</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.one_hot</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.one_hot</code></strong></p>
<div class="codehilite"><pre><span></span>    def one_hot(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.one_hot_layer">
    <p>def <span class="ident">one_hot_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.one_hot_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.one_hot_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.one_hot_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def one_hot_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ones">
    <p>def <span class="ident">ones</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ones</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ones</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ones</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ones_initializer">
    <p>def <span class="ident">ones_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ones_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ones_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ones_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ones_initializer_layer">
    <p>def <span class="ident">ones_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ones_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ones_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ones_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ones_layer">
    <p>def <span class="ident">ones_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ones_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ones_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ones_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ones_like">
    <p>def <span class="ident">ones_like</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.ones_like</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.ones_like</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.ones_like</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_like(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.ones_like_layer">
    <p>def <span class="ident">ones_like_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.ones_like_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.ones_like_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.ones_like_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_like_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.op_scope">
    <p>def <span class="ident">op_scope</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.op_scope</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.op_scope</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.op_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def op_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.op_scope_layer">
    <p>def <span class="ident">op_scope_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.op_scope_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.op_scope_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.op_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def op_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pack">
    <p>def <span class="ident">pack</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.pack</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.pack</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.pack</code></strong></p>
<div class="codehilite"><pre><span></span>    def pack(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pack_layer">
    <p>def <span class="ident">pack_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.pack_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.pack_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.pack_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def pack_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pad">
    <p>def <span class="ident">pad</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.pad</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.pad</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.pad</code></strong></p>
<div class="codehilite"><pre><span></span>    def pad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pad_layer">
    <p>def <span class="ident">pad_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.pad_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.pad_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.pad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def pad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.parse_example">
    <p>def <span class="ident">parse_example</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.parse_example</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.parse_example</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.parse_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.parse_example_layer">
    <p>def <span class="ident">parse_example_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.parse_example_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.parse_example_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.parse_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.parse_single_example">
    <p>def <span class="ident">parse_single_example</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.parse_single_example</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.parse_single_example</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.parse_single_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.parse_single_example_layer">
    <p>def <span class="ident">parse_single_example_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.parse_single_example_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.parse_single_example_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.parse_single_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.parse_single_sequence_example">
    <p>def <span class="ident">parse_single_sequence_example</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.parse_single_sequence_example</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.parse_single_sequence_example</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.parse_single_sequence_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_sequence_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.parse_single_sequence_example_layer">
    <p>def <span class="ident">parse_single_sequence_example_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.parse_single_sequence_example_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.parse_single_sequence_example_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.parse_single_sequence_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_sequence_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pipe">
    <p>def <span class="ident">pipe</span>(</p><p>builder, *ast)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.pipe', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.pipe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="o">*</span><span class="n">ast</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.placeholder">
    <p>def <span class="ident">placeholder</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.placeholder</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.placeholder</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.placeholder</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.placeholder_layer">
    <p>def <span class="ident">placeholder_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.placeholder_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.placeholder_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.placeholder_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.placeholder_with_default">
    <p>def <span class="ident">placeholder_with_default</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.placeholder_with_default</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.placeholder_with_default</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.placeholder_with_default</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder_with_default(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.placeholder_with_default_layer">
    <p>def <span class="ident">placeholder_with_default_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.placeholder_with_default_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.placeholder_with_default_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.placeholder_with_default_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder_with_default_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.polygamma">
    <p>def <span class="ident">polygamma</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.polygamma</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.polygamma</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.polygamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def polygamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.polygamma_layer">
    <p>def <span class="ident">polygamma_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.polygamma_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.polygamma_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.polygamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def polygamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pow">
    <p>def <span class="ident">pow</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.pow</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.pow</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.pow</code></strong></p>
<div class="codehilite"><pre><span></span>    def pow(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.pow_layer">
    <p>def <span class="ident">pow_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.pow_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.pow_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.pow_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def pow_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.py_func">
    <p>def <span class="ident">py_func</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.py_func</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.py_func</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.py_func</code></strong></p>
<div class="codehilite"><pre><span></span>    def py_func(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.py_func_layer">
    <p>def <span class="ident">py_func_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.py_func_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.py_func_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.py_func_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def py_func_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_crop">
    <p>def <span class="ident">random_crop</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.random_crop</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.random_crop</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.random_crop</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_crop(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_crop_layer">
    <p>def <span class="ident">random_crop_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.random_crop_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.random_crop_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.random_crop_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_crop_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_normal">
    <p>def <span class="ident">random_normal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.random_normal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.random_normal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.random_normal</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_normal_initializer">
    <p>def <span class="ident">random_normal_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.random_normal_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.random_normal_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.random_normal_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_normal_initializer_layer">
    <p>def <span class="ident">random_normal_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.random_normal_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.random_normal_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.random_normal_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_normal_layer">
    <p>def <span class="ident">random_normal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.random_normal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.random_normal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.random_normal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_shuffle">
    <p>def <span class="ident">random_shuffle</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.random_shuffle</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.random_shuffle</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.random_shuffle</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_shuffle(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_shuffle_layer">
    <p>def <span class="ident">random_shuffle_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.random_shuffle_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.random_shuffle_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.random_shuffle_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_shuffle_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_uniform">
    <p>def <span class="ident">random_uniform</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.random_uniform</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.random_uniform</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.random_uniform</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_uniform_initializer">
    <p>def <span class="ident">random_uniform_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.random_uniform_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.random_uniform_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.random_uniform_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_uniform_initializer_layer">
    <p>def <span class="ident">random_uniform_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.random_uniform_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.random_uniform_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.random_uniform_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.random_uniform_layer">
    <p>def <span class="ident">random_uniform_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.random_uniform_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.random_uniform_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.random_uniform_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.range">
    <p>def <span class="ident">range</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.range</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.range</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.range</code></strong></p>
<div class="codehilite"><pre><span></span>    def range(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.range_layer">
    <p>def <span class="ident">range_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.range_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.range_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.range_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def range_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.rank">
    <p>def <span class="ident">rank</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.rank</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.rank</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.rank</code></strong></p>
<div class="codehilite"><pre><span></span>    def rank(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.rank_layer">
    <p>def <span class="ident">rank_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.rank_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.rank_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.rank_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def rank_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.read_file">
    <p>def <span class="ident">read_file</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.read_file</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.read_file</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.read_file</code></strong></p>
<div class="codehilite"><pre><span></span>    def read_file(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.read_file_layer">
    <p>def <span class="ident">read_file_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.read_file_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.read_file_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.read_file_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def read_file_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.real">
    <p>def <span class="ident">real</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.real</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.real</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.real</code></strong></p>
<div class="codehilite"><pre><span></span>    def real(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.real_layer">
    <p>def <span class="ident">real_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.real_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.real_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.real_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def real_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce(tree, fn, initializer=None)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_all">
    <p>def <span class="ident">reduce_all</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_all</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_all</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_all</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_all(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_all_layer">
    <p>def <span class="ident">reduce_all_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_all_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_all_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_all_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_all_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_any">
    <p>def <span class="ident">reduce_any</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_any</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_any</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_any</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_any(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_any_layer">
    <p>def <span class="ident">reduce_any_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_any_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_any_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_any_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_any_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_join">
    <p>def <span class="ident">reduce_join</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_join</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_join</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_join</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_join(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_join_layer">
    <p>def <span class="ident">reduce_join_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_join_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_join_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_join_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_join_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_max">
    <p>def <span class="ident">reduce_max</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_max</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_max</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_max</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_max(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_max_layer">
    <p>def <span class="ident">reduce_max_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_max_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_max_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_max_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_max_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_mean">
    <p>def <span class="ident">reduce_mean</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_mean</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_mean</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_mean</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_mean(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_mean_layer">
    <p>def <span class="ident">reduce_mean_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_mean_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_mean_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_mean_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_mean_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_min">
    <p>def <span class="ident">reduce_min</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_min</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_min</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_min</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_min(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_min_layer">
    <p>def <span class="ident">reduce_min_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_min_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_min_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_min_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_min_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_prod">
    <p>def <span class="ident">reduce_prod</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_prod</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_prod</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_prod</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_prod(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_prod_layer">
    <p>def <span class="ident">reduce_prod_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_prod_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_prod_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_prod_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_prod_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_sum">
    <p>def <span class="ident">reduce_sum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reduce_sum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reduce_sum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reduce_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reduce_sum_layer">
    <p>def <span class="ident">reduce_sum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reduce_sum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reduce_sum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reduce_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.register_tensor_conversion_function">
    <p>def <span class="ident">register_tensor_conversion_function</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.register_tensor_conversion_function</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.register_tensor_conversion_function</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.register_tensor_conversion_function</code></strong></p>
<div class="codehilite"><pre><span></span>    def register_tensor_conversion_function(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.register_tensor_conversion_function_layer">
    <p>def <span class="ident">register_tensor_conversion_function_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.register_tensor_conversion_function_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.register_tensor_conversion_function_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.register_tensor_conversion_function_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def register_tensor_conversion_function_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.relu">
    <p>def <span class="ident">relu</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.relu</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.relu</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.relu</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.relu6">
    <p>def <span class="ident">relu6</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.relu6</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.relu6</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.relu6</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu6(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.relu6_layer">
    <p>def <span class="ident">relu6_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.relu6_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.relu6_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.relu6_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu6_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.relu_layer">
    <p>def <span class="ident">relu_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.relu_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.relu_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.relu_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.report_uninitialized_variables">
    <p>def <span class="ident">report_uninitialized_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.report_uninitialized_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.report_uninitialized_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.report_uninitialized_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def report_uninitialized_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.report_uninitialized_variables_layer">
    <p>def <span class="ident">report_uninitialized_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.report_uninitialized_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.report_uninitialized_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.report_uninitialized_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def report_uninitialized_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reset_default_graph">
    <p>def <span class="ident">reset_default_graph</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reset_default_graph</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reset_default_graph</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reset_default_graph</code></strong></p>
<div class="codehilite"><pre><span></span>    def reset_default_graph(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reset_default_graph_layer">
    <p>def <span class="ident">reset_default_graph_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reset_default_graph_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reset_default_graph_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reset_default_graph_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reset_default_graph_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reshape">
    <p>def <span class="ident">reshape</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reshape</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reshape</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reshape</code></strong></p>
<div class="codehilite"><pre><span></span>    def reshape(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reshape_layer">
    <p>def <span class="ident">reshape_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reshape_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reshape_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reshape_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reshape_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reverse">
    <p>def <span class="ident">reverse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reverse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reverse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reverse</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reverse_layer">
    <p>def <span class="ident">reverse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reverse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reverse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reverse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reverse_sequence">
    <p>def <span class="ident">reverse_sequence</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.reverse_sequence</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.reverse_sequence</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.reverse_sequence</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse_sequence(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.reverse_sequence_layer">
    <p>def <span class="ident">reverse_sequence_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.reverse_sequence_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.reverse_sequence_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.reverse_sequence_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse_sequence_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.rnn">
    <p>def <span class="ident">rnn</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.rnn</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.rnn</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.rnn_layer">
    <p>def <span class="ident">rnn_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.rnn_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.rnn_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.round">
    <p>def <span class="ident">round</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.round</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.round</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.round</code></strong></p>
<div class="codehilite"><pre><span></span>    def round(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.round_layer">
    <p>def <span class="ident">round_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.round_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.round_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.round_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def round_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.rsqrt">
    <p>def <span class="ident">rsqrt</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.rsqrt</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.rsqrt</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.rsqrt</code></strong></p>
<div class="codehilite"><pre><span></span>    def rsqrt(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.rsqrt_layer">
    <p>def <span class="ident">rsqrt_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.rsqrt_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.rsqrt_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.rsqrt_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def rsqrt_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sampled_softmax_loss">
    <p>def <span class="ident">sampled_softmax_loss</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sampled_softmax_loss</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sampled_softmax_loss</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sampled_softmax_loss</code></strong></p>
<div class="codehilite"><pre><span></span>    def sampled_softmax_loss(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sampled_softmax_loss_layer">
    <p>def <span class="ident">sampled_softmax_loss_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sampled_softmax_loss_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sampled_softmax_loss_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sampled_softmax_loss_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sampled_softmax_loss_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.saturate_cast">
    <p>def <span class="ident">saturate_cast</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.saturate_cast</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.saturate_cast</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.saturate_cast</code></strong></p>
<div class="codehilite"><pre><span></span>    def saturate_cast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.saturate_cast_layer">
    <p>def <span class="ident">saturate_cast_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.saturate_cast_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.saturate_cast_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.saturate_cast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def saturate_cast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scalar_mul">
    <p>def <span class="ident">scalar_mul</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.scalar_mul</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.scalar_mul</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.scalar_mul</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_mul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scalar_mul_layer">
    <p>def <span class="ident">scalar_mul_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.scalar_mul_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.scalar_mul_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.scalar_mul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_mul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scalar_summary">
    <p>def <span class="ident">scalar_summary</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.scalar_summary</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.scalar_summary</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.scalar_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scalar_summary_layer">
    <p>def <span class="ident">scalar_summary_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.scalar_summary_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.scalar_summary_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.scalar_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scan">
    <p>def <span class="ident">scan</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.scan</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.scan</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.scan</code></strong></p>
<div class="codehilite"><pre><span></span>    def scan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scan_layer">
    <p>def <span class="ident">scan_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.scan_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.scan_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.scan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scatter_add">
    <p>def <span class="ident">scatter_add</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.scatter_add</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.scatter_add</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.scatter_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scatter_add_layer">
    <p>def <span class="ident">scatter_add_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.scatter_add_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.scatter_add_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.scatter_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scatter_sub">
    <p>def <span class="ident">scatter_sub</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.scatter_sub</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.scatter_sub</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.scatter_sub</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_sub(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scatter_sub_layer">
    <p>def <span class="ident">scatter_sub_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.scatter_sub_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.scatter_sub_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.scatter_sub_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_sub_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scatter_update">
    <p>def <span class="ident">scatter_update</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.scatter_update</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.scatter_update</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.scatter_update</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_update(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.scatter_update_layer">
    <p>def <span class="ident">scatter_update_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.scatter_update_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.scatter_update_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.scatter_update_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_update_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_max">
    <p>def <span class="ident">segment_max</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.segment_max</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.segment_max</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.segment_max</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_max(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_max_layer">
    <p>def <span class="ident">segment_max_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.segment_max_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.segment_max_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.segment_max_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_max_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_mean">
    <p>def <span class="ident">segment_mean</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.segment_mean</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.segment_mean</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.segment_mean</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_mean(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_mean_layer">
    <p>def <span class="ident">segment_mean_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.segment_mean_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.segment_mean_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.segment_mean_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_mean_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_min">
    <p>def <span class="ident">segment_min</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.segment_min</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.segment_min</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.segment_min</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_min(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_min_layer">
    <p>def <span class="ident">segment_min_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.segment_min_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.segment_min_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.segment_min_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_min_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_prod">
    <p>def <span class="ident">segment_prod</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.segment_prod</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.segment_prod</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.segment_prod</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_prod(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_prod_layer">
    <p>def <span class="ident">segment_prod_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.segment_prod_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.segment_prod_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.segment_prod_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_prod_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_sum">
    <p>def <span class="ident">segment_sum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.segment_sum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.segment_sum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.segment_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.segment_sum_layer">
    <p>def <span class="ident">segment_sum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.segment_sum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.segment_sum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.segment_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.select">
    <p>def <span class="ident">select</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.select</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.select</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.select</code></strong></p>
<div class="codehilite"><pre><span></span>    def select(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.select_layer">
    <p>def <span class="ident">select_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.select_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.select_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.select_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def select_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.self_adjoint_eig">
    <p>def <span class="ident">self_adjoint_eig</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.self_adjoint_eig</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.self_adjoint_eig</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.self_adjoint_eig</code></strong></p>
<div class="codehilite"><pre><span></span>    def self_adjoint_eig(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.self_adjoint_eig_layer">
    <p>def <span class="ident">self_adjoint_eig_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.self_adjoint_eig_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.self_adjoint_eig_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.self_adjoint_eig_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def self_adjoint_eig_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.separable_conv2d">
    <p>def <span class="ident">separable_conv2d</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.separable_conv2d</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.separable_conv2d</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.separable_conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def separable_conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.separable_conv2d_layer">
    <p>def <span class="ident">separable_conv2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.separable_conv2d_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.separable_conv2d_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.separable_conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def separable_conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.serialize_many_sparse">
    <p>def <span class="ident">serialize_many_sparse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.serialize_many_sparse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.serialize_many_sparse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.serialize_many_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_many_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.serialize_many_sparse_layer">
    <p>def <span class="ident">serialize_many_sparse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.serialize_many_sparse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.serialize_many_sparse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.serialize_many_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_many_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.serialize_sparse">
    <p>def <span class="ident">serialize_sparse</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.serialize_sparse</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.serialize_sparse</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.serialize_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.serialize_sparse_layer">
    <p>def <span class="ident">serialize_sparse_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.serialize_sparse_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.serialize_sparse_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.serialize_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.set_random_seed">
    <p>def <span class="ident">set_random_seed</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.set_random_seed</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.set_random_seed</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.set_random_seed</code></strong></p>
<div class="codehilite"><pre><span></span>    def set_random_seed(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.set_random_seed_layer">
    <p>def <span class="ident">set_random_seed_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.set_random_seed_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.set_random_seed_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.set_random_seed_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def set_random_seed_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.shape">
    <p>def <span class="ident">shape</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.shape</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.shape</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.shape</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.shape_layer">
    <p>def <span class="ident">shape_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.shape_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.shape_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.shape_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.shape_n">
    <p>def <span class="ident">shape_n</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.shape_n</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.shape_n</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.shape_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.shape_n_layer">
    <p>def <span class="ident">shape_n_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.shape_n_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.shape_n_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.shape_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sigmoid">
    <p>def <span class="ident">sigmoid</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sigmoid</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sigmoid</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sigmoid</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sigmoid_cross_entropy_with_logits">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sigmoid_cross_entropy_with_logits</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sigmoid_cross_entropy_with_logits</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sigmoid_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sigmoid_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sigmoid_cross_entropy_with_logits_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sigmoid_cross_entropy_with_logits_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sigmoid_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sigmoid_layer">
    <p>def <span class="ident">sigmoid_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sigmoid_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sigmoid_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sigmoid_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sign">
    <p>def <span class="ident">sign</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sign</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sign</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sign</code></strong></p>
<div class="codehilite"><pre><span></span>    def sign(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sign_layer">
    <p>def <span class="ident">sign_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sign_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sign_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sign_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sign_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sin">
    <p>def <span class="ident">sin</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sin</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sin</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sin</code></strong></p>
<div class="codehilite"><pre><span></span>    def sin(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sin_layer">
    <p>def <span class="ident">sin_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sin_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sin_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sin_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sin_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.size">
    <p>def <span class="ident">size</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.size</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.size</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.size</code></strong></p>
<div class="codehilite"><pre><span></span>    def size(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.size_layer">
    <p>def <span class="ident">size_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.size_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.size_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.size_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def size_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.slice">
    <p>def <span class="ident">slice</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.slice</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.slice</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.slice</code></strong></p>
<div class="codehilite"><pre><span></span>    def slice(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.slice_layer">
    <p>def <span class="ident">slice_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.slice_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.slice_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.slice_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def slice_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softmax">
    <p>def <span class="ident">softmax</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.softmax</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.softmax</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.softmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softmax_cross_entropy_with_logits">
    <p>def <span class="ident">softmax_cross_entropy_with_logits</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.softmax_cross_entropy_with_logits</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.softmax_cross_entropy_with_logits</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.softmax_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">softmax_cross_entropy_with_logits_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.softmax_cross_entropy_with_logits_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.softmax_cross_entropy_with_logits_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.softmax_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softmax_layer">
    <p>def <span class="ident">softmax_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.softmax_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.softmax_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.softmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softplus">
    <p>def <span class="ident">softplus</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.softplus</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.softplus</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.softplus</code></strong></p>
<div class="codehilite"><pre><span></span>    def softplus(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softplus_layer">
    <p>def <span class="ident">softplus_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.softplus_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.softplus_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.softplus_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softplus_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softsign">
    <p>def <span class="ident">softsign</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.softsign</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.softsign</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.softsign</code></strong></p>
<div class="codehilite"><pre><span></span>    def softsign(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.softsign_layer">
    <p>def <span class="ident">softsign_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.softsign_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.softsign_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.softsign_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softsign_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.space_to_batch">
    <p>def <span class="ident">space_to_batch</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.space_to_batch</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.space_to_batch</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.space_to_batch</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_batch(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.space_to_batch_layer">
    <p>def <span class="ident">space_to_batch_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.space_to_batch_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.space_to_batch_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.space_to_batch_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_batch_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.space_to_depth">
    <p>def <span class="ident">space_to_depth</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.space_to_depth</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.space_to_depth</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.space_to_depth</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_depth(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.space_to_depth_layer">
    <p>def <span class="ident">space_to_depth_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.space_to_depth_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.space_to_depth_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.space_to_depth_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_depth_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_add">
    <p>def <span class="ident">sparse_add</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_add</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_add</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_add_layer">
    <p>def <span class="ident">sparse_add_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_add_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_add_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_concat">
    <p>def <span class="ident">sparse_concat</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_concat</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_concat</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_concat</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_concat(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_concat_layer">
    <p>def <span class="ident">sparse_concat_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_concat_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_concat_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_concat_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_concat_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_fill_empty_rows">
    <p>def <span class="ident">sparse_fill_empty_rows</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_fill_empty_rows</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_fill_empty_rows</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_fill_empty_rows</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_fill_empty_rows(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_fill_empty_rows_layer">
    <p>def <span class="ident">sparse_fill_empty_rows_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_fill_empty_rows_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_fill_empty_rows_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_fill_empty_rows_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_fill_empty_rows_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_mask">
    <p>def <span class="ident">sparse_mask</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_mask</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_mask</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_mask</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_mask(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_mask_layer">
    <p>def <span class="ident">sparse_mask_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_mask_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_mask_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_mask_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_mask_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_matmul_layer">
    <p>def <span class="ident">sparse_matmul_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_matmul_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_matmul_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_merge">
    <p>def <span class="ident">sparse_merge</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_merge</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_merge</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_merge</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_merge(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_merge_layer">
    <p>def <span class="ident">sparse_merge_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_merge_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_merge_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_merge_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_merge_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_placeholder">
    <p>def <span class="ident">sparse_placeholder</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_placeholder</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_placeholder</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_placeholder</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_placeholder(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_placeholder_layer">
    <p>def <span class="ident">sparse_placeholder_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_placeholder_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_placeholder_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_placeholder_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_placeholder_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_reduce_sum">
    <p>def <span class="ident">sparse_reduce_sum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_reduce_sum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_reduce_sum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_reduce_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reduce_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_reduce_sum_layer">
    <p>def <span class="ident">sparse_reduce_sum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_reduce_sum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_reduce_sum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_reduce_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reduce_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_reorder">
    <p>def <span class="ident">sparse_reorder</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_reorder</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_reorder</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_reorder</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reorder(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_reorder_layer">
    <p>def <span class="ident">sparse_reorder_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_reorder_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_reorder_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_reorder_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reorder_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_reset_shape">
    <p>def <span class="ident">sparse_reset_shape</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_reset_shape</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_reset_shape</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_reset_shape</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reset_shape(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_reset_shape_layer">
    <p>def <span class="ident">sparse_reset_shape_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_reset_shape_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_reset_shape_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_reset_shape_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reset_shape_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_retain">
    <p>def <span class="ident">sparse_retain</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_retain</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_retain</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_retain</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_retain(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_retain_layer">
    <p>def <span class="ident">sparse_retain_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_retain_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_retain_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_retain_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_retain_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_mean">
    <p>def <span class="ident">sparse_segment_mean</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_segment_mean</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_segment_mean</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_segment_mean</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_mean_grad">
    <p>def <span class="ident">sparse_segment_mean_grad</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_segment_mean_grad</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_segment_mean_grad</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_segment_mean_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_mean_grad_layer">
    <p>def <span class="ident">sparse_segment_mean_grad_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_segment_mean_grad_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_segment_mean_grad_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_mean_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_mean_layer">
    <p>def <span class="ident">sparse_segment_mean_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_segment_mean_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_segment_mean_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_mean_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_sqrt_n">
    <p>def <span class="ident">sparse_segment_sqrt_n</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_segment_sqrt_n</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_segment_sqrt_n</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_segment_sqrt_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_sqrt_n_grad">
    <p>def <span class="ident">sparse_segment_sqrt_n_grad</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_segment_sqrt_n_grad</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_segment_sqrt_n_grad</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_segment_sqrt_n_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_sqrt_n_grad_layer">
    <p>def <span class="ident">sparse_segment_sqrt_n_grad_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_segment_sqrt_n_grad_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_segment_sqrt_n_grad_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_sqrt_n_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_sqrt_n_layer">
    <p>def <span class="ident">sparse_segment_sqrt_n_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_segment_sqrt_n_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_segment_sqrt_n_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_sqrt_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_sum">
    <p>def <span class="ident">sparse_segment_sum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_segment_sum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_segment_sum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_segment_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_segment_sum_layer">
    <p>def <span class="ident">sparse_segment_sum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_segment_sum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_segment_sum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_softmax">
    <p>def <span class="ident">sparse_softmax</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_softmax</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_softmax</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_softmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_softmax_cross_entropy_with_logits</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_softmax_cross_entropy_with_logits</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_softmax_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_softmax_cross_entropy_with_logits_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_softmax_cross_entropy_with_logits_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_softmax_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_softmax_layer">
    <p>def <span class="ident">sparse_softmax_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_softmax_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_softmax_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_softmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_split">
    <p>def <span class="ident">sparse_split</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_split</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_split</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_split</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_split(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_split_layer">
    <p>def <span class="ident">sparse_split_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_split_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_split_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_split_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_split_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_tensor_dense_matmul">
    <p>def <span class="ident">sparse_tensor_dense_matmul</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_tensor_dense_matmul</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_tensor_dense_matmul</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_tensor_dense_matmul</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_dense_matmul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_tensor_dense_matmul_layer">
    <p>def <span class="ident">sparse_tensor_dense_matmul_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_tensor_dense_matmul_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_tensor_dense_matmul_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_tensor_dense_matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_dense_matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_tensor_to_dense">
    <p>def <span class="ident">sparse_tensor_to_dense</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_tensor_to_dense</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_tensor_to_dense</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_tensor_to_dense</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_to_dense(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_tensor_to_dense_layer">
    <p>def <span class="ident">sparse_tensor_to_dense_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_tensor_to_dense_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_tensor_to_dense_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_tensor_to_dense_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_to_dense_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_to_dense">
    <p>def <span class="ident">sparse_to_dense</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_to_dense</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_to_dense</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_to_dense</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_dense(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_to_dense_layer">
    <p>def <span class="ident">sparse_to_dense_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_to_dense_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_to_dense_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_to_dense_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_dense_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_to_indicator">
    <p>def <span class="ident">sparse_to_indicator</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sparse_to_indicator</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sparse_to_indicator</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sparse_to_indicator</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_indicator(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sparse_to_indicator_layer">
    <p>def <span class="ident">sparse_to_indicator_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sparse_to_indicator_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sparse_to_indicator_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sparse_to_indicator_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_indicator_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.split">
    <p>def <span class="ident">split</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.split</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.split</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.split</code></strong></p>
<div class="codehilite"><pre><span></span>    def split(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.split_layer">
    <p>def <span class="ident">split_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.split_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.split_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.split_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def split_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sqrt">
    <p>def <span class="ident">sqrt</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sqrt</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sqrt</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sqrt</code></strong></p>
<div class="codehilite"><pre><span></span>    def sqrt(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sqrt_layer">
    <p>def <span class="ident">sqrt_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sqrt_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sqrt_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sqrt_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sqrt_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.square">
    <p>def <span class="ident">square</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.square</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.square</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.square</code></strong></p>
<div class="codehilite"><pre><span></span>    def square(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.square_layer">
    <p>def <span class="ident">square_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.square_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.square_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.square_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def square_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.squared_difference">
    <p>def <span class="ident">squared_difference</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.squared_difference</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.squared_difference</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.squared_difference</code></strong></p>
<div class="codehilite"><pre><span></span>    def squared_difference(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.squared_difference_layer">
    <p>def <span class="ident">squared_difference_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.squared_difference_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.squared_difference_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.squared_difference_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def squared_difference_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.squeeze">
    <p>def <span class="ident">squeeze</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.squeeze</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.squeeze</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.squeeze</code></strong></p>
<div class="codehilite"><pre><span></span>    def squeeze(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.squeeze_layer">
    <p>def <span class="ident">squeeze_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.squeeze_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.squeeze_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.squeeze_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def squeeze_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.state_saving_rnn">
    <p>def <span class="ident">state_saving_rnn</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.state_saving_rnn</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.state_saving_rnn</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.state_saving_rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def state_saving_rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.state_saving_rnn_layer">
    <p>def <span class="ident">state_saving_rnn_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.state_saving_rnn_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.state_saving_rnn_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.state_saving_rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def state_saving_rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.stop_gradient">
    <p>def <span class="ident">stop_gradient</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.stop_gradient</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.stop_gradient</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.stop_gradient</code></strong></p>
<div class="codehilite"><pre><span></span>    def stop_gradient(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.stop_gradient_layer">
    <p>def <span class="ident">stop_gradient_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.stop_gradient_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.stop_gradient_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.stop_gradient_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def stop_gradient_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_hash_bucket">
    <p>def <span class="ident">string_to_hash_bucket</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.string_to_hash_bucket</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.string_to_hash_bucket</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.string_to_hash_bucket</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_hash_bucket_fast">
    <p>def <span class="ident">string_to_hash_bucket_fast</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.string_to_hash_bucket_fast</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.string_to_hash_bucket_fast</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.string_to_hash_bucket_fast</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_fast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_hash_bucket_fast_layer">
    <p>def <span class="ident">string_to_hash_bucket_fast_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.string_to_hash_bucket_fast_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.string_to_hash_bucket_fast_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.string_to_hash_bucket_fast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_fast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_hash_bucket_layer">
    <p>def <span class="ident">string_to_hash_bucket_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.string_to_hash_bucket_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.string_to_hash_bucket_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.string_to_hash_bucket_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_hash_bucket_strong">
    <p>def <span class="ident">string_to_hash_bucket_strong</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.string_to_hash_bucket_strong</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.string_to_hash_bucket_strong</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.string_to_hash_bucket_strong</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_strong(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_hash_bucket_strong_layer">
    <p>def <span class="ident">string_to_hash_bucket_strong_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.string_to_hash_bucket_strong_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.string_to_hash_bucket_strong_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.string_to_hash_bucket_strong_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_strong_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_number">
    <p>def <span class="ident">string_to_number</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.string_to_number</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.string_to_number</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.string_to_number</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_number(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.string_to_number_layer">
    <p>def <span class="ident">string_to_number_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.string_to_number_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.string_to_number_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.string_to_number_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_number_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sub">
    <p>def <span class="ident">sub</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sub</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sub</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sub</code></strong></p>
<div class="codehilite"><pre><span></span>    def sub(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sub_layer">
    <p>def <span class="ident">sub_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sub_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sub_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sub_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sub_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sufficient_statistics">
    <p>def <span class="ident">sufficient_statistics</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.sufficient_statistics</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.sufficient_statistics</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.sufficient_statistics</code></strong></p>
<div class="codehilite"><pre><span></span>    def sufficient_statistics(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.sufficient_statistics_layer">
    <p>def <span class="ident">sufficient_statistics_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.sufficient_statistics_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.sufficient_statistics_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.sufficient_statistics_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sufficient_statistics_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tan">
    <p>def <span class="ident">tan</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.tan</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.tan</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.tan</code></strong></p>
<div class="codehilite"><pre><span></span>    def tan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tan_layer">
    <p>def <span class="ident">tan_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.tan_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.tan_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.tan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tanh">
    <p>def <span class="ident">tanh</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.tanh</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.tanh</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.tanh</code></strong></p>
<div class="codehilite"><pre><span></span>    def tanh(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tanh_layer">
    <p>def <span class="ident">tanh_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.tanh_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.tanh_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.tanh_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tanh_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tensor">
    <p>def <span class="ident">tensor</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.tensor</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.tensor</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def tensor(self)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tensors">
    <p>def <span class="ident">tensors</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.tensors</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.tensors</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.tensors</code></strong></p>
<div class="codehilite"><pre><span></span>    def tensors(self)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.then">
    <p>def <span class="ident">then</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.then</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.then</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.then</code></strong></p>
<div class="codehilite"><pre><span></span>    def then(builder, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tile">
    <p>def <span class="ident">tile</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.tile</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.tile</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.tile</code></strong></p>
<div class="codehilite"><pre><span></span>    def tile(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tile_layer">
    <p>def <span class="ident">tile_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.tile_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.tile_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.tile_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tile_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_bfloat16">
    <p>def <span class="ident">to_bfloat16</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.to_bfloat16</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.to_bfloat16</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.to_bfloat16</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_bfloat16(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_bfloat16_layer">
    <p>def <span class="ident">to_bfloat16_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.to_bfloat16_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.to_bfloat16_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.to_bfloat16_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_bfloat16_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_double">
    <p>def <span class="ident">to_double</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.to_double</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.to_double</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.to_double</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_double(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_double_layer">
    <p>def <span class="ident">to_double_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.to_double_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.to_double_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.to_double_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_double_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_float">
    <p>def <span class="ident">to_float</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.to_float</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.to_float</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.to_float</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_float(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_float_layer">
    <p>def <span class="ident">to_float_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.to_float_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.to_float_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.to_float_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_float_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_int32">
    <p>def <span class="ident">to_int32</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.to_int32</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.to_int32</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.to_int32</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int32(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_int32_layer">
    <p>def <span class="ident">to_int32_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.to_int32_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.to_int32_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.to_int32_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int32_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_int64">
    <p>def <span class="ident">to_int64</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.to_int64</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.to_int64</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.to_int64</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int64(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.to_int64_layer">
    <p>def <span class="ident">to_int64_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.to_int64_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.to_int64_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.to_int64_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int64_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.top_k">
    <p>def <span class="ident">top_k</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.top_k</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.top_k</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.top_k</code></strong></p>
<div class="codehilite"><pre><span></span>    def top_k(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.top_k_layer">
    <p>def <span class="ident">top_k_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.top_k_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.top_k_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.top_k_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def top_k_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.trace">
    <p>def <span class="ident">trace</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.trace</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.trace</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.trace</code></strong></p>
<div class="codehilite"><pre><span></span>    def trace(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.trace_layer">
    <p>def <span class="ident">trace_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.trace_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.trace_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.trace_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def trace_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.trainable_variables">
    <p>def <span class="ident">trainable_variables</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.trainable_variables</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.trainable_variables</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.trainable_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def trainable_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.trainable_variables_layer">
    <p>def <span class="ident">trainable_variables_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.trainable_variables_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.trainable_variables_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.trainable_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def trainable_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.transpose">
    <p>def <span class="ident">transpose</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.transpose</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.transpose</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.transpose</code></strong></p>
<div class="codehilite"><pre><span></span>    def transpose(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.transpose_layer">
    <p>def <span class="ident">transpose_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.transpose_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.transpose_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.transpose_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def transpose_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.truediv">
    <p>def <span class="ident">truediv</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.truediv</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.truediv</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.truediv</code></strong></p>
<div class="codehilite"><pre><span></span>    def truediv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.truediv_layer">
    <p>def <span class="ident">truediv_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.truediv_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.truediv_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.truediv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truediv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.truncated_normal">
    <p>def <span class="ident">truncated_normal</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.truncated_normal</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.truncated_normal</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.truncated_normal</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.truncated_normal_initializer">
    <p>def <span class="ident">truncated_normal_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.truncated_normal_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.truncated_normal_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.truncated_normal_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.truncated_normal_initializer_layer">
    <p>def <span class="ident">truncated_normal_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.truncated_normal_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.truncated_normal_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.truncated_normal_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.truncated_normal_layer">
    <p>def <span class="ident">truncated_normal_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.truncated_normal_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.truncated_normal_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.truncated_normal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tuple">
    <p>def <span class="ident">tuple</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.tuple</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.tuple</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.tuple</code></strong></p>
<div class="codehilite"><pre><span></span>    def tuple(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.tuple_layer">
    <p>def <span class="ident">tuple_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.tuple_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.tuple_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.tuple_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tuple_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.uniform_candidate_sampler">
    <p>def <span class="ident">uniform_candidate_sampler</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.uniform_candidate_sampler</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.uniform_candidate_sampler</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.uniform_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.uniform_candidate_sampler_layer">
    <p>def <span class="ident">uniform_candidate_sampler_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.uniform_candidate_sampler_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.uniform_candidate_sampler_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.uniform_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.uniform_unit_scaling_initializer">
    <p>def <span class="ident">uniform_unit_scaling_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.uniform_unit_scaling_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.uniform_unit_scaling_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.uniform_unit_scaling_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_unit_scaling_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.uniform_unit_scaling_initializer_layer">
    <p>def <span class="ident">uniform_unit_scaling_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.uniform_unit_scaling_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.uniform_unit_scaling_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.uniform_unit_scaling_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_unit_scaling_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unique">
    <p>def <span class="ident">unique</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.unique</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.unique</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.unique</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unique_layer">
    <p>def <span class="ident">unique_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.unique_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.unique_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.unique_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unique_with_counts">
    <p>def <span class="ident">unique_with_counts</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.unique_with_counts</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.unique_with_counts</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.unique_with_counts</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique_with_counts(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unique_with_counts_layer">
    <p>def <span class="ident">unique_with_counts_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.unique_with_counts_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.unique_with_counts_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.unique_with_counts_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique_with_counts_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unpack">
    <p>def <span class="ident">unpack</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.unpack</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.unpack</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.unpack</code></strong></p>
<div class="codehilite"><pre><span></span>    def unpack(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unpack_layer">
    <p>def <span class="ident">unpack_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.unpack_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.unpack_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.unpack_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unpack_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unsorted_segment_sum">
    <p>def <span class="ident">unsorted_segment_sum</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.unsorted_segment_sum</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.unsorted_segment_sum</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.unsorted_segment_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def unsorted_segment_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.unsorted_segment_sum_layer">
    <p>def <span class="ident">unsorted_segment_sum_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.unsorted_segment_sum_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.unsorted_segment_sum_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.unsorted_segment_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unsorted_segment_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.variable_axis_size_partitioner">
    <p>def <span class="ident">variable_axis_size_partitioner</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.variable_axis_size_partitioner</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.variable_axis_size_partitioner</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.variable_axis_size_partitioner</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_axis_size_partitioner(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.variable_axis_size_partitioner_layer">
    <p>def <span class="ident">variable_axis_size_partitioner_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.variable_axis_size_partitioner_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.variable_axis_size_partitioner_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.variable_axis_size_partitioner_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_axis_size_partitioner_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.variable_op_scope">
    <p>def <span class="ident">variable_op_scope</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.variable_op_scope</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.variable_op_scope</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.variable_op_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_op_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.variable_op_scope_layer">
    <p>def <span class="ident">variable_op_scope_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.variable_op_scope_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.variable_op_scope_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.variable_op_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_op_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.variable_scope">
    <p>def <span class="ident">variable_scope</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.variable_scope</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.variable_scope</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.variable_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.variable_scope_layer">
    <p>def <span class="ident">variable_scope_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.variable_scope_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.variable_scope_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.variable_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.verify_tensor_all_finite">
    <p>def <span class="ident">verify_tensor_all_finite</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.verify_tensor_all_finite</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.verify_tensor_all_finite</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.verify_tensor_all_finite</code></strong></p>
<div class="codehilite"><pre><span></span>    def verify_tensor_all_finite(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.verify_tensor_all_finite_layer">
    <p>def <span class="ident">verify_tensor_all_finite_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.verify_tensor_all_finite_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.verify_tensor_all_finite_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.verify_tensor_all_finite_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def verify_tensor_all_finite_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.weighted_cross_entropy_with_logits">
    <p>def <span class="ident">weighted_cross_entropy_with_logits</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.weighted_cross_entropy_with_logits</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.weighted_cross_entropy_with_logits</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.weighted_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def weighted_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.weighted_cross_entropy_with_logits_layer">
    <p>def <span class="ident">weighted_cross_entropy_with_logits_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.weighted_cross_entropy_with_logits_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.weighted_cross_entropy_with_logits_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.weighted_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def weighted_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.where">
    <p>def <span class="ident">where</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.where</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.where</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.where</code></strong></p>
<div class="codehilite"><pre><span></span>    def where(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.where_layer">
    <p>def <span class="ident">where_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.where_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.where_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.where_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def where_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.while_loop">
    <p>def <span class="ident">while_loop</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.while_loop</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.while_loop</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.while_loop</code></strong></p>
<div class="codehilite"><pre><span></span>    def while_loop(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.while_loop_layer">
    <p>def <span class="ident">while_loop_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.while_loop_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.while_loop_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.while_loop_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def while_loop_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.xw_plus_b">
    <p>def <span class="ident">xw_plus_b</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.xw_plus_b</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.xw_plus_b</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.xw_plus_b</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.xw_plus_b_layer">
    <p>def <span class="ident">xw_plus_b_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.xw_plus_b_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.xw_plus_b_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.xw_plus_b_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.xw_plus_b_v1">
    <p>def <span class="ident">xw_plus_b_v1</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.xw_plus_b_v1</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.xw_plus_b_v1</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.xw_plus_b_v1</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b_v1(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.xw_plus_b_v1_layer">
    <p>def <span class="ident">xw_plus_b_v1_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.xw_plus_b_v1_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.xw_plus_b_v1_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.xw_plus_b_v1_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b_v1_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zero_fraction">
    <p>def <span class="ident">zero_fraction</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.zero_fraction</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.zero_fraction</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.zero_fraction</code></strong></p>
<div class="codehilite"><pre><span></span>    def zero_fraction(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zero_fraction_layer">
    <p>def <span class="ident">zero_fraction_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.zero_fraction_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.zero_fraction_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.zero_fraction_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zero_fraction_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeros">
    <p>def <span class="ident">zeros</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.zeros</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.zeros</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.zeros</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeros_initializer">
    <p>def <span class="ident">zeros_initializer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.zeros_initializer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.zeros_initializer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.zeros_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeros_initializer_layer">
    <p>def <span class="ident">zeros_initializer_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.zeros_initializer_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.zeros_initializer_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.zeros_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeros_layer">
    <p>def <span class="ident">zeros_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.zeros_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.zeros_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.zeros_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeros_like">
    <p>def <span class="ident">zeros_like</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.zeros_like</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.zeros_like</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.zeros_like</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_like(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeros_like_layer">
    <p>def <span class="ident">zeros_like_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.zeros_like_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.zeros_like_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.zeros_like_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_like_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeta">
    <p>def <span class="ident">zeta</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>Builder.zeta</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>Builder.zeta</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>Builder.zeta</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeta(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.zeta_layer">
    <p>def <span class="ident">zeta_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS FUNCTION IS AUTOMATICALLY GENERATED</p>
<p>This function accepts the same arguments as <code>BuilderTree.zeta_layer</code> but instead of getting the class instance as its first arguments, it returns a function that expects a builder and applies the builder plus all *args and **kwargs to <code>BuilderTree.zeta_layer</code>. The returned function is an <a href="#tensorbuilder.dsl.Applicative"><code>Applicative</code></a>, so you can use all the methods defined by this class.</p>
<p><strong> utils of <code>BuilderTree.zeta_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeta_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="tensorbuilder.dsl.Applicative" class="name">class <span class="ident">Applicative</span></p>
      
  
    <div class="desc"><p>docstring for Applicative</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.Applicative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.Applicative" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Applicative</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for Applicative&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Applicative</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function of type `a -&gt; b`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a compy of the applicative&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@tb.immutable</span>
    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="n">_compose2</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#tensorbuilder.dsl.Applicative">Applicative</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="tensorbuilder.dsl.Applicative.f" class="name">var <span class="ident">f</span></p>
            

            
  
    <div class="desc"><p>A function of type <code>a -&gt; b</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.Applicative.__init__', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.Applicative.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Applicative</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function of type `a -&gt; b`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.Assert">
    <p>def <span class="ident">Assert</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.Assert</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.Assert"><code>Assert</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.Assert"><code>Assert</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.Assert</code></strong></p>
<div class="codehilite"><pre><span></span>    def Assert(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.Assert_layer">
    <p>def <span class="ident">Assert_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.Assert_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.Assert_layer"><code>Assert_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.Assert_layer"><code>Assert_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.Assert_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def Assert_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.NoGradient">
    <p>def <span class="ident">NoGradient</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.NoGradient</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.NoGradient"><code>NoGradient</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.NoGradient"><code>NoGradient</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.NoGradient</code></strong></p>
<div class="codehilite"><pre><span></span>    def NoGradient(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.NoGradient_layer">
    <p>def <span class="ident">NoGradient_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.NoGradient_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.NoGradient_layer"><code>NoGradient_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.NoGradient_layer"><code>NoGradient_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.NoGradient_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def NoGradient_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.Print">
    <p>def <span class="ident">Print</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.Print</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.Print"><code>Print</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.Print"><code>Print</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.Print</code></strong></p>
<div class="codehilite"><pre><span></span>    def Print(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.Print_layer">
    <p>def <span class="ident">Print_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.Print_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.Print_layer"><code>Print_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.Print_layer"><code>Print_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.Print_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def Print_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.abs">
    <p>def <span class="ident">abs</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.abs</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.abs"><code>abs</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.abs"><code>abs</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.abs</code></strong></p>
<div class="codehilite"><pre><span></span>    def abs(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.abs_layer">
    <p>def <span class="ident">abs_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.abs_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.abs_layer"><code>abs_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.abs_layer"><code>abs_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.abs_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def abs_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.accumulate_n">
    <p>def <span class="ident">accumulate_n</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.accumulate_n</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.accumulate_n"><code>accumulate_n</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.accumulate_n"><code>accumulate_n</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.accumulate_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def accumulate_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.accumulate_n_layer">
    <p>def <span class="ident">accumulate_n_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.accumulate_n_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.accumulate_n_layer"><code>accumulate_n_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.accumulate_n_layer"><code>accumulate_n_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.accumulate_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def accumulate_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.acos">
    <p>def <span class="ident">acos</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.acos</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.acos"><code>acos</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.acos"><code>acos</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.acos</code></strong></p>
<div class="codehilite"><pre><span></span>    def acos(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.acos_layer">
    <p>def <span class="ident">acos_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.acos_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.acos_layer"><code>acos_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.acos_layer"><code>acos_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.acos_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def acos_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add">
    <p>def <span class="ident">add</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.add</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add"><code>add</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add"><code>add</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.add</code></strong></p>
<div class="codehilite"><pre><span></span>    def add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_check_numerics_ops">
    <p>def <span class="ident">add_check_numerics_ops</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.add_check_numerics_ops</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_check_numerics_ops"><code>add_check_numerics_ops</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_check_numerics_ops"><code>add_check_numerics_ops</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.add_check_numerics_ops</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_check_numerics_ops(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_check_numerics_ops_layer">
    <p>def <span class="ident">add_check_numerics_ops_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.add_check_numerics_ops_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_check_numerics_ops_layer"><code>add_check_numerics_ops_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_check_numerics_ops_layer"><code>add_check_numerics_ops_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.add_check_numerics_ops_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_check_numerics_ops_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_layer">
    <p>def <span class="ident">add_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.add_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_layer"><code>add_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_layer"><code>add_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_n">
    <p>def <span class="ident">add_n</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.add_n</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_n"><code>add_n</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_n"><code>add_n</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.add_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_n_layer">
    <p>def <span class="ident">add_n_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.add_n_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_n_layer"><code>add_n_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_n_layer"><code>add_n_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.add_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_to_collection">
    <p>def <span class="ident">add_to_collection</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.add_to_collection</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_to_collection"><code>add_to_collection</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_to_collection"><code>add_to_collection</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.add_to_collection</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_to_collection(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.add_to_collection_layer">
    <p>def <span class="ident">add_to_collection_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.add_to_collection_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.add_to_collection_layer"><code>add_to_collection_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.add_to_collection_layer"><code>add_to_collection_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.add_to_collection_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def add_to_collection_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.all_candidate_sampler">
    <p>def <span class="ident">all_candidate_sampler</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.all_candidate_sampler</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.all_candidate_sampler"><code>all_candidate_sampler</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.all_candidate_sampler"><code>all_candidate_sampler</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.all_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.all_candidate_sampler_layer">
    <p>def <span class="ident">all_candidate_sampler_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.all_candidate_sampler_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.all_candidate_sampler_layer"><code>all_candidate_sampler_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.all_candidate_sampler_layer"><code>all_candidate_sampler_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.all_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.all_variables">
    <p>def <span class="ident">all_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.all_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.all_variables"><code>all_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.all_variables"><code>all_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.all_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.all_variables_layer">
    <p>def <span class="ident">all_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.all_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.all_variables_layer"><code>all_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.all_variables_layer"><code>all_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.all_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def all_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.arg_max">
    <p>def <span class="ident">arg_max</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.arg_max</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.arg_max"><code>arg_max</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.arg_max"><code>arg_max</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.arg_max</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_max(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.arg_max_layer">
    <p>def <span class="ident">arg_max_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.arg_max_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.arg_max_layer"><code>arg_max_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.arg_max_layer"><code>arg_max_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.arg_max_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_max_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.arg_min">
    <p>def <span class="ident">arg_min</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.arg_min</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.arg_min"><code>arg_min</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.arg_min"><code>arg_min</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.arg_min</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_min(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.arg_min_layer">
    <p>def <span class="ident">arg_min_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.arg_min_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.arg_min_layer"><code>arg_min_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.arg_min_layer"><code>arg_min_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.arg_min_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def arg_min_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.argmax_layer">
    <p>def <span class="ident">argmax_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.argmax_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.argmax_layer"><code>argmax_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.argmax_layer"><code>argmax_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.argmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def argmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.argmin_layer">
    <p>def <span class="ident">argmin_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.argmin_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.argmin_layer"><code>argmin_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.argmin_layer"><code>argmin_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.argmin_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def argmin_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.as_dtype">
    <p>def <span class="ident">as_dtype</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.as_dtype</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.as_dtype"><code>as_dtype</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.as_dtype"><code>as_dtype</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.as_dtype</code></strong></p>
<div class="codehilite"><pre><span></span>    def as_dtype(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.as_dtype_layer">
    <p>def <span class="ident">as_dtype_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.as_dtype_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.as_dtype_layer"><code>as_dtype_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.as_dtype_layer"><code>as_dtype_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.as_dtype_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def as_dtype_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.asin">
    <p>def <span class="ident">asin</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.asin</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.asin"><code>asin</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.asin"><code>asin</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.asin</code></strong></p>
<div class="codehilite"><pre><span></span>    def asin(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.asin_layer">
    <p>def <span class="ident">asin_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.asin_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.asin_layer"><code>asin_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.asin_layer"><code>asin_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.asin_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def asin_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_equal">
    <p>def <span class="ident">assert_equal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_equal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_equal"><code>assert_equal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_equal"><code>assert_equal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_equal_layer">
    <p>def <span class="ident">assert_equal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_equal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_equal_layer"><code>assert_equal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_equal_layer"><code>assert_equal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_integer">
    <p>def <span class="ident">assert_integer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_integer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_integer"><code>assert_integer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_integer"><code>assert_integer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_integer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_integer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_integer_layer">
    <p>def <span class="ident">assert_integer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_integer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_integer_layer"><code>assert_integer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_integer_layer"><code>assert_integer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_integer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_integer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_less">
    <p>def <span class="ident">assert_less</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_less</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_less"><code>assert_less</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_less"><code>assert_less</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_less</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_less_equal">
    <p>def <span class="ident">assert_less_equal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_less_equal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_less_equal"><code>assert_less_equal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_less_equal"><code>assert_less_equal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_less_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_less_equal_layer">
    <p>def <span class="ident">assert_less_equal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_less_equal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_less_equal_layer"><code>assert_less_equal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_less_equal_layer"><code>assert_less_equal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_less_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_less_layer">
    <p>def <span class="ident">assert_less_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_less_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_less_layer"><code>assert_less_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_less_layer"><code>assert_less_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_less_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_less_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_negative">
    <p>def <span class="ident">assert_negative</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_negative</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_negative"><code>assert_negative</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_negative"><code>assert_negative</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_negative</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_negative(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_negative_layer">
    <p>def <span class="ident">assert_negative_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_negative_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_negative_layer"><code>assert_negative_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_negative_layer"><code>assert_negative_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_negative_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_negative_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_non_negative">
    <p>def <span class="ident">assert_non_negative</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_non_negative</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_non_negative"><code>assert_non_negative</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_non_negative"><code>assert_non_negative</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_non_negative</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_negative(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_non_negative_layer">
    <p>def <span class="ident">assert_non_negative_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_non_negative_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_non_negative_layer"><code>assert_non_negative_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_non_negative_layer"><code>assert_non_negative_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_non_negative_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_negative_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_non_positive">
    <p>def <span class="ident">assert_non_positive</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_non_positive</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_non_positive"><code>assert_non_positive</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_non_positive"><code>assert_non_positive</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_non_positive</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_positive(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_non_positive_layer">
    <p>def <span class="ident">assert_non_positive_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_non_positive_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_non_positive_layer"><code>assert_non_positive_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_non_positive_layer"><code>assert_non_positive_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_non_positive_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_non_positive_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_positive">
    <p>def <span class="ident">assert_positive</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_positive</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_positive"><code>assert_positive</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_positive"><code>assert_positive</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_positive</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_positive(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_positive_layer">
    <p>def <span class="ident">assert_positive_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_positive_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_positive_layer"><code>assert_positive_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_positive_layer"><code>assert_positive_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_positive_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_positive_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_proper_iterable">
    <p>def <span class="ident">assert_proper_iterable</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_proper_iterable</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_proper_iterable"><code>assert_proper_iterable</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_proper_iterable"><code>assert_proper_iterable</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_proper_iterable</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_proper_iterable(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_proper_iterable_layer">
    <p>def <span class="ident">assert_proper_iterable_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_proper_iterable_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_proper_iterable_layer"><code>assert_proper_iterable_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_proper_iterable_layer"><code>assert_proper_iterable_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_proper_iterable_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_proper_iterable_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_rank">
    <p>def <span class="ident">assert_rank</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_rank</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_rank"><code>assert_rank</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_rank"><code>assert_rank</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_rank</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_rank_at_least">
    <p>def <span class="ident">assert_rank_at_least</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_rank_at_least</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_rank_at_least"><code>assert_rank_at_least</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_rank_at_least"><code>assert_rank_at_least</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_rank_at_least</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank_at_least(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_rank_at_least_layer">
    <p>def <span class="ident">assert_rank_at_least_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_rank_at_least_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_rank_at_least_layer"><code>assert_rank_at_least_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_rank_at_least_layer"><code>assert_rank_at_least_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_rank_at_least_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank_at_least_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_rank_layer">
    <p>def <span class="ident">assert_rank_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_rank_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_rank_layer"><code>assert_rank_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_rank_layer"><code>assert_rank_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_rank_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_rank_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_type">
    <p>def <span class="ident">assert_type</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_type</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_type"><code>assert_type</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_type"><code>assert_type</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_type</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_type(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_type_layer">
    <p>def <span class="ident">assert_type_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_type_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_type_layer"><code>assert_type_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_type_layer"><code>assert_type_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_type_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_type_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_variables_initialized">
    <p>def <span class="ident">assert_variables_initialized</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assert_variables_initialized</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_variables_initialized"><code>assert_variables_initialized</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_variables_initialized"><code>assert_variables_initialized</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assert_variables_initialized</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_variables_initialized(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assert_variables_initialized_layer">
    <p>def <span class="ident">assert_variables_initialized_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assert_variables_initialized_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assert_variables_initialized_layer"><code>assert_variables_initialized_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assert_variables_initialized_layer"><code>assert_variables_initialized_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assert_variables_initialized_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assert_variables_initialized_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assign">
    <p>def <span class="ident">assign</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assign</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assign"><code>assign</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assign"><code>assign</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assign</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assign_add">
    <p>def <span class="ident">assign_add</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assign_add</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assign_add"><code>assign_add</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assign_add"><code>assign_add</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assign_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assign_add_layer">
    <p>def <span class="ident">assign_add_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assign_add_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assign_add_layer"><code>assign_add_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assign_add_layer"><code>assign_add_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assign_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assign_layer">
    <p>def <span class="ident">assign_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assign_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assign_layer"><code>assign_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assign_layer"><code>assign_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assign_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assign_sub">
    <p>def <span class="ident">assign_sub</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.assign_sub</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assign_sub"><code>assign_sub</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assign_sub"><code>assign_sub</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.assign_sub</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_sub(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.assign_sub_layer">
    <p>def <span class="ident">assign_sub_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.assign_sub_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.assign_sub_layer"><code>assign_sub_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.assign_sub_layer"><code>assign_sub_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.assign_sub_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def assign_sub_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.atan">
    <p>def <span class="ident">atan</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.atan</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.atan"><code>atan</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.atan"><code>atan</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.atan</code></strong></p>
<div class="codehilite"><pre><span></span>    def atan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.atan_layer">
    <p>def <span class="ident">atan_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.atan_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.atan_layer"><code>atan_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.atan_layer"><code>atan_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.atan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def atan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.atrous_conv2d">
    <p>def <span class="ident">atrous_conv2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.atrous_conv2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.atrous_conv2d"><code>atrous_conv2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.atrous_conv2d"><code>atrous_conv2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.atrous_conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def atrous_conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.atrous_conv2d_layer">
    <p>def <span class="ident">atrous_conv2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.atrous_conv2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.atrous_conv2d_layer"><code>atrous_conv2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.atrous_conv2d_layer"><code>atrous_conv2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.atrous_conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def atrous_conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.audio_summary">
    <p>def <span class="ident">audio_summary</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.audio_summary</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.audio_summary"><code>audio_summary</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.audio_summary"><code>audio_summary</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.audio_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def audio_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.audio_summary_layer">
    <p>def <span class="ident">audio_summary_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.audio_summary_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.audio_summary_layer"><code>audio_summary_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.audio_summary_layer"><code>audio_summary_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.audio_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def audio_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.avg_pool">
    <p>def <span class="ident">avg_pool</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.avg_pool</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.avg_pool"><code>avg_pool</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.avg_pool"><code>avg_pool</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.avg_pool</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.avg_pool3d">
    <p>def <span class="ident">avg_pool3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.avg_pool3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.avg_pool3d"><code>avg_pool3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.avg_pool3d"><code>avg_pool3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.avg_pool3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.avg_pool3d_grad">
    <p>def <span class="ident">avg_pool3d_grad</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.avg_pool3d_grad</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.avg_pool3d_grad"><code>avg_pool3d_grad</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.avg_pool3d_grad"><code>avg_pool3d_grad</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.avg_pool3d_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.avg_pool3d_grad_layer">
    <p>def <span class="ident">avg_pool3d_grad_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.avg_pool3d_grad_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.avg_pool3d_grad_layer"><code>avg_pool3d_grad_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.avg_pool3d_grad_layer"><code>avg_pool3d_grad_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.avg_pool3d_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.avg_pool3d_layer">
    <p>def <span class="ident">avg_pool3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.avg_pool3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.avg_pool3d_layer"><code>avg_pool3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.avg_pool3d_layer"><code>avg_pool3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.avg_pool3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.avg_pool_layer">
    <p>def <span class="ident">avg_pool_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.avg_pool_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.avg_pool_layer"><code>avg_pool_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.avg_pool_layer"><code>avg_pool_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.avg_pool_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def avg_pool_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_cholesky">
    <p>def <span class="ident">batch_cholesky</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_cholesky</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_cholesky"><code>batch_cholesky</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_cholesky"><code>batch_cholesky</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_cholesky</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_cholesky_layer">
    <p>def <span class="ident">batch_cholesky_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_cholesky_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_cholesky_layer"><code>batch_cholesky_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_cholesky_layer"><code>batch_cholesky_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_cholesky_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_cholesky_solve">
    <p>def <span class="ident">batch_cholesky_solve</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_cholesky_solve</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_cholesky_solve"><code>batch_cholesky_solve</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_cholesky_solve"><code>batch_cholesky_solve</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_cholesky_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_cholesky_solve_layer">
    <p>def <span class="ident">batch_cholesky_solve_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_cholesky_solve_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_cholesky_solve_layer"><code>batch_cholesky_solve_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_cholesky_solve_layer"><code>batch_cholesky_solve_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_cholesky_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_cholesky_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_fft">
    <p>def <span class="ident">batch_fft</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_fft</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_fft"><code>batch_fft</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_fft"><code>batch_fft</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_fft</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_fft2d">
    <p>def <span class="ident">batch_fft2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_fft2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_fft2d"><code>batch_fft2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_fft2d"><code>batch_fft2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_fft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_fft2d_layer">
    <p>def <span class="ident">batch_fft2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_fft2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_fft2d_layer"><code>batch_fft2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_fft2d_layer"><code>batch_fft2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_fft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_fft3d">
    <p>def <span class="ident">batch_fft3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_fft3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_fft3d"><code>batch_fft3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_fft3d"><code>batch_fft3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_fft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_fft3d_layer">
    <p>def <span class="ident">batch_fft3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_fft3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_fft3d_layer"><code>batch_fft3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_fft3d_layer"><code>batch_fft3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_fft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_fft_layer">
    <p>def <span class="ident">batch_fft_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_fft_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_fft_layer"><code>batch_fft_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_fft_layer"><code>batch_fft_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_fft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_fft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_ifft">
    <p>def <span class="ident">batch_ifft</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_ifft</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_ifft"><code>batch_ifft</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_ifft"><code>batch_ifft</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_ifft</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_ifft2d">
    <p>def <span class="ident">batch_ifft2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_ifft2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_ifft2d"><code>batch_ifft2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_ifft2d"><code>batch_ifft2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_ifft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_ifft2d_layer">
    <p>def <span class="ident">batch_ifft2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_ifft2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_ifft2d_layer"><code>batch_ifft2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_ifft2d_layer"><code>batch_ifft2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_ifft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_ifft3d">
    <p>def <span class="ident">batch_ifft3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_ifft3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_ifft3d"><code>batch_ifft3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_ifft3d"><code>batch_ifft3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_ifft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_ifft3d_layer">
    <p>def <span class="ident">batch_ifft3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_ifft3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_ifft3d_layer"><code>batch_ifft3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_ifft3d_layer"><code>batch_ifft3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_ifft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_ifft_layer">
    <p>def <span class="ident">batch_ifft_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_ifft_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_ifft_layer"><code>batch_ifft_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_ifft_layer"><code>batch_ifft_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_ifft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_ifft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matmul_layer">
    <p>def <span class="ident">batch_matmul_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matmul_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matmul_layer"><code>batch_matmul_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matmul_layer"><code>batch_matmul_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_band_part">
    <p>def <span class="ident">batch_matrix_band_part</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_band_part</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_band_part"><code>batch_matrix_band_part</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_band_part"><code>batch_matrix_band_part</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_band_part</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_band_part(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_band_part_layer">
    <p>def <span class="ident">batch_matrix_band_part_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_band_part_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_band_part_layer"><code>batch_matrix_band_part_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_band_part_layer"><code>batch_matrix_band_part_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_band_part_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_band_part_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_determinant">
    <p>def <span class="ident">batch_matrix_determinant</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_determinant</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_determinant"><code>batch_matrix_determinant</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_determinant"><code>batch_matrix_determinant</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_determinant</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_determinant(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_determinant_layer">
    <p>def <span class="ident">batch_matrix_determinant_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_determinant_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_determinant_layer"><code>batch_matrix_determinant_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_determinant_layer"><code>batch_matrix_determinant_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_determinant_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_determinant_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_diag">
    <p>def <span class="ident">batch_matrix_diag</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_diag</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_diag"><code>batch_matrix_diag</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_diag"><code>batch_matrix_diag</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_diag</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_diag_layer">
    <p>def <span class="ident">batch_matrix_diag_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_diag_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_diag_layer"><code>batch_matrix_diag_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_diag_layer"><code>batch_matrix_diag_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_diag_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_diag_part">
    <p>def <span class="ident">batch_matrix_diag_part</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_diag_part</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_diag_part"><code>batch_matrix_diag_part</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_diag_part"><code>batch_matrix_diag_part</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_diag_part</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag_part(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_diag_part_layer">
    <p>def <span class="ident">batch_matrix_diag_part_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_diag_part_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_diag_part_layer"><code>batch_matrix_diag_part_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_diag_part_layer"><code>batch_matrix_diag_part_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_diag_part_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_diag_part_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_inverse">
    <p>def <span class="ident">batch_matrix_inverse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_inverse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_inverse"><code>batch_matrix_inverse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_inverse"><code>batch_matrix_inverse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_inverse</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_inverse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_inverse_layer">
    <p>def <span class="ident">batch_matrix_inverse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_inverse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_inverse_layer"><code>batch_matrix_inverse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_inverse_layer"><code>batch_matrix_inverse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_inverse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_inverse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_solve">
    <p>def <span class="ident">batch_matrix_solve</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_solve</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_solve"><code>batch_matrix_solve</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_solve"><code>batch_matrix_solve</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_solve_layer">
    <p>def <span class="ident">batch_matrix_solve_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_solve_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_solve_layer"><code>batch_matrix_solve_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_solve_layer"><code>batch_matrix_solve_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_solve_ls">
    <p>def <span class="ident">batch_matrix_solve_ls</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_solve_ls</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_solve_ls"><code>batch_matrix_solve_ls</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_solve_ls"><code>batch_matrix_solve_ls</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_solve_ls</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve_ls(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_solve_ls_layer">
    <p>def <span class="ident">batch_matrix_solve_ls_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_solve_ls_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_solve_ls_layer"><code>batch_matrix_solve_ls_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_solve_ls_layer"><code>batch_matrix_solve_ls_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_solve_ls_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_solve_ls_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_triangular_solve">
    <p>def <span class="ident">batch_matrix_triangular_solve</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_matrix_triangular_solve</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_triangular_solve"><code>batch_matrix_triangular_solve</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_triangular_solve"><code>batch_matrix_triangular_solve</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_matrix_triangular_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_triangular_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_matrix_triangular_solve_layer">
    <p>def <span class="ident">batch_matrix_triangular_solve_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_matrix_triangular_solve_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_matrix_triangular_solve_layer"><code>batch_matrix_triangular_solve_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_matrix_triangular_solve_layer"><code>batch_matrix_triangular_solve_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_matrix_triangular_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_matrix_triangular_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_norm_with_global_normalization">
    <p>def <span class="ident">batch_norm_with_global_normalization</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_norm_with_global_normalization</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_norm_with_global_normalization"><code>batch_norm_with_global_normalization</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_norm_with_global_normalization"><code>batch_norm_with_global_normalization</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_norm_with_global_normalization</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_norm_with_global_normalization(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_norm_with_global_normalization_layer">
    <p>def <span class="ident">batch_norm_with_global_normalization_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_norm_with_global_normalization_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_norm_with_global_normalization_layer"><code>batch_norm_with_global_normalization_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_norm_with_global_normalization_layer"><code>batch_norm_with_global_normalization_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_norm_with_global_normalization_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_norm_with_global_normalization_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_normalization">
    <p>def <span class="ident">batch_normalization</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_normalization</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_normalization"><code>batch_normalization</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_normalization"><code>batch_normalization</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_normalization</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_normalization(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_normalization_layer">
    <p>def <span class="ident">batch_normalization_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_normalization_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_normalization_layer"><code>batch_normalization_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_normalization_layer"><code>batch_normalization_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_normalization_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_normalization_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_self_adjoint_eig">
    <p>def <span class="ident">batch_self_adjoint_eig</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_self_adjoint_eig</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_self_adjoint_eig"><code>batch_self_adjoint_eig</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_self_adjoint_eig"><code>batch_self_adjoint_eig</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_self_adjoint_eig</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_self_adjoint_eig(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_self_adjoint_eig_layer">
    <p>def <span class="ident">batch_self_adjoint_eig_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_self_adjoint_eig_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_self_adjoint_eig_layer"><code>batch_self_adjoint_eig_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_self_adjoint_eig_layer"><code>batch_self_adjoint_eig_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_self_adjoint_eig_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_self_adjoint_eig_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_to_space">
    <p>def <span class="ident">batch_to_space</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.batch_to_space</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_to_space"><code>batch_to_space</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_to_space"><code>batch_to_space</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.batch_to_space</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_to_space(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.batch_to_space_layer">
    <p>def <span class="ident">batch_to_space_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.batch_to_space_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.batch_to_space_layer"><code>batch_to_space_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.batch_to_space_layer"><code>batch_to_space_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.batch_to_space_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def batch_to_space_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bias_add">
    <p>def <span class="ident">bias_add</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.bias_add</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bias_add"><code>bias_add</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bias_add"><code>bias_add</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.bias_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bias_add_grad">
    <p>def <span class="ident">bias_add_grad</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.bias_add_grad</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bias_add_grad"><code>bias_add_grad</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bias_add_grad"><code>bias_add_grad</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.bias_add_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bias_add_grad_layer">
    <p>def <span class="ident">bias_add_grad_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.bias_add_grad_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bias_add_grad_layer"><code>bias_add_grad_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bias_add_grad_layer"><code>bias_add_grad_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.bias_add_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bias_add_layer">
    <p>def <span class="ident">bias_add_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.bias_add_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bias_add_layer"><code>bias_add_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bias_add_layer"><code>bias_add_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.bias_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bias_add_v1">
    <p>def <span class="ident">bias_add_v1</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.bias_add_v1</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bias_add_v1"><code>bias_add_v1</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bias_add_v1"><code>bias_add_v1</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.bias_add_v1</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_v1(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bias_add_v1_layer">
    <p>def <span class="ident">bias_add_v1_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.bias_add_v1_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bias_add_v1_layer"><code>bias_add_v1_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bias_add_v1_layer"><code>bias_add_v1_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.bias_add_v1_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bias_add_v1_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bidirectional_rnn">
    <p>def <span class="ident">bidirectional_rnn</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.bidirectional_rnn</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bidirectional_rnn"><code>bidirectional_rnn</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bidirectional_rnn"><code>bidirectional_rnn</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.bidirectional_rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def bidirectional_rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bidirectional_rnn_layer">
    <p>def <span class="ident">bidirectional_rnn_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.bidirectional_rnn_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bidirectional_rnn_layer"><code>bidirectional_rnn_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bidirectional_rnn_layer"><code>bidirectional_rnn_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.bidirectional_rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bidirectional_rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bitcast">
    <p>def <span class="ident">bitcast</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.bitcast</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bitcast"><code>bitcast</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bitcast"><code>bitcast</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.bitcast</code></strong></p>
<div class="codehilite"><pre><span></span>    def bitcast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.bitcast_layer">
    <p>def <span class="ident">bitcast_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.bitcast_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.bitcast_layer"><code>bitcast_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.bitcast_layer"><code>bitcast_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.bitcast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def bitcast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.boolean_mask">
    <p>def <span class="ident">boolean_mask</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.boolean_mask</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.boolean_mask"><code>boolean_mask</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.boolean_mask"><code>boolean_mask</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.boolean_mask</code></strong></p>
<div class="codehilite"><pre><span></span>    def boolean_mask(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.boolean_mask_layer">
    <p>def <span class="ident">boolean_mask_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.boolean_mask_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.boolean_mask_layer"><code>boolean_mask_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.boolean_mask_layer"><code>boolean_mask_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.boolean_mask_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def boolean_mask_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.branch">
    <p>def <span class="ident">branch</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.branch</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.branch"><code>branch</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.branch"><code>branch</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.branch</code></strong></p>
<div class="codehilite"><pre><span></span>    def branch(builder, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.builders">
    <p>def <span class="ident">builders</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.builders</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.builders"><code>builders</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.builders"><code>builders</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.builders</code></strong></p>
<div class="codehilite"><pre><span></span>    def builders(self)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.case">
    <p>def <span class="ident">case</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.case</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.case"><code>case</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.case"><code>case</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.case</code></strong></p>
<div class="codehilite"><pre><span></span>    def case(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.case_layer">
    <p>def <span class="ident">case_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.case_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.case_layer"><code>case_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.case_layer"><code>case_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.case_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def case_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cast">
    <p>def <span class="ident">cast</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.cast</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cast"><code>cast</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cast"><code>cast</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.cast</code></strong></p>
<div class="codehilite"><pre><span></span>    def cast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cast_layer">
    <p>def <span class="ident">cast_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.cast_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cast_layer"><code>cast_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cast_layer"><code>cast_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.cast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ceil">
    <p>def <span class="ident">ceil</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ceil</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ceil"><code>ceil</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ceil"><code>ceil</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ceil</code></strong></p>
<div class="codehilite"><pre><span></span>    def ceil(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ceil_layer">
    <p>def <span class="ident">ceil_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ceil_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ceil_layer"><code>ceil_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ceil_layer"><code>ceil_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ceil_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ceil_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.check_numerics">
    <p>def <span class="ident">check_numerics</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.check_numerics</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.check_numerics"><code>check_numerics</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.check_numerics"><code>check_numerics</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.check_numerics</code></strong></p>
<div class="codehilite"><pre><span></span>    def check_numerics(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.check_numerics_layer">
    <p>def <span class="ident">check_numerics_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.check_numerics_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.check_numerics_layer"><code>check_numerics_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.check_numerics_layer"><code>check_numerics_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.check_numerics_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def check_numerics_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cholesky">
    <p>def <span class="ident">cholesky</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.cholesky</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cholesky"><code>cholesky</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cholesky"><code>cholesky</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.cholesky</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cholesky_layer">
    <p>def <span class="ident">cholesky_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.cholesky_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cholesky_layer"><code>cholesky_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cholesky_layer"><code>cholesky_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.cholesky_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cholesky_solve">
    <p>def <span class="ident">cholesky_solve</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.cholesky_solve</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cholesky_solve"><code>cholesky_solve</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cholesky_solve"><code>cholesky_solve</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.cholesky_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cholesky_solve_layer">
    <p>def <span class="ident">cholesky_solve_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.cholesky_solve_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cholesky_solve_layer"><code>cholesky_solve_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cholesky_solve_layer"><code>cholesky_solve_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.cholesky_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cholesky_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_average_norm">
    <p>def <span class="ident">clip_by_average_norm</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.clip_by_average_norm</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_average_norm"><code>clip_by_average_norm</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_average_norm"><code>clip_by_average_norm</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.clip_by_average_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_average_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_average_norm_layer">
    <p>def <span class="ident">clip_by_average_norm_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.clip_by_average_norm_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_average_norm_layer"><code>clip_by_average_norm_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_average_norm_layer"><code>clip_by_average_norm_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.clip_by_average_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_average_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_global_norm">
    <p>def <span class="ident">clip_by_global_norm</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.clip_by_global_norm</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_global_norm"><code>clip_by_global_norm</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_global_norm"><code>clip_by_global_norm</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.clip_by_global_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_global_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_global_norm_layer">
    <p>def <span class="ident">clip_by_global_norm_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.clip_by_global_norm_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_global_norm_layer"><code>clip_by_global_norm_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_global_norm_layer"><code>clip_by_global_norm_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.clip_by_global_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_global_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_norm">
    <p>def <span class="ident">clip_by_norm</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.clip_by_norm</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_norm"><code>clip_by_norm</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_norm"><code>clip_by_norm</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.clip_by_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_norm_layer">
    <p>def <span class="ident">clip_by_norm_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.clip_by_norm_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_norm_layer"><code>clip_by_norm_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_norm_layer"><code>clip_by_norm_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.clip_by_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_value">
    <p>def <span class="ident">clip_by_value</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.clip_by_value</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_value"><code>clip_by_value</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_value"><code>clip_by_value</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.clip_by_value</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_value(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.clip_by_value_layer">
    <p>def <span class="ident">clip_by_value_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.clip_by_value_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.clip_by_value_layer"><code>clip_by_value_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.clip_by_value_layer"><code>clip_by_value_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.clip_by_value_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def clip_by_value_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.complex">
    <p>def <span class="ident">complex</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.complex</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.complex"><code>complex</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.complex"><code>complex</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.complex</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.complex_abs">
    <p>def <span class="ident">complex_abs</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.complex_abs</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.complex_abs"><code>complex_abs</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.complex_abs"><code>complex_abs</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.complex_abs</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex_abs(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.complex_abs_layer">
    <p>def <span class="ident">complex_abs_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.complex_abs_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.complex_abs_layer"><code>complex_abs_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.complex_abs_layer"><code>complex_abs_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.complex_abs_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex_abs_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.complex_layer">
    <p>def <span class="ident">complex_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.complex_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.complex_layer"><code>complex_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.complex_layer"><code>complex_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.complex_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def complex_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.compose">
    <p>def <span class="ident">compose</span>(</p><p>app, g)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.Applicative.compose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.Applicative.compose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@tb.immutable</span>
<span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="n">_compose2</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.compute_accidental_hits">
    <p>def <span class="ident">compute_accidental_hits</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.compute_accidental_hits</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.compute_accidental_hits"><code>compute_accidental_hits</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.compute_accidental_hits"><code>compute_accidental_hits</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.compute_accidental_hits</code></strong></p>
<div class="codehilite"><pre><span></span>    def compute_accidental_hits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.compute_accidental_hits_layer">
    <p>def <span class="ident">compute_accidental_hits_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.compute_accidental_hits_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.compute_accidental_hits_layer"><code>compute_accidental_hits_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.compute_accidental_hits_layer"><code>compute_accidental_hits_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.compute_accidental_hits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def compute_accidental_hits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.concat">
    <p>def <span class="ident">concat</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.concat</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.concat"><code>concat</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.concat"><code>concat</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.concat</code></strong></p>
<div class="codehilite"><pre><span></span>    def concat(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.concat_layer">
    <p>def <span class="ident">concat_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.concat_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.concat_layer"><code>concat_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.concat_layer"><code>concat_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.concat_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def concat_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cond">
    <p>def <span class="ident">cond</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.cond</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cond"><code>cond</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cond"><code>cond</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.cond</code></strong></p>
<div class="codehilite"><pre><span></span>    def cond(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cond_layer">
    <p>def <span class="ident">cond_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.cond_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cond_layer"><code>cond_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cond_layer"><code>cond_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.cond_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cond_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conj">
    <p>def <span class="ident">conj</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conj</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conj"><code>conj</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conj"><code>conj</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conj</code></strong></p>
<div class="codehilite"><pre><span></span>    def conj(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conj_layer">
    <p>def <span class="ident">conj_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conj_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conj_layer"><code>conj_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conj_layer"><code>conj_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conj_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conj_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.constant">
    <p>def <span class="ident">constant</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.constant</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.constant"><code>constant</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.constant"><code>constant</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.constant</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.constant_initializer">
    <p>def <span class="ident">constant_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.constant_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.constant_initializer"><code>constant_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.constant_initializer"><code>constant_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.constant_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.constant_initializer_layer">
    <p>def <span class="ident">constant_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.constant_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.constant_initializer_layer"><code>constant_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.constant_initializer_layer"><code>constant_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.constant_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.constant_layer">
    <p>def <span class="ident">constant_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.constant_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.constant_layer"><code>constant_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.constant_layer"><code>constant_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.constant_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def constant_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.control_dependencies">
    <p>def <span class="ident">control_dependencies</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.control_dependencies</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.control_dependencies"><code>control_dependencies</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.control_dependencies"><code>control_dependencies</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.control_dependencies</code></strong></p>
<div class="codehilite"><pre><span></span>    def control_dependencies(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.control_dependencies_layer">
    <p>def <span class="ident">control_dependencies_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.control_dependencies_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.control_dependencies_layer"><code>control_dependencies_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.control_dependencies_layer"><code>control_dependencies_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.control_dependencies_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def control_dependencies_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv1d">
    <p>def <span class="ident">conv1d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv1d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv1d"><code>conv1d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv1d"><code>conv1d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv1d</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv1d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv1d_layer">
    <p>def <span class="ident">conv1d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv1d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv1d_layer"><code>conv1d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv1d_layer"><code>conv1d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv1d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv1d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d">
    <p>def <span class="ident">conv2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d"><code>conv2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d"><code>conv2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_backprop_filter">
    <p>def <span class="ident">conv2d_backprop_filter</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv2d_backprop_filter</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_backprop_filter"><code>conv2d_backprop_filter</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_backprop_filter"><code>conv2d_backprop_filter</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv2d_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_backprop_filter_layer">
    <p>def <span class="ident">conv2d_backprop_filter_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv2d_backprop_filter_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_backprop_filter_layer"><code>conv2d_backprop_filter_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_backprop_filter_layer"><code>conv2d_backprop_filter_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv2d_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_backprop_input">
    <p>def <span class="ident">conv2d_backprop_input</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv2d_backprop_input</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_backprop_input"><code>conv2d_backprop_input</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_backprop_input"><code>conv2d_backprop_input</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv2d_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_backprop_input_layer">
    <p>def <span class="ident">conv2d_backprop_input_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv2d_backprop_input_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_backprop_input_layer"><code>conv2d_backprop_input_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_backprop_input_layer"><code>conv2d_backprop_input_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv2d_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_layer">
    <p>def <span class="ident">conv2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_layer"><code>conv2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_layer"><code>conv2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_transpose">
    <p>def <span class="ident">conv2d_transpose</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv2d_transpose</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_transpose"><code>conv2d_transpose</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_transpose"><code>conv2d_transpose</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv2d_transpose</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_transpose(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv2d_transpose_layer">
    <p>def <span class="ident">conv2d_transpose_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv2d_transpose_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv2d_transpose_layer"><code>conv2d_transpose_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv2d_transpose_layer"><code>conv2d_transpose_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv2d_transpose_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv2d_transpose_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv3d">
    <p>def <span class="ident">conv3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv3d"><code>conv3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv3d"><code>conv3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv3d_backprop_filter">
    <p>def <span class="ident">conv3d_backprop_filter</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv3d_backprop_filter</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv3d_backprop_filter"><code>conv3d_backprop_filter</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv3d_backprop_filter"><code>conv3d_backprop_filter</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv3d_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv3d_backprop_filter_layer">
    <p>def <span class="ident">conv3d_backprop_filter_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv3d_backprop_filter_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv3d_backprop_filter_layer"><code>conv3d_backprop_filter_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv3d_backprop_filter_layer"><code>conv3d_backprop_filter_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv3d_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv3d_backprop_input">
    <p>def <span class="ident">conv3d_backprop_input</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.conv3d_backprop_input</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv3d_backprop_input"><code>conv3d_backprop_input</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv3d_backprop_input"><code>conv3d_backprop_input</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.conv3d_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv3d_backprop_input_layer">
    <p>def <span class="ident">conv3d_backprop_input_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv3d_backprop_input_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv3d_backprop_input_layer"><code>conv3d_backprop_input_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv3d_backprop_input_layer"><code>conv3d_backprop_input_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv3d_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.conv3d_layer">
    <p>def <span class="ident">conv3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.conv3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.conv3d_layer"><code>conv3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.conv3d_layer"><code>conv3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.conv3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def conv3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.convert_to_tensor">
    <p>def <span class="ident">convert_to_tensor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.convert_to_tensor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.convert_to_tensor"><code>convert_to_tensor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.convert_to_tensor"><code>convert_to_tensor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.convert_to_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.convert_to_tensor_layer">
    <p>def <span class="ident">convert_to_tensor_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.convert_to_tensor_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.convert_to_tensor_layer"><code>convert_to_tensor_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.convert_to_tensor_layer"><code>convert_to_tensor_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.convert_to_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.convert_to_tensor_or_indexed_slices">
    <p>def <span class="ident">convert_to_tensor_or_indexed_slices</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.convert_to_tensor_or_indexed_slices</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.convert_to_tensor_or_indexed_slices"><code>convert_to_tensor_or_indexed_slices</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.convert_to_tensor_or_indexed_slices"><code>convert_to_tensor_or_indexed_slices</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.convert_to_tensor_or_indexed_slices</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor_or_indexed_slices(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.convert_to_tensor_or_indexed_slices_layer">
    <p>def <span class="ident">convert_to_tensor_or_indexed_slices_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.convert_to_tensor_or_indexed_slices_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.convert_to_tensor_or_indexed_slices_layer"><code>convert_to_tensor_or_indexed_slices_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.convert_to_tensor_or_indexed_slices_layer"><code>convert_to_tensor_or_indexed_slices_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.convert_to_tensor_or_indexed_slices_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def convert_to_tensor_or_indexed_slices_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.convolution2d">
    <p>def <span class="ident">convolution2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.convolution2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.convolution2d"><code>convolution2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.convolution2d"><code>convolution2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.convolution2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def convolution2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.copy">
    <p>def <span class="ident">copy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a compy of the applicative</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.dsl.Applicative.copy', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.dsl.Applicative.copy" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a compy of the applicative&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Applicative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cos">
    <p>def <span class="ident">cos</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.cos</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cos"><code>cos</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cos"><code>cos</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.cos</code></strong></p>
<div class="codehilite"><pre><span></span>    def cos(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cos_layer">
    <p>def <span class="ident">cos_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.cos_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cos_layer"><code>cos_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cos_layer"><code>cos_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.cos_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cos_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.count_up_to">
    <p>def <span class="ident">count_up_to</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.count_up_to</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.count_up_to"><code>count_up_to</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.count_up_to"><code>count_up_to</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.count_up_to</code></strong></p>
<div class="codehilite"><pre><span></span>    def count_up_to(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.count_up_to_layer">
    <p>def <span class="ident">count_up_to_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.count_up_to_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.count_up_to_layer"><code>count_up_to_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.count_up_to_layer"><code>count_up_to_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.count_up_to_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def count_up_to_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.create_partitioned_variables">
    <p>def <span class="ident">create_partitioned_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.create_partitioned_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.create_partitioned_variables"><code>create_partitioned_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.create_partitioned_variables"><code>create_partitioned_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.create_partitioned_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def create_partitioned_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.create_partitioned_variables_layer">
    <p>def <span class="ident">create_partitioned_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.create_partitioned_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.create_partitioned_variables_layer"><code>create_partitioned_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.create_partitioned_variables_layer"><code>create_partitioned_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.create_partitioned_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def create_partitioned_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cross">
    <p>def <span class="ident">cross</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.cross</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cross"><code>cross</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cross"><code>cross</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.cross</code></strong></p>
<div class="codehilite"><pre><span></span>    def cross(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.cross_layer">
    <p>def <span class="ident">cross_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.cross_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.cross_layer"><code>cross_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.cross_layer"><code>cross_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.cross_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def cross_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.decode_csv">
    <p>def <span class="ident">decode_csv</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.decode_csv</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.decode_csv"><code>decode_csv</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.decode_csv"><code>decode_csv</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.decode_csv</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_csv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.decode_csv_layer">
    <p>def <span class="ident">decode_csv_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.decode_csv_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.decode_csv_layer"><code>decode_csv_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.decode_csv_layer"><code>decode_csv_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.decode_csv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_csv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.decode_json_example">
    <p>def <span class="ident">decode_json_example</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.decode_json_example</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.decode_json_example"><code>decode_json_example</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.decode_json_example"><code>decode_json_example</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.decode_json_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_json_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.decode_json_example_layer">
    <p>def <span class="ident">decode_json_example_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.decode_json_example_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.decode_json_example_layer"><code>decode_json_example_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.decode_json_example_layer"><code>decode_json_example_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.decode_json_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_json_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.decode_raw">
    <p>def <span class="ident">decode_raw</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.decode_raw</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.decode_raw"><code>decode_raw</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.decode_raw"><code>decode_raw</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.decode_raw</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_raw(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.decode_raw_layer">
    <p>def <span class="ident">decode_raw_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.decode_raw_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.decode_raw_layer"><code>decode_raw_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.decode_raw_layer"><code>decode_raw_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.decode_raw_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def decode_raw_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.delete_session_tensor">
    <p>def <span class="ident">delete_session_tensor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.delete_session_tensor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.delete_session_tensor"><code>delete_session_tensor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.delete_session_tensor"><code>delete_session_tensor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.delete_session_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def delete_session_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.delete_session_tensor_layer">
    <p>def <span class="ident">delete_session_tensor_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.delete_session_tensor_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.delete_session_tensor_layer"><code>delete_session_tensor_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.delete_session_tensor_layer"><code>delete_session_tensor_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.delete_session_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def delete_session_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depth_to_space">
    <p>def <span class="ident">depth_to_space</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.depth_to_space</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depth_to_space"><code>depth_to_space</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depth_to_space"><code>depth_to_space</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.depth_to_space</code></strong></p>
<div class="codehilite"><pre><span></span>    def depth_to_space(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depth_to_space_layer">
    <p>def <span class="ident">depth_to_space_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.depth_to_space_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depth_to_space_layer"><code>depth_to_space_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depth_to_space_layer"><code>depth_to_space_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.depth_to_space_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depth_to_space_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d">
    <p>def <span class="ident">depthwise_conv2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.depthwise_conv2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d"><code>depthwise_conv2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d"><code>depthwise_conv2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.depthwise_conv2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_layer"><code>depthwise_conv2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_layer"><code>depthwise_conv2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_native">
    <p>def <span class="ident">depthwise_conv2d_native</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.depthwise_conv2d_native</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_native"><code>depthwise_conv2d_native</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_native"><code>depthwise_conv2d_native</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d_native</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_filter">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.depthwise_conv2d_native_backprop_filter</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter"><code>depthwise_conv2d_native_backprop_filter</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter"><code>depthwise_conv2d_native_backprop_filter</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d_native_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_filter_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.depthwise_conv2d_native_backprop_filter_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter_layer"><code>depthwise_conv2d_native_backprop_filter_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_filter_layer"><code>depthwise_conv2d_native_backprop_filter_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_native_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_input">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.depthwise_conv2d_native_backprop_input</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_input"><code>depthwise_conv2d_native_backprop_input</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_input"><code>depthwise_conv2d_native_backprop_input</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.depthwise_conv2d_native_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_native_backprop_input_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.depthwise_conv2d_native_backprop_input_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_input_layer"><code>depthwise_conv2d_native_backprop_input_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_native_backprop_input_layer"><code>depthwise_conv2d_native_backprop_input_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_native_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.depthwise_conv2d_native_layer">
    <p>def <span class="ident">depthwise_conv2d_native_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.depthwise_conv2d_native_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.depthwise_conv2d_native_layer"><code>depthwise_conv2d_native_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.depthwise_conv2d_native_layer"><code>depthwise_conv2d_native_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.depthwise_conv2d_native_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def depthwise_conv2d_native_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.deserialize_many_sparse">
    <p>def <span class="ident">deserialize_many_sparse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.deserialize_many_sparse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.deserialize_many_sparse"><code>deserialize_many_sparse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.deserialize_many_sparse"><code>deserialize_many_sparse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.deserialize_many_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def deserialize_many_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.deserialize_many_sparse_layer">
    <p>def <span class="ident">deserialize_many_sparse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.deserialize_many_sparse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.deserialize_many_sparse_layer"><code>deserialize_many_sparse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.deserialize_many_sparse_layer"><code>deserialize_many_sparse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.deserialize_many_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def deserialize_many_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.device">
    <p>def <span class="ident">device</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.device</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.device"><code>device</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.device"><code>device</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.device</code></strong></p>
<div class="codehilite"><pre><span></span>    def device(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.device_layer">
    <p>def <span class="ident">device_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.device_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.device_layer"><code>device_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.device_layer"><code>device_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.device_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def device_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.diag">
    <p>def <span class="ident">diag</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.diag</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.diag"><code>diag</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.diag"><code>diag</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.diag</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.diag_layer">
    <p>def <span class="ident">diag_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.diag_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.diag_layer"><code>diag_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.diag_layer"><code>diag_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.diag_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.diag_part">
    <p>def <span class="ident">diag_part</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.diag_part</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.diag_part"><code>diag_part</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.diag_part"><code>diag_part</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.diag_part</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag_part(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.diag_part_layer">
    <p>def <span class="ident">diag_part_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.diag_part_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.diag_part_layer"><code>diag_part_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.diag_part_layer"><code>diag_part_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.diag_part_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def diag_part_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.digamma">
    <p>def <span class="ident">digamma</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.digamma</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.digamma"><code>digamma</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.digamma"><code>digamma</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.digamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def digamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.digamma_layer">
    <p>def <span class="ident">digamma_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.digamma_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.digamma_layer"><code>digamma_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.digamma_layer"><code>digamma_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.digamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def digamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dilation2d">
    <p>def <span class="ident">dilation2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dilation2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dilation2d"><code>dilation2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dilation2d"><code>dilation2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dilation2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dilation2d_backprop_filter">
    <p>def <span class="ident">dilation2d_backprop_filter</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dilation2d_backprop_filter</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dilation2d_backprop_filter"><code>dilation2d_backprop_filter</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dilation2d_backprop_filter"><code>dilation2d_backprop_filter</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dilation2d_backprop_filter</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_filter(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dilation2d_backprop_filter_layer">
    <p>def <span class="ident">dilation2d_backprop_filter_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dilation2d_backprop_filter_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dilation2d_backprop_filter_layer"><code>dilation2d_backprop_filter_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dilation2d_backprop_filter_layer"><code>dilation2d_backprop_filter_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dilation2d_backprop_filter_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_filter_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dilation2d_backprop_input">
    <p>def <span class="ident">dilation2d_backprop_input</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dilation2d_backprop_input</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dilation2d_backprop_input"><code>dilation2d_backprop_input</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dilation2d_backprop_input"><code>dilation2d_backprop_input</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dilation2d_backprop_input</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_input(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dilation2d_backprop_input_layer">
    <p>def <span class="ident">dilation2d_backprop_input_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dilation2d_backprop_input_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dilation2d_backprop_input_layer"><code>dilation2d_backprop_input_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dilation2d_backprop_input_layer"><code>dilation2d_backprop_input_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dilation2d_backprop_input_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_backprop_input_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dilation2d_layer">
    <p>def <span class="ident">dilation2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dilation2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dilation2d_layer"><code>dilation2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dilation2d_layer"><code>dilation2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dilation2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dilation2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.div">
    <p>def <span class="ident">div</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.div</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.div"><code>div</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.div"><code>div</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.div</code></strong></p>
<div class="codehilite"><pre><span></span>    def div(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.div_layer">
    <p>def <span class="ident">div_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.div_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.div_layer"><code>div_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.div_layer"><code>div_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.div_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def div_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dropout">
    <p>def <span class="ident">dropout</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dropout</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dropout"><code>dropout</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dropout"><code>dropout</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dropout</code></strong></p>
<div class="codehilite"><pre><span></span>    def dropout(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dropout_layer">
    <p>def <span class="ident">dropout_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dropout_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dropout_layer"><code>dropout_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dropout_layer"><code>dropout_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dropout_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dropout_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dynamic_partition">
    <p>def <span class="ident">dynamic_partition</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dynamic_partition</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dynamic_partition"><code>dynamic_partition</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dynamic_partition"><code>dynamic_partition</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dynamic_partition</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_partition(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dynamic_partition_layer">
    <p>def <span class="ident">dynamic_partition_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dynamic_partition_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dynamic_partition_layer"><code>dynamic_partition_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dynamic_partition_layer"><code>dynamic_partition_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dynamic_partition_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_partition_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dynamic_rnn">
    <p>def <span class="ident">dynamic_rnn</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dynamic_rnn</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dynamic_rnn"><code>dynamic_rnn</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dynamic_rnn"><code>dynamic_rnn</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dynamic_rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dynamic_rnn_layer">
    <p>def <span class="ident">dynamic_rnn_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dynamic_rnn_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dynamic_rnn_layer"><code>dynamic_rnn_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dynamic_rnn_layer"><code>dynamic_rnn_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dynamic_rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dynamic_stitch">
    <p>def <span class="ident">dynamic_stitch</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.dynamic_stitch</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dynamic_stitch"><code>dynamic_stitch</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dynamic_stitch"><code>dynamic_stitch</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.dynamic_stitch</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_stitch(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.dynamic_stitch_layer">
    <p>def <span class="ident">dynamic_stitch_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.dynamic_stitch_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.dynamic_stitch_layer"><code>dynamic_stitch_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.dynamic_stitch_layer"><code>dynamic_stitch_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.dynamic_stitch_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def dynamic_stitch_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.edit_distance">
    <p>def <span class="ident">edit_distance</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.edit_distance</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.edit_distance"><code>edit_distance</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.edit_distance"><code>edit_distance</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.edit_distance</code></strong></p>
<div class="codehilite"><pre><span></span>    def edit_distance(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.edit_distance_layer">
    <p>def <span class="ident">edit_distance_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.edit_distance_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.edit_distance_layer"><code>edit_distance_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.edit_distance_layer"><code>edit_distance_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.edit_distance_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def edit_distance_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.elu">
    <p>def <span class="ident">elu</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.elu</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.elu"><code>elu</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.elu"><code>elu</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.elu</code></strong></p>
<div class="codehilite"><pre><span></span>    def elu(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.elu_layer">
    <p>def <span class="ident">elu_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.elu_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.elu_layer"><code>elu_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.elu_layer"><code>elu_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.elu_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def elu_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.embedding_lookup">
    <p>def <span class="ident">embedding_lookup</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.embedding_lookup</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.embedding_lookup"><code>embedding_lookup</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.embedding_lookup"><code>embedding_lookup</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.embedding_lookup</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.embedding_lookup_layer">
    <p>def <span class="ident">embedding_lookup_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.embedding_lookup_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.embedding_lookup_layer"><code>embedding_lookup_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.embedding_lookup_layer"><code>embedding_lookup_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.embedding_lookup_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.embedding_lookup_sparse">
    <p>def <span class="ident">embedding_lookup_sparse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.embedding_lookup_sparse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.embedding_lookup_sparse"><code>embedding_lookup_sparse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.embedding_lookup_sparse"><code>embedding_lookup_sparse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.embedding_lookup_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.embedding_lookup_sparse_layer">
    <p>def <span class="ident">embedding_lookup_sparse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.embedding_lookup_sparse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.embedding_lookup_sparse_layer"><code>embedding_lookup_sparse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.embedding_lookup_sparse_layer"><code>embedding_lookup_sparse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.embedding_lookup_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def embedding_lookup_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.equal">
    <p>def <span class="ident">equal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.equal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.equal"><code>equal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.equal"><code>equal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.equal_layer">
    <p>def <span class="ident">equal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.equal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.equal_layer"><code>equal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.equal_layer"><code>equal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.erf">
    <p>def <span class="ident">erf</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.erf</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.erf"><code>erf</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.erf"><code>erf</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.erf</code></strong></p>
<div class="codehilite"><pre><span></span>    def erf(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.erf_layer">
    <p>def <span class="ident">erf_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.erf_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.erf_layer"><code>erf_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.erf_layer"><code>erf_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.erf_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def erf_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.erfc">
    <p>def <span class="ident">erfc</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.erfc</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.erfc"><code>erfc</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.erfc"><code>erfc</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.erfc</code></strong></p>
<div class="codehilite"><pre><span></span>    def erfc(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.erfc_layer">
    <p>def <span class="ident">erfc_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.erfc_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.erfc_layer"><code>erfc_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.erfc_layer"><code>erfc_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.erfc_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def erfc_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.erosion2d">
    <p>def <span class="ident">erosion2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.erosion2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.erosion2d"><code>erosion2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.erosion2d"><code>erosion2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.erosion2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def erosion2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.erosion2d_layer">
    <p>def <span class="ident">erosion2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.erosion2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.erosion2d_layer"><code>erosion2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.erosion2d_layer"><code>erosion2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.erosion2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def erosion2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.exp">
    <p>def <span class="ident">exp</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.exp</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.exp"><code>exp</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.exp"><code>exp</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.exp</code></strong></p>
<div class="codehilite"><pre><span></span>    def exp(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.exp_layer">
    <p>def <span class="ident">exp_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.exp_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.exp_layer"><code>exp_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.exp_layer"><code>exp_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.exp_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def exp_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.expand_dims">
    <p>def <span class="ident">expand_dims</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.expand_dims</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.expand_dims"><code>expand_dims</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.expand_dims"><code>expand_dims</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.expand_dims</code></strong></p>
<div class="codehilite"><pre><span></span>    def expand_dims(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.expand_dims_layer">
    <p>def <span class="ident">expand_dims_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.expand_dims_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.expand_dims_layer"><code>expand_dims_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.expand_dims_layer"><code>expand_dims_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.expand_dims_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def expand_dims_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.extract">
    <p>def <span class="ident">extract</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.extract</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.extract"><code>extract</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.extract"><code>extract</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.extract</code></strong></p>
<div class="codehilite"><pre><span></span>    def extract(tree, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.extract_image_patches">
    <p>def <span class="ident">extract_image_patches</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.extract_image_patches</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.extract_image_patches"><code>extract_image_patches</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.extract_image_patches"><code>extract_image_patches</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.extract_image_patches</code></strong></p>
<div class="codehilite"><pre><span></span>    def extract_image_patches(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.extract_image_patches_layer">
    <p>def <span class="ident">extract_image_patches_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.extract_image_patches_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.extract_image_patches_layer"><code>extract_image_patches_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.extract_image_patches_layer"><code>extract_image_patches_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.extract_image_patches_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def extract_image_patches_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fft">
    <p>def <span class="ident">fft</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.fft</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fft"><code>fft</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fft"><code>fft</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.fft</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fft2d">
    <p>def <span class="ident">fft2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.fft2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fft2d"><code>fft2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fft2d"><code>fft2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.fft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fft2d_layer">
    <p>def <span class="ident">fft2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.fft2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fft2d_layer"><code>fft2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fft2d_layer"><code>fft2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.fft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fft3d">
    <p>def <span class="ident">fft3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.fft3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fft3d"><code>fft3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fft3d"><code>fft3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.fft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fft3d_layer">
    <p>def <span class="ident">fft3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.fft3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fft3d_layer"><code>fft3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fft3d_layer"><code>fft3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.fft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fft_layer">
    <p>def <span class="ident">fft_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.fft_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fft_layer"><code>fft_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fft_layer"><code>fft_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.fft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fill">
    <p>def <span class="ident">fill</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.fill</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fill"><code>fill</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fill"><code>fill</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.fill</code></strong></p>
<div class="codehilite"><pre><span></span>    def fill(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fill_layer">
    <p>def <span class="ident">fill_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.fill_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fill_layer"><code>fill_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fill_layer"><code>fill_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.fill_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fill_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fixed_unigram_candidate_sampler">
    <p>def <span class="ident">fixed_unigram_candidate_sampler</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.fixed_unigram_candidate_sampler</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fixed_unigram_candidate_sampler"><code>fixed_unigram_candidate_sampler</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fixed_unigram_candidate_sampler"><code>fixed_unigram_candidate_sampler</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.fixed_unigram_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def fixed_unigram_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fixed_unigram_candidate_sampler_layer">
    <p>def <span class="ident">fixed_unigram_candidate_sampler_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.fixed_unigram_candidate_sampler_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fixed_unigram_candidate_sampler_layer"><code>fixed_unigram_candidate_sampler_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fixed_unigram_candidate_sampler_layer"><code>fixed_unigram_candidate_sampler_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.fixed_unigram_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def fixed_unigram_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.floor">
    <p>def <span class="ident">floor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.floor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.floor"><code>floor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.floor"><code>floor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.floor</code></strong></p>
<div class="codehilite"><pre><span></span>    def floor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.floor_layer">
    <p>def <span class="ident">floor_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.floor_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.floor_layer"><code>floor_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.floor_layer"><code>floor_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.floor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def floor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.floordiv">
    <p>def <span class="ident">floordiv</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.floordiv</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.floordiv"><code>floordiv</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.floordiv"><code>floordiv</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.floordiv</code></strong></p>
<div class="codehilite"><pre><span></span>    def floordiv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.floordiv_layer">
    <p>def <span class="ident">floordiv_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.floordiv_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.floordiv_layer"><code>floordiv_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.floordiv_layer"><code>floordiv_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.floordiv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def floordiv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.foldl">
    <p>def <span class="ident">foldl</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.foldl</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.foldl"><code>foldl</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.foldl"><code>foldl</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.foldl</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldl(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.foldl_layer">
    <p>def <span class="ident">foldl_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.foldl_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.foldl_layer"><code>foldl_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.foldl_layer"><code>foldl_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.foldl_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldl_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.foldr">
    <p>def <span class="ident">foldr</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.foldr</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.foldr"><code>foldr</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.foldr"><code>foldr</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.foldr</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldr(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.foldr_layer">
    <p>def <span class="ident">foldr_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.foldr_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.foldr_layer"><code>foldr_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.foldr_layer"><code>foldr_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.foldr_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def foldr_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.fully_connected">
    <p>def <span class="ident">fully_connected</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.fully_connected</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.fully_connected"><code>fully_connected</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.fully_connected"><code>fully_connected</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.fully_connected</code></strong></p>
<div class="codehilite"><pre><span></span>    def fully_connected(tree, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.gather">
    <p>def <span class="ident">gather</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.gather</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.gather"><code>gather</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.gather"><code>gather</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.gather</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.gather_layer">
    <p>def <span class="ident">gather_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.gather_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.gather_layer"><code>gather_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.gather_layer"><code>gather_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.gather_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.gather_nd">
    <p>def <span class="ident">gather_nd</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.gather_nd</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.gather_nd"><code>gather_nd</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.gather_nd"><code>gather_nd</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.gather_nd</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather_nd(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.gather_nd_layer">
    <p>def <span class="ident">gather_nd_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.gather_nd_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.gather_nd_layer"><code>gather_nd_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.gather_nd_layer"><code>gather_nd_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.gather_nd_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def gather_nd_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_collection">
    <p>def <span class="ident">get_collection</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_collection</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_collection"><code>get_collection</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_collection"><code>get_collection</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_collection</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_collection_layer">
    <p>def <span class="ident">get_collection_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_collection_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_collection_layer"><code>get_collection_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_collection_layer"><code>get_collection_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_collection_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_collection_ref">
    <p>def <span class="ident">get_collection_ref</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_collection_ref</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_collection_ref"><code>get_collection_ref</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_collection_ref"><code>get_collection_ref</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_collection_ref</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection_ref(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_collection_ref_layer">
    <p>def <span class="ident">get_collection_ref_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_collection_ref_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_collection_ref_layer"><code>get_collection_ref_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_collection_ref_layer"><code>get_collection_ref_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_collection_ref_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_collection_ref_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_default_graph">
    <p>def <span class="ident">get_default_graph</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_default_graph</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_default_graph"><code>get_default_graph</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_default_graph"><code>get_default_graph</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_default_graph</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_graph(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_default_graph_layer">
    <p>def <span class="ident">get_default_graph_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_default_graph_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_default_graph_layer"><code>get_default_graph_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_default_graph_layer"><code>get_default_graph_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_default_graph_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_graph_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_default_session">
    <p>def <span class="ident">get_default_session</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_default_session</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_default_session"><code>get_default_session</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_default_session"><code>get_default_session</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_default_session</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_session(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_default_session_layer">
    <p>def <span class="ident">get_default_session_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_default_session_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_default_session_layer"><code>get_default_session_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_default_session_layer"><code>get_default_session_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_default_session_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_default_session_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_seed">
    <p>def <span class="ident">get_seed</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_seed</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_seed"><code>get_seed</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_seed"><code>get_seed</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_seed</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_seed(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_seed_layer">
    <p>def <span class="ident">get_seed_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_seed_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_seed_layer"><code>get_seed_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_seed_layer"><code>get_seed_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_seed_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_seed_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_session_handle">
    <p>def <span class="ident">get_session_handle</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_session_handle</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_session_handle"><code>get_session_handle</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_session_handle"><code>get_session_handle</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_session_handle</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_handle(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_session_handle_layer">
    <p>def <span class="ident">get_session_handle_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_session_handle_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_session_handle_layer"><code>get_session_handle_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_session_handle_layer"><code>get_session_handle_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_session_handle_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_handle_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_session_tensor">
    <p>def <span class="ident">get_session_tensor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_session_tensor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_session_tensor"><code>get_session_tensor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_session_tensor"><code>get_session_tensor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_session_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_session_tensor_layer">
    <p>def <span class="ident">get_session_tensor_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_session_tensor_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_session_tensor_layer"><code>get_session_tensor_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_session_tensor_layer"><code>get_session_tensor_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_session_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_session_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_variable">
    <p>def <span class="ident">get_variable</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_variable</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_variable"><code>get_variable</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_variable"><code>get_variable</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_variable</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_variable_layer">
    <p>def <span class="ident">get_variable_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_variable_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_variable_layer"><code>get_variable_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_variable_layer"><code>get_variable_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_variable_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_variable_scope">
    <p>def <span class="ident">get_variable_scope</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.get_variable_scope</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_variable_scope"><code>get_variable_scope</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_variable_scope"><code>get_variable_scope</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.get_variable_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.get_variable_scope_layer">
    <p>def <span class="ident">get_variable_scope_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.get_variable_scope_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.get_variable_scope_layer"><code>get_variable_scope_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.get_variable_scope_layer"><code>get_variable_scope_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.get_variable_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def get_variable_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.global_norm">
    <p>def <span class="ident">global_norm</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.global_norm</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.global_norm"><code>global_norm</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.global_norm"><code>global_norm</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.global_norm</code></strong></p>
<div class="codehilite"><pre><span></span>    def global_norm(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.global_norm_layer">
    <p>def <span class="ident">global_norm_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.global_norm_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.global_norm_layer"><code>global_norm_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.global_norm_layer"><code>global_norm_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.global_norm_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def global_norm_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.gradients">
    <p>def <span class="ident">gradients</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.gradients</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.gradients"><code>gradients</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.gradients"><code>gradients</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.gradients</code></strong></p>
<div class="codehilite"><pre><span></span>    def gradients(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.gradients_layer">
    <p>def <span class="ident">gradients_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.gradients_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.gradients_layer"><code>gradients_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.gradients_layer"><code>gradients_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.gradients_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def gradients_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.greater">
    <p>def <span class="ident">greater</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.greater</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.greater"><code>greater</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.greater"><code>greater</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.greater</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.greater_equal">
    <p>def <span class="ident">greater_equal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.greater_equal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.greater_equal"><code>greater_equal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.greater_equal"><code>greater_equal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.greater_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.greater_equal_layer">
    <p>def <span class="ident">greater_equal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.greater_equal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.greater_equal_layer"><code>greater_equal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.greater_equal_layer"><code>greater_equal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.greater_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.greater_layer">
    <p>def <span class="ident">greater_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.greater_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.greater_layer"><code>greater_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.greater_layer"><code>greater_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.greater_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def greater_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.group">
    <p>def <span class="ident">group</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.group</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.group"><code>group</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.group"><code>group</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.group</code></strong></p>
<div class="codehilite"><pre><span></span>    def group(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.group_layer">
    <p>def <span class="ident">group_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.group_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.group_layer"><code>group_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.group_layer"><code>group_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.group_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def group_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.histogram_fixed_width">
    <p>def <span class="ident">histogram_fixed_width</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.histogram_fixed_width</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.histogram_fixed_width"><code>histogram_fixed_width</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.histogram_fixed_width"><code>histogram_fixed_width</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.histogram_fixed_width</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_fixed_width(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.histogram_fixed_width_layer">
    <p>def <span class="ident">histogram_fixed_width_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.histogram_fixed_width_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.histogram_fixed_width_layer"><code>histogram_fixed_width_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.histogram_fixed_width_layer"><code>histogram_fixed_width_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.histogram_fixed_width_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_fixed_width_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.histogram_summary">
    <p>def <span class="ident">histogram_summary</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.histogram_summary</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.histogram_summary"><code>histogram_summary</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.histogram_summary"><code>histogram_summary</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.histogram_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.histogram_summary_layer">
    <p>def <span class="ident">histogram_summary_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.histogram_summary_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.histogram_summary_layer"><code>histogram_summary_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.histogram_summary_layer"><code>histogram_summary_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.histogram_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def histogram_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.identity">
    <p>def <span class="ident">identity</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.identity</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.identity"><code>identity</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.identity"><code>identity</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.identity</code></strong></p>
<div class="codehilite"><pre><span></span>    def identity(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.identity_layer">
    <p>def <span class="ident">identity_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.identity_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.identity_layer"><code>identity_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.identity_layer"><code>identity_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.identity_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def identity_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ifft">
    <p>def <span class="ident">ifft</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ifft</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ifft"><code>ifft</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ifft"><code>ifft</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ifft</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ifft2d">
    <p>def <span class="ident">ifft2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ifft2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ifft2d"><code>ifft2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ifft2d"><code>ifft2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ifft2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ifft2d_layer">
    <p>def <span class="ident">ifft2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ifft2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ifft2d_layer"><code>ifft2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ifft2d_layer"><code>ifft2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ifft2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ifft3d">
    <p>def <span class="ident">ifft3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ifft3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ifft3d"><code>ifft3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ifft3d"><code>ifft3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ifft3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ifft3d_layer">
    <p>def <span class="ident">ifft3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ifft3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ifft3d_layer"><code>ifft3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ifft3d_layer"><code>ifft3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ifft3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ifft_layer">
    <p>def <span class="ident">ifft_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ifft_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ifft_layer"><code>ifft_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ifft_layer"><code>ifft_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ifft_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ifft_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.igamma">
    <p>def <span class="ident">igamma</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.igamma</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.igamma"><code>igamma</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.igamma"><code>igamma</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.igamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def igamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.igamma_layer">
    <p>def <span class="ident">igamma_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.igamma_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.igamma_layer"><code>igamma_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.igamma_layer"><code>igamma_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.igamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def igamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.igammac">
    <p>def <span class="ident">igammac</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.igammac</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.igammac"><code>igammac</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.igammac"><code>igammac</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.igammac</code></strong></p>
<div class="codehilite"><pre><span></span>    def igammac(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.igammac_layer">
    <p>def <span class="ident">igammac_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.igammac_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.igammac_layer"><code>igammac_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.igammac_layer"><code>igammac_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.igammac_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def igammac_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.imag">
    <p>def <span class="ident">imag</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.imag</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.imag"><code>imag</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.imag"><code>imag</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.imag</code></strong></p>
<div class="codehilite"><pre><span></span>    def imag(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.imag_layer">
    <p>def <span class="ident">imag_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.imag_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.imag_layer"><code>imag_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.imag_layer"><code>imag_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.imag_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def imag_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.image_summary">
    <p>def <span class="ident">image_summary</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.image_summary</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.image_summary"><code>image_summary</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.image_summary"><code>image_summary</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.image_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def image_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.image_summary_layer">
    <p>def <span class="ident">image_summary_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.image_summary_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.image_summary_layer"><code>image_summary_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.image_summary_layer"><code>image_summary_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.image_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def image_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.import_graph_def">
    <p>def <span class="ident">import_graph_def</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.import_graph_def</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.import_graph_def"><code>import_graph_def</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.import_graph_def"><code>import_graph_def</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.import_graph_def</code></strong></p>
<div class="codehilite"><pre><span></span>    def import_graph_def(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.import_graph_def_layer">
    <p>def <span class="ident">import_graph_def_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.import_graph_def_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.import_graph_def_layer"><code>import_graph_def_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.import_graph_def_layer"><code>import_graph_def_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.import_graph_def_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def import_graph_def_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.in_top_k">
    <p>def <span class="ident">in_top_k</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.in_top_k</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.in_top_k"><code>in_top_k</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.in_top_k"><code>in_top_k</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.in_top_k</code></strong></p>
<div class="codehilite"><pre><span></span>    def in_top_k(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.in_top_k_layer">
    <p>def <span class="ident">in_top_k_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.in_top_k_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.in_top_k_layer"><code>in_top_k_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.in_top_k_layer"><code>in_top_k_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.in_top_k_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def in_top_k_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_all_tables">
    <p>def <span class="ident">initialize_all_tables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.initialize_all_tables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_all_tables"><code>initialize_all_tables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_all_tables"><code>initialize_all_tables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.initialize_all_tables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_tables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_all_tables_layer">
    <p>def <span class="ident">initialize_all_tables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.initialize_all_tables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_all_tables_layer"><code>initialize_all_tables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_all_tables_layer"><code>initialize_all_tables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.initialize_all_tables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_tables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_all_variables">
    <p>def <span class="ident">initialize_all_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.initialize_all_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_all_variables"><code>initialize_all_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_all_variables"><code>initialize_all_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.initialize_all_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_all_variables_layer">
    <p>def <span class="ident">initialize_all_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.initialize_all_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_all_variables_layer"><code>initialize_all_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_all_variables_layer"><code>initialize_all_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.initialize_all_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_all_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_local_variables">
    <p>def <span class="ident">initialize_local_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.initialize_local_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_local_variables"><code>initialize_local_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_local_variables"><code>initialize_local_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.initialize_local_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_local_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_local_variables_layer">
    <p>def <span class="ident">initialize_local_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.initialize_local_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_local_variables_layer"><code>initialize_local_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_local_variables_layer"><code>initialize_local_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.initialize_local_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_local_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_variables">
    <p>def <span class="ident">initialize_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.initialize_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_variables"><code>initialize_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_variables"><code>initialize_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.initialize_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.initialize_variables_layer">
    <p>def <span class="ident">initialize_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.initialize_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.initialize_variables_layer"><code>initialize_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.initialize_variables_layer"><code>initialize_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.initialize_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def initialize_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.inv">
    <p>def <span class="ident">inv</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.inv</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.inv"><code>inv</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.inv"><code>inv</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.inv</code></strong></p>
<div class="codehilite"><pre><span></span>    def inv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.inv_layer">
    <p>def <span class="ident">inv_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.inv_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.inv_layer"><code>inv_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.inv_layer"><code>inv_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.inv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def inv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.invert_permutation">
    <p>def <span class="ident">invert_permutation</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.invert_permutation</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.invert_permutation"><code>invert_permutation</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.invert_permutation"><code>invert_permutation</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.invert_permutation</code></strong></p>
<div class="codehilite"><pre><span></span>    def invert_permutation(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.invert_permutation_layer">
    <p>def <span class="ident">invert_permutation_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.invert_permutation_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.invert_permutation_layer"><code>invert_permutation_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.invert_permutation_layer"><code>invert_permutation_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.invert_permutation_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def invert_permutation_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_finite">
    <p>def <span class="ident">is_finite</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_finite</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_finite"><code>is_finite</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_finite"><code>is_finite</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_finite</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_finite(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_finite_layer">
    <p>def <span class="ident">is_finite_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_finite_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_finite_layer"><code>is_finite_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_finite_layer"><code>is_finite_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_finite_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_finite_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_inf">
    <p>def <span class="ident">is_inf</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_inf</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_inf"><code>is_inf</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_inf"><code>is_inf</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_inf</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_inf(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_inf_layer">
    <p>def <span class="ident">is_inf_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_inf_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_inf_layer"><code>is_inf_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_inf_layer"><code>is_inf_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_inf_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_inf_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_nan">
    <p>def <span class="ident">is_nan</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_nan</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_nan"><code>is_nan</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_nan"><code>is_nan</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_nan</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_nan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_nan_layer">
    <p>def <span class="ident">is_nan_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_nan_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_nan_layer"><code>is_nan_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_nan_layer"><code>is_nan_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_nan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_nan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_non_decreasing">
    <p>def <span class="ident">is_non_decreasing</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_non_decreasing</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_non_decreasing"><code>is_non_decreasing</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_non_decreasing"><code>is_non_decreasing</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_non_decreasing</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_non_decreasing(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_non_decreasing_layer">
    <p>def <span class="ident">is_non_decreasing_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_non_decreasing_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_non_decreasing_layer"><code>is_non_decreasing_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_non_decreasing_layer"><code>is_non_decreasing_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_non_decreasing_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_non_decreasing_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_numeric_tensor">
    <p>def <span class="ident">is_numeric_tensor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_numeric_tensor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_numeric_tensor"><code>is_numeric_tensor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_numeric_tensor"><code>is_numeric_tensor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_numeric_tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_numeric_tensor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_numeric_tensor_layer">
    <p>def <span class="ident">is_numeric_tensor_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_numeric_tensor_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_numeric_tensor_layer"><code>is_numeric_tensor_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_numeric_tensor_layer"><code>is_numeric_tensor_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_numeric_tensor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_numeric_tensor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_strictly_increasing">
    <p>def <span class="ident">is_strictly_increasing</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_strictly_increasing</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_strictly_increasing"><code>is_strictly_increasing</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_strictly_increasing"><code>is_strictly_increasing</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_strictly_increasing</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_strictly_increasing(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_strictly_increasing_layer">
    <p>def <span class="ident">is_strictly_increasing_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_strictly_increasing_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_strictly_increasing_layer"><code>is_strictly_increasing_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_strictly_increasing_layer"><code>is_strictly_increasing_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_strictly_increasing_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_strictly_increasing_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_variable_initialized">
    <p>def <span class="ident">is_variable_initialized</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.is_variable_initialized</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_variable_initialized"><code>is_variable_initialized</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_variable_initialized"><code>is_variable_initialized</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.is_variable_initialized</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_variable_initialized(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.is_variable_initialized_layer">
    <p>def <span class="ident">is_variable_initialized_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.is_variable_initialized_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.is_variable_initialized_layer"><code>is_variable_initialized_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.is_variable_initialized_layer"><code>is_variable_initialized_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.is_variable_initialized_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def is_variable_initialized_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.l2_loss">
    <p>def <span class="ident">l2_loss</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.l2_loss</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.l2_loss"><code>l2_loss</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.l2_loss"><code>l2_loss</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.l2_loss</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_loss(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.l2_loss_layer">
    <p>def <span class="ident">l2_loss_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.l2_loss_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.l2_loss_layer"><code>l2_loss_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.l2_loss_layer"><code>l2_loss_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.l2_loss_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_loss_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.l2_normalize">
    <p>def <span class="ident">l2_normalize</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.l2_normalize</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.l2_normalize"><code>l2_normalize</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.l2_normalize"><code>l2_normalize</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.l2_normalize</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_normalize(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.l2_normalize_layer">
    <p>def <span class="ident">l2_normalize_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.l2_normalize_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.l2_normalize_layer"><code>l2_normalize_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.l2_normalize_layer"><code>l2_normalize_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.l2_normalize_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def l2_normalize_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lbeta">
    <p>def <span class="ident">lbeta</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.lbeta</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lbeta"><code>lbeta</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lbeta"><code>lbeta</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.lbeta</code></strong></p>
<div class="codehilite"><pre><span></span>    def lbeta(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lbeta_layer">
    <p>def <span class="ident">lbeta_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.lbeta_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lbeta_layer"><code>lbeta_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lbeta_layer"><code>lbeta_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.lbeta_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lbeta_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.learned_unigram_candidate_sampler">
    <p>def <span class="ident">learned_unigram_candidate_sampler</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.learned_unigram_candidate_sampler</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.learned_unigram_candidate_sampler"><code>learned_unigram_candidate_sampler</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.learned_unigram_candidate_sampler"><code>learned_unigram_candidate_sampler</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.learned_unigram_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def learned_unigram_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.learned_unigram_candidate_sampler_layer">
    <p>def <span class="ident">learned_unigram_candidate_sampler_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.learned_unigram_candidate_sampler_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.learned_unigram_candidate_sampler_layer"><code>learned_unigram_candidate_sampler_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.learned_unigram_candidate_sampler_layer"><code>learned_unigram_candidate_sampler_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.learned_unigram_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def learned_unigram_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.less">
    <p>def <span class="ident">less</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.less</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.less"><code>less</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.less"><code>less</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.less</code></strong></p>
<div class="codehilite"><pre><span></span>    def less(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.less_equal">
    <p>def <span class="ident">less_equal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.less_equal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.less_equal"><code>less_equal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.less_equal"><code>less_equal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.less_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def less_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.less_equal_layer">
    <p>def <span class="ident">less_equal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.less_equal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.less_equal_layer"><code>less_equal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.less_equal_layer"><code>less_equal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.less_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def less_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.less_layer">
    <p>def <span class="ident">less_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.less_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.less_layer"><code>less_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.less_layer"><code>less_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.less_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def less_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lgamma">
    <p>def <span class="ident">lgamma</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.lgamma</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lgamma"><code>lgamma</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lgamma"><code>lgamma</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.lgamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def lgamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lgamma_layer">
    <p>def <span class="ident">lgamma_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.lgamma_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lgamma_layer"><code>lgamma_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lgamma_layer"><code>lgamma_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.lgamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lgamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lin_space">
    <p>def <span class="ident">lin_space</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.lin_space</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lin_space"><code>lin_space</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lin_space"><code>lin_space</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.lin_space</code></strong></p>
<div class="codehilite"><pre><span></span>    def lin_space(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lin_space_layer">
    <p>def <span class="ident">lin_space_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.lin_space_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lin_space_layer"><code>lin_space_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lin_space_layer"><code>lin_space_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.lin_space_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lin_space_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.linspace_layer">
    <p>def <span class="ident">linspace_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.linspace_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.linspace_layer"><code>linspace_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.linspace_layer"><code>linspace_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.linspace_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def linspace_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.list_diff">
    <p>def <span class="ident">list_diff</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.list_diff</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.list_diff"><code>list_diff</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.list_diff"><code>list_diff</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.list_diff</code></strong></p>
<div class="codehilite"><pre><span></span>    def list_diff(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.list_diff_layer">
    <p>def <span class="ident">list_diff_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.list_diff_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.list_diff_layer"><code>list_diff_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.list_diff_layer"><code>list_diff_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.list_diff_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def list_diff_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.listdiff_layer">
    <p>def <span class="ident">listdiff_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.listdiff_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.listdiff_layer"><code>listdiff_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.listdiff_layer"><code>listdiff_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.listdiff_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def listdiff_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.load_file_system_library">
    <p>def <span class="ident">load_file_system_library</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.load_file_system_library</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.load_file_system_library"><code>load_file_system_library</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.load_file_system_library"><code>load_file_system_library</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.load_file_system_library</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_file_system_library(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.load_file_system_library_layer">
    <p>def <span class="ident">load_file_system_library_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.load_file_system_library_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.load_file_system_library_layer"><code>load_file_system_library_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.load_file_system_library_layer"><code>load_file_system_library_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.load_file_system_library_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_file_system_library_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.load_op_library">
    <p>def <span class="ident">load_op_library</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.load_op_library</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.load_op_library"><code>load_op_library</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.load_op_library"><code>load_op_library</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.load_op_library</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_op_library(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.load_op_library_layer">
    <p>def <span class="ident">load_op_library_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.load_op_library_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.load_op_library_layer"><code>load_op_library_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.load_op_library_layer"><code>load_op_library_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.load_op_library_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def load_op_library_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.local_response_normalization_layer">
    <p>def <span class="ident">local_response_normalization_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.local_response_normalization_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.local_response_normalization_layer"><code>local_response_normalization_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.local_response_normalization_layer"><code>local_response_normalization_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.local_response_normalization_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def local_response_normalization_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.local_variables">
    <p>def <span class="ident">local_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.local_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.local_variables"><code>local_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.local_variables"><code>local_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.local_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def local_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.local_variables_layer">
    <p>def <span class="ident">local_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.local_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.local_variables_layer"><code>local_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.local_variables_layer"><code>local_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.local_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def local_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.log">
    <p>def <span class="ident">log</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.log</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.log"><code>log</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.log"><code>log</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.log</code></strong></p>
<div class="codehilite"><pre><span></span>    def log(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.log_layer">
    <p>def <span class="ident">log_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.log_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.log_layer"><code>log_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.log_layer"><code>log_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.log_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.log_softmax">
    <p>def <span class="ident">log_softmax</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.log_softmax</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.log_softmax"><code>log_softmax</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.log_softmax"><code>log_softmax</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.log_softmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_softmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.log_softmax_layer">
    <p>def <span class="ident">log_softmax_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.log_softmax_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.log_softmax_layer"><code>log_softmax_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.log_softmax_layer"><code>log_softmax_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.log_softmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_softmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.log_uniform_candidate_sampler">
    <p>def <span class="ident">log_uniform_candidate_sampler</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.log_uniform_candidate_sampler</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.log_uniform_candidate_sampler"><code>log_uniform_candidate_sampler</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.log_uniform_candidate_sampler"><code>log_uniform_candidate_sampler</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.log_uniform_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_uniform_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.log_uniform_candidate_sampler_layer">
    <p>def <span class="ident">log_uniform_candidate_sampler_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.log_uniform_candidate_sampler_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.log_uniform_candidate_sampler_layer"><code>log_uniform_candidate_sampler_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.log_uniform_candidate_sampler_layer"><code>log_uniform_candidate_sampler_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.log_uniform_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def log_uniform_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_and">
    <p>def <span class="ident">logical_and</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.logical_and</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_and"><code>logical_and</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_and"><code>logical_and</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.logical_and</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_and(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_and_layer">
    <p>def <span class="ident">logical_and_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.logical_and_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_and_layer"><code>logical_and_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_and_layer"><code>logical_and_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.logical_and_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_and_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_not">
    <p>def <span class="ident">logical_not</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.logical_not</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_not"><code>logical_not</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_not"><code>logical_not</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.logical_not</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_not(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_not_layer">
    <p>def <span class="ident">logical_not_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.logical_not_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_not_layer"><code>logical_not_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_not_layer"><code>logical_not_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.logical_not_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_not_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_or">
    <p>def <span class="ident">logical_or</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.logical_or</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_or"><code>logical_or</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_or"><code>logical_or</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.logical_or</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_or(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_or_layer">
    <p>def <span class="ident">logical_or_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.logical_or_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_or_layer"><code>logical_or_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_or_layer"><code>logical_or_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.logical_or_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_or_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_xor">
    <p>def <span class="ident">logical_xor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.logical_xor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_xor"><code>logical_xor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_xor"><code>logical_xor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.logical_xor</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_xor(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.logical_xor_layer">
    <p>def <span class="ident">logical_xor_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.logical_xor_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.logical_xor_layer"><code>logical_xor_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.logical_xor_layer"><code>logical_xor_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.logical_xor_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def logical_xor_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lrn">
    <p>def <span class="ident">lrn</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.lrn</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lrn"><code>lrn</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lrn"><code>lrn</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.lrn</code></strong></p>
<div class="codehilite"><pre><span></span>    def lrn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.lrn_layer">
    <p>def <span class="ident">lrn_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.lrn_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.lrn_layer"><code>lrn_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.lrn_layer"><code>lrn_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.lrn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def lrn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.make_all">
    <p>def <span class="ident">make_all</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.make_all</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.make_all"><code>make_all</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.make_all"><code>make_all</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.make_all</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_all(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.make_all_layer">
    <p>def <span class="ident">make_all_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.make_all_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.make_all_layer"><code>make_all_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.make_all_layer"><code>make_all_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.make_all_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_all_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.make_template">
    <p>def <span class="ident">make_template</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.make_template</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.make_template"><code>make_template</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.make_template"><code>make_template</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.make_template</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_template(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.make_template_layer">
    <p>def <span class="ident">make_template_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.make_template_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.make_template_layer"><code>make_template_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.make_template_layer"><code>make_template_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.make_template_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def make_template_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.map">
    <p>def <span class="ident">map</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.map</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.map"><code>map</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.map"><code>map</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.map</code></strong></p>
<div class="codehilite"><pre><span></span>    def map(builder, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.map_each">
    <p>def <span class="ident">map_each</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.map_each</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.map_each"><code>map_each</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.map_each"><code>map_each</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.map_each</code></strong></p>
<div class="codehilite"><pre><span></span>    def map_each(tree, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.map_fn">
    <p>def <span class="ident">map_fn</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.map_fn</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.map_fn"><code>map_fn</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.map_fn"><code>map_fn</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.map_fn</code></strong></p>
<div class="codehilite"><pre><span></span>    def map_fn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.map_fn_layer">
    <p>def <span class="ident">map_fn_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.map_fn_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.map_fn_layer"><code>map_fn_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.map_fn_layer"><code>map_fn_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.map_fn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def map_fn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matching_files">
    <p>def <span class="ident">matching_files</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matching_files</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matching_files"><code>matching_files</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matching_files"><code>matching_files</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matching_files</code></strong></p>
<div class="codehilite"><pre><span></span>    def matching_files(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matching_files_layer">
    <p>def <span class="ident">matching_files_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matching_files_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matching_files_layer"><code>matching_files_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matching_files_layer"><code>matching_files_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matching_files_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matching_files_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matmul">
    <p>def <span class="ident">matmul</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matmul</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matmul"><code>matmul</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matmul"><code>matmul</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matmul</code></strong></p>
<div class="codehilite"><pre><span></span>    def matmul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matmul_layer">
    <p>def <span class="ident">matmul_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matmul_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matmul_layer"><code>matmul_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matmul_layer"><code>matmul_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_determinant">
    <p>def <span class="ident">matrix_determinant</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matrix_determinant</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_determinant"><code>matrix_determinant</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_determinant"><code>matrix_determinant</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matrix_determinant</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_determinant(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_determinant_layer">
    <p>def <span class="ident">matrix_determinant_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matrix_determinant_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_determinant_layer"><code>matrix_determinant_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_determinant_layer"><code>matrix_determinant_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matrix_determinant_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_determinant_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_inverse">
    <p>def <span class="ident">matrix_inverse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matrix_inverse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_inverse"><code>matrix_inverse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_inverse"><code>matrix_inverse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matrix_inverse</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_inverse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_inverse_layer">
    <p>def <span class="ident">matrix_inverse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matrix_inverse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_inverse_layer"><code>matrix_inverse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_inverse_layer"><code>matrix_inverse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matrix_inverse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_inverse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_solve">
    <p>def <span class="ident">matrix_solve</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matrix_solve</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_solve"><code>matrix_solve</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_solve"><code>matrix_solve</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matrix_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_solve_layer">
    <p>def <span class="ident">matrix_solve_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matrix_solve_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_solve_layer"><code>matrix_solve_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_solve_layer"><code>matrix_solve_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matrix_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_solve_ls">
    <p>def <span class="ident">matrix_solve_ls</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matrix_solve_ls</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_solve_ls"><code>matrix_solve_ls</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_solve_ls"><code>matrix_solve_ls</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matrix_solve_ls</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve_ls(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_solve_ls_layer">
    <p>def <span class="ident">matrix_solve_ls_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matrix_solve_ls_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_solve_ls_layer"><code>matrix_solve_ls_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_solve_ls_layer"><code>matrix_solve_ls_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matrix_solve_ls_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_solve_ls_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_triangular_solve">
    <p>def <span class="ident">matrix_triangular_solve</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.matrix_triangular_solve</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_triangular_solve"><code>matrix_triangular_solve</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_triangular_solve"><code>matrix_triangular_solve</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.matrix_triangular_solve</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_triangular_solve(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.matrix_triangular_solve_layer">
    <p>def <span class="ident">matrix_triangular_solve_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.matrix_triangular_solve_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.matrix_triangular_solve_layer"><code>matrix_triangular_solve_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.matrix_triangular_solve_layer"><code>matrix_triangular_solve_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.matrix_triangular_solve_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def matrix_triangular_solve_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool">
    <p>def <span class="ident">max_pool</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.max_pool</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool"><code>max_pool</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool"><code>max_pool</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.max_pool</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool3d">
    <p>def <span class="ident">max_pool3d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.max_pool3d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool3d"><code>max_pool3d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool3d"><code>max_pool3d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.max_pool3d</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool3d_grad">
    <p>def <span class="ident">max_pool3d_grad</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.max_pool3d_grad</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool3d_grad"><code>max_pool3d_grad</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool3d_grad"><code>max_pool3d_grad</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.max_pool3d_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool3d_grad_layer">
    <p>def <span class="ident">max_pool3d_grad_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.max_pool3d_grad_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool3d_grad_layer"><code>max_pool3d_grad_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool3d_grad_layer"><code>max_pool3d_grad_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.max_pool3d_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool3d_layer">
    <p>def <span class="ident">max_pool3d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.max_pool3d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool3d_layer"><code>max_pool3d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool3d_layer"><code>max_pool3d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.max_pool3d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool3d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool_2d">
    <p>def <span class="ident">max_pool_2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.max_pool_2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool_2d"><code>max_pool_2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool_2d"><code>max_pool_2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.max_pool_2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool_layer">
    <p>def <span class="ident">max_pool_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.max_pool_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool_layer"><code>max_pool_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool_layer"><code>max_pool_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.max_pool_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool_with_argmax">
    <p>def <span class="ident">max_pool_with_argmax</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.max_pool_with_argmax</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool_with_argmax"><code>max_pool_with_argmax</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool_with_argmax"><code>max_pool_with_argmax</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.max_pool_with_argmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_with_argmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.max_pool_with_argmax_layer">
    <p>def <span class="ident">max_pool_with_argmax_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.max_pool_with_argmax_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.max_pool_with_argmax_layer"><code>max_pool_with_argmax_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.max_pool_with_argmax_layer"><code>max_pool_with_argmax_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.max_pool_with_argmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def max_pool_with_argmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.maximum">
    <p>def <span class="ident">maximum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.maximum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.maximum"><code>maximum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.maximum"><code>maximum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.maximum</code></strong></p>
<div class="codehilite"><pre><span></span>    def maximum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.maximum_layer">
    <p>def <span class="ident">maximum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.maximum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.maximum_layer"><code>maximum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.maximum_layer"><code>maximum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.maximum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def maximum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.merge_all_summaries">
    <p>def <span class="ident">merge_all_summaries</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.merge_all_summaries</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.merge_all_summaries"><code>merge_all_summaries</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.merge_all_summaries"><code>merge_all_summaries</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.merge_all_summaries</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_all_summaries(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.merge_all_summaries_layer">
    <p>def <span class="ident">merge_all_summaries_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.merge_all_summaries_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.merge_all_summaries_layer"><code>merge_all_summaries_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.merge_all_summaries_layer"><code>merge_all_summaries_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.merge_all_summaries_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_all_summaries_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.merge_summary">
    <p>def <span class="ident">merge_summary</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.merge_summary</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.merge_summary"><code>merge_summary</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.merge_summary"><code>merge_summary</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.merge_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.merge_summary_layer">
    <p>def <span class="ident">merge_summary_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.merge_summary_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.merge_summary_layer"><code>merge_summary_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.merge_summary_layer"><code>merge_summary_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.merge_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def merge_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.minimum">
    <p>def <span class="ident">minimum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.minimum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.minimum"><code>minimum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.minimum"><code>minimum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.minimum</code></strong></p>
<div class="codehilite"><pre><span></span>    def minimum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.minimum_layer">
    <p>def <span class="ident">minimum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.minimum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.minimum_layer"><code>minimum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.minimum_layer"><code>minimum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.minimum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def minimum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.mod">
    <p>def <span class="ident">mod</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.mod</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.mod"><code>mod</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.mod"><code>mod</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.mod</code></strong></p>
<div class="codehilite"><pre><span></span>    def mod(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.mod_layer">
    <p>def <span class="ident">mod_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.mod_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.mod_layer"><code>mod_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.mod_layer"><code>mod_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.mod_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def mod_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.moments">
    <p>def <span class="ident">moments</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.moments</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.moments"><code>moments</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.moments"><code>moments</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.moments</code></strong></p>
<div class="codehilite"><pre><span></span>    def moments(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.moments_layer">
    <p>def <span class="ident">moments_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.moments_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.moments_layer"><code>moments_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.moments_layer"><code>moments_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.moments_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def moments_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.moving_average_variables">
    <p>def <span class="ident">moving_average_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.moving_average_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.moving_average_variables"><code>moving_average_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.moving_average_variables"><code>moving_average_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.moving_average_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def moving_average_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.moving_average_variables_layer">
    <p>def <span class="ident">moving_average_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.moving_average_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.moving_average_variables_layer"><code>moving_average_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.moving_average_variables_layer"><code>moving_average_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.moving_average_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def moving_average_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.mul">
    <p>def <span class="ident">mul</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.mul</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.mul"><code>mul</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.mul"><code>mul</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.mul</code></strong></p>
<div class="codehilite"><pre><span></span>    def mul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.mul_layer">
    <p>def <span class="ident">mul_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.mul_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.mul_layer"><code>mul_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.mul_layer"><code>mul_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.mul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def mul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.multinomial">
    <p>def <span class="ident">multinomial</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.multinomial</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.multinomial"><code>multinomial</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.multinomial"><code>multinomial</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.multinomial</code></strong></p>
<div class="codehilite"><pre><span></span>    def multinomial(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.multinomial_layer">
    <p>def <span class="ident">multinomial_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.multinomial_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.multinomial_layer"><code>multinomial_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.multinomial_layer"><code>multinomial_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.multinomial_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def multinomial_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.name_scope">
    <p>def <span class="ident">name_scope</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.name_scope</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.name_scope"><code>name_scope</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.name_scope"><code>name_scope</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.name_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def name_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.name_scope_layer">
    <p>def <span class="ident">name_scope_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.name_scope_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.name_scope_layer"><code>name_scope_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.name_scope_layer"><code>name_scope_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.name_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def name_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.nce_loss">
    <p>def <span class="ident">nce_loss</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.nce_loss</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.nce_loss"><code>nce_loss</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.nce_loss"><code>nce_loss</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.nce_loss</code></strong></p>
<div class="codehilite"><pre><span></span>    def nce_loss(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.nce_loss_layer">
    <p>def <span class="ident">nce_loss_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.nce_loss_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.nce_loss_layer"><code>nce_loss_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.nce_loss_layer"><code>nce_loss_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.nce_loss_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def nce_loss_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.neg">
    <p>def <span class="ident">neg</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.neg</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.neg"><code>neg</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.neg"><code>neg</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.neg</code></strong></p>
<div class="codehilite"><pre><span></span>    def neg(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.neg_layer">
    <p>def <span class="ident">neg_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.neg_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.neg_layer"><code>neg_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.neg_layer"><code>neg_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.neg_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def neg_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.no_op">
    <p>def <span class="ident">no_op</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.no_op</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.no_op"><code>no_op</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.no_op"><code>no_op</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.no_op</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_op(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.no_op_layer">
    <p>def <span class="ident">no_op_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.no_op_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.no_op_layer"><code>no_op_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.no_op_layer"><code>no_op_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.no_op_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_op_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.no_regularizer">
    <p>def <span class="ident">no_regularizer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.no_regularizer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.no_regularizer"><code>no_regularizer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.no_regularizer"><code>no_regularizer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.no_regularizer</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_regularizer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.no_regularizer_layer">
    <p>def <span class="ident">no_regularizer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.no_regularizer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.no_regularizer_layer"><code>no_regularizer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.no_regularizer_layer"><code>no_regularizer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.no_regularizer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def no_regularizer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.normalize_moments">
    <p>def <span class="ident">normalize_moments</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.normalize_moments</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.normalize_moments"><code>normalize_moments</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.normalize_moments"><code>normalize_moments</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.normalize_moments</code></strong></p>
<div class="codehilite"><pre><span></span>    def normalize_moments(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.normalize_moments_layer">
    <p>def <span class="ident">normalize_moments_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.normalize_moments_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.normalize_moments_layer"><code>normalize_moments_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.normalize_moments_layer"><code>normalize_moments_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.normalize_moments_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def normalize_moments_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.not_equal">
    <p>def <span class="ident">not_equal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.not_equal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.not_equal"><code>not_equal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.not_equal"><code>not_equal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.not_equal</code></strong></p>
<div class="codehilite"><pre><span></span>    def not_equal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.not_equal_layer">
    <p>def <span class="ident">not_equal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.not_equal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.not_equal_layer"><code>not_equal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.not_equal_layer"><code>not_equal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.not_equal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def not_equal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.one_hot">
    <p>def <span class="ident">one_hot</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.one_hot</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.one_hot"><code>one_hot</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.one_hot"><code>one_hot</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.one_hot</code></strong></p>
<div class="codehilite"><pre><span></span>    def one_hot(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.one_hot_layer">
    <p>def <span class="ident">one_hot_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.one_hot_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.one_hot_layer"><code>one_hot_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.one_hot_layer"><code>one_hot_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.one_hot_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def one_hot_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ones">
    <p>def <span class="ident">ones</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ones</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ones"><code>ones</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ones"><code>ones</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ones</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ones_initializer">
    <p>def <span class="ident">ones_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ones_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ones_initializer"><code>ones_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ones_initializer"><code>ones_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ones_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ones_initializer_layer">
    <p>def <span class="ident">ones_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ones_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ones_initializer_layer"><code>ones_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ones_initializer_layer"><code>ones_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ones_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ones_layer">
    <p>def <span class="ident">ones_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ones_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ones_layer"><code>ones_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ones_layer"><code>ones_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ones_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ones_like">
    <p>def <span class="ident">ones_like</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.ones_like</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ones_like"><code>ones_like</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ones_like"><code>ones_like</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.ones_like</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_like(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.ones_like_layer">
    <p>def <span class="ident">ones_like_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.ones_like_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.ones_like_layer"><code>ones_like_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.ones_like_layer"><code>ones_like_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.ones_like_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def ones_like_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.op_scope">
    <p>def <span class="ident">op_scope</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.op_scope</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.op_scope"><code>op_scope</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.op_scope"><code>op_scope</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.op_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def op_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.op_scope_layer">
    <p>def <span class="ident">op_scope_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.op_scope_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.op_scope_layer"><code>op_scope_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.op_scope_layer"><code>op_scope_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.op_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def op_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.pack">
    <p>def <span class="ident">pack</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.pack</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.pack"><code>pack</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.pack"><code>pack</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.pack</code></strong></p>
<div class="codehilite"><pre><span></span>    def pack(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.pack_layer">
    <p>def <span class="ident">pack_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.pack_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.pack_layer"><code>pack_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.pack_layer"><code>pack_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.pack_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def pack_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.pad">
    <p>def <span class="ident">pad</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.pad</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.pad"><code>pad</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.pad"><code>pad</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.pad</code></strong></p>
<div class="codehilite"><pre><span></span>    def pad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.pad_layer">
    <p>def <span class="ident">pad_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.pad_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.pad_layer"><code>pad_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.pad_layer"><code>pad_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.pad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def pad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.parse_example">
    <p>def <span class="ident">parse_example</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.parse_example</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.parse_example"><code>parse_example</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.parse_example"><code>parse_example</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.parse_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.parse_example_layer">
    <p>def <span class="ident">parse_example_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.parse_example_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.parse_example_layer"><code>parse_example_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.parse_example_layer"><code>parse_example_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.parse_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.parse_single_example">
    <p>def <span class="ident">parse_single_example</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.parse_single_example</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.parse_single_example"><code>parse_single_example</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.parse_single_example"><code>parse_single_example</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.parse_single_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.parse_single_example_layer">
    <p>def <span class="ident">parse_single_example_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.parse_single_example_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.parse_single_example_layer"><code>parse_single_example_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.parse_single_example_layer"><code>parse_single_example_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.parse_single_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.parse_single_sequence_example">
    <p>def <span class="ident">parse_single_sequence_example</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.parse_single_sequence_example</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.parse_single_sequence_example"><code>parse_single_sequence_example</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.parse_single_sequence_example"><code>parse_single_sequence_example</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.parse_single_sequence_example</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_sequence_example(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.parse_single_sequence_example_layer">
    <p>def <span class="ident">parse_single_sequence_example_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.parse_single_sequence_example_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.parse_single_sequence_example_layer"><code>parse_single_sequence_example_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.parse_single_sequence_example_layer"><code>parse_single_sequence_example_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.parse_single_sequence_example_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def parse_single_sequence_example_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.placeholder">
    <p>def <span class="ident">placeholder</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.placeholder</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.placeholder"><code>placeholder</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.placeholder"><code>placeholder</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.placeholder</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.placeholder_layer">
    <p>def <span class="ident">placeholder_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.placeholder_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.placeholder_layer"><code>placeholder_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.placeholder_layer"><code>placeholder_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.placeholder_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.placeholder_with_default">
    <p>def <span class="ident">placeholder_with_default</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.placeholder_with_default</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.placeholder_with_default"><code>placeholder_with_default</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.placeholder_with_default"><code>placeholder_with_default</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.placeholder_with_default</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder_with_default(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.placeholder_with_default_layer">
    <p>def <span class="ident">placeholder_with_default_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.placeholder_with_default_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.placeholder_with_default_layer"><code>placeholder_with_default_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.placeholder_with_default_layer"><code>placeholder_with_default_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.placeholder_with_default_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def placeholder_with_default_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.polygamma">
    <p>def <span class="ident">polygamma</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.polygamma</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.polygamma"><code>polygamma</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.polygamma"><code>polygamma</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.polygamma</code></strong></p>
<div class="codehilite"><pre><span></span>    def polygamma(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.polygamma_layer">
    <p>def <span class="ident">polygamma_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.polygamma_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.polygamma_layer"><code>polygamma_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.polygamma_layer"><code>polygamma_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.polygamma_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def polygamma_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.pow">
    <p>def <span class="ident">pow</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.pow</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.pow"><code>pow</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.pow"><code>pow</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.pow</code></strong></p>
<div class="codehilite"><pre><span></span>    def pow(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.pow_layer">
    <p>def <span class="ident">pow_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.pow_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.pow_layer"><code>pow_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.pow_layer"><code>pow_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.pow_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def pow_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.py_func">
    <p>def <span class="ident">py_func</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.py_func</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.py_func"><code>py_func</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.py_func"><code>py_func</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.py_func</code></strong></p>
<div class="codehilite"><pre><span></span>    def py_func(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.py_func_layer">
    <p>def <span class="ident">py_func_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.py_func_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.py_func_layer"><code>py_func_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.py_func_layer"><code>py_func_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.py_func_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def py_func_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_crop">
    <p>def <span class="ident">random_crop</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.random_crop</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_crop"><code>random_crop</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_crop"><code>random_crop</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.random_crop</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_crop(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_crop_layer">
    <p>def <span class="ident">random_crop_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.random_crop_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_crop_layer"><code>random_crop_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_crop_layer"><code>random_crop_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.random_crop_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_crop_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_normal">
    <p>def <span class="ident">random_normal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.random_normal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_normal"><code>random_normal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_normal"><code>random_normal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.random_normal</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_normal_initializer">
    <p>def <span class="ident">random_normal_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.random_normal_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_normal_initializer"><code>random_normal_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_normal_initializer"><code>random_normal_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.random_normal_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_normal_initializer_layer">
    <p>def <span class="ident">random_normal_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.random_normal_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_normal_initializer_layer"><code>random_normal_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_normal_initializer_layer"><code>random_normal_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.random_normal_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_normal_layer">
    <p>def <span class="ident">random_normal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.random_normal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_normal_layer"><code>random_normal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_normal_layer"><code>random_normal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.random_normal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_normal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_shuffle">
    <p>def <span class="ident">random_shuffle</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.random_shuffle</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_shuffle"><code>random_shuffle</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_shuffle"><code>random_shuffle</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.random_shuffle</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_shuffle(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_shuffle_layer">
    <p>def <span class="ident">random_shuffle_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.random_shuffle_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_shuffle_layer"><code>random_shuffle_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_shuffle_layer"><code>random_shuffle_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.random_shuffle_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_shuffle_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_uniform">
    <p>def <span class="ident">random_uniform</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.random_uniform</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_uniform"><code>random_uniform</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_uniform"><code>random_uniform</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.random_uniform</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_uniform_initializer">
    <p>def <span class="ident">random_uniform_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.random_uniform_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_uniform_initializer"><code>random_uniform_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_uniform_initializer"><code>random_uniform_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.random_uniform_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_uniform_initializer_layer">
    <p>def <span class="ident">random_uniform_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.random_uniform_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_uniform_initializer_layer"><code>random_uniform_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_uniform_initializer_layer"><code>random_uniform_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.random_uniform_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.random_uniform_layer">
    <p>def <span class="ident">random_uniform_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.random_uniform_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.random_uniform_layer"><code>random_uniform_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.random_uniform_layer"><code>random_uniform_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.random_uniform_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def random_uniform_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.range">
    <p>def <span class="ident">range</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.range</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.range"><code>range</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.range"><code>range</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.range</code></strong></p>
<div class="codehilite"><pre><span></span>    def range(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.range_layer">
    <p>def <span class="ident">range_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.range_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.range_layer"><code>range_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.range_layer"><code>range_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.range_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def range_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.rank">
    <p>def <span class="ident">rank</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.rank</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.rank"><code>rank</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.rank"><code>rank</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.rank</code></strong></p>
<div class="codehilite"><pre><span></span>    def rank(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.rank_layer">
    <p>def <span class="ident">rank_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.rank_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.rank_layer"><code>rank_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.rank_layer"><code>rank_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.rank_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def rank_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.read_file">
    <p>def <span class="ident">read_file</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.read_file</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.read_file"><code>read_file</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.read_file"><code>read_file</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.read_file</code></strong></p>
<div class="codehilite"><pre><span></span>    def read_file(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.read_file_layer">
    <p>def <span class="ident">read_file_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.read_file_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.read_file_layer"><code>read_file_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.read_file_layer"><code>read_file_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.read_file_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def read_file_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.real">
    <p>def <span class="ident">real</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.real</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.real"><code>real</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.real"><code>real</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.real</code></strong></p>
<div class="codehilite"><pre><span></span>    def real(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.real_layer">
    <p>def <span class="ident">real_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.real_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.real_layer"><code>real_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.real_layer"><code>real_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.real_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def real_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce"><code>reduce</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce"><code>reduce</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce(tree, fn, initializer=None)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_all">
    <p>def <span class="ident">reduce_all</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_all</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_all"><code>reduce_all</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_all"><code>reduce_all</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_all</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_all(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_all_layer">
    <p>def <span class="ident">reduce_all_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_all_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_all_layer"><code>reduce_all_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_all_layer"><code>reduce_all_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_all_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_all_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_any">
    <p>def <span class="ident">reduce_any</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_any</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_any"><code>reduce_any</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_any"><code>reduce_any</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_any</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_any(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_any_layer">
    <p>def <span class="ident">reduce_any_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_any_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_any_layer"><code>reduce_any_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_any_layer"><code>reduce_any_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_any_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_any_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_join">
    <p>def <span class="ident">reduce_join</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_join</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_join"><code>reduce_join</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_join"><code>reduce_join</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_join</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_join(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_join_layer">
    <p>def <span class="ident">reduce_join_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_join_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_join_layer"><code>reduce_join_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_join_layer"><code>reduce_join_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_join_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_join_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_max">
    <p>def <span class="ident">reduce_max</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_max</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_max"><code>reduce_max</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_max"><code>reduce_max</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_max</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_max(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_max_layer">
    <p>def <span class="ident">reduce_max_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_max_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_max_layer"><code>reduce_max_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_max_layer"><code>reduce_max_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_max_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_max_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_mean">
    <p>def <span class="ident">reduce_mean</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_mean</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_mean"><code>reduce_mean</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_mean"><code>reduce_mean</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_mean</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_mean(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_mean_layer">
    <p>def <span class="ident">reduce_mean_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_mean_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_mean_layer"><code>reduce_mean_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_mean_layer"><code>reduce_mean_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_mean_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_mean_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_min">
    <p>def <span class="ident">reduce_min</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_min</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_min"><code>reduce_min</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_min"><code>reduce_min</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_min</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_min(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_min_layer">
    <p>def <span class="ident">reduce_min_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_min_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_min_layer"><code>reduce_min_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_min_layer"><code>reduce_min_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_min_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_min_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_prod">
    <p>def <span class="ident">reduce_prod</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_prod</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_prod"><code>reduce_prod</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_prod"><code>reduce_prod</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_prod</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_prod(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_prod_layer">
    <p>def <span class="ident">reduce_prod_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_prod_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_prod_layer"><code>reduce_prod_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_prod_layer"><code>reduce_prod_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_prod_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_prod_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_sum">
    <p>def <span class="ident">reduce_sum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reduce_sum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_sum"><code>reduce_sum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_sum"><code>reduce_sum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reduce_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reduce_sum_layer">
    <p>def <span class="ident">reduce_sum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reduce_sum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reduce_sum_layer"><code>reduce_sum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reduce_sum_layer"><code>reduce_sum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reduce_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reduce_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.register_tensor_conversion_function">
    <p>def <span class="ident">register_tensor_conversion_function</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.register_tensor_conversion_function</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.register_tensor_conversion_function"><code>register_tensor_conversion_function</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.register_tensor_conversion_function"><code>register_tensor_conversion_function</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.register_tensor_conversion_function</code></strong></p>
<div class="codehilite"><pre><span></span>    def register_tensor_conversion_function(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.register_tensor_conversion_function_layer">
    <p>def <span class="ident">register_tensor_conversion_function_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.register_tensor_conversion_function_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.register_tensor_conversion_function_layer"><code>register_tensor_conversion_function_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.register_tensor_conversion_function_layer"><code>register_tensor_conversion_function_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.register_tensor_conversion_function_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def register_tensor_conversion_function_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.relu">
    <p>def <span class="ident">relu</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.relu</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.relu"><code>relu</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.relu"><code>relu</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.relu</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.relu6">
    <p>def <span class="ident">relu6</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.relu6</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.relu6"><code>relu6</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.relu6"><code>relu6</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.relu6</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu6(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.relu6_layer">
    <p>def <span class="ident">relu6_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.relu6_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.relu6_layer"><code>relu6_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.relu6_layer"><code>relu6_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.relu6_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu6_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.relu_layer">
    <p>def <span class="ident">relu_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.relu_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.relu_layer"><code>relu_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.relu_layer"><code>relu_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.relu_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def relu_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.report_uninitialized_variables">
    <p>def <span class="ident">report_uninitialized_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.report_uninitialized_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.report_uninitialized_variables"><code>report_uninitialized_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.report_uninitialized_variables"><code>report_uninitialized_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.report_uninitialized_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def report_uninitialized_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.report_uninitialized_variables_layer">
    <p>def <span class="ident">report_uninitialized_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.report_uninitialized_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.report_uninitialized_variables_layer"><code>report_uninitialized_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.report_uninitialized_variables_layer"><code>report_uninitialized_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.report_uninitialized_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def report_uninitialized_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reset_default_graph">
    <p>def <span class="ident">reset_default_graph</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reset_default_graph</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reset_default_graph"><code>reset_default_graph</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reset_default_graph"><code>reset_default_graph</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reset_default_graph</code></strong></p>
<div class="codehilite"><pre><span></span>    def reset_default_graph(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reset_default_graph_layer">
    <p>def <span class="ident">reset_default_graph_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reset_default_graph_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reset_default_graph_layer"><code>reset_default_graph_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reset_default_graph_layer"><code>reset_default_graph_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reset_default_graph_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reset_default_graph_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reshape">
    <p>def <span class="ident">reshape</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reshape</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reshape"><code>reshape</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reshape"><code>reshape</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reshape</code></strong></p>
<div class="codehilite"><pre><span></span>    def reshape(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reshape_layer">
    <p>def <span class="ident">reshape_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reshape_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reshape_layer"><code>reshape_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reshape_layer"><code>reshape_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reshape_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reshape_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reverse">
    <p>def <span class="ident">reverse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reverse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reverse"><code>reverse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reverse"><code>reverse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reverse</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reverse_layer">
    <p>def <span class="ident">reverse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reverse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reverse_layer"><code>reverse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reverse_layer"><code>reverse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reverse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reverse_sequence">
    <p>def <span class="ident">reverse_sequence</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.reverse_sequence</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reverse_sequence"><code>reverse_sequence</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reverse_sequence"><code>reverse_sequence</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.reverse_sequence</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse_sequence(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.reverse_sequence_layer">
    <p>def <span class="ident">reverse_sequence_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.reverse_sequence_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.reverse_sequence_layer"><code>reverse_sequence_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.reverse_sequence_layer"><code>reverse_sequence_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.reverse_sequence_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def reverse_sequence_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.rnn">
    <p>def <span class="ident">rnn</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.rnn</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.rnn"><code>rnn</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.rnn"><code>rnn</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.rnn_layer">
    <p>def <span class="ident">rnn_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.rnn_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.rnn_layer"><code>rnn_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.rnn_layer"><code>rnn_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.round">
    <p>def <span class="ident">round</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.round</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.round"><code>round</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.round"><code>round</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.round</code></strong></p>
<div class="codehilite"><pre><span></span>    def round(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.round_layer">
    <p>def <span class="ident">round_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.round_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.round_layer"><code>round_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.round_layer"><code>round_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.round_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def round_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.rsqrt">
    <p>def <span class="ident">rsqrt</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.rsqrt</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.rsqrt"><code>rsqrt</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.rsqrt"><code>rsqrt</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.rsqrt</code></strong></p>
<div class="codehilite"><pre><span></span>    def rsqrt(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.rsqrt_layer">
    <p>def <span class="ident">rsqrt_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.rsqrt_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.rsqrt_layer"><code>rsqrt_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.rsqrt_layer"><code>rsqrt_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.rsqrt_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def rsqrt_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sampled_softmax_loss">
    <p>def <span class="ident">sampled_softmax_loss</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sampled_softmax_loss</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sampled_softmax_loss"><code>sampled_softmax_loss</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sampled_softmax_loss"><code>sampled_softmax_loss</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sampled_softmax_loss</code></strong></p>
<div class="codehilite"><pre><span></span>    def sampled_softmax_loss(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sampled_softmax_loss_layer">
    <p>def <span class="ident">sampled_softmax_loss_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sampled_softmax_loss_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sampled_softmax_loss_layer"><code>sampled_softmax_loss_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sampled_softmax_loss_layer"><code>sampled_softmax_loss_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sampled_softmax_loss_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sampled_softmax_loss_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.saturate_cast">
    <p>def <span class="ident">saturate_cast</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.saturate_cast</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.saturate_cast"><code>saturate_cast</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.saturate_cast"><code>saturate_cast</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.saturate_cast</code></strong></p>
<div class="codehilite"><pre><span></span>    def saturate_cast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.saturate_cast_layer">
    <p>def <span class="ident">saturate_cast_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.saturate_cast_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.saturate_cast_layer"><code>saturate_cast_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.saturate_cast_layer"><code>saturate_cast_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.saturate_cast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def saturate_cast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scalar_mul">
    <p>def <span class="ident">scalar_mul</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.scalar_mul</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scalar_mul"><code>scalar_mul</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scalar_mul"><code>scalar_mul</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.scalar_mul</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_mul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scalar_mul_layer">
    <p>def <span class="ident">scalar_mul_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.scalar_mul_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scalar_mul_layer"><code>scalar_mul_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scalar_mul_layer"><code>scalar_mul_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.scalar_mul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_mul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scalar_summary">
    <p>def <span class="ident">scalar_summary</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.scalar_summary</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scalar_summary"><code>scalar_summary</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scalar_summary"><code>scalar_summary</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.scalar_summary</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_summary(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scalar_summary_layer">
    <p>def <span class="ident">scalar_summary_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.scalar_summary_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scalar_summary_layer"><code>scalar_summary_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scalar_summary_layer"><code>scalar_summary_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.scalar_summary_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scalar_summary_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scan">
    <p>def <span class="ident">scan</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.scan</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scan"><code>scan</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scan"><code>scan</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.scan</code></strong></p>
<div class="codehilite"><pre><span></span>    def scan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scan_layer">
    <p>def <span class="ident">scan_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.scan_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scan_layer"><code>scan_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scan_layer"><code>scan_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.scan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scatter_add">
    <p>def <span class="ident">scatter_add</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.scatter_add</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scatter_add"><code>scatter_add</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scatter_add"><code>scatter_add</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.scatter_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scatter_add_layer">
    <p>def <span class="ident">scatter_add_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.scatter_add_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scatter_add_layer"><code>scatter_add_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scatter_add_layer"><code>scatter_add_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.scatter_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scatter_sub">
    <p>def <span class="ident">scatter_sub</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.scatter_sub</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scatter_sub"><code>scatter_sub</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scatter_sub"><code>scatter_sub</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.scatter_sub</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_sub(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scatter_sub_layer">
    <p>def <span class="ident">scatter_sub_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.scatter_sub_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scatter_sub_layer"><code>scatter_sub_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scatter_sub_layer"><code>scatter_sub_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.scatter_sub_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_sub_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scatter_update">
    <p>def <span class="ident">scatter_update</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.scatter_update</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scatter_update"><code>scatter_update</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scatter_update"><code>scatter_update</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.scatter_update</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_update(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.scatter_update_layer">
    <p>def <span class="ident">scatter_update_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.scatter_update_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.scatter_update_layer"><code>scatter_update_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.scatter_update_layer"><code>scatter_update_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.scatter_update_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def scatter_update_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_max">
    <p>def <span class="ident">segment_max</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.segment_max</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_max"><code>segment_max</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_max"><code>segment_max</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.segment_max</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_max(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_max_layer">
    <p>def <span class="ident">segment_max_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.segment_max_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_max_layer"><code>segment_max_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_max_layer"><code>segment_max_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.segment_max_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_max_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_mean">
    <p>def <span class="ident">segment_mean</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.segment_mean</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_mean"><code>segment_mean</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_mean"><code>segment_mean</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.segment_mean</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_mean(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_mean_layer">
    <p>def <span class="ident">segment_mean_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.segment_mean_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_mean_layer"><code>segment_mean_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_mean_layer"><code>segment_mean_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.segment_mean_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_mean_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_min">
    <p>def <span class="ident">segment_min</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.segment_min</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_min"><code>segment_min</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_min"><code>segment_min</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.segment_min</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_min(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_min_layer">
    <p>def <span class="ident">segment_min_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.segment_min_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_min_layer"><code>segment_min_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_min_layer"><code>segment_min_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.segment_min_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_min_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_prod">
    <p>def <span class="ident">segment_prod</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.segment_prod</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_prod"><code>segment_prod</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_prod"><code>segment_prod</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.segment_prod</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_prod(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_prod_layer">
    <p>def <span class="ident">segment_prod_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.segment_prod_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_prod_layer"><code>segment_prod_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_prod_layer"><code>segment_prod_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.segment_prod_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_prod_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_sum">
    <p>def <span class="ident">segment_sum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.segment_sum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_sum"><code>segment_sum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_sum"><code>segment_sum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.segment_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.segment_sum_layer">
    <p>def <span class="ident">segment_sum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.segment_sum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.segment_sum_layer"><code>segment_sum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.segment_sum_layer"><code>segment_sum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.segment_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def segment_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.select">
    <p>def <span class="ident">select</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.select</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.select"><code>select</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.select"><code>select</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.select</code></strong></p>
<div class="codehilite"><pre><span></span>    def select(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.select_layer">
    <p>def <span class="ident">select_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.select_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.select_layer"><code>select_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.select_layer"><code>select_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.select_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def select_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.self_adjoint_eig">
    <p>def <span class="ident">self_adjoint_eig</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.self_adjoint_eig</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.self_adjoint_eig"><code>self_adjoint_eig</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.self_adjoint_eig"><code>self_adjoint_eig</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.self_adjoint_eig</code></strong></p>
<div class="codehilite"><pre><span></span>    def self_adjoint_eig(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.self_adjoint_eig_layer">
    <p>def <span class="ident">self_adjoint_eig_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.self_adjoint_eig_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.self_adjoint_eig_layer"><code>self_adjoint_eig_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.self_adjoint_eig_layer"><code>self_adjoint_eig_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.self_adjoint_eig_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def self_adjoint_eig_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.separable_conv2d">
    <p>def <span class="ident">separable_conv2d</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.separable_conv2d</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.separable_conv2d"><code>separable_conv2d</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.separable_conv2d"><code>separable_conv2d</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.separable_conv2d</code></strong></p>
<div class="codehilite"><pre><span></span>    def separable_conv2d(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.separable_conv2d_layer">
    <p>def <span class="ident">separable_conv2d_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.separable_conv2d_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.separable_conv2d_layer"><code>separable_conv2d_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.separable_conv2d_layer"><code>separable_conv2d_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.separable_conv2d_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def separable_conv2d_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.serialize_many_sparse">
    <p>def <span class="ident">serialize_many_sparse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.serialize_many_sparse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.serialize_many_sparse"><code>serialize_many_sparse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.serialize_many_sparse"><code>serialize_many_sparse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.serialize_many_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_many_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.serialize_many_sparse_layer">
    <p>def <span class="ident">serialize_many_sparse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.serialize_many_sparse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.serialize_many_sparse_layer"><code>serialize_many_sparse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.serialize_many_sparse_layer"><code>serialize_many_sparse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.serialize_many_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_many_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.serialize_sparse">
    <p>def <span class="ident">serialize_sparse</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.serialize_sparse</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.serialize_sparse"><code>serialize_sparse</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.serialize_sparse"><code>serialize_sparse</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.serialize_sparse</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_sparse(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.serialize_sparse_layer">
    <p>def <span class="ident">serialize_sparse_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.serialize_sparse_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.serialize_sparse_layer"><code>serialize_sparse_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.serialize_sparse_layer"><code>serialize_sparse_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.serialize_sparse_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def serialize_sparse_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.set_random_seed">
    <p>def <span class="ident">set_random_seed</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.set_random_seed</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.set_random_seed"><code>set_random_seed</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.set_random_seed"><code>set_random_seed</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.set_random_seed</code></strong></p>
<div class="codehilite"><pre><span></span>    def set_random_seed(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.set_random_seed_layer">
    <p>def <span class="ident">set_random_seed_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.set_random_seed_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.set_random_seed_layer"><code>set_random_seed_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.set_random_seed_layer"><code>set_random_seed_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.set_random_seed_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def set_random_seed_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.shape">
    <p>def <span class="ident">shape</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.shape</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.shape"><code>shape</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.shape"><code>shape</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.shape</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.shape_layer">
    <p>def <span class="ident">shape_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.shape_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.shape_layer"><code>shape_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.shape_layer"><code>shape_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.shape_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.shape_n">
    <p>def <span class="ident">shape_n</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.shape_n</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.shape_n"><code>shape_n</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.shape_n"><code>shape_n</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.shape_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.shape_n_layer">
    <p>def <span class="ident">shape_n_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.shape_n_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.shape_n_layer"><code>shape_n_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.shape_n_layer"><code>shape_n_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.shape_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def shape_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sigmoid">
    <p>def <span class="ident">sigmoid</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sigmoid</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sigmoid"><code>sigmoid</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sigmoid"><code>sigmoid</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sigmoid</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sigmoid_cross_entropy_with_logits">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sigmoid_cross_entropy_with_logits</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sigmoid_cross_entropy_with_logits"><code>sigmoid_cross_entropy_with_logits</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sigmoid_cross_entropy_with_logits"><code>sigmoid_cross_entropy_with_logits</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sigmoid_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sigmoid_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sigmoid_cross_entropy_with_logits_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sigmoid_cross_entropy_with_logits_layer"><code>sigmoid_cross_entropy_with_logits_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sigmoid_cross_entropy_with_logits_layer"><code>sigmoid_cross_entropy_with_logits_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sigmoid_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sigmoid_layer">
    <p>def <span class="ident">sigmoid_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sigmoid_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sigmoid_layer"><code>sigmoid_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sigmoid_layer"><code>sigmoid_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sigmoid_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sigmoid_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sign">
    <p>def <span class="ident">sign</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sign</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sign"><code>sign</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sign"><code>sign</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sign</code></strong></p>
<div class="codehilite"><pre><span></span>    def sign(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sign_layer">
    <p>def <span class="ident">sign_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sign_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sign_layer"><code>sign_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sign_layer"><code>sign_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sign_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sign_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sin">
    <p>def <span class="ident">sin</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sin</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sin"><code>sin</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sin"><code>sin</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sin</code></strong></p>
<div class="codehilite"><pre><span></span>    def sin(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sin_layer">
    <p>def <span class="ident">sin_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sin_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sin_layer"><code>sin_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sin_layer"><code>sin_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sin_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sin_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.size">
    <p>def <span class="ident">size</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.size</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.size"><code>size</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.size"><code>size</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.size</code></strong></p>
<div class="codehilite"><pre><span></span>    def size(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.size_layer">
    <p>def <span class="ident">size_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.size_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.size_layer"><code>size_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.size_layer"><code>size_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.size_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def size_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.slice">
    <p>def <span class="ident">slice</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.slice</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.slice"><code>slice</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.slice"><code>slice</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.slice</code></strong></p>
<div class="codehilite"><pre><span></span>    def slice(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.slice_layer">
    <p>def <span class="ident">slice_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.slice_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.slice_layer"><code>slice_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.slice_layer"><code>slice_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.slice_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def slice_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softmax">
    <p>def <span class="ident">softmax</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.softmax</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softmax"><code>softmax</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softmax"><code>softmax</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.softmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softmax_cross_entropy_with_logits">
    <p>def <span class="ident">softmax_cross_entropy_with_logits</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.softmax_cross_entropy_with_logits</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softmax_cross_entropy_with_logits"><code>softmax_cross_entropy_with_logits</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softmax_cross_entropy_with_logits"><code>softmax_cross_entropy_with_logits</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.softmax_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">softmax_cross_entropy_with_logits_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.softmax_cross_entropy_with_logits_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softmax_cross_entropy_with_logits_layer"><code>softmax_cross_entropy_with_logits_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softmax_cross_entropy_with_logits_layer"><code>softmax_cross_entropy_with_logits_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.softmax_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softmax_layer">
    <p>def <span class="ident">softmax_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.softmax_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softmax_layer"><code>softmax_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softmax_layer"><code>softmax_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.softmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softplus">
    <p>def <span class="ident">softplus</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.softplus</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softplus"><code>softplus</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softplus"><code>softplus</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.softplus</code></strong></p>
<div class="codehilite"><pre><span></span>    def softplus(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softplus_layer">
    <p>def <span class="ident">softplus_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.softplus_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softplus_layer"><code>softplus_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softplus_layer"><code>softplus_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.softplus_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softplus_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softsign">
    <p>def <span class="ident">softsign</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.softsign</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softsign"><code>softsign</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softsign"><code>softsign</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.softsign</code></strong></p>
<div class="codehilite"><pre><span></span>    def softsign(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.softsign_layer">
    <p>def <span class="ident">softsign_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.softsign_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.softsign_layer"><code>softsign_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.softsign_layer"><code>softsign_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.softsign_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def softsign_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.space_to_batch">
    <p>def <span class="ident">space_to_batch</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.space_to_batch</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.space_to_batch"><code>space_to_batch</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.space_to_batch"><code>space_to_batch</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.space_to_batch</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_batch(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.space_to_batch_layer">
    <p>def <span class="ident">space_to_batch_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.space_to_batch_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.space_to_batch_layer"><code>space_to_batch_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.space_to_batch_layer"><code>space_to_batch_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.space_to_batch_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_batch_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.space_to_depth">
    <p>def <span class="ident">space_to_depth</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.space_to_depth</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.space_to_depth"><code>space_to_depth</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.space_to_depth"><code>space_to_depth</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.space_to_depth</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_depth(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.space_to_depth_layer">
    <p>def <span class="ident">space_to_depth_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.space_to_depth_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.space_to_depth_layer"><code>space_to_depth_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.space_to_depth_layer"><code>space_to_depth_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.space_to_depth_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def space_to_depth_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_add">
    <p>def <span class="ident">sparse_add</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_add</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_add"><code>sparse_add</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_add"><code>sparse_add</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_add</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_add(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_add_layer">
    <p>def <span class="ident">sparse_add_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_add_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_add_layer"><code>sparse_add_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_add_layer"><code>sparse_add_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_add_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_add_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_concat">
    <p>def <span class="ident">sparse_concat</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_concat</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_concat"><code>sparse_concat</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_concat"><code>sparse_concat</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_concat</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_concat(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_concat_layer">
    <p>def <span class="ident">sparse_concat_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_concat_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_concat_layer"><code>sparse_concat_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_concat_layer"><code>sparse_concat_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_concat_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_concat_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_fill_empty_rows">
    <p>def <span class="ident">sparse_fill_empty_rows</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_fill_empty_rows</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_fill_empty_rows"><code>sparse_fill_empty_rows</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_fill_empty_rows"><code>sparse_fill_empty_rows</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_fill_empty_rows</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_fill_empty_rows(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_fill_empty_rows_layer">
    <p>def <span class="ident">sparse_fill_empty_rows_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_fill_empty_rows_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_fill_empty_rows_layer"><code>sparse_fill_empty_rows_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_fill_empty_rows_layer"><code>sparse_fill_empty_rows_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_fill_empty_rows_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_fill_empty_rows_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_mask">
    <p>def <span class="ident">sparse_mask</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_mask</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_mask"><code>sparse_mask</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_mask"><code>sparse_mask</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_mask</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_mask(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_mask_layer">
    <p>def <span class="ident">sparse_mask_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_mask_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_mask_layer"><code>sparse_mask_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_mask_layer"><code>sparse_mask_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_mask_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_mask_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_matmul_layer">
    <p>def <span class="ident">sparse_matmul_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_matmul_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_matmul_layer"><code>sparse_matmul_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_matmul_layer"><code>sparse_matmul_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_merge">
    <p>def <span class="ident">sparse_merge</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_merge</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_merge"><code>sparse_merge</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_merge"><code>sparse_merge</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_merge</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_merge(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_merge_layer">
    <p>def <span class="ident">sparse_merge_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_merge_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_merge_layer"><code>sparse_merge_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_merge_layer"><code>sparse_merge_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_merge_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_merge_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_placeholder">
    <p>def <span class="ident">sparse_placeholder</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_placeholder</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_placeholder"><code>sparse_placeholder</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_placeholder"><code>sparse_placeholder</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_placeholder</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_placeholder(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_placeholder_layer">
    <p>def <span class="ident">sparse_placeholder_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_placeholder_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_placeholder_layer"><code>sparse_placeholder_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_placeholder_layer"><code>sparse_placeholder_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_placeholder_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_placeholder_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_reduce_sum">
    <p>def <span class="ident">sparse_reduce_sum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_reduce_sum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_reduce_sum"><code>sparse_reduce_sum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_reduce_sum"><code>sparse_reduce_sum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_reduce_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reduce_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_reduce_sum_layer">
    <p>def <span class="ident">sparse_reduce_sum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_reduce_sum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_reduce_sum_layer"><code>sparse_reduce_sum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_reduce_sum_layer"><code>sparse_reduce_sum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_reduce_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reduce_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_reorder">
    <p>def <span class="ident">sparse_reorder</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_reorder</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_reorder"><code>sparse_reorder</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_reorder"><code>sparse_reorder</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_reorder</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reorder(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_reorder_layer">
    <p>def <span class="ident">sparse_reorder_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_reorder_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_reorder_layer"><code>sparse_reorder_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_reorder_layer"><code>sparse_reorder_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_reorder_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reorder_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_reset_shape">
    <p>def <span class="ident">sparse_reset_shape</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_reset_shape</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_reset_shape"><code>sparse_reset_shape</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_reset_shape"><code>sparse_reset_shape</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_reset_shape</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reset_shape(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_reset_shape_layer">
    <p>def <span class="ident">sparse_reset_shape_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_reset_shape_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_reset_shape_layer"><code>sparse_reset_shape_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_reset_shape_layer"><code>sparse_reset_shape_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_reset_shape_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_reset_shape_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_retain">
    <p>def <span class="ident">sparse_retain</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_retain</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_retain"><code>sparse_retain</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_retain"><code>sparse_retain</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_retain</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_retain(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_retain_layer">
    <p>def <span class="ident">sparse_retain_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_retain_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_retain_layer"><code>sparse_retain_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_retain_layer"><code>sparse_retain_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_retain_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_retain_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_mean">
    <p>def <span class="ident">sparse_segment_mean</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_segment_mean</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_mean"><code>sparse_segment_mean</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_mean"><code>sparse_segment_mean</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_segment_mean</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_mean_grad">
    <p>def <span class="ident">sparse_segment_mean_grad</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_segment_mean_grad</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_mean_grad"><code>sparse_segment_mean_grad</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_mean_grad"><code>sparse_segment_mean_grad</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_segment_mean_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_mean_grad_layer">
    <p>def <span class="ident">sparse_segment_mean_grad_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_segment_mean_grad_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_mean_grad_layer"><code>sparse_segment_mean_grad_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_mean_grad_layer"><code>sparse_segment_mean_grad_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_mean_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_mean_layer">
    <p>def <span class="ident">sparse_segment_mean_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_segment_mean_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_mean_layer"><code>sparse_segment_mean_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_mean_layer"><code>sparse_segment_mean_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_mean_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_mean_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n">
    <p>def <span class="ident">sparse_segment_sqrt_n</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_segment_sqrt_n</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n"><code>sparse_segment_sqrt_n</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n"><code>sparse_segment_sqrt_n</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_segment_sqrt_n</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n_grad">
    <p>def <span class="ident">sparse_segment_sqrt_n_grad</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_segment_sqrt_n_grad</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_grad"><code>sparse_segment_sqrt_n_grad</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_grad"><code>sparse_segment_sqrt_n_grad</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_segment_sqrt_n_grad</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n_grad(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n_grad_layer">
    <p>def <span class="ident">sparse_segment_sqrt_n_grad_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_segment_sqrt_n_grad_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_grad_layer"><code>sparse_segment_sqrt_n_grad_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_grad_layer"><code>sparse_segment_sqrt_n_grad_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_sqrt_n_grad_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n_grad_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_sqrt_n_layer">
    <p>def <span class="ident">sparse_segment_sqrt_n_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_segment_sqrt_n_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_layer"><code>sparse_segment_sqrt_n_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_sqrt_n_layer"><code>sparse_segment_sqrt_n_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_sqrt_n_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sqrt_n_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_sum">
    <p>def <span class="ident">sparse_segment_sum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_segment_sum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_sum"><code>sparse_segment_sum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_sum"><code>sparse_segment_sum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_segment_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_segment_sum_layer">
    <p>def <span class="ident">sparse_segment_sum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_segment_sum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_segment_sum_layer"><code>sparse_segment_sum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_segment_sum_layer"><code>sparse_segment_sum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_segment_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_segment_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_softmax">
    <p>def <span class="ident">sparse_softmax</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_softmax</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_softmax"><code>sparse_softmax</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_softmax"><code>sparse_softmax</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_softmax</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_softmax_cross_entropy_with_logits">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_softmax_cross_entropy_with_logits</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits"><code>sparse_softmax_cross_entropy_with_logits</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits"><code>sparse_softmax_cross_entropy_with_logits</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_softmax_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_softmax_cross_entropy_with_logits_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits_layer"><code>sparse_softmax_cross_entropy_with_logits_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_softmax_cross_entropy_with_logits_layer"><code>sparse_softmax_cross_entropy_with_logits_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_softmax_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_softmax_layer">
    <p>def <span class="ident">sparse_softmax_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_softmax_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_softmax_layer"><code>sparse_softmax_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_softmax_layer"><code>sparse_softmax_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_softmax_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_softmax_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_split">
    <p>def <span class="ident">sparse_split</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_split</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_split"><code>sparse_split</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_split"><code>sparse_split</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_split</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_split(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_split_layer">
    <p>def <span class="ident">sparse_split_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_split_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_split_layer"><code>sparse_split_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_split_layer"><code>sparse_split_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_split_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_split_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_tensor_dense_matmul">
    <p>def <span class="ident">sparse_tensor_dense_matmul</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_tensor_dense_matmul</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_tensor_dense_matmul"><code>sparse_tensor_dense_matmul</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_tensor_dense_matmul"><code>sparse_tensor_dense_matmul</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_tensor_dense_matmul</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_dense_matmul(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_tensor_dense_matmul_layer">
    <p>def <span class="ident">sparse_tensor_dense_matmul_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_tensor_dense_matmul_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_tensor_dense_matmul_layer"><code>sparse_tensor_dense_matmul_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_tensor_dense_matmul_layer"><code>sparse_tensor_dense_matmul_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_tensor_dense_matmul_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_dense_matmul_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_tensor_to_dense">
    <p>def <span class="ident">sparse_tensor_to_dense</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_tensor_to_dense</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_tensor_to_dense"><code>sparse_tensor_to_dense</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_tensor_to_dense"><code>sparse_tensor_to_dense</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_tensor_to_dense</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_to_dense(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_tensor_to_dense_layer">
    <p>def <span class="ident">sparse_tensor_to_dense_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_tensor_to_dense_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_tensor_to_dense_layer"><code>sparse_tensor_to_dense_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_tensor_to_dense_layer"><code>sparse_tensor_to_dense_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_tensor_to_dense_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_tensor_to_dense_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_to_dense">
    <p>def <span class="ident">sparse_to_dense</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_to_dense</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_to_dense"><code>sparse_to_dense</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_to_dense"><code>sparse_to_dense</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_to_dense</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_dense(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_to_dense_layer">
    <p>def <span class="ident">sparse_to_dense_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_to_dense_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_to_dense_layer"><code>sparse_to_dense_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_to_dense_layer"><code>sparse_to_dense_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_to_dense_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_dense_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_to_indicator">
    <p>def <span class="ident">sparse_to_indicator</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sparse_to_indicator</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_to_indicator"><code>sparse_to_indicator</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_to_indicator"><code>sparse_to_indicator</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sparse_to_indicator</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_indicator(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sparse_to_indicator_layer">
    <p>def <span class="ident">sparse_to_indicator_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sparse_to_indicator_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sparse_to_indicator_layer"><code>sparse_to_indicator_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sparse_to_indicator_layer"><code>sparse_to_indicator_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sparse_to_indicator_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sparse_to_indicator_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.split">
    <p>def <span class="ident">split</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.split</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.split"><code>split</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.split"><code>split</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.split</code></strong></p>
<div class="codehilite"><pre><span></span>    def split(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.split_layer">
    <p>def <span class="ident">split_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.split_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.split_layer"><code>split_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.split_layer"><code>split_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.split_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def split_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sqrt">
    <p>def <span class="ident">sqrt</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sqrt</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sqrt"><code>sqrt</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sqrt"><code>sqrt</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sqrt</code></strong></p>
<div class="codehilite"><pre><span></span>    def sqrt(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sqrt_layer">
    <p>def <span class="ident">sqrt_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sqrt_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sqrt_layer"><code>sqrt_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sqrt_layer"><code>sqrt_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sqrt_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sqrt_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.square">
    <p>def <span class="ident">square</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.square</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.square"><code>square</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.square"><code>square</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.square</code></strong></p>
<div class="codehilite"><pre><span></span>    def square(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.square_layer">
    <p>def <span class="ident">square_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.square_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.square_layer"><code>square_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.square_layer"><code>square_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.square_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def square_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.squared_difference">
    <p>def <span class="ident">squared_difference</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.squared_difference</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.squared_difference"><code>squared_difference</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.squared_difference"><code>squared_difference</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.squared_difference</code></strong></p>
<div class="codehilite"><pre><span></span>    def squared_difference(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.squared_difference_layer">
    <p>def <span class="ident">squared_difference_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.squared_difference_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.squared_difference_layer"><code>squared_difference_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.squared_difference_layer"><code>squared_difference_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.squared_difference_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def squared_difference_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.squeeze">
    <p>def <span class="ident">squeeze</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.squeeze</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.squeeze"><code>squeeze</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.squeeze"><code>squeeze</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.squeeze</code></strong></p>
<div class="codehilite"><pre><span></span>    def squeeze(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.squeeze_layer">
    <p>def <span class="ident">squeeze_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.squeeze_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.squeeze_layer"><code>squeeze_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.squeeze_layer"><code>squeeze_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.squeeze_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def squeeze_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.state_saving_rnn">
    <p>def <span class="ident">state_saving_rnn</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.state_saving_rnn</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.state_saving_rnn"><code>state_saving_rnn</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.state_saving_rnn"><code>state_saving_rnn</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.state_saving_rnn</code></strong></p>
<div class="codehilite"><pre><span></span>    def state_saving_rnn(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.state_saving_rnn_layer">
    <p>def <span class="ident">state_saving_rnn_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.state_saving_rnn_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.state_saving_rnn_layer"><code>state_saving_rnn_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.state_saving_rnn_layer"><code>state_saving_rnn_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.state_saving_rnn_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def state_saving_rnn_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.stop_gradient">
    <p>def <span class="ident">stop_gradient</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.stop_gradient</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.stop_gradient"><code>stop_gradient</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.stop_gradient"><code>stop_gradient</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.stop_gradient</code></strong></p>
<div class="codehilite"><pre><span></span>    def stop_gradient(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.stop_gradient_layer">
    <p>def <span class="ident">stop_gradient_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.stop_gradient_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.stop_gradient_layer"><code>stop_gradient_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.stop_gradient_layer"><code>stop_gradient_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.stop_gradient_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def stop_gradient_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_hash_bucket">
    <p>def <span class="ident">string_to_hash_bucket</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.string_to_hash_bucket</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_hash_bucket"><code>string_to_hash_bucket</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_hash_bucket"><code>string_to_hash_bucket</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.string_to_hash_bucket</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_hash_bucket_fast">
    <p>def <span class="ident">string_to_hash_bucket_fast</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.string_to_hash_bucket_fast</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_hash_bucket_fast"><code>string_to_hash_bucket_fast</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_hash_bucket_fast"><code>string_to_hash_bucket_fast</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.string_to_hash_bucket_fast</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_fast(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_hash_bucket_fast_layer">
    <p>def <span class="ident">string_to_hash_bucket_fast_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.string_to_hash_bucket_fast_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_hash_bucket_fast_layer"><code>string_to_hash_bucket_fast_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_hash_bucket_fast_layer"><code>string_to_hash_bucket_fast_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.string_to_hash_bucket_fast_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_fast_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_hash_bucket_layer">
    <p>def <span class="ident">string_to_hash_bucket_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.string_to_hash_bucket_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_hash_bucket_layer"><code>string_to_hash_bucket_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_hash_bucket_layer"><code>string_to_hash_bucket_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.string_to_hash_bucket_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_hash_bucket_strong">
    <p>def <span class="ident">string_to_hash_bucket_strong</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.string_to_hash_bucket_strong</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_hash_bucket_strong"><code>string_to_hash_bucket_strong</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_hash_bucket_strong"><code>string_to_hash_bucket_strong</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.string_to_hash_bucket_strong</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_strong(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_hash_bucket_strong_layer">
    <p>def <span class="ident">string_to_hash_bucket_strong_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.string_to_hash_bucket_strong_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_hash_bucket_strong_layer"><code>string_to_hash_bucket_strong_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_hash_bucket_strong_layer"><code>string_to_hash_bucket_strong_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.string_to_hash_bucket_strong_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_hash_bucket_strong_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_number">
    <p>def <span class="ident">string_to_number</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.string_to_number</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_number"><code>string_to_number</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_number"><code>string_to_number</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.string_to_number</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_number(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.string_to_number_layer">
    <p>def <span class="ident">string_to_number_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.string_to_number_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.string_to_number_layer"><code>string_to_number_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.string_to_number_layer"><code>string_to_number_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.string_to_number_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def string_to_number_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sub">
    <p>def <span class="ident">sub</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sub</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sub"><code>sub</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sub"><code>sub</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sub</code></strong></p>
<div class="codehilite"><pre><span></span>    def sub(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sub_layer">
    <p>def <span class="ident">sub_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sub_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sub_layer"><code>sub_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sub_layer"><code>sub_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sub_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sub_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sufficient_statistics">
    <p>def <span class="ident">sufficient_statistics</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.sufficient_statistics</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sufficient_statistics"><code>sufficient_statistics</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sufficient_statistics"><code>sufficient_statistics</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.sufficient_statistics</code></strong></p>
<div class="codehilite"><pre><span></span>    def sufficient_statistics(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.sufficient_statistics_layer">
    <p>def <span class="ident">sufficient_statistics_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.sufficient_statistics_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.sufficient_statistics_layer"><code>sufficient_statistics_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.sufficient_statistics_layer"><code>sufficient_statistics_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.sufficient_statistics_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def sufficient_statistics_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tan">
    <p>def <span class="ident">tan</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.tan</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tan"><code>tan</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tan"><code>tan</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.tan</code></strong></p>
<div class="codehilite"><pre><span></span>    def tan(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tan_layer">
    <p>def <span class="ident">tan_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.tan_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tan_layer"><code>tan_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tan_layer"><code>tan_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.tan_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tan_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tanh">
    <p>def <span class="ident">tanh</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.tanh</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tanh"><code>tanh</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tanh"><code>tanh</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.tanh</code></strong></p>
<div class="codehilite"><pre><span></span>    def tanh(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tanh_layer">
    <p>def <span class="ident">tanh_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.tanh_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tanh_layer"><code>tanh_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tanh_layer"><code>tanh_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.tanh_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tanh_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tensor">
    <p>def <span class="ident">tensor</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.tensor</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tensor"><code>tensor</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tensor"><code>tensor</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.tensor</code></strong></p>
<div class="codehilite"><pre><span></span>    def tensor(self)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tensors">
    <p>def <span class="ident">tensors</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.tensors</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tensors"><code>tensors</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tensors"><code>tensors</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.tensors</code></strong></p>
<div class="codehilite"><pre><span></span>    def tensors(self)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.then">
    <p>def <span class="ident">then</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.then</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.then"><code>then</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.then"><code>then</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.then</code></strong></p>
<div class="codehilite"><pre><span></span>    def then(builder, fn)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tile">
    <p>def <span class="ident">tile</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.tile</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tile"><code>tile</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tile"><code>tile</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.tile</code></strong></p>
<div class="codehilite"><pre><span></span>    def tile(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tile_layer">
    <p>def <span class="ident">tile_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.tile_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tile_layer"><code>tile_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tile_layer"><code>tile_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.tile_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tile_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_bfloat16">
    <p>def <span class="ident">to_bfloat16</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.to_bfloat16</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_bfloat16"><code>to_bfloat16</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_bfloat16"><code>to_bfloat16</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.to_bfloat16</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_bfloat16(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_bfloat16_layer">
    <p>def <span class="ident">to_bfloat16_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.to_bfloat16_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_bfloat16_layer"><code>to_bfloat16_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_bfloat16_layer"><code>to_bfloat16_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.to_bfloat16_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_bfloat16_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_double">
    <p>def <span class="ident">to_double</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.to_double</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_double"><code>to_double</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_double"><code>to_double</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.to_double</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_double(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_double_layer">
    <p>def <span class="ident">to_double_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.to_double_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_double_layer"><code>to_double_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_double_layer"><code>to_double_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.to_double_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_double_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_float">
    <p>def <span class="ident">to_float</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.to_float</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_float"><code>to_float</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_float"><code>to_float</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.to_float</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_float(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_float_layer">
    <p>def <span class="ident">to_float_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.to_float_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_float_layer"><code>to_float_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_float_layer"><code>to_float_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.to_float_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_float_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_int32">
    <p>def <span class="ident">to_int32</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.to_int32</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_int32"><code>to_int32</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_int32"><code>to_int32</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.to_int32</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int32(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_int32_layer">
    <p>def <span class="ident">to_int32_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.to_int32_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_int32_layer"><code>to_int32_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_int32_layer"><code>to_int32_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.to_int32_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int32_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_int64">
    <p>def <span class="ident">to_int64</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.to_int64</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_int64"><code>to_int64</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_int64"><code>to_int64</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.to_int64</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int64(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.to_int64_layer">
    <p>def <span class="ident">to_int64_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.to_int64_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.to_int64_layer"><code>to_int64_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.to_int64_layer"><code>to_int64_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.to_int64_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def to_int64_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.top_k">
    <p>def <span class="ident">top_k</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.top_k</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.top_k"><code>top_k</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.top_k"><code>top_k</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.top_k</code></strong></p>
<div class="codehilite"><pre><span></span>    def top_k(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.top_k_layer">
    <p>def <span class="ident">top_k_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.top_k_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.top_k_layer"><code>top_k_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.top_k_layer"><code>top_k_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.top_k_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def top_k_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.trace">
    <p>def <span class="ident">trace</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.trace</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.trace"><code>trace</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.trace"><code>trace</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.trace</code></strong></p>
<div class="codehilite"><pre><span></span>    def trace(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.trace_layer">
    <p>def <span class="ident">trace_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.trace_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.trace_layer"><code>trace_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.trace_layer"><code>trace_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.trace_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def trace_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.trainable_variables">
    <p>def <span class="ident">trainable_variables</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.trainable_variables</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.trainable_variables"><code>trainable_variables</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.trainable_variables"><code>trainable_variables</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.trainable_variables</code></strong></p>
<div class="codehilite"><pre><span></span>    def trainable_variables(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.trainable_variables_layer">
    <p>def <span class="ident">trainable_variables_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.trainable_variables_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.trainable_variables_layer"><code>trainable_variables_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.trainable_variables_layer"><code>trainable_variables_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.trainable_variables_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def trainable_variables_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.transpose">
    <p>def <span class="ident">transpose</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.transpose</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.transpose"><code>transpose</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.transpose"><code>transpose</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.transpose</code></strong></p>
<div class="codehilite"><pre><span></span>    def transpose(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.transpose_layer">
    <p>def <span class="ident">transpose_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.transpose_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.transpose_layer"><code>transpose_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.transpose_layer"><code>transpose_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.transpose_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def transpose_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.truediv">
    <p>def <span class="ident">truediv</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.truediv</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.truediv"><code>truediv</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.truediv"><code>truediv</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.truediv</code></strong></p>
<div class="codehilite"><pre><span></span>    def truediv(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.truediv_layer">
    <p>def <span class="ident">truediv_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.truediv_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.truediv_layer"><code>truediv_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.truediv_layer"><code>truediv_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.truediv_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truediv_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.truncated_normal">
    <p>def <span class="ident">truncated_normal</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.truncated_normal</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.truncated_normal"><code>truncated_normal</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.truncated_normal"><code>truncated_normal</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.truncated_normal</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.truncated_normal_initializer">
    <p>def <span class="ident">truncated_normal_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.truncated_normal_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.truncated_normal_initializer"><code>truncated_normal_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.truncated_normal_initializer"><code>truncated_normal_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.truncated_normal_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.truncated_normal_initializer_layer">
    <p>def <span class="ident">truncated_normal_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.truncated_normal_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.truncated_normal_initializer_layer"><code>truncated_normal_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.truncated_normal_initializer_layer"><code>truncated_normal_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.truncated_normal_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.truncated_normal_layer">
    <p>def <span class="ident">truncated_normal_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.truncated_normal_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.truncated_normal_layer"><code>truncated_normal_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.truncated_normal_layer"><code>truncated_normal_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.truncated_normal_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def truncated_normal_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tuple">
    <p>def <span class="ident">tuple</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.tuple</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tuple"><code>tuple</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tuple"><code>tuple</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.tuple</code></strong></p>
<div class="codehilite"><pre><span></span>    def tuple(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.tuple_layer">
    <p>def <span class="ident">tuple_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.tuple_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.tuple_layer"><code>tuple_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.tuple_layer"><code>tuple_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.tuple_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def tuple_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.uniform_candidate_sampler">
    <p>def <span class="ident">uniform_candidate_sampler</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.uniform_candidate_sampler</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.uniform_candidate_sampler"><code>uniform_candidate_sampler</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.uniform_candidate_sampler"><code>uniform_candidate_sampler</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.uniform_candidate_sampler</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_candidate_sampler(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.uniform_candidate_sampler_layer">
    <p>def <span class="ident">uniform_candidate_sampler_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.uniform_candidate_sampler_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.uniform_candidate_sampler_layer"><code>uniform_candidate_sampler_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.uniform_candidate_sampler_layer"><code>uniform_candidate_sampler_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.uniform_candidate_sampler_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_candidate_sampler_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.uniform_unit_scaling_initializer">
    <p>def <span class="ident">uniform_unit_scaling_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.uniform_unit_scaling_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.uniform_unit_scaling_initializer"><code>uniform_unit_scaling_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.uniform_unit_scaling_initializer"><code>uniform_unit_scaling_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.uniform_unit_scaling_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_unit_scaling_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.uniform_unit_scaling_initializer_layer">
    <p>def <span class="ident">uniform_unit_scaling_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.uniform_unit_scaling_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.uniform_unit_scaling_initializer_layer"><code>uniform_unit_scaling_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.uniform_unit_scaling_initializer_layer"><code>uniform_unit_scaling_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.uniform_unit_scaling_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def uniform_unit_scaling_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unique">
    <p>def <span class="ident">unique</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.unique</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unique"><code>unique</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unique"><code>unique</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.unique</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unique_layer">
    <p>def <span class="ident">unique_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.unique_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unique_layer"><code>unique_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unique_layer"><code>unique_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.unique_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unique_with_counts">
    <p>def <span class="ident">unique_with_counts</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.unique_with_counts</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unique_with_counts"><code>unique_with_counts</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unique_with_counts"><code>unique_with_counts</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.unique_with_counts</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique_with_counts(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unique_with_counts_layer">
    <p>def <span class="ident">unique_with_counts_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.unique_with_counts_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unique_with_counts_layer"><code>unique_with_counts_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unique_with_counts_layer"><code>unique_with_counts_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.unique_with_counts_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unique_with_counts_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unpack">
    <p>def <span class="ident">unpack</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.unpack</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unpack"><code>unpack</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unpack"><code>unpack</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.unpack</code></strong></p>
<div class="codehilite"><pre><span></span>    def unpack(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unpack_layer">
    <p>def <span class="ident">unpack_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.unpack_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unpack_layer"><code>unpack_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unpack_layer"><code>unpack_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.unpack_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unpack_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unsorted_segment_sum">
    <p>def <span class="ident">unsorted_segment_sum</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.unsorted_segment_sum</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unsorted_segment_sum"><code>unsorted_segment_sum</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unsorted_segment_sum"><code>unsorted_segment_sum</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.unsorted_segment_sum</code></strong></p>
<div class="codehilite"><pre><span></span>    def unsorted_segment_sum(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.unsorted_segment_sum_layer">
    <p>def <span class="ident">unsorted_segment_sum_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.unsorted_segment_sum_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.unsorted_segment_sum_layer"><code>unsorted_segment_sum_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.unsorted_segment_sum_layer"><code>unsorted_segment_sum_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.unsorted_segment_sum_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def unsorted_segment_sum_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.variable_axis_size_partitioner">
    <p>def <span class="ident">variable_axis_size_partitioner</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.variable_axis_size_partitioner</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.variable_axis_size_partitioner"><code>variable_axis_size_partitioner</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.variable_axis_size_partitioner"><code>variable_axis_size_partitioner</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.variable_axis_size_partitioner</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_axis_size_partitioner(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.variable_axis_size_partitioner_layer">
    <p>def <span class="ident">variable_axis_size_partitioner_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.variable_axis_size_partitioner_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.variable_axis_size_partitioner_layer"><code>variable_axis_size_partitioner_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.variable_axis_size_partitioner_layer"><code>variable_axis_size_partitioner_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.variable_axis_size_partitioner_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_axis_size_partitioner_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.variable_op_scope">
    <p>def <span class="ident">variable_op_scope</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.variable_op_scope</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.variable_op_scope"><code>variable_op_scope</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.variable_op_scope"><code>variable_op_scope</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.variable_op_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_op_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.variable_op_scope_layer">
    <p>def <span class="ident">variable_op_scope_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.variable_op_scope_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.variable_op_scope_layer"><code>variable_op_scope_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.variable_op_scope_layer"><code>variable_op_scope_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.variable_op_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_op_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.variable_scope">
    <p>def <span class="ident">variable_scope</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.variable_scope</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.variable_scope"><code>variable_scope</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.variable_scope"><code>variable_scope</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.variable_scope</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_scope(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.variable_scope_layer">
    <p>def <span class="ident">variable_scope_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.variable_scope_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.variable_scope_layer"><code>variable_scope_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.variable_scope_layer"><code>variable_scope_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.variable_scope_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def variable_scope_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.verify_tensor_all_finite">
    <p>def <span class="ident">verify_tensor_all_finite</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.verify_tensor_all_finite</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.verify_tensor_all_finite"><code>verify_tensor_all_finite</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.verify_tensor_all_finite"><code>verify_tensor_all_finite</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.verify_tensor_all_finite</code></strong></p>
<div class="codehilite"><pre><span></span>    def verify_tensor_all_finite(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.verify_tensor_all_finite_layer">
    <p>def <span class="ident">verify_tensor_all_finite_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.verify_tensor_all_finite_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.verify_tensor_all_finite_layer"><code>verify_tensor_all_finite_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.verify_tensor_all_finite_layer"><code>verify_tensor_all_finite_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.verify_tensor_all_finite_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def verify_tensor_all_finite_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.weighted_cross_entropy_with_logits">
    <p>def <span class="ident">weighted_cross_entropy_with_logits</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.weighted_cross_entropy_with_logits</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.weighted_cross_entropy_with_logits"><code>weighted_cross_entropy_with_logits</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.weighted_cross_entropy_with_logits"><code>weighted_cross_entropy_with_logits</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.weighted_cross_entropy_with_logits</code></strong></p>
<div class="codehilite"><pre><span></span>    def weighted_cross_entropy_with_logits(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.weighted_cross_entropy_with_logits_layer">
    <p>def <span class="ident">weighted_cross_entropy_with_logits_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.weighted_cross_entropy_with_logits_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.weighted_cross_entropy_with_logits_layer"><code>weighted_cross_entropy_with_logits_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.weighted_cross_entropy_with_logits_layer"><code>weighted_cross_entropy_with_logits_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.weighted_cross_entropy_with_logits_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def weighted_cross_entropy_with_logits_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.where">
    <p>def <span class="ident">where</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.where</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.where"><code>where</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.where"><code>where</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.where</code></strong></p>
<div class="codehilite"><pre><span></span>    def where(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.where_layer">
    <p>def <span class="ident">where_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.where_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.where_layer"><code>where_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.where_layer"><code>where_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.where_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def where_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.while_loop">
    <p>def <span class="ident">while_loop</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.while_loop</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.while_loop"><code>while_loop</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.while_loop"><code>while_loop</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.while_loop</code></strong></p>
<div class="codehilite"><pre><span></span>    def while_loop(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.while_loop_layer">
    <p>def <span class="ident">while_loop_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.while_loop_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.while_loop_layer"><code>while_loop_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.while_loop_layer"><code>while_loop_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.while_loop_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def while_loop_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.xw_plus_b">
    <p>def <span class="ident">xw_plus_b</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.xw_plus_b</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.xw_plus_b"><code>xw_plus_b</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.xw_plus_b"><code>xw_plus_b</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.xw_plus_b</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.xw_plus_b_layer">
    <p>def <span class="ident">xw_plus_b_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.xw_plus_b_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.xw_plus_b_layer"><code>xw_plus_b_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.xw_plus_b_layer"><code>xw_plus_b_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.xw_plus_b_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.xw_plus_b_v1">
    <p>def <span class="ident">xw_plus_b_v1</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.xw_plus_b_v1</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.xw_plus_b_v1"><code>xw_plus_b_v1</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.xw_plus_b_v1"><code>xw_plus_b_v1</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.xw_plus_b_v1</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b_v1(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.xw_plus_b_v1_layer">
    <p>def <span class="ident">xw_plus_b_v1_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.xw_plus_b_v1_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.xw_plus_b_v1_layer"><code>xw_plus_b_v1_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.xw_plus_b_v1_layer"><code>xw_plus_b_v1_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.xw_plus_b_v1_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def xw_plus_b_v1_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zero_fraction">
    <p>def <span class="ident">zero_fraction</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.zero_fraction</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zero_fraction"><code>zero_fraction</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zero_fraction"><code>zero_fraction</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.zero_fraction</code></strong></p>
<div class="codehilite"><pre><span></span>    def zero_fraction(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zero_fraction_layer">
    <p>def <span class="ident">zero_fraction_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.zero_fraction_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zero_fraction_layer"><code>zero_fraction_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zero_fraction_layer"><code>zero_fraction_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.zero_fraction_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zero_fraction_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeros">
    <p>def <span class="ident">zeros</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.zeros</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeros"><code>zeros</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeros"><code>zeros</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.zeros</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeros_initializer">
    <p>def <span class="ident">zeros_initializer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.zeros_initializer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeros_initializer"><code>zeros_initializer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeros_initializer"><code>zeros_initializer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.zeros_initializer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_initializer(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeros_initializer_layer">
    <p>def <span class="ident">zeros_initializer_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.zeros_initializer_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeros_initializer_layer"><code>zeros_initializer_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeros_initializer_layer"><code>zeros_initializer_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.zeros_initializer_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_initializer_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeros_layer">
    <p>def <span class="ident">zeros_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.zeros_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeros_layer"><code>zeros_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeros_layer"><code>zeros_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.zeros_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeros_like">
    <p>def <span class="ident">zeros_like</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.zeros_like</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeros_like"><code>zeros_like</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeros_like"><code>zeros_like</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.zeros_like</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_like(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeros_like_layer">
    <p>def <span class="ident">zeros_like_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.zeros_like_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeros_like_layer"><code>zeros_like_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeros_like_layer"><code>zeros_like_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.zeros_like_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeros_like_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeta">
    <p>def <span class="ident">zeta</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>Builder.zeta</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeta"><code>zeta</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeta"><code>zeta</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>Builder.zeta</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeta(builder)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.dsl.Applicative.zeta_layer">
    <p>def <span class="ident">zeta_layer</span>(</p><p>app, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<p>This method accepts the same arguments as <code>BuilderTree.zeta_layer</code> but:</p>
<ol>
<li>Forwards all of its arguments to <a href="#tensorbuilder.dsl.zeta_layer"><code>zeta_layer</code></a>, this returns a function <code>g</code>.</li>
<li>Applies <a href="#tensorbuilder.dsl.Applicative.compose"><code>compose</code></a> over <code>g</code>, this roughly computes the composition <code>g</code> of <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</li>
</ol>
<p>So the result of this method is compose <a href="#tensorbuilder.dsl.zeta_layer"><code>zeta_layer</code></a> with <a href="#tensorbuilder.dsl.Applicative.f"><code>f</code></a>.</p>
<p><strong> utils of <code>BuilderTree.zeta_layer</code></strong></p>
<div class="codehilite"><pre><span></span>    def zeta_layer(builder, size)
</pre></div></div>
  <div class="source_cont">
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>

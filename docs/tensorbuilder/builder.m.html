<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>tensorbuilder.builder API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.builder.name">name</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.builder.f">f</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#tensorbuilder.builder.TensorBuilder">TensorBuilder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.__init__">__init__</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Assert">Assert</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Context">Context</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.DoRegisterMethod">DoRegisterMethod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Make">Make</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.NMake">NMake</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.NPipe">NPipe</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.NRun">NRun</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.NotDifferentiable">NotDifferentiable</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Pipe">Pipe</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Print">Print</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register0">Register0</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register1">Register1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register2">Register2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register3">Register3</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register4">Register4</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register5">Register5</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterFunction0">RegisterFunction0</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterFunction1">RegisterFunction1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterFunction2">RegisterFunction2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterFunction3">RegisterFunction3</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterFunction4">RegisterFunction4</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterFunction5">RegisterFunction5</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterMethod">RegisterMethod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Run">Run</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then">Then</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then0">Then0</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then1">Then1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then2">Then2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then3">Then3</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then4">Then4</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then5">Then5</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ThenAt">ThenAt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Val">Val</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.With">With</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.abs">abs</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.accumulate_n">accumulate_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.acos">acos</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add">add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_check_numerics_ops">add_check_numerics_ops</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_n">add_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_regularization_loss">add_regularization_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_to_collection">add_to_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_candidate_sampler">all_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer">all_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer">all_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_variables">all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.arg_max">arg_max</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.arg_min">arg_min</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.as_dtype">as_dtype</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.as_string">as_string</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.asin">asin</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_equal">assert_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_greater">assert_greater</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_greater_equal">assert_greater_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_integer">assert_integer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_less">assert_less</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_less_equal">assert_less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_negative">assert_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_non_negative">assert_non_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_non_positive">assert_non_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_positive">assert_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_proper_iterable">assert_proper_iterable</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_rank">assert_rank</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_rank_at_least">assert_rank_at_least</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_type">assert_type</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_variables_initialized">assert_variables_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assign">assign</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assign_add">assign_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assign_sub">assign_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atan">atan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atrous_conv2d">atrous_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer">atrous_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer">atrous_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.audio_summary">audio_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool">avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool2d">avg_pool2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d">avg_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer">avg_pool3d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_grad">avg_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer">avg_pool3d_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer">avg_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_layer">avg_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer">avg_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool_layer">avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization">batch_norm_with_global_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer">batch_norm_with_global_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer">batch_norm_with_global_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_normalization">batch_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer">batch_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_normalization_layer">batch_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_to_space">batch_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_to_space_nd">batch_to_space_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.betainc">betainc</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add">bias_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer">bias_add_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_grad">bias_add_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer">bias_add_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_grad_layer">bias_add_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_layer">bias_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_v1">bias_add_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer">bias_add_v1_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_v1_layer">bias_add_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn">bidirectional_dynamic_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer">bidirectional_dynamic_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer">bidirectional_dynamic_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_rnn">bidirectional_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer">bidirectional_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer">bidirectional_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bitcast">bitcast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.boolean_mask">boolean_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.case">case</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cast">cast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ceil">ceil</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.check_numerics">check_numerics</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cholesky">cholesky</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cholesky_solve">cholesky_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_average_norm">clip_by_average_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_global_norm">clip_by_global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_norm">clip_by_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_value">clip_by_value</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.complex">complex</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.complex_abs">complex_abs</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.compute_accidental_hits">compute_accidental_hits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer">compute_accidental_hits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer">compute_accidental_hits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.concat">concat</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cond">cond</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conj">conj</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.constant">constant</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.constant_initializer">constant_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.container">container</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.control_dependencies">control_dependencies</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv1d">conv1d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer">conv1d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv1d_layer">conv1d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d">conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter">conv2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer">conv2d_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer">conv2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_input">conv2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer">conv2d_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer">conv2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer">conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_layer">conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_transpose">conv2d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer">conv2d_transpose_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer">conv2d_transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d">conv3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter">conv3d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer">conv3d_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer">conv3d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2">conv3d_backprop_filter_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer">conv3d_backprop_filter_v2_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer">conv3d_backprop_filter_v2_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input">conv3d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer">conv3d_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer">conv3d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2">conv3d_backprop_input_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer">conv3d_backprop_input_v2_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer">conv3d_backprop_input_v2_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer">conv3d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_layer">conv3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_transpose">conv3d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer">conv3d_transpose_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer">conv3d_transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convert_to_tensor">convert_to_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices">convert_to_tensor_or_indexed_slices</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convolution2d">convolution2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cos">cos</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.count_up_to">count_up_to</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.create_partitioned_variables">create_partitioned_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.crelu">crelu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer">crelu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.crelu_layer">crelu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cross">cross</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder">ctc_beam_search_decoder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer">ctc_beam_search_decoder_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer">ctc_beam_search_decoder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder">ctc_greedy_decoder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer">ctc_greedy_decoder_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer">ctc_greedy_decoder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_loss">ctc_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer">ctc_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_loss_layer">ctc_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cumprod">cumprod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cumsum">cumsum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.data">data</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_base64">decode_base64</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_csv">decode_csv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_json_example">decode_json_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_raw">decode_raw</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.delete_session_tensor">delete_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depth_to_space">depth_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d">depthwise_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer">depthwise_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer">depthwise_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native">depthwise_conv2d_native</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter">depthwise_conv2d_native_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer">depthwise_conv2d_native_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer">depthwise_conv2d_native_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input">depthwise_conv2d_native_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer">depthwise_conv2d_native_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer">depthwise_conv2d_native_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer">depthwise_conv2d_native_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer">depthwise_conv2d_native_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.deserialize_many_sparse">deserialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.device">device</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.diag">diag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.diag_part">diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.digamma">digamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d">dilation2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter">dilation2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer">dilation2d_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer">dilation2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input">dilation2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer">dilation2d_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer">dilation2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer">dilation2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_layer">dilation2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.div">div</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.drop_layer">drop_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dropout">dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer">dropout_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dropout_layer">dropout_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_partition">dynamic_partition</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_rnn">dynamic_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer">dynamic_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer">dynamic_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_stitch">dynamic_stitch</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.edit_distance">edit_distance</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.einsum">einsum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.elu">elu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.elu_conv2d_layer">elu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.elu_layer">elu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup">embedding_lookup</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer">embedding_lookup_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_layer">embedding_lookup_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse">embedding_lookup_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer">embedding_lookup_sparse_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer">embedding_lookup_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.encode_base64">encode_base64</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ensamble_dropout">ensamble_dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.equal">equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erf">erf</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erfc">erfc</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erosion2d">erosion2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer">erosion2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erosion2d_layer">erosion2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.exp">exp</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.expand_dims">expand_dims</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.extract_image_patches">extract_image_patches</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fft">fft</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fft2d">fft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fft3d">fft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fill">fill</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_size_partitioner">fixed_size_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler">fixed_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer">fixed_unigram_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer">fixed_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.flatten">flatten</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.floor">floor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.floordiv">floordiv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.foldl">foldl</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.foldr">foldr</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_avg_pool">fractional_avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer">fractional_avg_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer">fractional_avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_max_pool">fractional_max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer">fractional_max_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer">fractional_max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d">fused_resize_and_pad_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer">fused_resize_and_pad_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer">fused_resize_and_pad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.gather">gather</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.gather_nd">gather_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_collection">get_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_collection_ref">get_collection_ref</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_default_graph">get_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_default_session">get_default_session</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_seed">get_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_session_handle">get_session_handle</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_session_tensor">get_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_variable">get_variable</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_variable_scope">get_variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.global_norm">global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.gradients">gradients</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.greater">greater</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.greater_equal">greater_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.group">group</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.histogram_fixed_width">histogram_fixed_width</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.histogram_summary">histogram_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.identity">identity</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ifft">ifft</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ifft2d">ifft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ifft3d">ifft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.igamma">igamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.igammac">igammac</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.imag">imag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.image_summary">image_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.import_graph_def">import_graph_def</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.in_top_k">in_top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer">in_top_k_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.in_top_k_layer">in_top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.inception_layer">inception_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_all_tables">initialize_all_tables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_all_variables">initialize_all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_local_variables">initialize_local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_variables">initialize_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.inv">inv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.invert_permutation">invert_permutation</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_finite">is_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_inf">is_inf</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_nan">is_nan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_non_decreasing">is_non_decreasing</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_numeric_tensor">is_numeric_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_strictly_increasing">is_strictly_increasing</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_variable_initialized">is_variable_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_loss">l2_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer">l2_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_loss_layer">l2_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_normalize">l2_normalize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer">l2_normalize_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_normalize_layer">l2_normalize_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lbeta">lbeta</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler">learned_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer">learned_unigram_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer">learned_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.less">less</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.less_equal">less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lgamma">lgamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lin_space">lin_space</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.linear_conv2d_layer">linear_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.linear_layer">linear_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.list_diff">list_diff</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.load_file_system_library">load_file_system_library</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.load_op_library">load_op_library</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer">local_response_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_response_normalization_layer">local_response_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_variables">local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log">log</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_poisson_loss">log_poisson_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer">log_poisson_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer">log_poisson_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_softmax">log_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer">log_softmax_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_softmax_layer">log_softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler">log_uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer">log_uniform_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer">log_uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_and">logical_and</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_not">logical_not</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_or">logical_or</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_xor">logical_xor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lrn">lrn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer">lrn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lrn_layer">lrn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_all">make_all</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer">make_all_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_all_layer">make_all_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_audio_summary">make_audio_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_histogram_summary">make_histogram_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_image_summary">make_image_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_merge_summary">make_merge_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_scalar_summary">make_scalar_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_template">make_template</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.map_fn">map_fn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matching_files">matching_files</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matmul">matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_band_part">matrix_band_part</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_determinant">matrix_determinant</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_diag">matrix_diag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_diag_part">matrix_diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_inverse">matrix_inverse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_set_diag">matrix_set_diag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_solve">matrix_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_solve_ls">matrix_solve_ls</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_transpose">matrix_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_triangular_solve">matrix_triangular_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool">max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool2d">max_pool2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d">max_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer">max_pool3d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_grad">max_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer">max_pool3d_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer">max_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_layer">max_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer">max_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_layer">max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_with_argmax">max_pool_with_argmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer">max_pool_with_argmax_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer">max_pool_with_argmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.maximize">maximize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.maximum">maximum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.merge_all_summaries">merge_all_summaries</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.merge_summary">merge_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.meshgrid">meshgrid</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner">min_max_variable_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.minimize">minimize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.minimum">minimum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.mod">mod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.model_variables">model_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moments">moments</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moments_conv2d_layer">moments_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moments_layer">moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moving_average_variables">moving_average_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.mul">mul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.multinomial">multinomial</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.name_scope">name_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.nce_loss">nce_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer">nce_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.nce_loss_layer">nce_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.neg">neg</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.no_op">no_op</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.no_regularizer">no_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.normalize_moments">normalize_moments</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer">normalize_moments_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.normalize_moments_layer">normalize_moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.not_equal">not_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.one_hot">one_hot</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ones">ones</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ones_initializer">ones_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ones_like">ones_like</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.op_scope">op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pack">pack</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pad">pad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_example">parse_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_single_example">parse_single_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_single_sequence_example">parse_single_sequence_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_tensor">parse_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.placeholder">placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.placeholder_with_default">placeholder_with_default</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.polygamma">polygamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.polynomial_layer">polynomial_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pow">pow</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.py_func">py_func</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_crop">random_crop</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_gamma">random_gamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_normal">random_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_normal_initializer">random_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_shuffle">random_shuffle</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_uniform">random_uniform</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_uniform_initializer">random_uniform_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.range">range</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rank">rank</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.raw_rnn">raw_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer">raw_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.raw_rnn_layer">raw_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.read_file">read_file</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.real">real</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_all">reduce_all</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_any">reduce_any</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_join">reduce_join</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_logsumexp">reduce_logsumexp</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_max">reduce_max</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_mean">reduce_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_min">reduce_min</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_prod">reduce_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_sum">reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function">register_tensor_conversion_function</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu">relu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu6">relu6</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer">relu6_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu6_layer">relu6_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu_conv2d_layer">relu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu_layer">relu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.report_uninitialized_variables">report_uninitialized_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings">required_space_to_batch_paddings</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reset_default_graph">reset_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reshape">reshape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reverse">reverse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reverse_sequence">reverse_sequence</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn">rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer">rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_layer">rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state">rnn_placeholders_from_state</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict">rnn_state_feed_dict</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.round">round</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rsqrt">rsqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sampled_softmax_loss">sampled_softmax_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer">sampled_softmax_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer">sampled_softmax_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.saturate_cast">saturate_cast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scalar_mul">scalar_mul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scalar_summary">scalar_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scan">scan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_add">scatter_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_div">scatter_div</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_mul">scatter_mul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_sub">scatter_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_update">scatter_update</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_max">segment_max</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_mean">segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_min">segment_min</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_prod">segment_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_sum">segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.select">select</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.self_adjoint_eig">self_adjoint_eig</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals">self_adjoint_eigvals</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.separable_conv2d">separable_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer">separable_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.separable_conv2d_layer">separable_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sequence_mask">sequence_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.serialize_many_sparse">serialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.serialize_sparse">serialize_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.set_random_seed">set_random_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.shape">shape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.shape_n">shape_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid">sigmoid</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer">sigmoid_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits">sigmoid_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer">sigmoid_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer">sigmoid_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_layer">sigmoid_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sign">sign</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sin">sin</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.size">size</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.slice">slice</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax">softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer">softmax_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits">softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer">softmax_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer">softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_layer">softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softplus">softplus</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer">softplus_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softplus_layer">softplus_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softsign">softsign</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer">softsign_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softsign_layer">softsign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.space_to_batch">space_to_batch</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.space_to_batch_nd">space_to_batch_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.space_to_depth">space_to_depth</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_add">sparse_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_concat">sparse_concat</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows">sparse_fill_empty_rows</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_mask">sparse_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_maximum">sparse_maximum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_merge">sparse_merge</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_minimum">sparse_minimum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_placeholder">sparse_placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reduce_sum">sparse_reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse">sparse_reduce_sum_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reorder">sparse_reorder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reset_shape">sparse_reset_shape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reshape">sparse_reshape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_retain">sparse_retain</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_segment_mean">sparse_segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n">sparse_segment_sqrt_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_segment_sum">sparse_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax">sparse_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits">sparse_softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer">sparse_softmax_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer">sparse_softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_split">sparse_split</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul">sparse_tensor_dense_matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense">sparse_tensor_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_to_dense">sparse_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_to_indicator">sparse_to_indicator</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_transpose">sparse_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.split">split</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sqrt">sqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.square">square</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.squared_difference">squared_difference</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.squeeze">squeeze</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.state_saving_rnn">state_saving_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer">state_saving_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer">state_saving_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.stop_gradient">stop_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.strided_slice">strided_slice</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_join">string_join</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_split">string_split</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_hash_bucket">string_to_hash_bucket</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast">string_to_hash_bucket_fast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong">string_to_hash_bucket_strong</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_number">string_to_number</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sub">sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sufficient_statistics">sufficient_statistics</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer">sufficient_statistics_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer">sufficient_statistics_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.svd">svd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tan">tan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tanh">tanh</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer">tanh_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tanh_layer">tanh_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tile">tile</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_bfloat16">to_bfloat16</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_double">to_double</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_float">to_float</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_int32">to_int32</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_int64">to_int64</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.top_k">top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer">top_k_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.top_k_layer">top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.trace">trace</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.trainable_variables">trainable_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.transpose">transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truediv">truediv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truncated_normal">truncated_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truncated_normal_initializer">truncated_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tuple">tuple</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler">uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer">uniform_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer">uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer">uniform_unit_scaling_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unique">unique</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unique_with_counts">unique_with_counts</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unpack">unpack</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unsorted_segment_sum">unsorted_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner">variable_axis_size_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variable_op_scope">variable_op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variable_scope">variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite">verify_tensor_all_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits">weighted_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer">weighted_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer">weighted_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.where">where</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.while_loop">while_loop</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b">xw_plus_b</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer">xw_plus_b_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_layer">xw_plus_b_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_v1">xw_plus_b_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer">xw_plus_b_v1_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer">xw_plus_b_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zero_fraction">zero_fraction</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer">zero_fraction_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zero_fraction_layer">zero_fraction_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeros">zeros</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeros_initializer">zeros_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeros_like">zeros_like</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeta">zeta</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">tensorbuilder.builder</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder" class="source">
    <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi.builder</span> <span class="kn">import</span> <span class="n">Builder</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">tensordata</span> <span class="kn">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">class</span> <span class="nc">TensorBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for TensorBuilder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">TensorBuilder</span><span class="o">.</span><span class="n">__core__</span> <span class="o">=</span> <span class="p">[</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">TensorBuilder</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">)</span> <span class="p">]</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="tensorbuilder.builder.name" class="name">var <span class="ident">name</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.f">
    <p>def <span class="ident">f</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.f', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.f" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="tensorbuilder.builder.TensorBuilder" class="name">class <span class="ident">TensorBuilder</span></p>
      
  
    <div class="desc"><p>docstring for TensorBuilder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TensorBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for TensorBuilder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#tensorbuilder.builder.TensorBuilder">TensorBuilder</a></li>
          <li>phi.builder.Builder</li>
          <li>phi.lambdas.Lambda</li>
          <li>phi.dsl.Function</li>
          <li>phi.dsl.Node</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.If" class="name">var <span class="ident">If</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Ref" class="name">var <span class="ident">Ref</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Obj" class="name">var <span class="ident">Obj</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Read" class="name">var <span class="ident">Read</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Rec" class="name">var <span class="ident">Rec</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Write" class="name">var <span class="ident">Write</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.layers" class="name">var <span class="ident">layers</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">Lambda</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Assert">
    <p>def <span class="ident">Assert</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.Assert(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.Assert</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.Assert(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.Assert(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.Assert</strong></p>
<div class="codehilite"><pre><span></span>Asserts that the given condition is true.
</pre></div>


<p>If <code>condition</code> evaluates to false, print the list of tensors in <code>data</code>.
<code>summarize</code> determines how many entries of the tensors to print.</p>
<p>NOTE: To ensure that Assert executes, one usually attaches a dependency:</p>
<p><code>python
 # Ensure maximum element of x is smaller or equal to 1
assert_op = tf.Assert(tf.less_equal(tf.reduce_max(x), 1.), [x])
x = tf.with_dependencies([assert_op], x)</code></p>
<p>Args:
  condition: The condition to evaluate.
  data: The tensors to print out when condition is false.
  summarize: Print this many entries of each tensor.
  name: A name for this operation (optional).</p>
<p>Returns:
  assert_op: An <code>Operation</code> that, when executed, raises a
  <code>tf.errors.InvalidArgumentError</code> if <code>condition</code> is not true.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Assert', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Assert" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Context">
    <p>def <span class="ident">Context</span>(</p><p>cls, *args)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>Builder Core</strong>. Also available as a global function as <code>phi.Context</code>.</p>
<p>Returns the context object of the current <code>dsl.With</code> statemente.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong>: By design <code>Context</code> accepts any number of arguments and completely ignores them.</li>
</ul>
<p>This is a classmethod and it doesnt return a <code>Builder</code>/<code>Lambda</code> by design so it can be called directly:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span>
        <span class="n">read_file</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Here we called <code>Context</code> with no arguments to get the context back, however, since you can also give this function an argument (which it will ignore) it can be passed to the DSL so we can rewrite the previous as:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Obj</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span>
        <span class="n">Context</span><span class="p">,</span> <span class="c1"># f</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p><code>Context</code> yields an exception when used outside of a <code>With</code> block.</p>
<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Context', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Context" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Context</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ilder Core**. Also available as a global function as `phi.Context`.</span>
<span class="sd">rns the context object of the current `dsl.With` statemente.</span>
<span class="sd">guments**</span>
<span class="sd">*args**: By design `Context` accepts any number of arguments and completely ignores them.</span>
<span class="sd"> is a classmethod and it doesnt return a `Builder`/`Lambda` by design so it can be called directly:</span>
<span class="sd">from phi import P, Context, Obj</span>
<span class="sd">def read_file(z):</span>
<span class="sd">    f = Context()</span>
<span class="sd">    return f.read()</span>
<span class="sd">lines = P.Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    P.With( open,</span>
<span class="sd">        read_file,</span>
<span class="sd">        Obj.split(&quot;\\n&quot;)</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd"> we called `Context` with no arguments to get the context back, however, since you can also give this function an argument (which it will ignore) it can be passed to the DSL so we can rewrite the previous as:</span>
<span class="sd">from phi import P, Context, Obj</span>
<span class="sd">lines = P.Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    P.With( open,</span>
<span class="sd">        Context, # f</span>
<span class="sd">        Obj.read()</span>
<span class="sd">        Obj.split(&quot;\\n&quot;)</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">text` yields an exception when used outside of a `With` block.</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Obj`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dsl</span><span class="o">.</span><span class="n">With</span><span class="o">.</span><span class="n">GLOBAL_CONTEXT</span> <span class="ow">is</span> <span class="n">dsl</span><span class="o">.</span><span class="n">_NO_VALUE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot use &#39;Context&#39; outside of a &#39;With&#39; block&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dsl</span><span class="o">.</span><span class="n">With</span><span class="o">.</span><span class="n">GLOBAL_CONTEXT</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.DoRegisterMethod">
    <p>def <span class="ident">DoRegisterMethod</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True)</p>
    </div>
    

    
  
    <div class="desc"><p>This method enables you to register any function <code>fn</code> that takes an Applicative as its first argument as a method of the Builder class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>fn</code>: a function that atleast takes an Applicative as its first argument.</li>
<li><code>library_path</code>: the route of the librar from which this function was taken, used for documentation purposes.</li>
<li><code>alias</code>: allows you to specify the name of the method, it will take the name of the function if its <code>None</code>.</li>
<li><code>doc</code>: the documentation for the method, if <code>None</code> a predefied documentation will be generated based on the documentation of <code>fn</code>.</li>
</ul>
<p><strong>Return</strong></p>
<p><code>None</code></p>
<p><strong>Examples</strong></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.DoRegisterMethod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.DoRegisterMethod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">DoRegisterMethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method enables you to register any function `fn` that takes an Applicative as its first argument as a method of the Builder class.</span>
<span class="sd">    **Arguments**</span>
<span class="sd">    * `fn`: a function that atleast takes an Applicative as its first argument.</span>
<span class="sd">    * `library_path`: the route of the librar from which this function was taken, used for documentation purposes.</span>
<span class="sd">    * `alias`: allows you to specify the name of the method, it will take the name of the function if its `None`.</span>
<span class="sd">    * `doc`: the documentation for the method, if `None` a predefied documentation will be generated based on the documentation of `fn`.</span>
<span class="sd">    **Return**</span>
<span class="sd">    `None`</span>
<span class="sd">    **Examples**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wrapped</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">fn_signature</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_method_sig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
 	<span class="n">fn_docs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getdoc</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">alias</span> <span class="k">if</span> <span class="n">alias</span> <span class="k">else</span> <span class="n">fn</span><span class="o">.</span><span class="n">__name__</span>
    <span class="n">original_name</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">__name__</span> <span class="k">if</span> <span class="n">wrapped</span> <span class="k">else</span> <span class="n">original_name</span> <span class="k">if</span> <span class="n">original_name</span> <span class="k">else</span> <span class="n">name</span>
    <span class="n">fn</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">fn</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doc</span> <span class="k">if</span> <span class="n">doc</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> METHOD IS AUTOMATICALLY GENERATED</span>
<span class="s2">builder.{1}(*args, **kwargs)</span>
<span class="s2">ccepts the same arguments as `{3}.{0}`. &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">}.{0}**</span>
<span class="s2">{2}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">original_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn_docs</span><span class="p">,</span> <span class="n">library_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="n">fn_docs</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__core__</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can&#39;t add method &#39;{0}&#39; because its on __core__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">method_type</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Make">
    <p>def <span class="ident">Make</span>(</p><p>self, *code, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>The <code>Make</code> method takes an expression from the DSL and compiles it to a function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*code</strong>: any expression from the DSL.<code>code</code> is implicitly a <code>tuple</code> since that is what Python gives you when you declare a <a href="https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists">Variadic Function</a>, therefore, according to the rules of the DSL, all expressions inside of <code>code</code> will be composed together. See <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Composition">Composition</a>.</li>
<li><em>flatten = False</em>: if <code>flatten</code> is True and the argument being returned by the compiled function is a <code>list</code> it will instead return a flattened list.</li>
<li><em>_return_type = None</em>: By default <code>Make</code> returns an object of the same class e.g. <code>Builder</code>, however you can pass in a custom class that inherits from <code>Builder</code> as the returned contianer. This is useful if the custom builder has specialized methods.</li>
<li><em>create_ref_context = True</em>: determines if a reference manager should be created on compilation. See <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a>.</li>
<li><em>refs = True</em>: external/default values for references passed during compilation. See <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a>.</li>
</ul>
<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">mul3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Make</span><span class="p">(</span>
    <span class="n">add1</span><span class="p">,</span>
    <span class="n">mul3</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p>Here <code>f</code> is equivalent to</p>
<p>def f(x):
    x = add1(x)
    x = mul3(x)
    return x</p>
<p>The previous example using <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a> to create the functions</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Make</span><span class="p">(</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">3</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
<li><a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a>
**</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Make', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Make" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Make</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">`Make` method takes an expression from the DSL and compiles it to a function.</span>
<span class="sd">guments**</span>
<span class="sd">*code**: any expression from the DSL.`code` is implicitly a `tuple` since that is what Python gives you when you declare a [Variadic Function](https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists), therefore, according to the rules of the DSL, all expressions inside of `code` will be composed together. See [Composition](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Composition).</span>
<span class="sd">latten = False*: if `flatten` is True and the argument being returned by the compiled function is a `list` it will instead return a flattened list.</span>
<span class="sd">return_type = None*: By default `Make` returns an object of the same class e.g. `Builder`, however you can pass in a custom class that inherits from `Builder` as the returned contianer. This is useful if the custom builder has specialized methods.</span>
<span class="sd">reate_ref_context = True*: determines if a reference manager should be created on compilation. See [Compile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile).</span>
<span class="sd">efs = True*: external/default values for references passed during compilation. See [Compile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile).</span>
<span class="sd">amples**</span>
<span class="sd">from phi import P</span>
<span class="sd">def add1(x): return x + 1</span>
<span class="sd">def mul3(x): return x * 3</span>
<span class="sd">f = P.Make(</span>
<span class="sd">    add1,</span>
<span class="sd">    mul3</span>
<span class="sd">)</span>
<span class="sd">assert f(1) == 6</span>
<span class="sd"> `f` is equivalent to</span>
<span class="sd">f(x):</span>
<span class="sd">x = add1(x)</span>
<span class="sd">x = mul3(x)</span>
<span class="sd">return x</span>
<span class="sd">previous example using [lambdas](https://cgarciae.github.io/phi/lambdas.m.html) to create the functions</span>
<span class="sd">from phi import P</span>
<span class="sd">f = P.Make(</span>
<span class="sd">    P + 1,</span>
<span class="sd">    P * 3</span>
<span class="sd">)</span>
<span class="sd">assert f(1) == 6</span>
<span class="sd">so see**</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">ambdas](https://cgarciae.github.io/phi/lambdas.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_return_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_return_type&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">flatten</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;flatten&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">refs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;refs&#39;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">create_ref_context</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;create_ref_context&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="c1"># code = (self, code)</span>
    <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">utils</span><span class="o">.</span><span class="n">flatten_list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">dsl</span><span class="o">.</span><span class="n">Compile</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">refs</span><span class="p">,</span> <span class="n">create_ref_context</span><span class="o">=</span><span class="n">create_ref_context</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.NMake">
    <p>def <span class="ident">NMake</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>NMake</code> is shortcut for <code>Make(..., create_ref_context=False)</code>, its full name should be <em>NoCreateRefContextMake</em> but its impractically long. Normally methods that <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">compile</a> DSL expressions like <code>phi.builder.Builder.Make</code> or <code>phi.builder.Builder.Pipe</code> create a reference context unless especified, these contexts encapsulate references (see <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read">read</a> or <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write">write</a>) and prevent them from leaking, which is good. There are times however when you consciously want a sub-Make or sub-Pipe expression to read or write references from the main Make or Pipe expression, for this you need to set <code>create_ref_context</code> to <code>False</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>Same arguments as <code>phi.builder.Builder.Make</code> but...</li>
<li><strong>create_ref_context</strong> is hardcoded to <code>False</code></li>
</ul>
<p><strong>Examples</strong></p>
<p>If you compile a sub expression as a function for another expression e.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span> <span class="c1"># write s == 1, outer context</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Make</span><span class="p">(</span>
        <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">}</span> <span class="c1"># write s == 2, inner context</span>
    <span class="p">),</span>
    <span class="s1">&#39;s&#39;</span>  <span class="c1"># read s == 1, outer context</span>
<span class="p">)</span>
</pre></div>


<p>you find that references are not shared. However if you avoid the creation of a new reference context via a keyword arguments</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span>   <span class="c1">#write s == 1, same context</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Make</span><span class="p">(</span>
        <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span>   <span class="c1">#write s == 2, same context</span>
        <span class="n">create_ref_context</span><span class="o">=</span><span class="bp">False</span>
    <span class="p">),</span>
    <span class="s1">&#39;s&#39;</span>   <span class="c1"># read s == 2, same context</span>
<span class="p">)</span>
</pre></div>


<p>you can achieve what you want. Yet writting <code>create_ref_context=False</code> is a little cumbersome, so to make things nicer we just use a shortcut by appending an <code>N</code> at the beggining of the <code>NMake</code> method</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span>   <span class="c1">#write s == 1, same context</span>
    <span class="n">P</span><span class="o">.</span><span class="n">NMake</span><span class="p">(</span>
        <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">}</span>   <span class="c1">#write s == 2, same context</span>
    <span class="p">),</span>
    <span class="s1">&#39;s&#39;</span>   <span class="c1"># read s == 2, same context</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Make</code></li>
<li><code>phi.builder.Builder.NPipe</code></li>
<li><code>phi.builder.Builder.NRun</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.NMake', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.NMake" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">NMake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ke` is shortcut for `Make(..., create_ref_context=False)`, its full name should be *NoCreateRefContextMake* but its impractically long. Normally methods that [compile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile) DSL expressions like `phi.builder.Builder.Make` or `phi.builder.Builder.Pipe` create a reference context unless especified, these contexts encapsulate references (see [read](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read) or [write](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write)) and prevent them from leaking, which is good. There are times however when you consciously want a sub-Make or sub-Pipe expression to read or write references from the main Make or Pipe expression, for this you need to set `create_ref_context` to `False`.</span>
<span class="sd">guments**</span>
<span class="sd">me arguments as `phi.builder.Builder.Make` but...</span>
<span class="sd">create_ref_context** is hardcoded to `False`</span>
<span class="sd">amples**</span>
<span class="sd">ou compile a sub expression as a function for another expression e.g.</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 1 == P.Pipe(</span>
<span class="sd">    1, {&#39;s&#39;}, # write s == 1, outer context</span>
<span class="sd">    P.Make(</span>
<span class="sd">        P + 1, {&#39;s&#39;} # write s == 2, inner context</span>
<span class="sd">    ),</span>
<span class="sd">    &#39;s&#39;  # read s == 1, outer context</span>
<span class="sd">)</span>
<span class="sd">find that references are not shared. However if you avoid the creation of a new reference context via a keyword arguments</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 2 == P.Pipe(</span>
<span class="sd">    1, {&#39;s&#39;},   #write s == 1, same context</span>
<span class="sd">    P.Make(</span>
<span class="sd">        P + 1, {&#39;s&#39;},   #write s == 2, same context</span>
<span class="sd">        create_ref_context=False</span>
<span class="sd">    ),</span>
<span class="sd">    &#39;s&#39;   # read s == 2, same context</span>
<span class="sd">)</span>
<span class="sd">can achieve what you want. Yet writting `create_ref_context=False` is a little cumbersome, so to make things nicer we just use a shortcut by appending an `N` at the beggining of the `NMake` method</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 2 == P.Pipe(</span>
<span class="sd">    1, {&#39;s&#39;},   #write s == 1, same context</span>
<span class="sd">    P.NMake(</span>
<span class="sd">        P + 1, {&#39;s&#39;}   #write s == 2, same context</span>
<span class="sd">    ),</span>
<span class="sd">    &#39;s&#39;   # read s == 2, same context</span>
<span class="sd">)</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Make`</span>
<span class="sd">hi.builder.Builder.NPipe`</span>
<span class="sd">hi.builder.Builder.NRun`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;create_ref_context&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Make</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.NPipe">
    <p>def <span class="ident">NPipe</span>(</p><p>self, x, *code, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>NPipe</code> is shortcut for <code>Pipe(..., create_ref_context=False)</code>, its full name should be <em>NoCreateRefContextPipe</em> but its impractically long. Normally methods that <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">compile</a> DSL expressions like <code>phi.builder.Builder.Make</code> or <code>phi.builder.Builder.Pipe</code> create a reference context unless especified, these contexts encapsulate references (see <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read">read</a> or <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write">write</a>) and prevent them from leaking, which is good. There are times however when you consciously want a sub-Make or sub-Pipe expression to read or write references from the main Make or Pipe expression, for this you need to set <code>create_ref_context</code> to <code>False</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>Same arguments as <code>phi.builder.Builder.Pipe</code> but...</li>
<li><strong>create_ref_context</strong> is hardcoded to <code>False</code></li>
</ul>
<p><strong>Examples</strong></p>
<p>If you compile a sub expression as a function for another expression e.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span> <span class="c1"># write s == 1, outer context</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">}</span> <span class="c1"># write s == 2, inner context</span>
    <span class="p">),</span>
    <span class="s1">&#39;s&#39;</span>  <span class="c1"># read s == 1, outer context</span>
<span class="p">)</span>
</pre></div>


<p>you find that references are not shared. However if you avoid the creation of a new reference context via a keyword arguments</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span>   <span class="c1">#write s == 1, same context</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span>   <span class="c1">#write s == 2, same context</span>
        <span class="n">create_ref_context</span><span class="o">=</span><span class="bp">False</span>
    <span class="p">),</span>
    <span class="s1">&#39;s&#39;</span>   <span class="c1"># read s == 2, same context</span>
<span class="p">)</span>
</pre></div>


<p>you can achieve what you want. Yet writting <code>create_ref_context=False</code> is a little cumbersome, so to make things nicer we just use a shortcut by appending an <code>N</code> at the beggining of the <code>NPipe</code> method</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">},</span>   <span class="c1">#write s == 1, same context</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">NPipe</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">}</span>   <span class="c1">#write s == 2, same context</span>
    <span class="p">),</span>
    <span class="s1">&#39;s&#39;</span>   <span class="c1"># read s == 2, same context</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Pipe</code></li>
<li><code>phi.builder.Builder.NMake</code></li>
<li><code>phi.builder.Builder.NRun</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.NPipe', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.NPipe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">NPipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">pe` is shortcut for `Pipe(..., create_ref_context=False)`, its full name should be *NoCreateRefContextPipe* but its impractically long. Normally methods that [compile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile) DSL expressions like `phi.builder.Builder.Make` or `phi.builder.Builder.Pipe` create a reference context unless especified, these contexts encapsulate references (see [read](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read) or [write](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write)) and prevent them from leaking, which is good. There are times however when you consciously want a sub-Make or sub-Pipe expression to read or write references from the main Make or Pipe expression, for this you need to set `create_ref_context` to `False`.</span>
<span class="sd">guments**</span>
<span class="sd">me arguments as `phi.builder.Builder.Pipe` but...</span>
<span class="sd">create_ref_context** is hardcoded to `False`</span>
<span class="sd">amples**</span>
<span class="sd">ou compile a sub expression as a function for another expression e.g.</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 1 == P.Pipe(</span>
<span class="sd">    1, {&#39;s&#39;}, # write s == 1, outer context</span>
<span class="sd">    lambda x: P.Pipe(</span>
<span class="sd">        x,</span>
<span class="sd">        P + 1, {&#39;s&#39;} # write s == 2, inner context</span>
<span class="sd">    ),</span>
<span class="sd">    &#39;s&#39;  # read s == 1, outer context</span>
<span class="sd">)</span>
<span class="sd">find that references are not shared. However if you avoid the creation of a new reference context via a keyword arguments</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 2 == P.Pipe(</span>
<span class="sd">    1, {&#39;s&#39;},   #write s == 1, same context</span>
<span class="sd">    lambda x: P.Pipe(</span>
<span class="sd">        x,</span>
<span class="sd">        P + 1, {&#39;s&#39;},   #write s == 2, same context</span>
<span class="sd">        create_ref_context=False</span>
<span class="sd">    ),</span>
<span class="sd">    &#39;s&#39;   # read s == 2, same context</span>
<span class="sd">)</span>
<span class="sd">can achieve what you want. Yet writting `create_ref_context=False` is a little cumbersome, so to make things nicer we just use a shortcut by appending an `N` at the beggining of the `NPipe` method</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 2 == P.Pipe(</span>
<span class="sd">    1, {&#39;s&#39;},   #write s == 1, same context</span>
<span class="sd">    lambda x: P.NPipe(</span>
<span class="sd">        x,</span>
<span class="sd">        P + 1, {&#39;s&#39;}   #write s == 2, same context</span>
<span class="sd">    ),</span>
<span class="sd">    &#39;s&#39;   # read s == 2, same context</span>
<span class="sd">)</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Pipe`</span>
<span class="sd">hi.builder.Builder.NMake`</span>
<span class="sd">hi.builder.Builder.NRun`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMake</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.NRun">
    <p>def <span class="ident">NRun</span>(</p><p>self, *code, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>NRun</code> is shortcut for <code>Run(..., create_ref_context=False)</code>, its full name should be <em>NoCreateRefContextRun</em> but its impractically long.</p>
<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Run</code></li>
<li><code>phi.builder.Builder.NMake</code></li>
<li><code>phi.builder.Builder.NPipe</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.NRun', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.NRun" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">NRun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n` is shortcut for `Run(..., create_ref_context=False)`, its full name should be *NoCreateRefContextRun* but its impractically long.</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Run`</span>
<span class="sd">hi.builder.Builder.NMake`</span>
<span class="sd">hi.builder.Builder.NPipe`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">NPipe</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.NotDifferentiable">
    <p>def <span class="ident">NotDifferentiable</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.NotDifferentiable(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.NotDifferentiable</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.NotDifferentiable(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.NotDifferentiable(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.NotDifferentiable</strong></p>
<div class="codehilite"><pre><span></span>Specifies that ops of type `op_type` is not differentiable.
</pre></div>


<p>This function should <em>not</em> be used for operations that have a
well-defined gradient that is not yet implemented.</p>
<p>This function is only used when defining a new op type. It may be
used for ops such as <code>tf.size()</code> that are not differentiable.  For
example:</p>
<p><code>python
tf.NotDifferentiable("Size")</code></p>
<p>The gradient computed for 'op_type' will then propagate zeros.</p>
<p>For ops that have a well-defined gradient but are not yet implemented,
no declaration should be made, and an error <em>must</em> be thrown if
an attempt to request its gradient is made.</p>
<p>Args:
  op_type: The string type of an operation. This corresponds to the
    <code>OpDef.name</code> field for the proto that defines the operation.</p>
<p>Raises:
  TypeError: If <code>op_type</code> is not a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.NotDifferentiable', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.NotDifferentiable" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Pipe">
    <p>def <span class="ident">Pipe</span>(</p><p>self, x, *code, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Pipe</code> is method that takes an input argument plus an expression from the DSL, it compiles the expression and applies the resulting function to the input. Its highly inspired by Elixir's <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2">|&gt; (pipe)</a> operator.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>x</strong>: any input object</li>
<li><strong>*code</strong>: any expression from the DSL.<code>code</code> is implicitly a <code>tuple</code> since that is what Python gives you when you declare a <a href="https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists">Variadic Function</a>, therefore, according to the rules of the DSL, all expressions inside of <code>code</code> will be composed together. See <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Composition">Composition</a>.</li>
<li><strong>**kwargs</strong>: <code>Pipe</code> forwards all <code>kwargs</code> to <code>phi.builder.Builder.Make</code>, visit its documentation for more info.</li>
</ul>
<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">mul3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>     <span class="c1">#input</span>
    <span class="n">add1</span><span class="p">,</span>  <span class="c1">#1 + 1 == 2</span>
    <span class="n">mul3</span>   <span class="c1">#2 * 3 == 6</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p>The previous using <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a> to create the functions</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>      <span class="c1">#input</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">#1 + 1 == 2</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">#2 * 3 == 6</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Make</code></li>
<li><code>phi.builder.Builder.Run</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
<li><a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Pipe', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Pipe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">e` is method that takes an input argument plus an expression from the DSL, it compiles the expression and applies the resulting function to the input. Its highly inspired by Elixir&#39;s [|&gt; (pipe)](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2) operator.</span>
<span class="sd">guments**</span>
<span class="sd">x**: any input object</span>
<span class="sd">*code**: any expression from the DSL.`code` is implicitly a `tuple` since that is what Python gives you when you declare a [Variadic Function](https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists), therefore, according to the rules of the DSL, all expressions inside of `code` will be composed together. See [Composition](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Composition).</span>
<span class="sd">**kwargs**: `Pipe` forwards all `kwargs` to `phi.builder.Builder.Make`, visit its documentation for more info.</span>
<span class="sd">amples**</span>
<span class="sd">from phi import P</span>
<span class="sd">def add1(x): return x + 1</span>
<span class="sd">def mul3(x): return x * 3</span>
<span class="sd">x = P.Pipe(</span>
<span class="sd">    1,     #input</span>
<span class="sd">    add1,  #1 + 1 == 2</span>
<span class="sd">    mul3   #2 * 3 == 6</span>
<span class="sd">)</span>
<span class="sd">assert x == 6</span>
<span class="sd">previous using [lambdas](https://cgarciae.github.io/phi/lambdas.m.html) to create the functions</span>
<span class="sd">from phi import P</span>
<span class="sd">x = P.Pipe(</span>
<span class="sd">    1,      #input</span>
<span class="sd">    P + 1,  #1 + 1 == 2</span>
<span class="sd">    P * 3   #2 * 3 == 6</span>
<span class="sd">)</span>
<span class="sd">assert x == 6</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Make`</span>
<span class="sd">hi.builder.Builder.Run`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">ambdas](https://cgarciae.github.io/phi/lambdas.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Make</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Print">
    <p>def <span class="ident">Print</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.Print(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.Print</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.Print(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.Print(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.Print</strong></p>
<div class="codehilite"><pre><span></span>Prints a list of tensors.
</pre></div>


<p>This is an identity op with the side effect of printing <code>data</code> when
evaluating.</p>
<p>Args:
  input_: A tensor passed through this op.
  data: A list of tensors to print out when op is evaluated.
  message: A string, prefix of the error message.
  first_n: Only log <code>first_n</code> number of times. Negative numbers log always;
           this is the default.
  summarize: Only print this many entries of each tensor. If None, then a
             maximum of 3 elements are printed per input tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same tensor as <code>input_</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Print', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Print" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register0">
    <p>def <span class="ident">Register0</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register0" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register0</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterFunction0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register1">
    <p>def <span class="ident">Register1</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register1" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register1</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">_wrapped</span> <span class="o">=</span> <span class="n">wrapped</span> <span class="k">if</span> <span class="n">wrapped</span> <span class="k">else</span> <span class="n">fn</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterFunction1</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">_wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register2">
    <p>def <span class="ident">Register2</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register2</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterFunction2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register3">
    <p>def <span class="ident">Register3</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register3" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register3</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterFunction3</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register4">
    <p>def <span class="ident">Register4</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register4" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register4</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterFunction4</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register5">
    <p>def <span class="ident">Register5</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register5" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register5</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterFunction5</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterFunction0">
    <p>def <span class="ident">RegisterFunction0</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterFunction0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterFunction0" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterFunction0</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ver, a partial with the arguments is returned which expects any argument `x` and complete ignores it, such that</span>
<span class="s2">{3}.{0}(*args, **kwargs)</span>
<span class="s2">quivalent to</span>
<span class="s2">builder.{1}(*args, **kwargs)(x)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span> <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterFunction1">
    <p>def <span class="ident">RegisterFunction1</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
    <div class="desc"><p>This method enables you to register any function <code>fn</code> that takes an object as its first argument as a method of the Builder and Applicative class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>fn</code>: a function that atleast takes an Object as its first argument.</li>
<li><code>library_path</code>: the route of the librar from which this function was taken, used for documentation purposes.</li>
<li><code>alias</code>: allows you to specify the name of the method, it will take the name of the function if its <code>None</code>.</li>
<li><code>doc</code>: the documentation for the method, if <code>None</code> a predefied documentation will be generated based on the documentation of <code>fn</code>.</li>
</ul>
<p><strong>Return</strong></p>
<p><code>None</code></p>
<p><strong>Examples</strong></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterFunction1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterFunction1" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterFunction1</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method enables you to register any function `fn` that takes an object as its first argument as a method of the Builder and Applicative class.</span>
<span class="sd">    **Arguments**</span>
<span class="sd">    * `fn`: a function that atleast takes an Object as its first argument.</span>
<span class="sd">    * `library_path`: the route of the librar from which this function was taken, used for documentation purposes.</span>
<span class="sd">    * `alias`: allows you to specify the name of the method, it will take the name of the function if its `None`.</span>
<span class="sd">    * `doc`: the documentation for the method, if `None` a predefied documentation will be generated based on the documentation of `fn`.</span>
<span class="sd">    **Return**</span>
<span class="sd">    `None`</span>
<span class="sd">    **Examples**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ver, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</span>
<span class="s2">{3}.{0}(x1, *args, **kwargs)</span>
<span class="s2">quivalent to</span>
<span class="s2">builder.{1}(*args, **kwargs)(x1)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span>  <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterFunction2">
    <p>def <span class="ident">RegisterFunction2</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterFunction2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterFunction2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterFunction2</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ver, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</span>
<span class="s2">{3}.{0}(x1, x2, *args, **kwargs)</span>
<span class="s2">quivalent to</span>
<span class="s2">builder.{1}(x1, *args, **kwargs)(x2)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span> <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterFunction3">
    <p>def <span class="ident">RegisterFunction3</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterFunction3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterFunction3" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterFunction3</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then3</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ver, the 3rd argument is omitted, a partial with the rest of the arguments is returned which expects the 3rd argument such that</span>
<span class="s2">{3}.{0}(x1, x2, x3, *args, **kwargs)</span>
<span class="s2">quivalent to</span>
<span class="s2">builder.{1}(x1, x2, *args, **kwargs)(x3)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span> <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterFunction4">
    <p>def <span class="ident">RegisterFunction4</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterFunction4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterFunction4" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterFunction4</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then4</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ver, the 4th argument is omitted, a partial with the rest of the arguments is returned which expects the 4th argument such that</span>
<span class="s2">{3}.{0}(x1, x2, x3, x4, *args, **kwargs)</span>
<span class="s2">quivalent to</span>
<span class="s2">builder.{1}(x1, x2, x3, *args, **kwargs)(x4)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span> <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterFunction5">
    <p>def <span class="ident">RegisterFunction5</span>(</p><p>cls, fn, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True, _return_type=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterFunction5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterFunction5" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterFunction5</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then5</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ver, the 5th argument is omitted, a partial with the rest of the arguments is returned which expects the 5th argument such that</span>
<span class="s2">{3}.{0}(x1, x2, x3, x4, x5, *args, **kwargs)</span>
<span class="s2">quivalent to</span>
<span class="s2">builder.{1}(x1, x2, x3, x4, *args, **kwargs)(x5)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">explanation</span> <span class="k">if</span> <span class="n">explain</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterMethod">
    <p>def <span class="ident">RegisterMethod</span>(</p><p>cls, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&#39;&#39;, method_type=&lt;function identity at 0x7fe86c6f1848&gt;, explain=True)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterMethod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterMethod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterMethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">DoRegisterMethod</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">original_name</span><span class="o">=</span><span class="n">original_name</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">,</span> <span class="n">method_type</span><span class="o">=</span><span class="n">method_type</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="n">explain</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Run">
    <p>def <span class="ident">Run</span>(</p><p>self, *code, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Run(*code, **kwargs)</code> is equivalent to <code>Pipe(None, *code, **kwargs)</code>, that is, it compiles the code and applies in a <code>None</code> value.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>Same as <code>phi.builder.Builder.Make</code>.</li>
</ul>
<p><strong>Examples</strong></p>
<p>You might create code that totally ignores its input argument e.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="bp">None</span><span class="p">,</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Val</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
            <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">),</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Val</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">P</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">9</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">25</span>
</pre></div>


<p>Here the <code>Val</code> statemente drops the <code>None</code> and introduces its own constants. Given this its more suitable to use <code>Run</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Val</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
            <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">),</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Val</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">P</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">9</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">25</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Make</code></li>
<li><code>phi.builder.Builder.Pipe</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Run', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Run" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">(*code, **kwargs)` is equivalent to `Pipe(None, *code, **kwargs)`, that is, it compiles the code and applies in a `None` value.</span>
<span class="sd">guments**</span>
<span class="sd">me as `phi.builder.Builder.Make`.</span>
<span class="sd">amples**</span>
<span class="sd">might create code that totally ignores its input argument e.g.</span>
<span class="sd">from phi import P</span>
<span class="sd">result = P.Pipe(</span>
<span class="sd">    None,</span>
<span class="sd">    dict(</span>
<span class="sd">        x = (</span>
<span class="sd">            Val(10),</span>
<span class="sd">            P + 1</span>
<span class="sd">        ),</span>
<span class="sd">        y = (</span>
<span class="sd">            Val(5),</span>
<span class="sd">            P * 5</span>
<span class="sd">        )</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">assert result.x == 9</span>
<span class="sd">assert result.y == 25</span>
<span class="sd"> the `Val` statemente drops the `None` and introduces its own constants. Given this its more suitable to use `Run`</span>
<span class="sd">from phi import P</span>
<span class="sd">result = P.Run(</span>
<span class="sd">    dict(</span>
<span class="sd">        x = (</span>
<span class="sd">            Val(10),</span>
<span class="sd">            P + 1</span>
<span class="sd">        ),</span>
<span class="sd">        y = (</span>
<span class="sd">            Val(5),</span>
<span class="sd">            P * 5</span>
<span class="sd">        )</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">assert result.x == 9</span>
<span class="sd">assert result.y == 25</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Make`</span>
<span class="sd">hi.builder.Builder.Pipe`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then">
    <p>def <span class="ident">Then</span>(</p><p>self, expr, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then0">
    <p>def <span class="ident">Then0</span>(</p><p>self, expr, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then0" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then1">
    <p>def <span class="ident">Then1</span>(</p><p>self, expr, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then1" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then2">
    <p>def <span class="ident">Then2</span>(</p><p>self, expr, arg1, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then2" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then3">
    <p>def <span class="ident">Then3</span>(</p><p>self, expr, arg1, arg2, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then3" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then4">
    <p>def <span class="ident">Then4</span>(</p><p>self, expr, arg1, arg2, arg3, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then4" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then5">
    <p>def <span class="ident">Then5</span>(</p><p>self, expr, arg1, arg2, arg3, arg4, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then5" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ThenAt">
    <p>def <span class="ident">ThenAt</span>(</p><p>self, n, expr, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ThenAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ThenAt" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ThenAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">_return_type</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="s1">&#39;_return_type&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">_return_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">_lambda</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">args</span>
        <span class="k">return</span> <span class="n">expr</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unit__</span><span class="p">(</span><span class="n">_lambda</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Val">
    <p>def <span class="ident">Val</span>(</p><p>self, x)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Val', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Val" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.With">
    <p>def <span class="ident">With</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>With</strong></p>
<div class="codehilite"><pre><span></span>def With(context_manager, *body):
</pre></div>


<p><strong>Arguments</strong></p>
<ul>
<li><strong>context_manager</strong>: a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> object or valid expression from the DSL that returns a context manager.</li>
<li><strong>*body</strong>: any valid expression of the DSL to be evaluated inside the context. <code>*body</code> is interpreted as a tuple so all expression contained are composed.</li>
</ul>
<p>As with normal python programs you sometimes might want to create a context for a block of code. You normally give a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> to the <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement">with</a> statemente, in Phi you use <code>P.With</code> or <code>phi.With</code></p>
<p><strong>Context</strong></p>
<p>Python's <code>with</code> statemente returns a context object through <code>as</code> keyword, in the DSL this object can be obtained using the <code>P.Context</code> method or the <code>phi.Context</code> function.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">With</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">text</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>The previous is equivalent to</p>
<div class="codehilite"><pre><span></span>with open(&quot;text.txt&quot;) as f:
    text = f.read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.With', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.With" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">With</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMake</span><span class="p">(</span><span class="n">dsl</span><span class="o">.</span><span class="n">With</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.abs">
    <p>def <span class="ident">abs</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.abs(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.abs</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.abs(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.abs(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.abs</strong></p>
<div class="codehilite"><pre><span></span>Computes the absolute value of a tensor.
</pre></div>


<p>Given a tensor of real numbers <code>x</code>, this operation returns a tensor
containing the absolute value of each element in <code>x</code>. For example, if x is
an input element and y is an output element, this operation computes
\(y = |x|\).</p>
<p>See <a href="#tf_complex_abs"><code>tf.complex_abs()</code></a> to compute the absolute value of a complex
number.</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code>, or
    <code>int64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> the same size and type as <code>x</code> with absolute
    values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.abs', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.abs" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.accumulate_n">
    <p>def <span class="ident">accumulate_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.accumulate_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.accumulate_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.accumulate_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.accumulate_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.accumulate_n</strong></p>
<div class="codehilite"><pre><span></span>Returns the element-wise sum of a list of tensors.
</pre></div>


<p>Optionally, pass <code>shape</code> and <code>tensor_dtype</code> for shape and type checking,
otherwise, these are inferred.</p>
<p>NOTE: This operation is not differentiable and cannot be used if inputs depend
on trainable variables. Please use tf.add_n for such cases.</p>
<p>For example:</p>
<p>```python</p>
<h1>tensor 'a' is [[1, 2], [3, 4]]</h1>
<h1>tensor <code>b</code> is [[5, 0], [0, 6]]</h1>
<p>tf.accumulate_n([a, b, a]) ==&gt; [[7, 4], [6, 14]]</p>
<h1>Explicitly pass shape and type</h1>
<p>tf.accumulate_n([a, b, a], shape=[2, 2], tensor_dtype=tf.int32)
  ==&gt; [[7, 4], [6, 14]]
```</p>
<p>Args:
  inputs: A list of <code>Tensor</code> objects, each with same shape and type.
  shape: Shape of elements of <code>inputs</code>.
  tensor_dtype: The type of <code>inputs</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of same shape and type as the elements of <code>inputs</code>.</p>
<p>Raises:
  ValueError: If <code>inputs</code> don't all have same shape and dtype or the shape
  cannot be inferred.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.accumulate_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.accumulate_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.acos">
    <p>def <span class="ident">acos</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.acos(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.acos</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.acos(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.acos(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.acos</strong></p>
<div class="codehilite"><pre><span></span>Computes acos of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.acos', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.acos" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add">
    <p>def <span class="ident">add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add</strong></p>
<div class="codehilite"><pre><span></span>Returns x + y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>, <code>string</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_check_numerics_ops">
    <p>def <span class="ident">add_check_numerics_ops</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.add_check_numerics_ops(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add_check_numerics_ops</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add_check_numerics_ops(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.add_check_numerics_ops(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add_check_numerics_ops</strong></p>
<div class="codehilite"><pre><span></span>Connect a `check_numerics` to every floating point tensor.
</pre></div>


<p><code>check_numerics</code> operations themselves are added for each <code>half</code>, <code>float</code>,
or <code>double</code> tensor in the graph. For all ops in the graph, the
<code>check_numerics</code> op for all of its (<code>half</code>, <code>float</code>, or <code>double</code>) inputs
is guaranteed to run before the <code>check_numerics</code> op on any of its outputs.</p>
<p>Returns:
  A <code>group</code> op depending on all <code>check_numerics</code> ops added.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_check_numerics_ops', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_check_numerics_ops" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_n">
    <p>def <span class="ident">add_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.add_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.add_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add_n</strong></p>
<div class="codehilite"><pre><span></span>Adds all input tensors element-wise.
</pre></div>


<p>Args:
  inputs: A list of <code>Tensor</code> objects, each with same shape and type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of same shape and type as the elements of <code>inputs</code>.</p>
<p>Raises:
  ValueError: If <code>inputs</code> don't all have same shape and dtype or the shape
  cannot be inferred.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_regularization_loss">
    <p>def <span class="ident">add_regularization_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.add_regularization_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.add_regularization_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.add_regularization_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.add_regularization_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tb.add_regularization_loss</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_regularization_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_regularization_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_to_collection">
    <p>def <span class="ident">add_to_collection</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.add_to_collection(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add_to_collection</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add_to_collection(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.add_to_collection(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add_to_collection</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.add_to_collection()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.add_to_collection"><code>Graph.add_to_collection()</code></a>
for more details.</p>
<p>Args:
  name: The key for the collection. For example, the <code>GraphKeys</code> class
    contains many standard names for collections.
  value: The value to add to the collection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_to_collection', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_to_collection" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_candidate_sampler">
    <p>def <span class="ident">all_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.all_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.all_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.all_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.all_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.all_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Generate the set of all classes.
</pre></div>


<p>Deterministically generates and returns the set of all possible classes.
For testing purposes.  There is no need to use this, since you might as
well use full softmax or full logistic regression.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of possible classes.
  unique: A <code>bool</code>. Ignored.
    unique.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    This operation deterministically returns the entire range
    <code>[0, num_sampled]</code>.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>. All returned values are 1.0.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>. All returned values are 1.0.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">all_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.all_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.all_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.all_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer">
    <p>def <span class="ident">all_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.all_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.all_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.all_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_variables">
    <p>def <span class="ident">all_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.all_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.all_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.all_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.all_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.all_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables that must be saved/restored.
</pre></div>


<p>The <code>Variable()</code> constructor automatically adds new variables to the graph
collection <code>GraphKeys.VARIABLES</code>. This convenience function returns the
contents of that collection.</p>
<p>Returns:
  A list of <code>Variable</code> objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.arg_max">
    <p>def <span class="ident">arg_max</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.arg_max(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.arg_max</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.arg_max(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.arg_max(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.arg_max</strong></p>
<div class="codehilite"><pre><span></span>Returns the index with the largest value across dimensions of a tensor.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  dimension: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    int32, 0 &lt;= dimension &lt; rank(input).  Describes which dimension
    of the input Tensor to reduce across. For vectors, use dimension = 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.arg_max', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.arg_max" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.arg_min">
    <p>def <span class="ident">arg_min</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.arg_min(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.arg_min</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.arg_min(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.arg_min(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.arg_min</strong></p>
<div class="codehilite"><pre><span></span>Returns the index with the smallest value across dimensions of a tensor.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  dimension: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    int32, 0 &lt;= dimension &lt; rank(input).  Describes which dimension
    of the input Tensor to reduce across. For vectors, use dimension = 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.arg_min', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.arg_min" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.as_dtype">
    <p>def <span class="ident">as_dtype</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.as_dtype(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.as_dtype</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.as_dtype(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.as_dtype(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.as_dtype</strong></p>
<div class="codehilite"><pre><span></span>Converts the given `type_value` to a `DType`.
</pre></div>


<p>Args:
  type_value: A value that can be converted to a <code>tf.DType</code>
    object. This may currently be a <code>tf.DType</code> object, a
    <a href="https://www.tensorflow.org/code/tensorflow/core/framework/types.proto"><code>DataType</code> enum</a>,
    a string type name, or a <code>numpy.dtype</code>.</p>
<p>Returns:
  A <code>DType</code> corresponding to <code>type_value</code>.</p>
<p>Raises:
  TypeError: If <code>type_value</code> cannot be converted to a <code>DType</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.as_dtype', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.as_dtype" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.as_string">
    <p>def <span class="ident">as_string</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.as_string(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.as_string</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.as_string(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.as_string(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.as_string</strong></p>
<div class="codehilite"><pre><span></span>Converts each entry in the given tensor to strings.  Supports many numeric
</pre></div>


<p>types and boolean.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>float32</code>, <code>float64</code>, <code>bool</code>, <code>int8</code>.
  precision: An optional <code>int</code>. Defaults to <code>-1</code>.
    The post-decimal precision to use for floating point numbers.
    Only used if precision &gt; -1.
  scientific: An optional <code>bool</code>. Defaults to <code>False</code>.
    Use scientific notation for floating point numbers.
  shortest: An optional <code>bool</code>. Defaults to <code>False</code>.
    Use shortest representation (either scientific or standard) for
    floating point numbers.
  width: An optional <code>int</code>. Defaults to <code>-1</code>.
    Pad pre-decimal numbers to this width.
    Applies to both floating point and integer numbers.
    Only used if width &gt; -1.
  fill: An optional <code>string</code>. Defaults to <code>""</code>.
    The value to pad if width &gt; -1.  If empty, pads with spaces.
    Another typical value is '0'.  String cannot be longer than 1 character.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.as_string', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.as_string" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.asin">
    <p>def <span class="ident">asin</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.asin(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.asin</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.asin(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.asin(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.asin</strong></p>
<div class="codehilite"><pre><span></span>Computes asin of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.asin', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.asin" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_equal">
    <p>def <span class="ident">assert_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_equal</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x == y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_equal(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_equal(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] == y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_equal".</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x == y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_greater">
    <p>def <span class="ident">assert_greater</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_greater(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_greater</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_greater(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_greater(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_greater</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt; y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_greater(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_greater(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &gt; y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_greater".</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &gt; y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_greater', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_greater" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_greater_equal">
    <p>def <span class="ident">assert_greater_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_greater_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_greater_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_greater_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_greater_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_greater_equal</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt;= y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_greater_equal(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_greater_equal(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &gt;= y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to
    "assert_greater_equal"</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &gt;= y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_greater_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_greater_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_integer">
    <p>def <span class="ident">assert_integer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_integer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_integer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_integer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_integer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_integer</strong></p>
<div class="codehilite"><pre><span></span>Assert that `x` is of integer dtype.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_integer(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_integer(x)], x)</code></p>
<p>Args:
  x: <code>Tensor</code> whose basetype is integer and is not quantized.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_integer".</p>
<p>Raises:
  TypeError:  If <code>x.dtype</code> is anything other than non-quantized integer.</p>
<p>Returns:
  A <code>no_op</code> that does nothing.  Type can be determined statically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_integer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_integer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_less">
    <p>def <span class="ident">assert_less</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_less(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_less</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_less(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_less(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_less</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt; y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_less(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_less(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &lt; y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_less".</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &lt; y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_less', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_less" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_less_equal">
    <p>def <span class="ident">assert_less_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_less_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_less_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_less_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_less_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_less_equal</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt;= y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_less_equal(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_less_equal(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &lt;= y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_less_equal"</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &lt;= y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_less_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_less_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_negative">
    <p>def <span class="ident">assert_negative</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_negative(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_negative</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_negative(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_negative(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_negative</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt; 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_negative(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_negative(x)], x)</code></p>
<p>Negative means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &lt; 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_negative".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all negative.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_negative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_negative" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_non_negative">
    <p>def <span class="ident">assert_non_negative</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_non_negative(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_non_negative</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_non_negative(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_non_negative(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_non_negative</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt;= 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_non_negative(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_non_negative(x)], x)</code></p>
<p>Non-negative means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &gt;= 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).
    Defaults to "assert_non_negative".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all non-negative.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_non_negative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_non_negative" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_non_positive">
    <p>def <span class="ident">assert_non_positive</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_non_positive(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_non_positive</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_non_positive(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_non_positive(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_non_positive</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt;= 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_non_positive(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_non_positive(x)], x)</code></p>
<p>Non-positive means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &lt;= 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).
    Defaults to "assert_non_positive".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all non-positive.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_non_positive', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_non_positive" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_positive">
    <p>def <span class="ident">assert_positive</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_positive(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_positive</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_positive(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_positive(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_positive</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt; 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_positive(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_positive(x)], x)</code></p>
<p>Positive means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &gt; 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_positive".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all positive.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_positive', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_positive" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_proper_iterable">
    <p>def <span class="ident">assert_proper_iterable</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_proper_iterable(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_proper_iterable</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_proper_iterable(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_proper_iterable(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_proper_iterable</strong></p>
<div class="codehilite"><pre><span></span>Static assert that values is a &quot;proper&quot; iterable.
</pre></div>


<p><code>Ops</code> that expect iterables of <code>Tensor</code> can call this to validate input.
Useful since <code>Tensor</code>, <code>ndarray</code>, byte/text type are all iterables themselves.</p>
<p>Args:
  values:  Object to be checked.</p>
<p>Raises:
  TypeError:  If <code>values</code> is not iterable or is one of
    <code>Tensor</code>, <code>SparseTensor</code>, <code>np.array</code>, <code>tf.compat.bytes_or_text_types</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_proper_iterable', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_proper_iterable" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_rank">
    <p>def <span class="ident">assert_rank</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_rank(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_rank</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_rank(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_rank(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_rank</strong></p>
<div class="codehilite"><pre><span></span>Assert `x` has rank equal to `rank`.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_rank(x, 2)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_rank(x, 2)], x)</code></p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  rank:  Scalar integer <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_rank".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> has specified rank.
  If static checks determine <code>x</code> has correct rank, a <code>no_op</code> is returned.</p>
<p>Raises:
  ValueError:  If static checks determine <code>x</code> has wrong rank.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_rank', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_rank" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_rank_at_least">
    <p>def <span class="ident">assert_rank_at_least</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_rank_at_least(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_rank_at_least</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_rank_at_least(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_rank_at_least(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_rank_at_least</strong></p>
<div class="codehilite"><pre><span></span>Assert `x` has rank equal to `rank` or higher.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_rank_at_least(x, 2)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_rank_at_least(x, 2)], x)</code></p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  rank:  Scalar <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).
    Defaults to "assert_rank_at_least".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> has specified rank or higher.
  If static checks determine <code>x</code> has correct rank, a <code>no_op</code> is returned.</p>
<p>Raises:
  ValueError:  If static checks determine <code>x</code> has wrong rank.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_rank_at_least', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_rank_at_least" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_type">
    <p>def <span class="ident">assert_type</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_type(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_type</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_type(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_type(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_type</strong></p>
<div class="codehilite"><pre><span></span>Statically asserts that the given `Tensor` is of the specified type.
</pre></div>


<p>Args:
  tensor: A tensorflow <code>Tensor</code>.
  tf_type: A tensorflow type (dtypes.float32, tf.int64, dtypes.bool, etc).
  message: A string to prefix to the default message.
  name:  A name to give this <code>Op</code>.  Defaults to "assert_type"</p>
<p>Raises:
  TypeError: If the tensors data type doesn't match tf_type.</p>
<p>Returns:
  A <code>no_op</code> that does nothing.  Type can be determined statically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_type', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_type" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_variables_initialized">
    <p>def <span class="ident">assert_variables_initialized</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assert_variables_initialized(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_variables_initialized</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_variables_initialized(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assert_variables_initialized(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_variables_initialized</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op to check if variables are initialized.
</pre></div>


<p>NOTE: This function is obsolete and will be removed in 6 months.  Please
change your implementation to use <code>report_uninitialized_variables()</code>.</p>
<p>When run, the returned Op will raise the exception <code>FailedPreconditionError</code>
if any of the variables has not yet been initialized.</p>
<p>Note: This function is implemented by trying to fetch the values of the
variables. If one of the variables is not initialized a message may be
logged by the C++ runtime. This is expected.</p>
<p>Args:
  var_list: List of <code>Variable</code> objects to check. Defaults to the
    value of <code>all_variables().</code></p>
<p>Returns:
  An Op, or None if there are no variables.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_variables_initialized', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_variables_initialized" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assign">
    <p>def <span class="ident">assign</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assign(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assign(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assign</strong></p>
<div class="codehilite"><pre><span></span>Update &#39;ref&#39; by assigning &#39;value&#39; to it.
</pre></div>


<p>This operation outputs "ref" after the assignment is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>.
    Should be from a <code>Variable</code> node. May be uninitialized.
  value: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    The value to be assigned to the variable.
  validate_shape: An optional <code>bool</code>. Defaults to <code>True</code>.
    If true, the operation will validate that the shape
    of 'value' matches the shape of the Tensor being assigned to.  If false,
    'ref' will take on the shape of 'value'.
  use_locking: An optional <code>bool</code>. Defaults to <code>True</code>.
    If True, the assignment will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as "ref".  Returned as a convenience for operations that want
  to use the new value after the variable has been reset.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assign', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assign" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assign_add">
    <p>def <span class="ident">assign_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assign_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assign_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assign_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assign_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assign_add</strong></p>
<div class="codehilite"><pre><span></span>Update &#39;ref&#39; by adding &#39;value&#39; to it.
</pre></div>


<p>This operation outputs "ref" after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  value: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    The value to be added to the variable.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the addition will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as "ref".  Returned as a convenience for operations that want
  to use the new value after the variable has been updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assign_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assign_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assign_sub">
    <p>def <span class="ident">assign_sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.assign_sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assign_sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assign_sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.assign_sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assign_sub</strong></p>
<div class="codehilite"><pre><span></span>Update &#39;ref&#39; by subtracting &#39;value&#39; from it.
</pre></div>


<p>This operation outputs "ref" after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  value: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    The value to be subtracted to the variable.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the subtraction will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as "ref".  Returned as a convenience for operations that want
  to use the new value after the variable has been updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assign_sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assign_sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atan">
    <p>def <span class="ident">atan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.atan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.atan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.atan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.atan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.atan</strong></p>
<div class="codehilite"><pre><span></span>Computes atan of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atrous_conv2d">
    <p>def <span class="ident">atrous_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.atrous_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.atrous_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.atrous_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.atrous_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.atrous_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Atrous convolution (a.k.a. convolution with holes or dilated convolution).
</pre></div>


<p>Computes a 2-D atrous convolution, also known as convolution with holes or
dilated convolution, given 4-D <code>value</code> and <code>filters</code> tensors. If the <code>rate</code>
parameter is equal to one, it performs regular 2-D convolution. If the <code>rate</code>
parameter is greater than one, it performs convolution with holes, sampling
the input values every <code>rate</code> pixels in the <code>height</code> and <code>width</code> dimensions.
This is equivalent to convolving the input with a set of upsampled filters,
produced by inserting <code>rate - 1</code> zeros between two consecutive values of the
filters along the <code>height</code> and <code>width</code> dimensions, hence the name atrous
convolution or convolution with holes (the French word trous means holes in
English).</p>
<p>More specifically:</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q} filters[di, dj, q, k] *
      value[b, i + rate * di, j + rate * dj, q]
</pre></div>


<p>Atrous convolution allows us to explicitly control how densely to compute
feature responses in fully convolutional networks. Used in conjunction with
bilinear interpolation, it offers an alternative to <code>conv2d_transpose</code> in
dense prediction tasks such as semantic image segmentation, optical flow
computation, or depth estimation. It also allows us to effectively enlarge
the field of view of filters without increasing the number of parameters or
the amount of computation.</p>
<p>For a description of atrous convolution and how it can be used for dense
feature extraction, please see: <a href="http://arxiv.org/abs/1412.7062">Semantic Image Segmentation with Deep
Convolutional Nets and Fully Connected CRFs</a>.
The same operation is investigated further in <a href="http://arxiv.org/abs/1511.07122">Multi-Scale Context Aggregation
by Dilated Convolutions</a>. Previous works
that effectively use atrous convolution in different ways are, among others,
<a href="http://arxiv.org/abs/1312.6229">OverFeat: Integrated Recognition, Localization and Detection using
Convolutional Networks</a> and [Fast Image
Scanning with Deep Max-Pooling Convolutional Neural Networks]
(http://arxiv.org/abs/1302.1700). Atrous convolution is also closely related
to the so-called noble identities in multi-rate signal processing.</p>
<p>There are many different ways to implement atrous convolution (see the refs
above). The implementation here reduces</p>
<div class="codehilite"><pre><span></span>atrous_conv2d(value, filters, rate, padding=padding)
</pre></div>


<p>to the following three operations:</p>
<div class="codehilite"><pre><span></span>paddings = ...
net = space_to_batch(value, paddings, block_size=rate)
net = conv2d(net, filters, strides=[1, 1, 1, 1], padding=&quot;VALID&quot;)
crops = ...
net = batch_to_space(net, crops, block_size=rate)
</pre></div>


<p>Advanced usage. Note the following optimization: A sequence of <code>atrous_conv2d</code>
operations with identical <code>rate</code> parameters, 'SAME' <code>padding</code>, and filters
with odd heights/ widths:</p>
<div class="codehilite"><pre><span></span>net = atrous_conv2d(net, filters1, rate, padding=&quot;SAME&quot;)
net = atrous_conv2d(net, filters2, rate, padding=&quot;SAME&quot;)
...
net = atrous_conv2d(net, filtersK, rate, padding=&quot;SAME&quot;)
</pre></div>


<p>can be equivalently performed cheaper in terms of computation and memory as:</p>
<div class="codehilite"><pre><span></span>pad = ...  # padding so that the input dims are multiples of rate
net = space_to_batch(net, paddings=pad, block_size=rate)
net = conv2d(net, filters1, strides=[1, 1, 1, 1], padding=&quot;SAME&quot;)
net = conv2d(net, filters2, strides=[1, 1, 1, 1], padding=&quot;SAME&quot;)
...
net = conv2d(net, filtersK, strides=[1, 1, 1, 1], padding=&quot;SAME&quot;)
net = batch_to_space(net, crops=pad, block_size=rate)
</pre></div>


<p>because a pair of consecutive <code>space_to_batch</code> and <code>batch_to_space</code> ops with
the same <code>block_size</code> cancel out when their respective <code>paddings</code> and <code>crops</code>
inputs are identical.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code>. It needs to be in the default "NHWC"
    format. Its shape is <code>[batch, in_height, in_width, in_channels]</code>.
  filters: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>. <code>filters</code>'
    <code>in_channels</code> dimension must match that of <code>value</code>. Atrous convolution is
    equivalent to standard convolution with upsampled filters with effective
    height <code>filter_height + (filter_height - 1) * (rate - 1)</code> and effective
    width <code>filter_width + (filter_width - 1) * (rate - 1)</code>, produced by
    inserting <code>rate - 1</code> zeros along consecutive elements across the
    <code>filters</code>' spatial dimensions.
  rate: A positive int32. The stride with which we sample input values across
    the <code>height</code> and <code>width</code> dimensions. Equivalently, the rate by which we
    upsample the filter values by inserting zeros across the <code>height</code> and
    <code>width</code> dimensions. In the literature, the same parameter is sometimes
    called <code>input stride</code> or <code>dilation</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filters</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atrous_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atrous_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer">
    <p>def <span class="ident">atrous_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.atrous_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.atrous_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.atrous_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer">
    <p>def <span class="ident">atrous_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.atrous_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.atrous_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.atrous_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.audio_summary">
    <p>def <span class="ident">audio_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.audio_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.audio_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.audio_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.audio_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.audio_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with audio.
</pre></div>


<p>The summary has up to <code>max_outputs</code> summary values containing audio. The
audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,
frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are
assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of
<code>sample_rate</code>.</p>
<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
build the <code>tag</code> of the summary values:</p>
<ul>
<li>If <code>max_outputs</code> is 1, the summary value tag is '<em>tag</em>/audio'.</li>
<li>If <code>max_outputs</code> is greater than 1, the summary value tags are
   generated sequentially as '<em>tag</em>/audio/0', '<em>tag</em>/audio/1', etc.</li>
</ul>
<p>Args:
  tag: A scalar <code>Tensor</code> of type <code>string</code>. Used to build the <code>tag</code>
    of the summary values.
  tensor: A 3-D <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, frames, channels]</code>
    or a 2-D <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, frames]</code>.
  sample_rate: The sample rate of the signal in hertz.
  max_outputs: Max number of batch elements to generate audio for.
  collections: Optional list of ops.GraphKeys.  The collections to add the
    summary to.  Defaults to [ops.GraphKeys.SUMMARIES]
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.audio_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.audio_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool">
    <p>def <span class="ident">avg_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the average pooling on the input.
</pre></div>


<p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
window in <code>value</code>.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of shape <code>[batch, height, width, channels]</code> and type
    <code>float32</code>, <code>float64</code>, <code>qint8</code>, <code>quint8</code>, or <code>qint32</code>.
  ksize: A list of ints that has length &gt;= 4.
    The size of the window for each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool2d">
    <p>def <span class="ident">avg_pool2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.avg_pool2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.avg_pool2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layers.avg_pool2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D average pooling op.
</pre></div>


<p>It is assumed that the pooling is done per image but not in batch or channels.</p>
<p>Args:
  inputs: A <code>Tensor</code> of size [batch_size, height, width, channels].
  kernel_size: A list of length 2: [kernel_height, kernel_width] of the
    pooling kernel over which the op is computed. Can be an int if both
    values are the same.
  stride: A list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: The padding method, either 'VALID' or 'SAME'.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d">
    <p>def <span class="ident">avg_pool3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.avg_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.avg_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.avg_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D average pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer">
    <p>def <span class="ident">avg_pool3d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_grad">
    <p>def <span class="ident">avg_pool3d_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.avg_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.avg_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.avg_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of average pooling function.
</pre></div>


<p>Args:
  orig_input_shape: A <code>Tensor</code> of type <code>int32</code>.
    The original input dimensions.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>. The backprop for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer">
    <p>def <span class="ident">avg_pool3d_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d_grad`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer">
    <p>def <span class="ident">avg_pool3d_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d_grad`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_layer">
    <p>def <span class="ident">avg_pool3d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool3d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer">
    <p>def <span class="ident">avg_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool_layer">
    <p>def <span class="ident">avg_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.avg_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.avg_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization">
    <p>def <span class="ident">batch_norm_with_global_normalization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_norm_with_global_normalization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.batch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.batch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_norm_with_global_normalization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.batch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A 4D input Tensor.
  m: A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  v: A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  beta: A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  gamma: A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  scale_after_normalization: A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for this operation (optional).</p>
<p>Returns:
   A batch-normalized <code>t</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer">
    <p>def <span class="ident">batch_norm_with_global_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_norm_with_global_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_norm_with_global_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_norm_with_global_normalization`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer">
    <p>def <span class="ident">batch_norm_with_global_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_norm_with_global_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_norm_with_global_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_norm_with_global_normalization`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_normalization">
    <p>def <span class="ident">batch_normalization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_normalization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.batch_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.batch_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_normalization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.batch_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.
Normalizes a tensor by <code>mean</code> and <code>variance</code>, and applies (optionally) a
<code>scale</code> \\(\gamma\\) to it, as well as an <code>offset</code> \\(\beta\\):</p>
<p>\\(\frac{\gamma(x-\mu)}{\sigma}+\beta\\)</p>
<p><code>mean</code>, <code>variance</code>, <code>offset</code> and <code>scale</code> are all expected to be of one of two
shapes:
  * In all generality, they can have the same number of dimensions as the
    input <code>x</code>, with identical sizes as <code>x</code> for the dimensions that are not
    normalized over (the 'depth' dimension(s)), and dimension 1 for the
    others which are being normalized over.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=True)</code> during training, or running averages
    thereof during inference.
  * In the common case where the 'depth' dimension is the last dimension in
    the input tensor <code>x</code>, they may be one dimensional tensors of the same
    size as the 'depth' dimension.
    This is the case for example for the common <code>[batch, depth]</code> layout of
    fully-connected layers, and <code>[batch, height, width, depth]</code> for
    convolutions.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=False)</code> during training, or running averages
    thereof during inference.</p>
<p>Args:
  x: Input <code>Tensor</code> of arbitrary dimensionality.
  mean: A mean <code>Tensor</code>.
  variance: A variance <code>Tensor</code>.
  offset: An offset <code>Tensor</code>, often denoted \\(\beta\\) in equations, or
    None. If present, will be added to the normalized tensor.
  scale: A scale <code>Tensor</code>, often denoted \\(\gamma\\) in equations, or
    <code>None</code>. If present, the scale is applied to the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  name: A name for this operation (optional).</p>
<p>Returns:
  the normalized, scaled, offset tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_normalization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_normalization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer">
    <p>def <span class="ident">batch_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_normalization`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_normalization_layer">
    <p>def <span class="ident">batch_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_normalization`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_to_space">
    <p>def <span class="ident">batch_to_space</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_to_space(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.batch_to_space</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.batch_to_space(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_to_space(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.batch_to_space</strong></p>
<div class="codehilite"><pre><span></span>BatchToSpace for 4-D tensors of type T.
</pre></div>


<p>This is a legacy version of the more general BatchToSpaceND.</p>
<p>Rearranges (permutes) data from batch into blocks of spatial data, followed by
cropping. This is the reverse transformation of SpaceToBatch. More specifically,
this op outputs a copy of the input tensor where values from the <code>batch</code>
dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions,
followed by cropping along the <code>height</code> and <code>width</code> dimensions.</p>
<p>Args:
  input: A <code>Tensor</code>. 4-D tensor with shape
    <code>[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
      depth]</code>. Note that the batch size of the input tensor must be divisible by
    <code>block_size * block_size</code>.
  crops: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
    how many elements to crop from the intermediate result across the spatial
    dimensions as follows:</p>
<div class="codehilite"><pre><span></span>    crops = [[crop_top, crop_bottom], [crop_left, crop_right]]
</pre></div>


<p>block_size: An <code>int</code> that is <code>&gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, height, width, depth]</code>, where:</p>
<div class="codehilite"><pre><span></span>    height = height_pad - crop_top - crop_bottom
    width = width_pad - crop_left - crop_right
</pre></div>


<p>The attr <code>block_size</code> must be greater than one. It indicates the block size.</p>
<p>Some examples:</p>
<p>(1) For the following input of shape <code>[4, 1, 1, 1]</code> and block_size of 2:</p>
<p><code>prettyprint
  [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]</code></p>
<p>The output tensor has shape <code>[1, 2, 2, 1]</code> and value:</p>
<p><code>prettyprint
  x = [[[[1], [2]], [[3], [4]]]]</code></p>
<p>(2) For the following input of shape <code>[4, 1, 1, 3]</code> and block_size of 2:</p>
<p><code>prettyprint
  [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]</code></p>
<p>The output tensor has shape <code>[1, 2, 2, 3]</code> and value:</p>
<p><code>prettyprint
  x = [[[[1, 2, 3], [4, 5, 6]],
        [[7, 8, 9], [10, 11, 12]]]]</code></p>
<p>(3) For the following input of shape <code>[4, 2, 2, 1]</code> and block_size of 2:</p>
<p><code>prettyprint
  x = [[[[1], [3]], [[5], [7]]],
       [[[2], [4]], [[10], [12]]],
       [[[5], [7]], [[13], [15]]],
       [[[6], [8]], [[14], [16]]]]</code></p>
<p>The output tensor has shape <code>[1, 4, 4, 1]</code> and value:</p>
<p><code>prettyprint
  x = [[[1],   [2],  [3],  [4]],
       [[5],   [6],  [7],  [8]],
       [[9],  [10], [11],  [12]],
       [[13], [14], [15],  [16]]]</code></p>
<p>(4) For the following input of shape <code>[8, 1, 2, 1]</code> and block_size of 2:</p>
<p><code>prettyprint
  x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
       [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]</code></p>
<p>The output tensor has shape <code>[2, 2, 4, 1]</code> and value:</p>
<p><code>prettyprint
  x = [[[[1], [3]], [[5], [7]]],
       [[[2], [4]], [[10], [12]]],
       [[[5], [7]], [[13], [15]]],
       [[[6], [8]], [[14], [16]]]]</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_to_space', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_to_space" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_to_space_nd">
    <p>def <span class="ident">batch_to_space_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.batch_to_space_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.batch_to_space_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.batch_to_space_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.batch_to_space_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.batch_to_space_nd</strong></p>
<div class="codehilite"><pre><span></span>BatchToSpace for N-D tensors of type T.
</pre></div>


<p>This operation reshapes the "batch" dimension 0 into <code>M + 1</code> dimensions of shape
<code>block_shape + [batch]</code>, interleaves these blocks back into the grid defined by
the spatial dimensions <code>[1, ..., M]</code>, to obtain a result with the same rank as
the input.  The spatial dimensions of this intermediate result are then
optionally cropped according to <code>crops</code> to produce the output.  This is the
reverse of SpaceToBatch.  See below for a precise description.</p>
<p>Args:
  input: A <code>Tensor</code>.
    N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
    where spatial_shape has M dimensions.
  block_shape: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D with shape <code>[M]</code>, all values must be &gt;= 1.
  crops: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.
      <code>crops[i] = [crop_start, crop_end]</code> specifies the amount to crop from input
      dimension <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is
      required that
      <code>crop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1]</code>.</p>
<div class="codehilite"><pre><span></span>This operation is equivalent to the following steps:

1. Reshape `input` to `reshaped` of shape:
     [block_shape[0], ..., block_shape[M-1],
      batch / prod(block_shape),
      input_shape[1], ..., input_shape[N-1]]

2. Permute dimensions of `reshaped` to produce `permuted` of shape
     [batch / prod(block_shape),

      input_shape[1], block_shape[0],
      ...,
      input_shape[M], block_shape[M-1],

      input_shape[M+1], ..., input_shape[N-1]]

3. Reshape `permuted` to produce `reshaped_permuted` of shape
     [batch / prod(block_shape),

      input_shape[1] * block_shape[0],
      ...,
      input_shape[M] * block_shape[M-1],

      input_shape[M+1],
      ...,
      input_shape[N-1]]

4. Crop the start and end of dimensions `[1, ..., M]` of
   `reshaped_permuted` according to `crops` to produce the output of shape:
     [batch / prod(block_shape),

      input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],
      ...,
      input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],

      input_shape[M+1], ..., input_shape[N-1]]

Some examples:

(1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [0, 0]]`:

```prettyprint
[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
```

The output tensor has shape `[1, 2, 2, 1]` and value:

```prettyprint
x = [[[[1], [2]], [[3], [4]]]]
```

(2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [0, 0]]`:

```prettyprint
[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
```

The output tensor has shape `[1, 2, 2, 3]` and value:

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

(3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
```

The output tensor has shape `[1, 4, 4, 1]` and value:

```prettyprint
x = [[[1],   [2],  [3],  [4]],
     [[5],   [6],  [7],  [8]],
     [[9],  [10], [11],  [12]],
     [[13], [14], [15],  [16]]]
```

(4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [2, 0]]`:

```prettyprint
x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
     [[[0], [2], [4]]], [[[0], [10], [12]]],
     [[[0], [5], [7]]], [[[0], [13], [15]]],
     [[[0], [6], [8]]], [[[0], [14], [16]]]]
```

The output tensor has shape `[2, 2, 4, 1]` and value:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_to_space_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_to_space_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.betainc">
    <p>def <span class="ident">betainc</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.betainc(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.betainc</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.betainc(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.betainc(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.betainc</strong></p>
<div class="codehilite"><pre><span></span>Compute the regularized incomplete beta integral \\(I_x(a, b)\\).
</pre></div>


<p>The regularized incomplete beta integral is defined as:</p>
<p><code>I_x(a, b) = \frac{B(x; a, b)}{B(a, b)}</code>
where</p>
<p><code>B(x; a, b) = \int_0^x t^{a-1} (1 - t)^{b-1} dt</code></p>
<p>is the incomplete beta function and \(B(a, b)\) is the <em>complete</em>
beta function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  b: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.betainc', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.betainc" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add">
    <p>def <span class="ident">bias_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.bias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.bias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.bias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer">
    <p>def <span class="ident">bias_add_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_grad">
    <p>def <span class="ident">bias_add_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.bias_add_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.bias_add_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.bias_add_grad</strong></p>
<div class="codehilite"><pre><span></span>The backward operation for &quot;BiasAdd&quot; on the &quot;bias&quot; tensor.
</pre></div>


<p>It accumulates all the values from out_backprop into the feature dimension.
For NHWC data format, the feature dimension is the last. For NCHW data format,
the feature dimension is the third-to-last.</p>
<p>Args:
  out_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Any number of dimensions.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the bias tensor will be added to the last dimension
    of the value tensor.
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
    The tensor will be added to "in_channels", the third-to-the-last
        dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>out_backprop</code>.
  1-D with size the feature dimension of <code>out_backprop</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer">
    <p>def <span class="ident">bias_add_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_grad`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_grad_layer">
    <p>def <span class="ident">bias_add_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_grad`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_layer">
    <p>def <span class="ident">bias_add_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_v1">
    <p>def <span class="ident">bias_add_v1</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_v1(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.bias_add_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.bias_add_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_v1(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.bias_add_v1</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is a deprecated version of bias_add and will soon to be removed.</p>
<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_v1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_v1" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer">
    <p>def <span class="ident">bias_add_v1_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_v1_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_v1_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_v1`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_v1_layer">
    <p>def <span class="ident">bias_add_v1_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bias_add_v1_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bias_add_v1_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_v1`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_v1_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_v1_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn">
    <p>def <span class="ident">bidirectional_dynamic_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_dynamic_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.bidirectional_dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.bidirectional_dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_dynamic_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.bidirectional_dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a dynamic version of bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs. The input_size of forward and
backward cell must match. The initial state for both directions is zero by
default (but can be set optionally) and no intermediate states are ever
returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not
given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: The RNN inputs.
    If time_major == False (default), this must be a tensor of shape:
      <code>[batch_size, max_time, input_size]</code>.
    If time_major == True, this must be a tensor of shape:
      <code>[max_time, batch_size, input_size]</code>.
    [batch_size, input_size].
  sequence_length: An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial states and expected output.
    Required if initial_states are not provided or RNN states have a
    heterogeneous dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  dtype: (optional) The data type for the initial state.  Required if
    initial_state is not provided.
  sequence_length: An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
    either of the initial states are not provided.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_states) where:
    outputs: A tuple (output_fw, output_bw) containing the forward and
      the backward rnn output <code>Tensor</code>.
      If time_major == False (default),
        output_fw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_bw.output_size]</code>.
      If time_major == True,
        output_fw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_bw.output_size]</code>.
      It returns a tuple instead of a single concatenated <code>Tensor</code>, unlike
      in the <code>bidirectional_rnn</code>. If the concatenated one is preferred,
      the forward and backward outputs can be concatenated as
      <code>tf.concat(2, outputs)</code>.
    output_states: A tuple (output_state_fw, output_state_bw) containing
      the forward and the backward final states of bidirectional rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer">
    <p>def <span class="ident">bidirectional_dynamic_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_dynamic_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_dynamic_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_dynamic_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer">
    <p>def <span class="ident">bidirectional_dynamic_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_dynamic_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_dynamic_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_dynamic_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_rnn">
    <p>def <span class="ident">bidirectional_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.bidirectional_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.bidirectional_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.bidirectional_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs with the final forward and backward
outputs depth-concatenated, such that the output will have the format
[time][batch][cell_fw.output_size + cell_bw.output_size]. The input_size of
forward and backward cell must match. The initial state for both directions
is zero by default (but can be set optionally) and no intermediate states are
ever returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: A length T list of inputs, each a tensor of shape
    [batch_size, input_size], or a nested tuple of such elements.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  sequence_length: (optional) An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_state_fw, output_state_bw) where:
    outputs is a length <code>T</code> list of outputs (one for each input), which
      are depth-concatenated forward and backward outputs.
    output_state_fw is the final state of the forward rnn.
    output_state_bw is the final state of the backward rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer">
    <p>def <span class="ident">bidirectional_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer">
    <p>def <span class="ident">bidirectional_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bidirectional_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bitcast">
    <p>def <span class="ident">bitcast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.bitcast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.bitcast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.bitcast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.bitcast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.bitcast</strong></p>
<div class="codehilite"><pre><span></span>Bitcasts a tensor from one type to another without copying data.
</pre></div>


<p>Given a tensor <code>input</code>, this operation returns a tensor that has the same buffer
data as <code>input</code> with datatype <code>type</code>.</p>
<p>If the input datatype <code>T</code> is larger than the output datatype <code>type</code> then the
shape changes from [...] to [..., sizeof(<code>T</code>)/sizeof(<code>type</code>)].</p>
<p>If <code>T</code> is smaller than <code>type</code>, the operator requires that the rightmost
dimension be equal to sizeof(<code>type</code>)/sizeof(<code>T</code>). The shape then goes from
[..., sizeof(<code>type</code>)/sizeof(<code>T</code>)] to [...].</p>
<p><em>NOTE</em>: Bitcast is implemented as a low-level cast, so machines with different
endian orderings will give different results.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  type: A <code>tf.DType</code> from: <code>tf.float32, tf.float64, tf.int64, tf.int32, tf.uint8, tf.uint16, tf.int16, tf.int8, tf.complex64, tf.complex128, tf.qint8, tf.quint8, tf.qint32, tf.half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bitcast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bitcast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.boolean_mask">
    <p>def <span class="ident">boolean_mask</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.boolean_mask(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.boolean_mask</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.boolean_mask(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.boolean_mask(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.boolean_mask</strong></p>
<div class="codehilite"><pre><span></span>Apply boolean mask to tensor.  Numpy equivalent is `tensor[mask]`.
</pre></div>


<p>```python</p>
<h1>1-D example</h1>
<p>tensor = [0, 1, 2, 3]
mask = [True, False, True, False]
boolean_mask(tensor, mask) ==&gt; [0, 2]
```</p>
<p>In general, <code>0 &lt; dim(mask) = K &lt;= dim(tensor)</code>, and <code>mask</code>'s shape must match
the first K dimensions of <code>tensor</code>'s shape.  We then have:
  <code>boolean_mask(tensor, mask)[i, j1,...,jd] = tensor[i1,...,iK,j1,...,jd]</code>
where <code>(i1,...,iK)</code> is the ith <code>True</code> entry of <code>mask</code> (row-major order).</p>
<p>Args:
  tensor:  N-D tensor.
  mask:  K-D boolean tensor, K &lt;= N and K must be known statically.
  name:  A name for this operation (optional).</p>
<p>Returns:
  Tensor populated by entries in <code>tensor</code> corresponding to <code>True</code> values in
    <code>mask</code>.</p>
<p>Raises:
  ValueError:  If shapes do not conform.</p>
<p>Examples:</p>
<p>```python</p>
<h1>2-D example</h1>
<p>tensor = [[1, 2], [3, 4], [5, 6]]
mask = [True, False, True]
boolean_mask(tensor, mask) ==&gt; [[1, 2], [5, 6]]
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.boolean_mask', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.boolean_mask" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.case">
    <p>def <span class="ident">case</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.case(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.case</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.case(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.case(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.case</strong></p>
<div class="codehilite"><pre><span></span>Create a case operation.
</pre></div>


<p>The <code>pred_fn_pairs</code> parameter is a dict or list of pairs of size N.
Each pair contains a boolean scalar tensor and a python callable that
creates the tensors to be returned if the boolean evaluates to True.
<code>default</code> is a callable generating a list of tensors. All the callables
in <code>pred_fn_pairs</code> as well as <code>default</code> should return the same number
and types of tensors.</p>
<p>If <code>exclusive==True</code>, all predicates are evaluated, and a logging operation
with an error is returned if more than one of the predicates evaluates to
True. If <code>exclusive==False</code>, execution stops are the first predicate which
evaluates to True, and the tensors generated by the corresponding function
are returned immediately. If none of the predicates evaluate to True, this
operation returns the tensors generated by <code>default</code>.</p>
<p>Example 1:
  Pseudocode:
  <code>if (x &lt; y) return 17;
    else return 23;</code></p>
<p>Expressions:
  <code>f1 = lambda: tf.constant(17)
    f2 = lambda: tf.constant(23)
    r = case([(tf.less(x, y), f1)], default=f2)</code></p>
<p>Example 2:
  Pseudocode:
  <code>if (x &lt; y &amp;&amp; x &gt; z) raise OpError("Only one predicate may evaluate true");
    if (x &lt; y) return 17;
    else if (x &gt; z) return 23;
    else return -1;</code></p>
<p>Expressions:
  <code>x = tf.constant(0)
    y = tf.constant(1)
    z = tf.constant(2)
    def f1(): return tf.constant(17)
    def f2(): return tf.constant(23)
    def f3(): return tf.constant(-1)
    r = case({tf.less(x, y): f1, tf.greater(x, z): f2},
             default=f3, exclusive=True)</code></p>
<p>Args:
  pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a
                 callable which returns a list of tensors.
  default: A callable that returns a list of tensors.
  exclusive: True iff more than one predicate is allowed to evaluate to True.
  name: A name for this operation (optional).</p>
<p>Returns:
  The tensors returned by the first pair whose predicate evaluated to True, or
  those returned by <code>default</code> if none does.</p>
<p>Raises:
  TypeError: If <code>pred_fn_pairs</code> is not a list/dictionary.
  TypeError: If <code>pred_fn_pairs</code> is a list but does not contain 2-tuples.
  TypeError: If <code>fns[i]</code> is not callable for any i, or <code>default</code> is not
             callable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.case', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.case" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cast">
    <p>def <span class="ident">cast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cast</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to a new type.
</pre></div>


<p>The operation casts <code>x</code> (in case of <code>Tensor</code>) or <code>x.values</code>
(in case of <code>SparseTensor</code>) to <code>dtype</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>tensor <code>a</code> is [1.8, 2.2], dtype=tf.float</h1>
<p>tf.cast(a, tf.int32) ==&gt; [1, 2]  # dtype=tf.int32
```</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  dtype: The destination type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>dtype</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ceil">
    <p>def <span class="ident">ceil</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ceil(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ceil</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ceil(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ceil(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ceil</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise smallest integer in not less than x.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ceil', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ceil" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.check_numerics">
    <p>def <span class="ident">check_numerics</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.check_numerics(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.check_numerics</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.check_numerics(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.check_numerics(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.check_numerics</strong></p>
<div class="codehilite"><pre><span></span>Checks a tensor for NaN and Inf values.
</pre></div>


<p>When run, reports an <code>InvalidArgument</code> error if <code>tensor</code> has any values
that are not a number (NaN) or infinity (Inf). Otherwise, passes <code>tensor</code> as-is.</p>
<p>Args:
  tensor: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  message: A <code>string</code>. Prefix of the error message.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.check_numerics', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.check_numerics" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cholesky">
    <p>def <span class="ident">cholesky</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cholesky(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cholesky</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cholesky(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cholesky(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cholesky</strong></p>
<div class="codehilite"><pre><span></span>Computes the Cholesky decomposition of one or more square matrices.
</pre></div>


<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices, with the same constraints as the single matrix Cholesky
decomposition above. The output is a tensor of the same shape as the input
containing the Cholesky decompositions for all input submatrices <code>[..., :, :]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. Shape is <code>[..., M, M]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cholesky', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cholesky" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cholesky_solve">
    <p>def <span class="ident">cholesky_solve</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cholesky_solve(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cholesky_solve</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cholesky_solve(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cholesky_solve(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cholesky_solve</strong></p>
<div class="codehilite"><pre><span></span>Solves systems of linear eqns `A X = RHS`, given Cholesky factorizations.
</pre></div>


<p>```python</p>
<h1>Solve 10 separate 2x2 linear systems:</h1>
<p>A = ... # shape 10 x 2 x 2
RHS = ... # shape 10 x 2 x 1
chol = tf.cholesky(A)  # shape 10 x 2 x 2
X = tf.cholesky_solve(chol, RHS)  # shape 10 x 2 x 1</p>
<h1>tf.matmul(A, X) ~ RHS</h1>
<p>X[3, :, 0]  # Solution to the linear system A[3, :, :] x = RHS[3, :, 0]</p>
<h1>Solve five linear systems (K = 5) for every member of the length 10 batch.</h1>
<p>A = ... # shape 10 x 2 x 2
RHS = ... # shape 10 x 2 x 5
...
X[3, :, 2]  # Solution to the linear system A[3, :, :] x = RHS[3, :, 2]
```</p>
<p>Args:
  chol:  A <code>Tensor</code>.  Must be <code>float32</code> or <code>float64</code>, shape is <code>[..., M, M]</code>.
    Cholesky factorization of <code>A</code>, e.g. <code>chol = tf.cholesky(A)</code>.
    For that reason, only the lower triangular parts (including the diagonal)
    of the last two dimensions of <code>chol</code> are used.  The strictly upper part is
    assumed to be zero and not accessed.
  rhs:  A <code>Tensor</code>, same type as <code>chol</code>, shape is <code>[..., M, K]</code>.
  name:  A name to give this <code>Op</code>.  Defaults to <code>cholesky_solve</code>.</p>
<p>Returns:
  Solution to <code>A x = rhs</code>, shape <code>[..., M, K]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cholesky_solve', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cholesky_solve" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_average_norm">
    <p>def <span class="ident">clip_by_average_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.clip_by_average_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_average_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_average_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.clip_by_average_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_average_norm</strong></p>
<div class="codehilite"><pre><span></span>Clips tensor values to a maximum average L2-norm.
</pre></div>


<p>Given a tensor <code>t</code>, and a maximum clip value <code>clip_norm</code>, this operation
normalizes <code>t</code> so that its average L2-norm is less than or equal to
<code>clip_norm</code>. Specifically, if the average L2-norm is already less than or
equal to <code>clip_norm</code>, then <code>t</code> is not modified. If the average L2-norm is
greater than <code>clip_norm</code>, then this operation returns a tensor of the same
type and shape as <code>t</code> with its values set to:</p>
<p><code>t * clip_norm / l2norm_avg(t)</code></p>
<p>In this case, the average L2-norm of the output tensor is <code>clip_norm</code>.</p>
<p>This operation is typically used to clip gradients before applying them with
an optimizer.</p>
<p>Args:
  t: A <code>Tensor</code>.
  clip_norm: A 0-D (scalar) <code>Tensor</code> &gt; 0. A maximum clipping value.
  name: A name for the operation (optional).</p>
<p>Returns:
  A clipped <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_average_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_average_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_global_norm">
    <p>def <span class="ident">clip_by_global_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.clip_by_global_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_global_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_global_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.clip_by_global_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_global_norm</strong></p>
<div class="codehilite"><pre><span></span>Clips values of multiple tensors by the ratio of the sum of their norms.
</pre></div>


<p>Given a tuple or list of tensors <code>t_list</code>, and a clipping ratio <code>clip_norm</code>,
this operation returns a list of clipped tensors <code>list_clipped</code>
and the global norm (<code>global_norm</code>) of all tensors in <code>t_list</code>. Optionally,
if you've already computed the global norm for <code>t_list</code>, you can specify
the global norm with <code>use_norm</code>.</p>
<p>To perform the clipping, the values <code>t_list[i]</code> are set to:</p>
<div class="codehilite"><pre><span></span>t_list[i] * clip_norm / max(global_norm, clip_norm)
</pre></div>


<p>where:</p>
<div class="codehilite"><pre><span></span>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))
</pre></div>


<p>If <code>clip_norm &gt; global_norm</code> then the entries in <code>t_list</code> remain as they are,
otherwise they're all shrunk by the global ratio.</p>
<p>Any of the entries of <code>t_list</code> that are of type <code>None</code> are ignored.</p>
<p>This is the correct way to perform gradient clipping (for example, see
<a href="http://arxiv.org/abs/1211.5063">Pascanu et al., 2012</a>
(<a href="http://arxiv.org/pdf/1211.5063.pdf">pdf</a>)).</p>
<p>However, it is slower than <code>clip_by_norm()</code> because all the parameters must be
ready before the clipping operation can be performed.</p>
<p>Args:
  t_list: A tuple or list of mixed <code>Tensors</code>, <code>IndexedSlices</code>, or None.
  clip_norm: A 0-D (scalar) <code>Tensor</code> &gt; 0. The clipping ratio.
  use_norm: A 0-D (scalar) <code>Tensor</code> of type <code>float</code> (optional). The global
    norm to use. If not provided, <code>global_norm()</code> is used to compute the norm.
  name: A name for the operation (optional).</p>
<p>Returns:
  list_clipped: A list of <code>Tensors</code> of the same type as <code>list_t</code>.
  global_norm: A 0-D (scalar) <code>Tensor</code> representing the global norm.</p>
<p>Raises:
  TypeError: If <code>t_list</code> is not a sequence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_global_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_global_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_norm">
    <p>def <span class="ident">clip_by_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.clip_by_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.clip_by_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_norm</strong></p>
<div class="codehilite"><pre><span></span>Clips tensor values to a maximum L2-norm.
</pre></div>


<p>Given a tensor <code>t</code>, and a maximum clip value <code>clip_norm</code>, this operation
normalizes <code>t</code> so that its L2-norm is less than or equal to <code>clip_norm</code>,
along the dimensions given in <code>axes</code>. Specifically, in the default case
where all dimensions are used for calculation, if the L2-norm of <code>t</code> is
already less than or equal to <code>clip_norm</code>, then <code>t</code> is not modified. If
the L2-norm is greater than <code>clip_norm</code>, then this operation returns a
tensor of the same type and shape as <code>t</code> with its values set to:</p>
<p><code>t * clip_norm / l2norm(t)</code></p>
<p>In this case, the L2-norm of the output tensor is <code>clip_norm</code>.</p>
<p>As another example, if <code>t</code> is a matrix and <code>axes == [1]</code>, then each row
of the output will have L2-norm equal to <code>clip_norm</code>. If <code>axes == [0]</code>
instead, each column of the output will be clipped.</p>
<p>This operation is typically used to clip gradients before applying them with
an optimizer.</p>
<p>Args:
  t: A <code>Tensor</code>.
  clip_norm: A 0-D (scalar) <code>Tensor</code> &gt; 0. A maximum clipping value.
  axes: A 1-D (vector) <code>Tensor</code> of type int32 containing the dimensions
    to use for computing the L2-norm. If <code>None</code> (the default), uses all
    dimensions.
  name: A name for the operation (optional).</p>
<p>Returns:
  A clipped <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_value">
    <p>def <span class="ident">clip_by_value</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.clip_by_value(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_value</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_value(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.clip_by_value(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_value</strong></p>
<div class="codehilite"><pre><span></span>Clips tensor values to a specified min and max.
</pre></div>


<p>Given a tensor <code>t</code>, this operation returns a tensor of the same type and
shape as <code>t</code> with its values clipped to <code>clip_value_min</code> and <code>clip_value_max</code>.
Any values less than <code>clip_value_min</code> are set to <code>clip_value_min</code>. Any values
greater than <code>clip_value_max</code> are set to <code>clip_value_max</code>.</p>
<p>Args:
  t: A <code>Tensor</code>.
  clip_value_min: A 0-D (scalar) <code>Tensor</code>. The minimum value to clip by.
  clip_value_max: A 0-D (scalar) <code>Tensor</code>. The maximum value to clip by.
  name: A name for the operation (optional).</p>
<p>Returns:
  A clipped <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_value', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_value" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.complex">
    <p>def <span class="ident">complex</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.complex(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.complex</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.complex(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.complex(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.complex</strong></p>
<div class="codehilite"><pre><span></span>Converts two real numbers to a complex number.
</pre></div>


<p>Given a tensor <code>real</code> representing the real part of a complex number, and a
tensor <code>imag</code> representing the imaginary part of a complex number, this
operation returns complex numbers elementwise of the form (a + bj), where
<em>a</em> represents the <code>real</code> part and <em>b</em> represents the <code>imag</code> part.</p>
<p>The input tensors <code>real</code> and <code>imag</code> must have the same shape.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'real' is [2.25, 3.25]</h1>
<h1>tensor <code>imag</code> is [4.75, 5.75]</h1>
<p>tf.complex(real, imag) ==&gt; [[2.25 + 4.75j], [3.25 + 5.75j]]
```</p>
<p>Args:
  real: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  imag: A <code>Tensor</code>. Must have the same type as <code>real</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code> or <code>complex128</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.complex', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.complex" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.complex_abs">
    <p>def <span class="ident">complex_abs</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.complex_abs(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.complex_abs</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.complex_abs(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.complex_abs(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.complex_abs</strong></p>
<div class="codehilite"><pre><span></span>Computes the complex absolute value of a tensor.
</pre></div>


<p>Given a tensor <code>x</code> of complex numbers, this operation returns a tensor of type
<code>float32</code> or <code>float64</code> that is the absolute value of each element in <code>x</code>. All
elements in <code>x</code> must be complex numbers of the form \(a + bj\). The
absolute value is computed as \( \sqrt{a^2 + b^2}\).</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'x' is [[-2.25 + 4.75j], [-3.25 + 5.75j]]</h1>
<p>tf.complex_abs(x) ==&gt; [5.25594902, 6.60492229]
```</p>
<p>Args:
  x: A <code>Tensor</code> of type <code>complex64</code> or <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.complex_abs', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.complex_abs" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.compute_accidental_hits">
    <p>def <span class="ident">compute_accidental_hits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.compute_accidental_hits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.compute_accidental_hits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.compute_accidental_hits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.compute_accidental_hits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.compute_accidental_hits</strong></p>
<div class="codehilite"><pre><span></span>Compute the position ids in `sampled_candidates` matching `true_classes`.
</pre></div>


<p>In Candidate Sampling, this operation facilitates virtually removing
sampled classes which happen to match target classes.  This is done
in Sampled Softmax and Sampled Logistic.</p>
<p>See our <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">Candidate Sampling Algorithms
Reference</a>.</p>
<p>We presuppose that the <code>sampled_candidates</code> are unique.</p>
<p>We call it an 'accidental hit' when one of the target classes
matches one of the sampled classes.  This operation reports
accidental hits as triples <code>(index, id, weight)</code>, where <code>index</code>
represents the row number in <code>true_classes</code>, <code>id</code> represents the
position in <code>sampled_candidates</code>, and weight is <code>-FLOAT_MAX</code>.</p>
<p>The result of this op should be passed through a <code>sparse_to_dense</code>
operation, then added to the logits of the sampled classes. This
removes the contradictory effect of accidentally sampling the true
target classes as noise classes for the same example.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled_candidates output of CandidateSampler.
  num_true: An <code>int</code>.  The number of target classes per training example.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  indices: A <code>Tensor</code> of type <code>int32</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate rows in <code>true_classes</code>.
  ids: A <code>Tensor</code> of type <code>int64</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate positions in <code>sampled_candidates</code>.
  weights: A <code>Tensor</code> of type <code>float</code> and shape <code>[num_accidental_hits]</code>.
    Each value is <code>-FLOAT_MAX</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer">
    <p>def <span class="ident">compute_accidental_hits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.compute_accidental_hits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.compute_accidental_hits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.compute_accidental_hits`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer">
    <p>def <span class="ident">compute_accidental_hits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.compute_accidental_hits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.compute_accidental_hits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.compute_accidental_hits`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.concat">
    <p>def <span class="ident">concat</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.concat(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.concat</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.concat(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.concat(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.concat</strong></p>
<div class="codehilite"><pre><span></span>Concatenates tensors along one dimension.
</pre></div>


<p>Concatenates the list of tensors <code>values</code> along dimension <code>concat_dim</code>.  If
<code>values[i].shape = [D0, D1, ... Dconcat_dim(i), ...Dn]</code>, the concatenated
result has shape</p>
<div class="codehilite"><pre><span></span>[D0, D1, ... Rconcat_dim, ...Dn]
</pre></div>


<p>where</p>
<div class="codehilite"><pre><span></span>Rconcat_dim = sum(Dconcat_dim(i))
</pre></div>


<p>That is, the data from the input tensors is joined along the <code>concat_dim</code>
dimension.</p>
<p>The number of dimensions of the input tensors must match, and all dimensions
except <code>concat_dim</code> must be equal.</p>
<p>For example:</p>
<p>```python
t1 = [[1, 2, 3], [4, 5, 6]]
t2 = [[7, 8, 9], [10, 11, 12]]
tf.concat(0, [t1, t2]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]
tf.concat(1, [t1, t2]) ==&gt; [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]</p>
<h1>tensor t3 with shape [2, 3]</h1>
<h1>tensor t4 with shape [2, 3]</h1>
<p>tf.shape(tf.concat(0, [t3, t4])) ==&gt; [4, 3]
tf.shape(tf.concat(1, [t3, t4])) ==&gt; [2, 6]
```</p>
<p>Note: If you are concatenating along a new axis consider using pack.
E.g.</p>
<p><code>python
tf.concat(axis, [tf.expand_dims(t, axis) for t in tensors])</code></p>
<p>can be rewritten as</p>
<p><code>python
tf.pack(tensors, axis=axis)</code></p>
<p>Args:
  concat_dim: 0-D <code>int32</code> <code>Tensor</code>.  Dimension along which to concatenate.
  values: A list of <code>Tensor</code> objects or a single <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> resulting from concatenation of the input tensors.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.concat', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.concat" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cond">
    <p>def <span class="ident">cond</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cond(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cond</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cond(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cond(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cond</strong></p>
<div class="codehilite"><pre><span></span>Return either fn1() or fn2() based on the boolean predicate `pred`.
</pre></div>


<p><code>fn1</code> and <code>fn2</code> both return lists of output tensors. <code>fn1</code> and <code>fn2</code> must have
the same non-zero number and type of outputs.</p>
<p>Note that the conditional execution applies only to the operations defined in
fn1 and fn2. Consider the following simple program:</p>
<p><code>python
z = tf.mul(a, b)
result = tf.cond(x &lt; y, lambda: tf.add(x, z), lambda: tf.square(y))</code></p>
<p>If x &lt; y, the tf.add operation will be executed and tf.square
operation will not be executed. Since z is needed for at least one
branch of the cond, the tf.mul operation is always executed, unconditionally.
Although this behavior is consistent with the dataflow model of TensorFlow,
it has occasionally surprised some users who expected a lazier semantics.</p>
<p>Args:
  pred: A scalar determining whether to return the result of <code>fn1</code> or <code>fn2</code>.
  fn1: The callable to be performed if pred is true.
  fn2: The callable to be performed if pref is false.
  name: Optional name prefix for the returned tensors.</p>
<p>Returns:
  Tensors returned by the call to either <code>fn1</code> or <code>fn2</code>. If the callables
  return a singleton list, the element is extracted from the list.</p>
<p>Raises:
  TypeError: if <code>fn1</code> or <code>fn2</code> is not callable.
  ValueError: if <code>fn1</code> and <code>fn2</code> do not return the same number of tensors, or
              return tensors of different types.</p>
<p>Example:</p>
<p><code>python
  x = tf.constant(2)
  y = tf.constant(5)
  def f1(): return tf.mul(x, 17)
  def f2(): return tf.add(y, 23)
  r = cond(tf.less(x, y), f1, f2)
  # r is set to f1().
  # Operations in f2 (e.g., tf.add) are not executed.</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cond', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cond" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conj">
    <p>def <span class="ident">conj</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conj(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.conj</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.conj(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conj(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.conj</strong></p>
<div class="codehilite"><pre><span></span>Returns the complex conjugate of a complex number.
</pre></div>


<p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
complex numbers that are the complex conjugate of each element in <code>input</code>. The
complex numbers in <code>input</code> must be of the form \(a + bj\), where <em>a</em> is the
real part and <em>b</em> is the imaginary part.</p>
<p>The complex conjugate returned by this operation is of the form \(a - bj\).</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span># tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.conj(input) ==&gt; [-2.25 - 4.75j, 3.25 - 5.75j]
</pre></div>


<p>If <code>x</code> is real, it is returned unchanged.</p>
<p>Args:
  x: <code>Tensor</code> to conjugate.  Must have numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> that is the conjugate of <code>x</code> (with the same type).</p>
<p>Raises:
  TypeError: If <code>x</code> is not a numeric tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conj', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conj" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.constant">
    <p>def <span class="ident">constant</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.constant(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.constant</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.constant(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.constant(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.constant</strong></p>
<div class="codehilite"><pre><span></span>Creates a constant tensor.
</pre></div>


<p>The resulting tensor is populated with values of type <code>dtype</code>, as
 specified by arguments <code>value</code> and (optionally) <code>shape</code> (see examples
 below).</p>
<p>The argument <code>value</code> can be a constant value, or a list of values of type
 <code>dtype</code>. If <code>value</code> is a list, then the length of the list must be less
 than or equal to the number of elements implied by the <code>shape</code> argument (if
 specified). In the case where the list length is less than the number of
 elements specified by <code>shape</code>, the last element in the list will be used
 to fill the remaining entries.</p>
<p>The argument <code>shape</code> is optional. If present, it specifies the dimensions of
 the resulting tensor. If not present, the shape of <code>value</code> is used.</p>
<p>If the argument <code>dtype</code> is not specified, then the type is inferred from
 the type of <code>value</code>.</p>
<p>For example:</p>
<p>```python
 # Constant 1-D Tensor populated with value list.
 tensor = tf.constant([1, 2, 3, 4, 5, 6, 7]) =&gt; [1 2 3 4 5 6 7]</p>
<p># Constant 2-D tensor populated with scalar value -1.
 tensor = tf.constant(-1.0, shape=[2, 3]) =&gt; [[-1. -1. -1.]
                                              [-1. -1. -1.]]
 ```</p>
<p>Args:
  value:     A constant value (or list) of output type <code>dtype</code>.</p>
<p>dtype:     The type of the elements of the resulting tensor.</p>
<p>shape:     Optional dimensions of resulting tensor.</p>
<p>name:      Optional name for the tensor.</p>
<p>Returns:
  A Constant Tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.constant', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.constant" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.constant_initializer">
    <p>def <span class="ident">constant_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.constant_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.constant_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.constant_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.constant_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.constant_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors with constant values.
</pre></div>


<p>The resulting tensor is populated with values of type <code>dtype</code>, as
specified by arguments <code>value</code> following the desired <code>shape</code> of the
new tensor (see examples below).</p>
<p>The argument <code>value</code> can be a constant value, or a list of values of type
<code>dtype</code>. If <code>value</code> is a list, then the length of the list must be less
than or equal to the number of elements implied by the desired shape of the
tensor. In the case where the total number of elements in <code>value</code> is less
than the number of elements required by the tensor shape, the last element
in <code>value</code> will be used to fill the remaining entries. If the total number of
elements in <code>value</code> is greater than the number of elements required by the
tensor shape, the initializer will raise a <code>ValueError</code>.</p>
<p>Args:
  value: A Python scalar, list of values, or a N-dimensional numpy array. All
    elements of the initialized variable will be set to the corresponding
    value in the <code>value</code> argument.
  dtype: The data type.</p>
<p>Returns:
  An initializer that generates tensors with constant values.</p>
<p>Examples:
  The following example can be rewritten using a numpy.ndarray instead
  of the <code>value</code> list, even reshaped, as shown in the two commented lines
  below the <code>value</code> list initialization.</p>
<p>```python</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import tensorflow as tf</p>
<p>value = [0, 1, 2, 3, 4, 5, 6, 7]</p>
<h1>value = np.array(value)</h1>
<h1>value = value.reshape([2, 4])</h1>
<p>init = tf.constant_initializer(value)</p>
<p>print('fitting shape:')
tf.reset_default_graph()
with tf.Session():
  x = tf.get_variable('x', shape=[2, 4], initializer=init)
  x.initializer.run()
  print(x.eval())</p>
</blockquote>
</blockquote>
</blockquote>
<p>fitting shape:
  [[ 0.  1.  2.  3.]
   [ 4.  5.  6.  7.]]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print('larger shape:')
tf.reset_default_graph()
with tf.Session():
  x = tf.get_variable('x', shape=[3, 4], initializer=init)
  x.initializer.run()
  print(x.eval())</p>
</blockquote>
</blockquote>
</blockquote>
<p>larger shape:
  [[ 0.  1.  2.  3.]
   [ 4.  5.  6.  7.]
   [ 7.  7.  7.  7.]]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print('smaller shape:')
tf.reset_default_graph()
with tf.Session():
  x = tf.get_variable('x', shape=[2, 3], initializer=init)</p>
</blockquote>
</blockquote>
</blockquote>
<p>ValueError: Too many elements provided. Needed at most 6, but received 8
  ```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.constant_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.constant_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.container">
    <p>def <span class="ident">container</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.container(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.container</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.container(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.container(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.container</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.container()` using the default graph.
</pre></div>


<p>Args:
  container_name: The container string to use in the context.</p>
<p>Returns:
  A context manager that specifies the default container to use for newly
  created stateful ops.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.container', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.container" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.control_dependencies">
    <p>def <span class="ident">control_dependencies</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.control_dependencies(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.control_dependencies</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.control_dependencies(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.control_dependencies(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.control_dependencies</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.control_dependencies()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.control_dependencies"><code>Graph.control_dependencies()</code></a>
for more details.</p>
<p>Args:
  control_inputs: A list of <code>Operation</code> or <code>Tensor</code> objects which
    must be executed or computed before running the operations
    defined in the context.  Can also be <code>None</code> to clear the control
    dependencies.</p>
<p>Returns:
 A context manager that specifies control dependencies for all
 operations constructed within the context.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.control_dependencies', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.control_dependencies" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv1d">
    <p>def <span class="ident">conv1d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv1d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv1d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv1d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv1d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv1d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 1-D convolution given 3-D input and filter tensors.
</pre></div>


<p>Given an input tensor of shape [batch, in_width, in_channels]
and a filter / kernel tensor of shape
[filter_width, in_channels, out_channels], this op reshapes
the arguments to pass them to conv2d to perform the equivalent
convolution operation.</p>
<p>Internally, this op reshapes the input tensors and invokes
<code>tf.nn.conv2d</code>.  A tensor of shape [batch, in_width, in_channels]
is reshaped to [batch, 1, in_width, in_channels], and the filter
is reshaped to [1, filter_width, in_channels, out_channels].
The result is then reshaped back to [batch, out_width, out_channels]
(where out_width is a function of the stride and padding as in
conv2d) and returned to the caller.</p>
<p>Args:
  value: A 3D <code>Tensor</code>.  Must be of type <code>float32</code> or <code>float64</code>.
  filters: A 3D <code>Tensor</code>.  Must have the same type as <code>input</code>.
  stride: An <code>integer</code>.  The number of entries by which
    the filter is moved right at each step.
  padding: 'SAME' or 'VALID'
  use_cudnn_on_gpu: An optional <code>bool</code>.  Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from <code>"NHWC", "NCHW"</code>.  Defaults
    to <code>"NHWC"</code>, the data is stored in the order of
    [batch, in_width, in_channels].  The <code>"NCHW"</code> format stores
    data as [batch, in_channels, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>.  Has the same type as input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv1d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv1d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer">
    <p>def <span class="ident">conv1d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv1d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv1d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv1d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv1d_layer">
    <p>def <span class="ident">conv1d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv1d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv1d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv1d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv1d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv1d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d">
    <p>def <span class="ident">conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>, this op
performs the following:</p>
<ol>
<li>Flattens the filter to a 2-D matrix with shape
   <code>[filter_height * filter_width * in_channels, output_channels]</code>.</li>
<li>Extracts image patches from the input tensor to form a <em>virtual</em>
   tensor of shape <code>[batch, out_height, out_width,
   filter_height * filter_width * in_channels]</code>.</li>
<li>For each patch, right-multiplies the filter matrix and the image patch
   vector.</li>
</ol>
<p>In detail, with the default NHWC format,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter">
    <p>def <span class="ident">conv2d_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer">
    <p>def <span class="ident">conv2d_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer">
    <p>def <span class="ident">conv2d_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_input">
    <p>def <span class="ident">conv2d_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer">
    <p>def <span class="ident">conv2d_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer">
    <p>def <span class="ident">conv2d_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer">
    <p>def <span class="ident">conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_layer">
    <p>def <span class="ident">conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_transpose">
    <p>def <span class="ident">conv2d_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv2d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv2d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv2d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv2d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv2d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, height, width, in_channels]</code>.
  filter: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer">
    <p>def <span class="ident">conv2d_transpose_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_transpose_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_transpose_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_transpose`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer">
    <p>def <span class="ident">conv2d_transpose_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv2d_transpose_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv2d_transpose_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_transpose`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d">
    <p>def <span class="ident">conv3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv3d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 3-D convolution given 5-D `input` and `filter` tensors.
</pre></div>


<p>In signal processing, cross-correlation is a measure of similarity of
two waveforms as a function of a time-lag applied to one of them. This
is also known as a sliding dot product or sliding inner-product.</p>
<p>Our Conv3D implements a form of cross-correlation.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[filter_depth, filter_height, filter_width, in_channels,
    out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter">
    <p>def <span class="ident">conv3d_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv3d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv3d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv3d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer">
    <p>def <span class="ident">conv3d_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2">
    <p>def <span class="ident">conv3d_backprop_filter_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv3d_backprop_filter_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv3d_backprop_filter_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv3d_backprop_filter_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 5-D
    <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
    tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_filter_v2_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_v2_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_v2_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter_v2`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer">
    <p>def <span class="ident">conv3d_backprop_filter_v2_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_v2_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_filter_v2_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter_v2`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input">
    <p>def <span class="ident">conv3d_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv3d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv3d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv3d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer">
    <p>def <span class="ident">conv3d_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2">
    <p>def <span class="ident">conv3d_backprop_input_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv3d_backprop_input_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv3d_backprop_input_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv3d_backprop_input_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>input</code>,
    where <code>input</code> is a 5-D
    <code>[batch, depth, rows, cols, in_channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_input_v2_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_v2_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_v2_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input_v2`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer">
    <p>def <span class="ident">conv3d_backprop_input_v2_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_v2_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_backprop_input_v2_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input_v2`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer">
    <p>def <span class="ident">conv3d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_layer">
    <p>def <span class="ident">conv3d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_transpose">
    <p>def <span class="ident">conv3d_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.conv3d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.conv3d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.conv3d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv3d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv3d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 5-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, depth, height, width, in_channels]</code>.
  filter: A 5-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[depth, height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer">
    <p>def <span class="ident">conv3d_transpose_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_transpose_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_transpose_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_transpose`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer">
    <p>def <span class="ident">conv3d_transpose_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.conv3d_transpose_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.conv3d_transpose_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_transpose`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convert_to_tensor">
    <p>def <span class="ident">convert_to_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.convert_to_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.convert_to_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.convert_to_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.convert_to_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.convert_to_tensor</strong></p>
<div class="codehilite"><pre><span></span>Converts the given `value` to a `Tensor`.
</pre></div>


<p>This function converts Python objects of various types to <code>Tensor</code>
objects. It accepts <code>Tensor</code> objects, numpy arrays, Python lists,
and Python scalars. For example:</p>
<p>```python
import numpy as np</p>
<p>def my_func(arg):
  arg = tf.convert_to_tensor(arg, dtype=tf.float32)
  return tf.matmul(arg, arg) + arg</p>
<h1>The following calls are equivalent.</h1>
<p>value_1 = my_func(tf.constant([[1.0, 2.0], [3.0, 4.0]]))
value_2 = my_func([[1.0, 2.0], [3.0, 4.0]])
value_3 = my_func(np.array([[1.0, 2.0], [3.0, 4.0]], dtype=np.float32))
```</p>
<p>This function can be useful when composing a new operation in Python
(such as <code>my_func</code> in the example above). All standard Python op
constructors apply this function to each of their Tensor-valued
inputs, which allows those ops to accept numpy arrays, Python lists,
and scalars in addition to <code>Tensor</code> objects.</p>
<p>Args:
  value: An object whose type has a registered <code>Tensor</code> conversion function.
  dtype: Optional element type for the returned tensor. If missing, the
    type is inferred from the type of <code>value</code>.
  name: Optional name to use if a new <code>Tensor</code> is created.
  as_ref: True if we want the result as a ref tensor. Only used if a new
    <code>Tensor</code> is created.
  preferred_dtype: Optional element type for the returned tensor,
    used when dtype is None. In some cases, a caller may not have a
    dtype in mind when converting to a tensor, so preferred_dtype
    can be used as a soft preference.  If the conversion to
    <code>preferred_dtype</code> is not possible, this argument has no effect.</p>
<p>Returns:
  A <code>Tensor</code> based on <code>value</code>.</p>
<p>Raises:
  TypeError: If no conversion function is registered for <code>value</code>.
  RuntimeError: If a registered conversion function returns an invalid value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convert_to_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convert_to_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices">
    <p>def <span class="ident">convert_to_tensor_or_indexed_slices</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.convert_to_tensor_or_indexed_slices(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.convert_to_tensor_or_indexed_slices</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.convert_to_tensor_or_indexed_slices(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.convert_to_tensor_or_indexed_slices(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.convert_to_tensor_or_indexed_slices</strong></p>
<div class="codehilite"><pre><span></span>Converts the given object to a `Tensor` or an `IndexedSlices`.
</pre></div>


<p>If <code>value</code> is an <code>IndexedSlices</code> or <code>SparseTensor</code> it is returned
unmodified. Otherwise, it is converted to a <code>Tensor</code> using
<code>convert_to_tensor()</code>.</p>
<p>Args:
  value: An <code>IndexedSlices</code>, <code>SparseTensor</code>, or an object that can be consumed
    by <code>convert_to_tensor()</code>.
  dtype: (Optional.) The required <code>DType</code> of the returned <code>Tensor</code> or
    <code>IndexedSlices</code>.
  name: (Optional.) A name to use if a new <code>Tensor</code> is created.
  as_ref: True if the caller wants the results as ref tensors.</p>
<p>Returns:
  An <code>Tensor</code>, <code>IndexedSlices</code>, or <code>SparseTensor</code> based on <code>value</code>.</p>
<p>Raises:
  ValueError: If <code>dtype</code> does not match the element type of <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convolution2d">
    <p>def <span class="ident">convolution2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.convolution2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.convolution2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convolution2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convolution2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cos">
    <p>def <span class="ident">cos</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cos(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cos</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cos(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cos(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cos</strong></p>
<div class="codehilite"><pre><span></span>Computes cos of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cos', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cos" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.count_up_to">
    <p>def <span class="ident">count_up_to</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.count_up_to(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.count_up_to</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.count_up_to(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.count_up_to(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.count_up_to</strong></p>
<div class="codehilite"><pre><span></span>Increments &#39;ref&#39; until it reaches &#39;limit&#39;.
</pre></div>


<p>This operation outputs "ref" after the update is done.  This makes it
easier to chain operations that need to use the updated value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Should be from a scalar <code>Variable</code> node.
  limit: An <code>int</code>.
    If incrementing ref would bring it above limit, instead generates an
    'OutOfRange' error.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>ref</code>.
  A copy of the input before increment. If nothing else modifies the
  input, the values produced will all be distinct.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.count_up_to', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.count_up_to" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.create_partitioned_variables">
    <p>def <span class="ident">create_partitioned_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.create_partitioned_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.create_partitioned_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.create_partitioned_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.create_partitioned_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.create_partitioned_variables</strong></p>
<div class="codehilite"><pre><span></span>Create a list of partitioned variables according to the given `slicing`.
</pre></div>


<p>Currently only one dimension of the full variable can be sliced, and the
full variable can be reconstructed by the concatenation of the returned
list along that dimension.</p>
<p>Args:
  shape: List of integers.  The shape of the full variable.
  slicing: List of integers.  How to partition the variable.
    Must be of the same length as <code>shape</code>.  Each value
    indicate how many slices to create in the corresponding
    dimension.  Presently only one of the values can be more than 1;
    that is, the variable can only be sliced along one dimension.</p>
<div class="codehilite"><pre><span></span>For convenience, The requested number of partitions does not have to
divide the corresponding dimension evenly.  If it does not, the
shapes of the partitions are incremented by 1 starting from partition
0 until all slack is absorbed.  The adjustment rules may change in the
future, but as you can save/restore these variables with different
slicing specifications this should not be a problem.
</pre></div>


<p>initializer: A <code>Tensor</code> of shape <code>shape</code> or a variable initializer
    function.  If a function, it will be called once for each slice,
    passing the shape and data type of the slice as parameters.  The
    function must return a tensor with the same shape as the slice.
  dtype: Type of the variables. Ignored if <code>initializer</code> is a <code>Tensor</code>.
  trainable: If True also add all the variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code>.
  collections: List of graph collections keys to add the variables to.
    Defaults to <code>[GraphKeys.VARIABLES]</code>.
  name: Optional name for the full variable.  Defaults to
    <code>"PartitionedVariable"</code> and gets uniquified automatically.
  reuse: Boolean or <code>None</code>; if <code>True</code> and name is set, it would reuse
    previously created variables. if <code>False</code> it will create new variables.
    if <code>None</code>, it would inherit the parent scope reuse.</p>
<p>Returns:
  A list of Variables corresponding to the slicing.</p>
<p>Raises:
  ValueError: If any of the arguments is malformed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.create_partitioned_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.create_partitioned_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.crelu">
    <p>def <span class="ident">crelu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.crelu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.crelu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.crelu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.crelu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.crelu</strong></p>
<div class="codehilite"><pre><span></span>Computes Concatenated ReLU.
</pre></div>


<p>Concatenates a ReLU which selects only the positive part of the activation
with a ReLU which selects only the <em>negative</em> part of the activation.
Note that as a result this non-linearity doubles the depth of the activations.
Source: https://arxiv.org/abs/1603.05201</p>
<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.crelu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.crelu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer">
    <p>def <span class="ident">crelu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.crelu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.crelu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.crelu`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.crelu_layer">
    <p>def <span class="ident">crelu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.crelu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.crelu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.crelu`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.crelu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.crelu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cross">
    <p>def <span class="ident">cross</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cross(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cross</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cross(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cross(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cross</strong></p>
<div class="codehilite"><pre><span></span>Compute the pairwise cross product.
</pre></div>


<p><code>a</code> and <code>b</code> must be the same shape; they can either be simple 3-element vectors,
or any shape where the innermost dimension is 3. In the latter case, each pair
of corresponding 3-element vectors is cross-multiplied independently.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    A tensor containing 3-element vectors.
  b: A <code>Tensor</code>. Must have the same type as <code>a</code>.
    Another tensor, of same type and shape as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.
  Pairwise cross product of the vectors in <code>a</code> and <code>b</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cross', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cross" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder">
    <p>def <span class="ident">ctc_beam_search_decoder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_beam_search_decoder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.ctc_beam_search_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.ctc_beam_search_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_beam_search_decoder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.ctc_beam_search_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs beam search decoding on the logits given in input.
</pre></div>


<p><strong>Note</strong> The <code>ctc_greedy_decoder</code> is a special case of the
<code>ctc_beam_search_decoder</code> with <code>top_paths=1</code> (but that decoder is faster
for this special case).</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in the output beams.
This means that if consecutive entries in a beam are the same,
only the first of these is emitted.  That is, when the top path
is <code>A B B B B</code>, the return value is:</p>
<ul>
<li><code>A B</code> if <code>merge_repeated = True</code>.</li>
<li><code>A B B B B</code> if <code>merge_repeated = False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>, size
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  beam_width: An int scalar &gt;= 0 (beam search beam width).
  top_paths: An int scalar &gt;= 0, &lt;= beam_width (controls output size).
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A list of length top_paths, where <code>decoded[j]</code>
    is a <code>SparseTensor</code> containing the decoded outputs:
    <code>decoded[j].indices</code>: Indices matrix <code>(total_decoded_outputs[j] x 2)</code>
      The rows store: [batch, time].
    <code>decoded[j].values</code>: Values vector, size <code>(total_decoded_outputs[j])</code>.
      The vector stores the decoded classes for beam j.
    <code>decoded[j].shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length[j]]</code>.
  log_probability: A <code>float</code> matrix <code>(batch_size x top_paths)</code> containing
      sequence log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer">
    <p>def <span class="ident">ctc_beam_search_decoder_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_beam_search_decoder_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_beam_search_decoder_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_beam_search_decoder`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer">
    <p>def <span class="ident">ctc_beam_search_decoder_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_beam_search_decoder_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_beam_search_decoder_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_beam_search_decoder`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder">
    <p>def <span class="ident">ctc_greedy_decoder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_greedy_decoder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.ctc_greedy_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.ctc_greedy_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_greedy_decoder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.ctc_greedy_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs greedy decoding on the logits given in input (best path).
</pre></div>


<p>Note: Regardless of the value of merge_repeated, if the maximum index of a
given time and batch corresponds to the blank index <code>(num_classes - 1)</code>, no
new element is emitted.</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in output.
This means that if consecutive logits' maximum indices are the same,
only the first of these is emitted.  The sequence <code>A B B * B * B</code> (where '*'
is the blank label) becomes</p>
<ul>
<li><code>A B</code> if <code>merge_repeated=True</code>.</li>
<li><code>A B B B B B</code> if <code>merge_repeated=False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code> sized
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A single-element list. <code>decoded[0]</code>
    is an <code>SparseTensor</code> containing the decoded outputs s.t.:
    <code>decoded.indices</code>: Indices matrix <code>(total_decoded_outputs x 2)</code>.
      The rows store: <code>[batch, time]</code>.
    <code>decoded.values</code>: Values vector, size <code>(total_decoded_outputs)</code>.
      The vector stores the decoded classes.
    <code>decoded.shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length]</code>
  log_probability: A <code>float</code> matrix <code>(batch_size x 1)</code> containing sequence
      log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer">
    <p>def <span class="ident">ctc_greedy_decoder_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_greedy_decoder_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_greedy_decoder_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_greedy_decoder`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer">
    <p>def <span class="ident">ctc_greedy_decoder_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_greedy_decoder_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_greedy_decoder_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_greedy_decoder`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_loss">
    <p>def <span class="ident">ctc_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.ctc_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.ctc_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.ctc_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes the CTC (Connectionist Temporal Classification) Loss.
</pre></div>


<p>This op implements the CTC loss as presented in the article:</p>
<p>A. Graves, S. Fernandez, F. Gomez, J. Schmidhuber.
Connectionist Temporal Classification: Labelling Unsegmented Sequence Data
with Recurrent Neural Networks. ICML 2006, Pittsburgh, USA, pp. 369-376.</p>
<p>http://www.cs.toronto.edu/~graves/icml_2006.pdf</p>
<p>Input requirements:</p>
<p>```
sequence_length(b) &lt;= time for all b</p>
<p>max(labels.indices(labels.indices[:, 1] == b, 2))
  &lt;= sequence_length(b) for all b.
```</p>
<p>Notes:</p>
<p>This class performs the softmax operation for you, so inputs should
be e.g. linear projections of outputs by an LSTM.</p>
<p>The <code>inputs</code> Tensor's innermost dimension size, <code>num_classes</code>, represents
<code>num_labels + 1</code> classes, where num_labels is the number of true labels, and
the largest value <code>(num_classes - 1)</code> is reserved for the blank label.</p>
<p>For example, for a vocabulary containing 3 labels <code>[a, b, c]</code>,
<code>num_classes = 4</code> and the labels indexing is <code>{a: 0, b: 1, c: 2, blank: 3}</code>.</p>
<p>Regarding the arguments <code>preprocess_collapse_repeated</code> and
<code>ctc_merge_repeated</code>:</p>
<p>If <code>preprocess_collapse_repeated</code> is True, then a preprocessing step runs
before loss calculation, wherein repeated labels passed to the loss
are merged into single labels.  This is useful if the training labels come
from, e.g., forced alignments and therefore have unnecessary repetitions.</p>
<p>If <code>ctc_merge_repeated</code> is set False, then deep within the CTC calculation,
repeated non-blank labels will not be merged and are interpreted
as individual labels.  This is a simplified (non-standard) version of CTC.</p>
<p>Here is a table of the (roughly) expected first order behavior:</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Classical CTC behavior: Outputs true repeated classes with blanks in
  between, and can also output repeated classes with no blanks in
  between that need to be collapsed by the decoder.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Never learns to output repeated classes, as they are collapsed
  in the input labels before training.</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Outputs repeated classes with blanks in between, but generally does not
  require the decoder to collapse/merge repeated classes.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Untested.  Very likely will not learn to output repeated classes.</p>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>.
    If time_major == False, this will be a <code>Tensor</code> shaped:
      <code>[batch_size x max_time x num_classes]</code>.
    If time_major == True (default), this will be a <code>Tensor</code> shaped:
      <code>[max_time x batch_size x num_classes]</code>.
    The logits.
  labels: An <code>int32</code> <code>SparseTensor</code>.
    <code>labels.indices[i, :] == [b, t]</code> means <code>labels.values[i]</code> stores
    the id for (batch b, time t).
    <code>labels.values[i]</code> must take on values in <code>[0, num_labels)</code>.
    See <code>core/ops/ctc_ops.cc</code> for more details.
  sequence_length: 1-D <code>int32</code> vector, size <code>[batch_size]</code>.
    The sequence lengths.
  preprocess_collapse_repeated: Boolean.  Default: False.
    If True, repeated labels are collapsed prior to the CTC calculation.
  ctc_merge_repeated: Boolean.  Default: True.
  time_major: The shape format of the <code>inputs</code> Tensors.
    If True, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, num_classes]</code>.
    If False, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, num_classes]</code>.
    Using <code>time_major = True</code> (default) is a bit more efficient because it avoids
    transposes at the beginning of the ctc_loss calculation.  However, most
    TensorFlow data is batch-major, so by this function also accepts inputs
    in batch-major form.</p>
<p>Returns:
  A 1-D <code>float</code> <code>Tensor</code>, size <code>[batch]</code>, containing the negative log probabilities.</p>
<p>Raises:
  TypeError: if labels is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer">
    <p>def <span class="ident">ctc_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_loss`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_loss_layer">
    <p>def <span class="ident">ctc_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ctc_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ctc_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_loss`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cumprod">
    <p>def <span class="ident">cumprod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cumprod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cumprod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cumprod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cumprod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cumprod</strong></p>
<div class="codehilite"><pre><span></span>Compute the cumulative product of the tensor `x` along `axis`.
</pre></div>


<p>By default, this op performs an inclusive cumprod, which means that the
first
element of the input is identical to the first element of the output:
<code>prettyprint
tf.cumprod([a, b, c]) ==&gt; [a, a * b, a * b * c]</code></p>
<p>By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumprod is
performed
instead:
<code>prettyprint
tf.cumprod([a, b, c], exclusive=True) ==&gt; [0, a, a * b]</code></p>
<p>By setting the <code>reverse</code> kwarg to <code>True</code>, the cumprod is performed in the
opposite direction:
<code>prettyprint
tf.cumprod([a, b, c], reverse=True) ==&gt; [a * b * c, b * c, c]</code>
This is more efficient than using separate <code>tf.reverse</code> ops.</p>
<p>The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:
<code>prettyprint
tf.cumprod([a, b, c], exclusive=True, reverse=True) ==&gt; [b * c, c, 0]</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
     <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
     <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  axis: A <code>Tensor</code> of type <code>int32</code> (default: 0).
  reverse: A <code>bool</code> (default: False).
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cumprod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cumprod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cumsum">
    <p>def <span class="ident">cumsum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.cumsum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cumsum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cumsum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.cumsum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cumsum</strong></p>
<div class="codehilite"><pre><span></span>Compute the cumulative sum of the tensor `x` along `axis`.
</pre></div>


<p>By default, this op performs an inclusive cumsum, which means that the first
element of the input is identical to the first element of the output:
<code>prettyprint
tf.cumsum([a, b, c]) ==&gt; [a, a + b, a + b + c]</code></p>
<p>By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumsum is performed
instead:
<code>prettyprint
tf.cumsum([a, b, c], exclusive=True) ==&gt; [0, a, a + b]</code></p>
<p>By setting the <code>reverse</code> kwarg to <code>True</code>, the cumsum is performed in the
opposite direction:
<code>prettyprint
tf.cumsum([a, b, c], reverse=True) ==&gt; [a + b + c, b + c, c]</code>
This is more efficient than using separate <code>tf.reverse</code> ops.</p>
<p>The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:
<code>prettyprint
tf.cumsum([a, b, c], exclusive=True, reverse=True) ==&gt; [b + c, c, 0]</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
     <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
     <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
     axis: A <code>Tensor</code> of type <code>int32</code> (default: 0).
     reverse: A <code>bool</code> (default: False).
     name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cumsum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cumsum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.data">
    <p>def <span class="ident">data</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.data', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_base64">
    <p>def <span class="ident">decode_base64</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.decode_base64(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_base64</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_base64(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.decode_base64(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_base64</strong></p>
<div class="codehilite"><pre><span></span>Decode web-safe base64-encoded strings.
</pre></div>


<p>Input may or may not have padding at the end. See EncodeBase64 for padding.
Web-safe means that input must use - and _ instead of + and /.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. Base64 strings to decode.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. Decoded strings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_base64', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_base64" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_csv">
    <p>def <span class="ident">decode_csv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.decode_csv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_csv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_csv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.decode_csv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_csv</strong></p>
<div class="codehilite"><pre><span></span>Convert CSV records to tensors. Each column maps to one tensor.
</pre></div>


<p>RFC 4180 format is expected for the CSV records.
(https://tools.ietf.org/html/rfc4180)
Note that we allow leading and trailing spaces with int or float field.</p>
<p>Args:
  records: A <code>Tensor</code> of type <code>string</code>.
    Each string is a record/row in the csv and all records should have
    the same format.
  record_defaults: A list of <code>Tensor</code> objects with types from: <code>float32</code>, <code>int32</code>, <code>int64</code>, <code>string</code>.
    One tensor per column of the input record, with either a
    scalar default value for that column or empty if the column is required.
  field_delim: An optional <code>string</code>. Defaults to <code>","</code>.
    delimiter to separate fields in a record.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list of <code>Tensor</code> objects. Has the same type as <code>record_defaults</code>.
  Each tensor will have the same shape as records.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_csv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_csv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_json_example">
    <p>def <span class="ident">decode_json_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.decode_json_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_json_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_json_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.decode_json_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_json_example</strong></p>
<div class="codehilite"><pre><span></span>Convert JSON-encoded Example records to binary protocol buffer strings.
</pre></div>


<p>This op translates a tensor containing Example records, encoded using
the <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">standard JSON
mapping</a>,
into a tensor containing the same records encoded as binary protocol
buffers. The resulting tensor can then be fed to any of the other
Example-parsing ops.</p>
<p>Args:
  json_examples: A <code>Tensor</code> of type <code>string</code>.
    Each string is a JSON object serialized according to the JSON
    mapping of the Example proto.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.
  Each string is a binary Example protocol buffer corresponding
  to the respective element of <code>json_examples</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_json_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_json_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_raw">
    <p>def <span class="ident">decode_raw</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.decode_raw(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_raw</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_raw(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.decode_raw(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_raw</strong></p>
<div class="codehilite"><pre><span></span>Reinterpret the bytes of a string as a vector of numbers.
</pre></div>


<p>Args:
  bytes: A <code>Tensor</code> of type <code>string</code>.
    All the elements must have the same length.
  out_type: A <code>tf.DType</code> from: <code>tf.float32, tf.float64, tf.int32, tf.uint8, tf.int16, tf.int8, tf.int64</code>.
  little_endian: An optional <code>bool</code>. Defaults to <code>True</code>.
    Whether the input <code>bytes</code> are in little-endian order.
    Ignored for <code>out_type</code> values that are stored in a single byte like
    <code>uint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>.
  A Tensor with one more dimension than the input <code>bytes</code>.  The
  added dimension will have size equal to the length of the elements
  of <code>bytes</code> divided by the number of bytes to represent <code>out_type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_raw', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_raw" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.delete_session_tensor">
    <p>def <span class="ident">delete_session_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.delete_session_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.delete_session_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.delete_session_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.delete_session_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.delete_session_tensor</strong></p>
<div class="codehilite"><pre><span></span>Delete the tensor for the given tensor handle.
</pre></div>


<p>This is EXPERIMENTAL and subject to change.</p>
<p>Delete the tensor of a given tensor handle. The tensor is produced
in a previous run() and stored in the state of the session.</p>
<p>Args:
  handle: The string representation of a persistent tensor handle.
  name: Optional name prefix for the return tensor.</p>
<p>Returns:
  A pair of graph elements. The first is a placeholder for feeding a
  tensor handle and the second is a deletion operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.delete_session_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.delete_session_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depth_to_space">
    <p>def <span class="ident">depth_to_space</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depth_to_space(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.depth_to_space</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.depth_to_space(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depth_to_space(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.depth_to_space</strong></p>
<div class="codehilite"><pre><span></span>DepthToSpace for tensors of type T.
</pre></div>


<p>Rearranges data from depth into blocks of spatial data.
This is the reverse transformation of SpaceToDepth. More specifically,
this op outputs a copy of the input tensor where values from the <code>depth</code>
dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions.
The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>
<ul>
<li>Chunks of data of size <code>block_size * block_size</code> from depth are rearranged
    into non-overlapping blocks of size <code>block_size x block_size</code></li>
<li>The width the output tensor is <code>input_depth * block_size</code>, whereas the
    height is <code>input_height * block_size</code>.</li>
<li>The depth of the input tensor must be divisible by
    <code>block_size * block_size</code>.</li>
</ul>
<p>That is, assuming the input is in the shape:
<code>[batch, height, width, depth]</code>,
the shape of the output will be:
<code>[batch, height*block_size, width*block_size, depth/(block_size*block_size)]</code></p>
<p>This operation requires that the input tensor be of rank 4, and that
<code>block_size</code> be &gt;=1 and that <code>block_size * block_size</code> be a divisor of the
input depth.</p>
<p>This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</p>
<p>For example, given this input of shape <code>[1, 1, 1, 4]</code>, and a block size of 2:</p>
<p>```prettyprint
x = [[[[1, 2, 3, 4]]]]</p>
<p>```</p>
<p>This operation will output a tensor of shape <code>[1, 2, 2, 1]</code>:</p>
<p><code>prettyprint
   [[[[1], [2]],
     [[3], [4]]]]</code></p>
<p>Here, the input has a batch of 1 and each batch element has shape <code>[1, 1, 4]</code>,
the corresponding output will have 2x2 elements and will have a depth of
1 channel (1 = <code>4 / (block_size * block_size)</code>).
The output element shape is <code>[2, 2, 1]</code>.</p>
<p>For an input tensor with larger depth, here of shape <code>[1, 1, 1, 12]</code>, e.g.</p>
<p><code>prettyprint
x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]</code></p>
<p>This operation, for block size of 2, will return the following tensor of shape
<code>[1, 2, 2, 3]</code></p>
<p>```prettyprint
   [[[[1, 2, 3], [4, 5, 6]],
     [[7, 8, 9], [10, 11, 12]]]]</p>
<p>```</p>
<p>Similarly, for the following input of shape <code>[1 2 2 4]</code>, and a block size of 2:</p>
<p><code>prettyprint
x =  [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]</code></p>
<p>the operator will return the following tensor of shape <code>[1 4 4 1]</code>:</p>
<p>```prettyprint
x = [[ [1],   [2],  [5],  [6]],
     [ [3],   [4],  [7],  [8]],
     [ [9],  [10], [13],  [14]],
     [ [11], [12], [15],  [16]]]</p>
<p>```</p>
<p>Args:
  input: A <code>Tensor</code>.
  block_size: An <code>int</code> that is <code>&gt;= 2</code>.
    The size of the spatial block, same as in Space2Depth.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depth_to_space', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depth_to_space" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d">
    <p>def <span class="ident">depthwise_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.depthwise_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.depthwise_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.depthwise_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Depthwise 2-D convolution.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>
containing <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code>
applies a different filter to each input channel (expanding from 1 channel
to <code>channel_multiplier</code> channels for each), then concatenates the results
together.  The output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k * channel_multiplier + q] =
    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                 filter[di, dj, k, q]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the
same horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter: 4-D with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
  strides: 1-D of size 4.  The stride of the sliding window for each
    dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape
  <code>[batch, out_height, out_width, in_channels * channel_multiplier].</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native">
    <p>def <span class="ident">depthwise_conv2d_native</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.depthwise_conv2d_native</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.depthwise_conv2d_native(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.depthwise_conv2d_native</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing
<code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies
a different filter to each input channel (expanding from 1 channel to
<code>channel_multiplier</code> channels for each), then concatenates the results
together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>for k in 0..in_channels-1
  for q in 0..channel_multiplier-1
    output[b, i, j, k * channel_multiplier + q] =
      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]</p>
<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.depthwise_conv2d_native_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.depthwise_conv2d_native_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.depthwise_conv2d_native_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.depthwise_conv2d_native_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.depthwise_conv2d_native_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.depthwise_conv2d_native_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_native_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer">
    <p>def <span class="ident">depthwise_conv2d_native_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.depthwise_conv2d_native_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.deserialize_many_sparse">
    <p>def <span class="ident">deserialize_many_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.deserialize_many_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.deserialize_many_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.deserialize_many_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.deserialize_many_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.deserialize_many_sparse</strong></p>
<div class="codehilite"><pre><span></span>Deserialize and concatenate `SparseTensors` from a serialized minibatch.
</pre></div>


<p>The input <code>serialized_sparse</code> must be a string matrix of shape <code>[N x 3]</code> where
<code>N</code> is the minibatch size and the rows correspond to packed outputs of
<code>serialize_sparse</code>.  The ranks of the original <code>SparseTensor</code> objects
must all match.  When the final <code>SparseTensor</code> is created, it has rank one
higher than the ranks of the incoming <code>SparseTensor</code> objects (they have been
concatenated along a new row dimension).</p>
<p>The output <code>SparseTensor</code> object's shape values for all dimensions but the
first are the max across the input <code>SparseTensor</code> objects' shape values
for the corresponding dimensions.  Its first shape value is <code>N</code>, the minibatch
size.</p>
<p>The input <code>SparseTensor</code> objects' indices are assumed ordered in
standard lexicographic order.  If this is not the case, after this
step run <code>sparse_reorder</code> to restore index ordering.</p>
<p>For example, if the serialized input is a <code>[2, 3]</code> matrix representing two
original <code>SparseTensor</code> objects:</p>
<div class="codehilite"><pre><span></span>index = [ 0]
        [10]
        [20]
values = [1, 2, 3]
shape = [50]
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>index = [ 2]
        [10]
values = [4, 5]
shape = [30]
</pre></div>


<p>then the final deserialized <code>SparseTensor</code> will be:</p>
<div class="codehilite"><pre><span></span>index = [0  0]
        [0 10]
        [0 20]
        [1  2]
        [1 10]
values = [1, 2, 3, 4, 5]
shape = [2 50]
</pre></div>


<p>Args:
  serialized_sparse: 2-D <code>Tensor</code> of type <code>string</code> of shape <code>[N, 3]</code>.
    The serialized and packed <code>SparseTensor</code> objects.
  dtype: The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.
  rank: (optional) Python int, the rank of the <code>SparseTensor</code> objects.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A <code>SparseTensor</code> representing the deserialized <code>SparseTensor</code>s,
  concatenated along the <code>SparseTensor</code>s' first dimension.</p>
<p>All of the serialized <code>SparseTensor</code>s must have had the same rank and type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.deserialize_many_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.deserialize_many_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.device">
    <p>def <span class="ident">device</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.device(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.device</code>. 
However, a partial with the arguments is returned which expects any argument <code>x</code> and complete ignores it, such that</p>
<div class="codehilite"><pre><span></span>tensorflow.device(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.device(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.device</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.device()` using the default graph.
</pre></div>


<p>See
<a href="../../api_docs/python/framework.md#Graph.device"><code>Graph.device()</code></a>
for more details.</p>
<p>Args:
  device_name_or_function: The device name or function to use in
    the context.</p>
<p>Returns:
  A context manager that specifies the default device to use for newly
  created ops.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.device', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.device" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.diag">
    <p>def <span class="ident">diag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.diag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.diag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.diag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.diag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.diag</strong></p>
<div class="codehilite"><pre><span></span>Returns a diagonal tensor with a given diagonal values.
</pre></div>


<p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
everything else padded with zeros. The diagonal is computed as follows:</p>
<p>Assume <code>diagonal</code> has dimensions [D1,..., Dk], then the output is a tensor of
rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:</p>
<p><code>output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]</code> and 0 everywhere else.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'diagonal' is [1, 2, 3, 4]</h1>
<p>tf.diag(diagonal) ==&gt; [[1, 0, 0, 0]
                       [0, 2, 0, 0]
                       [0, 0, 3, 0]
                       [0, 0, 0, 4]]
```</p>
<p>Args:
  diagonal: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
    Rank k tensor where k is at most 3.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>diagonal</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.diag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.diag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.diag_part">
    <p>def <span class="ident">diag_part</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.diag_part(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.diag_part</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.diag_part(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.diag_part(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.diag_part</strong></p>
<div class="codehilite"><pre><span></span>Returns the diagonal part of the tensor.
</pre></div>


<p>This operation returns a tensor with the <code>diagonal</code> part
of the <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>
<p>Assume <code>input</code> has dimensions <code>[D1,..., Dk, D1,..., Dk]</code>, then the output is a
tensor of rank <code>k</code> with dimensions <code>[D1,..., Dk]</code> where:</p>
<p><code>diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'input' is [[1, 0, 0, 0]</h1>
<div class="codehilite"><pre><span></span>          [0, 2, 0, 0]
          [0, 0, 3, 0]
          [0, 0, 0, 4]]
</pre></div>


<p>tf.diag_part(input) ==&gt; [1, 2, 3, 4]
```</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
    Rank k tensor where k is 2, 4, or 6.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. The extracted diagonal.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.diag_part', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.diag_part" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.digamma">
    <p>def <span class="ident">digamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.digamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.digamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.digamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.digamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.digamma</strong></p>
<div class="codehilite"><pre><span></span>Computes Psi, the derivative of Lgamma (the log of the absolute value of
</pre></div>


<p><code>Gamma(x)</code>), element-wise.</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.digamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.digamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d">
    <p>def <span class="ident">dilation2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.dilation2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.dilation2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.dilation2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.
</pre></div>


<p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each
input channel is processed independently of the others with its own structuring
function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output
tensor depend on the <code>padding</code> algorithm. We currently only support the default
"NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D dilation is the max-sum correlation
(for consistency with <code>conv2d</code>, we use unmirrored filters):</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   max_{dy, dx} input[b,
                      strides[1] * y + rates[1] * dy,
                      strides[2] * x + rates[2] * dx,
                      c] +
                filter[dy, dx, c]
</pre></div>


<p>Max-pooling is a special case when the filter has size equal to the pooling
kernel size and contains all zeros.</p>
<p>Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the
negation of the erosion of <code>-input</code> by the reflected <code>filter</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the input
    tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The input stride for atrous morphological dilation. Must be:
    <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter">
    <p>def <span class="ident">dilation2d_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.dilation2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.dilation2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.dilation2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  3-D with shape <code>[filter_height, filter_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer">
    <p>def <span class="ident">dilation2d_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer">
    <p>def <span class="ident">dilation2d_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_filter`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input">
    <p>def <span class="ident">dilation2d_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.dilation2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.dilation2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.dilation2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer">
    <p>def <span class="ident">dilation2d_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer">
    <p>def <span class="ident">dilation2d_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_input`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer">
    <p>def <span class="ident">dilation2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_layer">
    <p>def <span class="ident">dilation2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dilation2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.div">
    <p>def <span class="ident">div</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.div(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.div</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.div(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.div(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.div</strong></p>
<div class="codehilite"><pre><span></span>Returns x / y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Div</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.div', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.div" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.drop_layer">
    <p>def <span class="ident">drop_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.drop_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.drop_layer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.drop_layer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.drop_layer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tb.drop_layer</strong></p>
<div class="codehilite"><pre><span></span>Computes dropout.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>Args:
  x: A tensor.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).
Returns:
  A Tensor of the same shape of <code>x</code>.
Raises:
  ValueError: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.drop_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.drop_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dropout">
    <p>def <span class="ident">dropout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dropout(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.dropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.dropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dropout(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.dropout</strong></p>
<div class="codehilite"><pre><span></span>Computes dropout.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>By default, each element is kept or dropped independently.  If <code>noise_shape</code>
is specified, it must be
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcastable</a>
to the shape of <code>x</code>, and only dimensions with <code>noise_shape[i] == shape(x)[i]</code>
will make independent decisions.  For example, if <code>shape(x) = [k, l, m, n]</code>
and <code>noise_shape = [k, 1, 1, n]</code>, each batch and channel component will be
kept independently and each row and column will be kept or not kept together.</p>
<p>Args:
  x: A tensor.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).</p>
<p>Returns:
  A Tensor of the same shape of <code>x</code>.</p>
<p>Raises:
  ValueError: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dropout', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dropout" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer">
    <p>def <span class="ident">dropout_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dropout_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dropout_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dropout`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dropout_layer">
    <p>def <span class="ident">dropout_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dropout_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dropout_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dropout`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dropout_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dropout_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_partition">
    <p>def <span class="ident">dynamic_partition</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dynamic_partition(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.dynamic_partition</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.dynamic_partition(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dynamic_partition(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.dynamic_partition</strong></p>
<div class="codehilite"><pre><span></span>Partitions `data` into `num_partitions` tensors using indices from `partitions`.
</pre></div>


<p>For each index tuple <code>js</code> of size <code>partitions.ndim</code>, the slice <code>data[js, ...]</code>
becomes part of <code>outputs[partitions[js]]</code>.  The slices with <code>partitions[js] = i</code>
are placed in <code>outputs[i]</code> in lexicographic order of <code>js</code>, and the first
dimension of <code>outputs[i]</code> is the number of entries in <code>partitions</code> equal to <code>i</code>.
In detail,</p>
<div class="codehilite"><pre><span></span>outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]

outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
</pre></div>


<p><code>data.shape</code> must start with <code>partitions.shape</code>.</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span># Scalar partitions
partitions = 1
num_partitions = 2
data = [10, 20]
outputs[0] = []  # Empty with shape [0, 2]
outputs[1] = [[10, 20]]

# Vector partitions
partitions = [0, 0, 1, 1, 0]
num_partitions = 2
data = [10, 20, 30, 40, 50]
outputs[0] = [10, 20, 50]
outputs[1] = [30, 40]
</pre></div>


<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicPartition.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>.
  partitions: A <code>Tensor</code> of type <code>int32</code>.
    Any shape.  Indices in the range <code>[0, num_partitions)</code>.
  num_partitions: An <code>int</code> that is <code>&gt;= 1</code>.
    The number of partitions to output.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list of <code>num_partitions</code> <code>Tensor</code> objects of the same type as data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_partition', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_partition" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_rnn">
    <p>def <span class="ident">dynamic_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dynamic_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dynamic_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>This function is functionally identical to the function <code>rnn</code> above, but
performs fully dynamic unrolling of <code>inputs</code>.</p>
<p>Unlike <code>rnn</code>, the input <code>inputs</code> is not a Python list of <code>Tensors</code>, one for
each frame.  Instead, <code>inputs</code> may be a single <code>Tensor</code> where
the maximum time is either the first or second dimension (see the parameter
<code>time_major</code>).  Alternatively, it may be a (possibly nested) tuple of
Tensors, each of them having matching batch and time dimensions.
The corresponding output is either a single <code>Tensor</code> having the same number
of time steps and batch size, or a (possibly nested) tuple of such tensors,
matching the nested structure of <code>cell.output_size</code>.</p>
<p>The parameter <code>sequence_length</code> is optional and is used to copy-through state
and zero-out outputs when past a batch element's sequence length. So it's more
for correctness than performance, unlike in rnn().</p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: The RNN inputs.</p>
<div class="codehilite"><pre><span></span>If `time_major == False` (default), this must be a `Tensor` of shape:
  `[batch_size, max_time, ...]`, or a nested tuple of such
  elements.

If `time_major == True`, this must be a `Tensor` of shape:
  `[max_time, batch_size, ...]`, or a nested tuple of such
  elements.

This may also be a (possibly nested) tuple of Tensors satisfying
this property.  The first two dimensions must match across all the inputs,
but otherwise the ranks and other shape components may differ.
In this case, input to `cell` at each time-step will replicate the
structure of these tuples, except for the time dimension (from which the
time is taken).

The input to `cell` at each time step will be a `Tensor` or (possibly
nested) tuple of Tensors each with dimensions `[batch_size, ...]`.
</pre></div>


<p>sequence_length: (optional) An int32/int64 vector sized <code>[batch_size]</code>.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<div class="codehilite"><pre><span></span>outputs: The RNN output `Tensor`.

  If time_major == False (default), this will be a `Tensor` shaped:
    `[batch_size, max_time, cell.output_size]`.

  If time_major == True, this will be a `Tensor` shaped:
    `[max_time, batch_size, cell.output_size]`.

  Note, if `cell.output_size` is a (possibly nested) tuple of integers
  or `TensorShape` objects, then `outputs` will be a tuple having the
  same structure as `cell.output_size`, containing Tensors having shapes
  corresponding to the shape data in `cell.output_size`.

state: The final state.  If `cell.state_size` is an int, this
  will be shaped `[batch_size, cell.state_size]`.  If it is a
  `TensorShape`, this will be shaped `[batch_size] + cell.state_size`.
  If it is a (possibly nested) tuple of ints or `TensorShape`, this will
  be a tuple having the corresponding shapes.
</pre></div>


<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer">
    <p>def <span class="ident">dynamic_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dynamic_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dynamic_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dynamic_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer">
    <p>def <span class="ident">dynamic_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dynamic_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dynamic_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dynamic_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_stitch">
    <p>def <span class="ident">dynamic_stitch</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.dynamic_stitch(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.dynamic_stitch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.dynamic_stitch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.dynamic_stitch(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.dynamic_stitch</strong></p>
<div class="codehilite"><pre><span></span>Interleave the values from the `data` tensors into a single tensor.
</pre></div>


<p>Builds a merged tensor such that</p>
<div class="codehilite"><pre><span></span>merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
</pre></div>


<p>For example, if each <code>indices[m]</code> is scalar or vector, we have</p>
<div class="codehilite"><pre><span></span># Scalar indices
merged[indices[m], ...] = data[m][...]

# Vector indices
merged[indices[m][i], ...] = data[m][i, ...]
</pre></div>


<p>Each <code>data[i].shape</code> must start with the corresponding <code>indices[i].shape</code>,
and the rest of <code>data[i].shape</code> must be constant w.r.t. <code>i</code>.  That is, we
must have <code>data[i].shape = indices[i].shape + constant</code>.  In terms of this
<code>constant</code>, the output shape is</p>
<div class="codehilite"><pre><span></span>merged.shape = [max(indices)] + constant
</pre></div>


<p>Values are merged in order, so if an index appears in both <code>indices[m][i]</code> and
<code>indices[n][j]</code> for <code>(m,i) &lt; (n,j)</code> the slice <code>data[n][j]</code> will appear in the
merged result.</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span>indices[0] = 6
indices[1] = [4, 1]
indices[2] = [[5, 2], [0, 3]]
data[0] = [61, 62]
data[1] = [[41, 42], [11, 12]]
data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
          [51, 52], [61, 62]]
</pre></div>


<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicStitch.png" alt>
</div>

<p>Args:
  indices: A list of at least 1 <code>Tensor</code> objects of type <code>int32</code>.
  data: A list with the same number of <code>Tensor</code> objects as <code>indices</code> of <code>Tensor</code> objects of the same type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_stitch', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_stitch" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.edit_distance">
    <p>def <span class="ident">edit_distance</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.edit_distance(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.edit_distance</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.edit_distance(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.edit_distance(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.edit_distance</strong></p>
<div class="codehilite"><pre><span></span>Computes the Levenshtein distance between sequences.
</pre></div>


<p>This operation takes variable-length sequences (<code>hypothesis</code> and <code>truth</code>),
each provided as a <code>SparseTensor</code>, and computes the Levenshtein distance.
You can normalize the edit distance by length of <code>truth</code> by setting
<code>normalize</code> to true.</p>
<p>For example, given the following input:</p>
<p>```python</p>
<h1>'hypothesis' is a tensor of shape <code>[2, 1]</code> with variable-length values:</h1>
<h1>(0,0) = ["a"]</h1>
<h1>(1,0) = ["b"]</h1>
<p>hypothesis = tf.SparseTensor(
    [[0, 0, 0],
     [1, 0, 0]],
    ["a", "b"]
    (2, 1, 1))</p>
<h1>'truth' is a tensor of shape <code>[2, 2]</code> with variable-length values:</h1>
<h1>(0,0) = []</h1>
<h1>(0,1) = ["a"]</h1>
<h1>(1,0) = ["b", "c"]</h1>
<h1>(1,1) = ["a"]</h1>
<p>truth = tf.SparseTensor(
    [[0, 1, 0],
     [1, 0, 0],
     [1, 0, 1],
     [1, 1, 0]]
    ["a", "b", "c", "a"],
    (2, 2, 2))</p>
<p>normalize = True
```</p>
<p>This operation would return the following:</p>
<p>```python</p>
<h1>'output' is a tensor of shape <code>[2, 2]</code> with edit distances normalized</h1>
<h1>by 'truth' lengths.</h1>
<p>output ==&gt; [[inf, 1.0],  # (0,0): no truth, (0,1): no hypothesis
           [0.5, 1.0]]  # (1,0): addition, (1,1): no hypothesis
```</p>
<p>Args:
  hypothesis: A <code>SparseTensor</code> containing hypothesis sequences.
  truth: A <code>SparseTensor</code> containing truth sequences.
  normalize: A <code>bool</code>. If <code>True</code>, normalizes the Levenshtein distance by
    length of <code>truth.</code>
  name: A name for the operation (optional).</p>
<p>Returns:
  A dense <code>Tensor</code> with rank <code>R - 1</code>, where R is the rank of the
  <code>SparseTensor</code> inputs <code>hypothesis</code> and <code>truth</code>.</p>
<p>Raises:
  TypeError: If either <code>hypothesis</code> or <code>truth</code> are not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.edit_distance', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.edit_distance" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.einsum">
    <p>def <span class="ident">einsum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.einsum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.einsum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.einsum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.einsum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.einsum</strong></p>
<div class="codehilite"><pre><span></span>A generalized contraction between tensors of arbitrary dimension.
</pre></div>


<p>Like numpy.einsum.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.einsum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.einsum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.elu">
    <p>def <span class="ident">elu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.elu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.elu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.elu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.elu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.elu</strong></p>
<div class="codehilite"><pre><span></span>Computes exponential linear: `exp(features) - 1` if &lt; 0, `features` otherwise.
</pre></div>


<p>See <a href="http://arxiv.org/abs/1511.07289">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
</a></p>
<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.elu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.elu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.elu_conv2d_layer">
    <p>def <span class="ident">elu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.elu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.elu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.elu`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.elu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.elu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.elu_layer">
    <p>def <span class="ident">elu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.elu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.elu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.elu`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.elu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.elu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup">
    <p>def <span class="ident">embedding_lookup</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.embedding_lookup</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.embedding_lookup(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.embedding_lookup</strong></p>
<div class="codehilite"><pre><span></span>Looks up `ids` in a list of embedding tensors.
</pre></div>


<p>This function is used to perform parallel lookups on the list of
tensors in <code>params</code>.  It is a generalization of
<a href="../../api_docs/python/array_ops.md#gather"><code>tf.gather()</code></a>, where <code>params</code> is
interpreted as a partition of a larger embedding tensor.</p>
<p>If <code>len(params) &gt; 1</code>, each element <code>id</code> of <code>ids</code> is partitioned between
the elements of <code>params</code> according to the <code>partition_strategy</code>.
In all strategies, if the id space does not evenly divide the number of
partitions, each of the first <code>(max_id + 1) % len(params)</code> partitions will
be assigned one more id.</p>
<p>If <code>partition_strategy</code> is <code>"mod"</code>, we assign each id to partition
<code>p = id % len(params)</code>. For instance,
13 ids are split across 5 partitions as:
<code>[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]</code></p>
<p>If <code>partition_strategy</code> is <code>"div"</code>, we assign ids to partitions in a
contiguous manner. In this case, 13 ids are split across 5 partitions as:
<code>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]</code></p>
<p>The results of the lookup are concatenated into a dense
tensor. The returned tensor has shape <code>shape(ids) + shape(params)[1:]</code>.</p>
<p>Args:
  params: A list of tensors with the same type and which can be concatenated
    along dimension 0. Each <code>Tensor</code> must be appropriately sized for the given
    <code>partition_strategy</code>.
  ids: A <code>Tensor</code> with type <code>int32</code> or <code>int64</code> containing the ids to be looked
    up in <code>params</code>.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>.
  name: A name for the operation (optional).
  validate_indices: Whether or not to validate gather indices.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as the tensors in <code>params</code>.</p>
<p>Raises:
  ValueError: If <code>params</code> is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer">
    <p>def <span class="ident">embedding_lookup_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_layer">
    <p>def <span class="ident">embedding_lookup_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse">
    <p>def <span class="ident">embedding_lookup_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.embedding_lookup_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.embedding_lookup_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.embedding_lookup_sparse</strong></p>
<div class="codehilite"><pre><span></span>Computes embeddings for the given ids and weights.
</pre></div>


<p>This op assumes that there is at least one id for each row in the dense tensor
represented by sp_ids (i.e. there are no rows with empty features), and that
all the indices of sp_ids are in canonical row-major order.</p>
<p>It also assumes that all id values lie in the range [0, p0), where p0
is the sum of the size of params along dimension 0.</p>
<p>Args:
  params: A single tensor representing the complete embedding tensor,
    or a list of P tensors all of same shape except for the first dimension,
    representing sharded embedding tensors.
  sp_ids: N x M SparseTensor of int64 ids (typically from FeatureValueToId),
    where N is typically batch size and M is arbitrary.
  sp_weights: either a SparseTensor of float / double weights, or None to
    indicate all weights should be taken to be 1. If specified, sp_weights
    must have exactly the same shape and indices as sp_ids.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: Optional name for the op.
  combiner: A string specifying the reduction op. Currently "mean", "sqrtn"
    and "sum" are supported.
    "sum" computes the weighted sum of the embedding results for each row.
    "mean" is the weighted sum divided by the total weight.
    "sqrtn" is the weighted sum divided by the square root of the sum of the
    squares of the weights.</p>
<p>Returns:
  A dense tensor representing the combined embeddings for the
  sparse ids. For each row in the dense tensor represented by sp_ids, the op
  looks up the embeddings for all ids in that row, multiplies them by the
  corresponding weight, and combines these embeddings as specified.</p>
<p>In other words, if
    shape(combined params) = [p0, p1, ..., pm]
  and
    shape(sp_ids) = shape(sp_weights) = [d0, d1, ..., dn]
  then
    shape(output) = [d0, d1, ..., dn-1, p1, ..., pm].</p>
<p>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</p>
<div class="codehilite"><pre><span></span>[0, 0]: id 1, weight 2.0
[0, 1]: id 3, weight 0.5
[1, 0]: id 0, weight 1.0
[2, 3]: id 1, weight 3.0
</pre></div>


<p>with combiner="mean", then the output will be a 3x20 matrix where
    output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)
    output[1, :] = params[0, :] * 1.0
    output[2, :] = params[1, :] * 3.0</p>
<p>Raises:
  TypeError: If sp_ids is not a SparseTensor, or if sp_weights is neither
    None nor SparseTensor.
  ValueError: If combiner is not one of {"mean", "sqrtn", "sum"}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer">
    <p>def <span class="ident">embedding_lookup_sparse_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_sparse_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_sparse_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup_sparse`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer">
    <p>def <span class="ident">embedding_lookup_sparse_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_sparse_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.embedding_lookup_sparse_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup_sparse`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.encode_base64">
    <p>def <span class="ident">encode_base64</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.encode_base64(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.encode_base64</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.encode_base64(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.encode_base64(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.encode_base64</strong></p>
<div class="codehilite"><pre><span></span>Encode strings into web-safe base64 format.
</pre></div>


<p>Refer to the following article for more information on base64 format:
en.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the
end so that the encoded has length multiple of 4. See Padding section of the
link above.</p>
<p>Web-safe means that the encoder uses - and _ instead of + and /.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. Strings to be encoded.
  pad: An optional <code>bool</code>. Defaults to <code>False</code>.
    Bool whether padding is applied at the ends.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. Input strings encoded in base64.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.encode_base64', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.encode_base64" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ensamble_dropout">
    <p>def <span class="ident">ensamble_dropout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ensamble_dropout(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.ensamble_dropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.ensamble_dropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ensamble_dropout(*args, **kwargs)(x1)
</pre></div>


<p><strong>tb.ensamble_dropout</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ensamble_dropout', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ensamble_dropout" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.equal">
    <p>def <span class="ident">equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x == y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Equal</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>quint8</code>, <code>qint8</code>, <code>qint32</code>, <code>string</code>, <code>bool</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erf">
    <p>def <span class="ident">erf</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.erf(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.erf</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.erf(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.erf(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.erf</strong></p>
<div class="codehilite"><pre><span></span>Computes the Gauss error function of `x` element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> of <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erf', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erf" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erfc">
    <p>def <span class="ident">erfc</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.erfc(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.erfc</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.erfc(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.erfc(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.erfc</strong></p>
<div class="codehilite"><pre><span></span>Computes the complementary error function of `x` element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erfc', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erfc" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erosion2d">
    <p>def <span class="ident">erosion2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.erosion2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.erosion2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.erosion2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.erosion2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.erosion2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale erosion of 4-D `value` and 3-D `kernel` tensors.
</pre></div>


<p>The <code>value</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>kernel</code> tensor has shape <code>[kernel_height, kernel_width, depth]</code>, i.e.,
each input channel is processed independently of the others with its own
structuring function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the
output tensor depend on the <code>padding</code> algorithm. We currently only support the
default "NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D erosion is given by:</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   min_{dy, dx} value[b,
                      strides[1] * y - rates[1] * dy,
                      strides[2] * x - rates[2] * dx,
                      c] -
                kernel[dy, dx, c]
</pre></div>


<p>Duality: The erosion of <code>value</code> by the <code>kernel</code> is equal to the negation of
the dilation of <code>-value</code> by the reflected <code>kernel</code>.</p>
<p>Args:
  value: A <code>Tensor</code>. 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  kernel: A <code>Tensor</code>. Must have the same type as <code>value</code>.
    3-D with shape <code>[kernel_height, kernel_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional). If not specified "erosion2d"
    is used.</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>value</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
<p>Raises:
  ValueError: If the <code>value</code> depth does not match <code>kernel</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erosion2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erosion2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer">
    <p>def <span class="ident">erosion2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.erosion2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.erosion2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.erosion2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erosion2d_layer">
    <p>def <span class="ident">erosion2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.erosion2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.erosion2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.erosion2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erosion2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erosion2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.exp">
    <p>def <span class="ident">exp</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.exp(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.exp</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.exp(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.exp(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.exp</strong></p>
<div class="codehilite"><pre><span></span>Computes exponential of x element-wise.  \\(y = e^x\\).
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.exp', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.exp" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.expand_dims">
    <p>def <span class="ident">expand_dims</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.expand_dims(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.expand_dims</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.expand_dims(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.expand_dims(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.expand_dims</strong></p>
<div class="codehilite"><pre><span></span>Inserts a dimension of 1 into a tensor&#39;s shape.
</pre></div>


<p>Given a tensor <code>input</code>, this operation inserts a dimension of 1 at the
dimension index <code>dim</code> of <code>input</code>'s shape. The dimension index <code>dim</code> starts at
zero; if you specify a negative number for <code>dim</code> it is counted backward from
the end.</p>
<p>This operation is useful if you want to add a batch dimension to a single
element. For example, if you have a single image of shape <code>[height, width,
channels]</code>, you can make it a batch of 1 image with <code>expand_dims(image, 0)</code>,
which will make the shape <code>[1, height, width, channels]</code>.</p>
<p>Other examples:</p>
<p>```prettyprint</p>
<h1>'t' is a tensor of shape [2]</h1>
<p>shape(expand_dims(t, 0)) ==&gt; [1, 2]
shape(expand_dims(t, 1)) ==&gt; [2, 1]
shape(expand_dims(t, -1)) ==&gt; [2, 1]</p>
<h1>'t2' is a tensor of shape [2, 3, 5]</h1>
<p>shape(expand_dims(t2, 0)) ==&gt; [1, 2, 3, 5]
shape(expand_dims(t2, 2)) ==&gt; [2, 3, 1, 5]
shape(expand_dims(t2, 3)) ==&gt; [2, 3, 5, 1]
```</p>
<p>This operation requires that:</p>
<p><code>-1-input.dims() &lt;= dim &lt;= input.dims()</code></p>
<p>This operation is related to <code>squeeze()</code>, which removes dimensions of
size 1.</p>
<p>Args:
  input: A <code>Tensor</code>.
  dim: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    0-D (scalar). Specifies the dimension index at which to
    expand the shape of <code>input</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Contains the same data as <code>input</code>, but its shape has an additional
  dimension of size 1 added.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.expand_dims', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.expand_dims" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.extract_image_patches">
    <p>def <span class="ident">extract_image_patches</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.extract_image_patches(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.extract_image_patches</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.extract_image_patches(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.extract_image_patches(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.extract_image_patches</strong></p>
<div class="codehilite"><pre><span></span>Extract `patches` from `images` and put them in the &quot;depth&quot; output dimension.
</pre></div>


<p>Args:
  images: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D Tensor with shape <code>[batch, in_rows, in_cols, depth]</code>.
  ksizes: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The size of the sliding window for each dimension of <code>images</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. How far the centers of two consecutive patches are in
    the images. Must be: <code>[1, stride_rows, stride_cols, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. Must be: <code>[1, rate_rows, rate_cols, 1]</code>. This is the
    input stride, specifying how far two consecutive patch samples are in the
    input. Equivalent to extracting patches with
    <code>patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1), followed by
    subsampling them spatially by a factor of</code>rates<code>.
  padding: A</code>string<code>from:</code>"SAME", "VALID"`.
    The type of padding algorithm to use.</p>
<div class="codehilite"><pre><span></span>We specify the size-related attributes as:

      ksizes = [1, ksize_rows, ksize_cols, 1]
      strides = [1, strides_rows, strides_cols, 1]
      rates = [1, rates_rows, rates_cols, 1]
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>images</code>.
  4-D Tensor with shape <code>[batch, out_rows, out_cols, ksize_rows *
  ksize_cols * depth]</code> containing image patches with size
  <code>ksize_rows x ksize_cols x depth</code> vectorized in the "depth" dimension.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.extract_image_patches', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.extract_image_patches" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fft">
    <p>def <span class="ident">fft</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fft(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fft</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fft(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fft(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fft</strong></p>
<div class="codehilite"><pre><span></span>Compute the 1-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>dimension of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most
  dimension of <code>input</code> is replaced with its 1D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fft', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fft" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fft2d">
    <p>def <span class="ident">fft2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fft2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fft2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fft2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fft2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fft2d</strong></p>
<div class="codehilite"><pre><span></span>Compute the 2-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>2 dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 2
  dimensions of <code>input</code> are replaced with their 2D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fft2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fft2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fft3d">
    <p>def <span class="ident">fft3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fft3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fft3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fft3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fft3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fft3d</strong></p>
<div class="codehilite"><pre><span></span>Compute the 3-dimensional discrete Fourier Transform over the inner-most 3
</pre></div>


<p>dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
  dimensions of <code>input</code> are replaced with their 3D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fft3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fft3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fill">
    <p>def <span class="ident">fill</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fill(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fill</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fill(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fill(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fill</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor filled with a scalar value.
</pre></div>


<p>This operation creates a tensor of shape <code>dims</code> and fills it with <code>value</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>Output tensor has shape [2, 3].</h1>
<p>fill([2, 3], 9) ==&gt; [[9, 9, 9]
                     [9, 9, 9]]
```</p>
<p>Args:
  dims: A <code>Tensor</code> of type <code>int32</code>.
    1-D. Represents the shape of the output tensor.
  value: A <code>Tensor</code>. 0-D (scalar). Value to fill the returned tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fill', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fill" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_size_partitioner">
    <p>def <span class="ident">fixed_size_partitioner</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fixed_size_partitioner(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fixed_size_partitioner</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fixed_size_partitioner(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fixed_size_partitioner(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fixed_size_partitioner</strong></p>
<div class="codehilite"><pre><span></span>Partitioner to specify a fixed number of shards along given axis.
</pre></div>


<p>Args:
  num_shards: <code>int</code>, number of shards to partition variable.
  axis: <code>int</code>, axis to partition on.</p>
<p>Returns:
  A partition function usable as the <code>partitioner</code> argument to
  <code>variable_scope</code>, <code>get_variable</code>, and <code>get_partitioned_variable_list</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_size_partitioner', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_size_partitioner" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler">
    <p>def <span class="ident">fixed_unigram_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fixed_unigram_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.fixed_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.fixed_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fixed_unigram_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.fixed_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using the provided (fixed) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution is read from a file or passed in as an
in-memory array. There is also an option to skew the distribution by
applying a distortion power to the weights.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  vocab_file: Each valid line in this file (which should have a CSV-like
    format) corresponds to a valid word ID. IDs are in sequential order,
    starting from num_reserved_ids. The last entry in each line is expected
    to be a value corresponding to the count or relative probability. Exactly
    one of <code>vocab_file</code> and <code>unigrams</code> needs to be passed to this operation.
  distortion: The distortion is used to skew the unigram probability
    distribution.  Each weight is first raised to the distortion's power
    before adding to the internal unigram distribution. As a result,
    <code>distortion = 1.0</code> gives regular unigram sampling (as defined by the vocab
    file), and <code>distortion = 0.0</code> gives a uniform distribution.
  num_reserved_ids: Optionally some reserved IDs can be added in the range
    <code>[0, num_reserved_ids]</code> by the users. One use case is that a special
    unknown word token is used as ID 0. These IDs will have a sampling
    probability of 0.
  num_shards: A sampler can be used to sample from a subset of the original
    range in order to speed up the whole computation through parallelism. This
    parameter (together with <code>shard</code>) indicates the number of partitions that
    are being used in the overall computation.
  shard: A sampler can be used to sample from a subset of the original range
    in order to speed up the whole computation through parallelism. This
    parameter (together with <code>num_shards</code>) indicates the particular partition
    number of the operation, when partitioning is being used.
  unigrams: A list of unigram counts or probabilities, one per ID in
    sequential order. Exactly one of <code>vocab_file</code> and <code>unigrams</code> should be
    passed to this operation.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">fixed_unigram_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fixed_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fixed_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fixed_unigram_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer">
    <p>def <span class="ident">fixed_unigram_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fixed_unigram_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fixed_unigram_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fixed_unigram_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.flatten">
    <p>def <span class="ident">flatten</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.flatten(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.flatten</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.flatten(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.flatten(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layers.flatten</strong></p>
<div class="codehilite"><pre><span></span>Flattens the input while maintaining the batch_size.
</pre></div>


<p>Assumes that the first dimension represents the batch.</p>
<p>Args:
  inputs: a tensor of size [batch_size, ...].
  outputs_collections: collection to add the outputs.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  a flattened tensor with shape [batch_size, k].
Raises:
  ValueError: if inputs.shape is wrong.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.flatten', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.flatten" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.floor">
    <p>def <span class="ident">floor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.floor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.floor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.floor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.floor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.floor</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise largest integer not greater than x.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.floor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.floor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.floordiv">
    <p>def <span class="ident">floordiv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.floordiv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.floordiv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.floordiv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.floordiv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.floordiv</strong></p>
<div class="codehilite"><pre><span></span>Divides `x / y` elementwise, rounding down for floating point.
</pre></div>


<p>The same as <code>tf.div(x,y)</code> for integers, but uses <code>tf.floor(tf.div(x,y))</code> for
floating point arguments so that the result is always an integer (though
possibly an integer represented as floating point).  This op is generated by
<code>x // y</code> floor division in Python 3 and in Python 2.7 with
<code>from __future__ import division</code>.</p>
<p>Note that for efficiency, <code>floordiv</code> uses C semantics for negative numbers
(unlike Python and Numpy).</p>
<p><code>x</code> and <code>y</code> must have the same type, and the result will have the same type
as well.</p>
<p>Args:
  x: <code>Tensor</code> numerator of real numeric type.
  y: <code>Tensor</code> denominator of real numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>x / y</code> rounded down (except possibly towards zero for negative integers).</p>
<p>Raises:
  TypeError: If the inputs are complex.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.floordiv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.floordiv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.foldl">
    <p>def <span class="ident">foldl</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.foldl(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.foldl</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.foldl(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.foldl(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.foldl</strong></p>
<div class="codehilite"><pre><span></span>foldl on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>This foldl operator repeatedly applies the callable <code>fn</code> to a sequence
of elements from first to last. The elements are made of the tensors
unpacked from <code>elems</code> on dimension 0. The callable fn takes two tensors as
arguments. The first argument is the accumulated value computed from the
preceding invocation of fn. If <code>initializer</code> is None, <code>elems</code> must contain
at least one element, and its first element is used as the initializer.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is fn(initializer, values[0]).shape`.</p>
<p>Args:
  fn: The callable to be performed.
  elems: A tensor to be unpacked on dimension 0.
  initializer: (optional) The initial value for the accumulator.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor resulting from applying <code>fn</code> consecutively to the list of tensors
  unpacked from <code>elems</code>, from first to last.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable.</p>
<p>Example:
  <code>python
  elems = [1, 2, 3, 4, 5, 6]
  sum = foldl(lambda a, x: a + x, elems)
  # sum == 21</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.foldl', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.foldl" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.foldr">
    <p>def <span class="ident">foldr</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.foldr(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.foldr</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.foldr(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.foldr(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.foldr</strong></p>
<div class="codehilite"><pre><span></span>foldr on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>This foldr operator repeatedly applies the callable <code>fn</code> to a sequence
of elements from last to first. The elements are made of the tensors
unpacked from <code>elems</code>. The callable fn takes two tensors as arguments.
The first argument is the accumulated value computed from the preceding
invocation of fn. If <code>initializer</code> is None, <code>elems</code> must contain at least
one element, and its first element is used as the initializer.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is <code>fn(initializer, values[0]).shape</code>.</p>
<p>Args:
  fn: The callable to be performed.
  elems: A tensor that is unpacked into a sequence of tensors to apply <code>fn</code>.
  initializer: (optional) The initial value for the accumulator.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor resulting from applying <code>fn</code> consecutively to the list of tensors
  unpacked from <code>elems</code>, from last to first.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable.</p>
<p>Example:
  <code>python
  elems = [1, 2, 3, 4, 5, 6]
  sum = foldr(lambda a, x: a + x, elems)
  # sum == 21</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.foldr', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.foldr" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_avg_pool">
    <p>def <span class="ident">fractional_avg_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fractional_avg_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.fractional_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.fractional_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fractional_avg_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.fractional_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional average pooling on the input.
</pre></div>


<p>Fractional average pooling is similar to Fractional max pooling in the pooling
region generation step. The only difference is that after pooling regions are
generated, a mean operation is performed instead of a max operation in each
pooling region.</p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
    Graham, Fractional Max-Pooling] (http://arxiv.org/abs/1412.6071) for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [41/3, 26/3] for fractional avg pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalAvgPool node in the computation graph. Mainly used
    in unit test to make FractionalAvgPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional avg pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer">
    <p>def <span class="ident">fractional_avg_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fractional_avg_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fractional_avg_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_avg_pool`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer">
    <p>def <span class="ident">fractional_avg_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fractional_avg_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fractional_avg_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_avg_pool`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_max_pool">
    <p>def <span class="ident">fractional_max_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fractional_max_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.fractional_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.fractional_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fractional_max_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.fractional_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional max pooling on the input.
</pre></div>


<p>Fractional max pooling is slightly different than regular max pooling.  In
regular max pooling, you downsize an input set by taking the maximum value of
smaller N x N subsections of the set (often 2x2), and try to reduce the set by
a factor of N, where N is an integer.  Fractional max pooling, as you might
expect from the word "fractional", means that the overall reduction ratio N
does not have to be an integer.</p>
<p>The sizes of the pooling regions are generated randomly but are fairly uniform.
For example, let's look at the height dimension, and the constraints on the
list of rows that will be pool boundaries.</p>
<p>First we define the following:</p>
<ol>
<li>input_row_length : the number of rows from the input set</li>
<li>output_row_length : which will be smaller than the input</li>
<li>alpha = input_row_length / output_row_length : our reduction ratio</li>
<li>K = floor(alpha)</li>
<li>row_pooling_sequence : this is the result list of pool boundary rows</li>
</ol>
<p>Then, row_pooling_sequence should satisfy:</p>
<ol>
<li>a[0] = 0 : the first value of the sequence is 0</li>
<li>a[end] = input_row_length : the last value of the sequence is the size</li>
<li>K &lt;= (a[i+1] - a[i]) &lt;= K+1 : all intervals are K or K+1 size</li>
<li>length(row_pooling_sequence) = output_row_length+1</li>
</ol>
<p>For more details on fractional max pooling, see this paper:
[Benjamin Graham, Fractional Max-Pooling]
(http://arxiv.org/abs/1412.6071)</p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
    Graham, Fractional Max-Pooling] (http://arxiv.org/abs/1412.6071) for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [20, 16] for fractional max pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalMaxPool node in the computation graph. Mainly used
    in unit test to make FractionalMaxPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional max pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_max_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_max_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer">
    <p>def <span class="ident">fractional_max_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fractional_max_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fractional_max_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_max_pool`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer">
    <p>def <span class="ident">fractional_max_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fractional_max_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fractional_max_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_max_pool`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d">
    <p>def <span class="ident">fused_resize_and_pad_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fused_resize_and_pad_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.fused_resize_and_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.fused_resize_and_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fused_resize_and_pad_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.fused_resize_and_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a resize and padding as a preprocess during a convolution.
</pre></div>


<p>It's often possible to do spatial transformations more efficiently as part of
the packing stage of a convolution, so this op allows for an optimized
implementation where these stages are fused together. This prevents the need to
write out the intermediate results as whole tensors, reducing memory pressure,
and we can get some latency gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and defaults to
'NHWC' order.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  size: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
    new size for the images.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  resize_align_corners: An optional <code>bool</code>. Defaults to <code>False</code>.
    If true, rescale input by (new_height - 1) / (height - 1),
    which exactly aligns the 4 corners of images and resized images. If false, rescale
    by new_height / height. Treat similarly the width dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer">
    <p>def <span class="ident">fused_resize_and_pad_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fused_resize_and_pad_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fused_resize_and_pad_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_resize_and_pad_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer">
    <p>def <span class="ident">fused_resize_and_pad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.fused_resize_and_pad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.fused_resize_and_pad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_resize_and_pad_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.gather">
    <p>def <span class="ident">gather</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.gather(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.gather</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.gather(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.gather(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.gather</strong></p>
<div class="codehilite"><pre><span></span>Gather slices from `params` according to `indices`.
</pre></div>


<p><code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:</p>
<div class="codehilite"><pre><span></span># Scalar indices
output[:, ..., :] = params[indices, :, ... :]

# Vector indices
output[i, :, ..., :] = params[indices[i], :, ... :]

# Higher rank indices
output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
</pre></div>


<p>If <code>indices</code> is a permutation and <code>len(indices) == params.shape[0]</code> then
this operation will permute <code>params</code> accordingly.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/Gather.png" alt>
</div>

<p>Args:
  params: A <code>Tensor</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
  validate_indices: An optional <code>bool</code>. Defaults to <code>True</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>params</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.gather', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.gather" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.gather_nd">
    <p>def <span class="ident">gather_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.gather_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.gather_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.gather_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.gather_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.gather_nd</strong></p>
<div class="codehilite"><pre><span></span>Gather values or slices from `params` according to `indices`.
</pre></div>


<p><code>params</code> is a Tensor of rank <code>R</code> and <code>indices</code> is a Tensor of rank <code>M</code>.</p>
<p><code>indices</code> must be integer tensor, containing indices into <code>params</code>.
It must be shape <code>[d_0, ..., d_N, R]</code> where <code>0 &lt; R &lt;= M</code>.</p>
<p>The innermost dimension of <code>indices</code> (with length <code>R</code>) corresponds to
indices into elements (if <code>R = M</code>) or slices (if <code>R &lt; M</code>) along the <code>N</code>th
dimension of <code>params</code>.</p>
<p>Produces an output tensor with shape</p>
<div class="codehilite"><pre><span></span>[d_0, ..., d_{n-1}, params.shape[R], ..., params.shape[M-1]].
</pre></div>


<p>Some examples below.</p>
<p>Simple indexing into a matrix:</p>
<div class="codehilite"><pre><span></span>indices = [[0, 0], [1, 1]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [&#39;a&#39;, &#39;d&#39;]
</pre></div>


<p>Slice indexing into a matrix:</p>
<div class="codehilite"><pre><span></span>indices = [[1], [0]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [[&#39;c&#39;, &#39;d&#39;], [&#39;a&#39;, &#39;b&#39;]]
</pre></div>


<p>Indexing into a 3-tensor:</p>
<div class="codehilite"><pre><span></span>indices = [[1]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


indices = [[0, 1], [1, 0]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]]


indices = [[0, 0, 1], [1, 0, 1]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [&#39;b0&#39;, &#39;b1&#39;]
</pre></div>


<p>Batched indexing into a matrix:</p>
<div class="codehilite"><pre><span></span>indices = [[[0, 0]], [[0, 1]]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [[&#39;a&#39;], [&#39;b&#39;]]
</pre></div>


<p>Batched slice indexing into a matrix:</p>
<div class="codehilite"><pre><span></span>indices = [[[1]], [[0]]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [[[&#39;c&#39;, &#39;d&#39;]], [[&#39;a&#39;, &#39;b&#39;]]]
</pre></div>


<p>Batched indexing into a 3-tensor:</p>
<div class="codehilite"><pre><span></span>indices = [[[1]], [[0]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]],
          [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]]]]


indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]],
          [[&#39;a0&#39;, &#39;b0&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[&#39;b0&#39;, &#39;b1&#39;], [&#39;d0&#39;, &#39;c1&#39;]]
</pre></div>


<p>Args:
  params: A <code>Tensor</code>. <code>M-D</code>.  The tensor from which to gather values.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    <code>(N+1)-D</code>.  Index tensor having shape <code>[d_0, ..., d_N, R]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>params</code>.
  <code>(N+M-R)-D</code>.  Values from <code>params</code> gathered from indices given by
  <code>indices</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.gather_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.gather_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_collection">
    <p>def <span class="ident">get_collection</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_collection(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_collection</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_collection(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_collection(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_collection</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.get_collection()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.get_collection"><code>Graph.get_collection()</code></a>
for more details.</p>
<p>Args:
  key: The key for the collection. For example, the <code>GraphKeys</code> class
    contains many standard names for collections.
  scope: (Optional.) If supplied, the resulting list is filtered to include
    only items whose <code>name</code> attribute matches using <code>re.match</code>. Items
    without a <code>name</code> attribute are never returned if a scope is supplied and
    the choice or <code>re.match</code> means that a <code>scope</code> without special tokens
    filters by prefix.</p>
<p>Returns:
  The list of values in the collection with the given <code>name</code>, or
  an empty list if no value has been added to that collection. The
  list contains the values in the order under which they were
  collected.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_collection', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_collection" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_collection_ref">
    <p>def <span class="ident">get_collection_ref</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_collection_ref(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_collection_ref</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_collection_ref(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_collection_ref(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_collection_ref</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.get_collection_ref()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.get_collection_ref"><code>Graph.get_collection_ref()</code></a>
for more details.</p>
<p>Args:
  key: The key for the collection. For example, the <code>GraphKeys</code> class
    contains many standard names for collections.</p>
<p>Returns:
  The list of values in the collection with the given <code>name</code>, or an empty
  list if no value has been added to that collection.  Note that this returns
  the collection list itself, which can be modified in place to change the
  collection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_collection_ref', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_collection_ref" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_default_graph">
    <p>def <span class="ident">get_default_graph</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_default_graph(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_default_graph</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_default_graph(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_default_graph(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_default_graph</strong></p>
<div class="codehilite"><pre><span></span>Returns the default graph for the current thread.
</pre></div>


<p>The returned graph will be the innermost graph on which a
<code>Graph.as_default()</code> context has been entered, or a global default
graph if none has been explicitly created.</p>
<p>NOTE: The default graph is a property of the current thread. If you
create a new thread, and wish to use the default graph in that
thread, you must explicitly add a <code>with g.as_default():</code> in that
thread's function.</p>
<p>Returns:
  The default <code>Graph</code> being used in the current thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_default_graph', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_default_graph" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_default_session">
    <p>def <span class="ident">get_default_session</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_default_session(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_default_session</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_default_session(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_default_session(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_default_session</strong></p>
<div class="codehilite"><pre><span></span>Returns the default session for the current thread.
</pre></div>


<p>The returned <code>Session</code> will be the innermost session on which a
<code>Session</code> or <code>Session.as_default()</code> context has been entered.</p>
<p>NOTE: The default session is a property of the current thread. If you
create a new thread, and wish to use the default session in that
thread, you must explicitly add a <code>with sess.as_default():</code> in that
thread's function.</p>
<p>Returns:
  The default <code>Session</code> being used in the current thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_default_session', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_default_session" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_seed">
    <p>def <span class="ident">get_seed</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_seed(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_seed</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_seed(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_seed(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_seed</strong></p>
<div class="codehilite"><pre><span></span>Returns the local seeds an operation should use given an op-specific seed.
</pre></div>


<p>Given operation-specific seed, <code>op_seed</code>, this helper function returns two
seeds derived from graph-level and op-level seeds. Many random operations
internally use the two seeds to allow user to change the seed globally for a
graph, or for only specific operations.</p>
<p>For details on how the graph-level seed interacts with op seeds, see
<a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>.</p>
<p>Args:
  op_seed: integer.</p>
<p>Returns:
  A tuple of two integers that should be used for the local seed of this
  operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_seed', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_seed" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_session_handle">
    <p>def <span class="ident">get_session_handle</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_session_handle(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_session_handle</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_session_handle(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_session_handle(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_session_handle</strong></p>
<div class="codehilite"><pre><span></span>Return the handle of `data`.
</pre></div>


<p>This is EXPERIMENTAL and subject to change.</p>
<p>Keep <code>data</code> "in-place" in the runtime and create a handle that can be
used to retrieve <code>data</code> in a subsequent run().</p>
<p>Combined with <code>get_session_tensor</code>, we can keep a tensor produced in
one run call in place, and use it as the input in a future run call.</p>
<p>Args:
  data: A tensor to be stored in the session.
  name: Optional name prefix for the return tensor.</p>
<p>Returns:
  A scalar string tensor representing a unique handle for <code>data</code>.</p>
<p>Raises:
  TypeError: if <code>data</code> is not a Tensor.</p>
<p>Example:</p>
<p>```python
c = tf.mul(a, b)
h = tf.get_session_handle(c)
h = sess.run(h)</p>
<p>p, a = tf.get_session_tensor(h.handle, tf.float32)
b = tf.mul(a, 10)
c = sess.run(b, feed_dict={p: h.handle})
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_session_handle', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_session_handle" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_session_tensor">
    <p>def <span class="ident">get_session_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_session_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_session_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_session_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_session_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_session_tensor</strong></p>
<div class="codehilite"><pre><span></span>Get the tensor of type `dtype` by feeding a tensor handle.
</pre></div>


<p>This is EXPERIMENTAL and subject to change.</p>
<p>Get the value of the tensor from a tensor handle. The tensor
is produced in a previous run() and stored in the state of the
session.</p>
<p>Args:
  handle: The string representation of a persistent tensor handle.
  dtype: The type of the output tensor.
  name: Optional name prefix for the return tensor.</p>
<p>Returns:
  A pair of tensors. The first is a placeholder for feeding a
  tensor handle and the second is the tensor in the session state
  keyed by the tensor handle.</p>
<p>Example:</p>
<p>```python
c = tf.mul(a, b)
h = tf.get_session_handle(c)
h = sess.run(h)</p>
<p>p, a = tf.get_session_tensor(h.handle, tf.float32)
b = tf.mul(a, 10)
c = sess.run(b, feed_dict={p: h.handle})
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_session_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_session_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_variable">
    <p>def <span class="ident">get_variable</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_variable(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_variable</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_variable(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_variable(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_variable</strong></p>
<div class="codehilite"><pre><span></span>Gets an existing variable with these parameters or create a new one.
</pre></div>


<p>This function prefixes the name with the current variable scope
and performs reuse checks. See the
<a href="../../how_tos/variable_scope/index.md">Variable Scope How To</a>
for an extensive description of how reusing works. Here is a basic example:</p>
<p><code>python
with tf.variable_scope("foo"):
    v = tf.get_variable("v", [1])  # v.name == "foo/v:0"
    w = tf.get_variable("w", [1])  # w.name == "foo/w:0"
with tf.variable_scope("foo", reuse=True)
    v1 = tf.get_variable("v")  # The same as v above.</code></p>
<p>If initializer is <code>None</code> (the default), the default initializer passed in
the variable scope will be used. If that one is <code>None</code> too, a
<code>uniform_unit_scaling_initializer</code> will be used. The initializer can also be
a Tensor, in which case the variable is initialized to this value and shape.</p>
<p>Similarly, if the regularizer is <code>None</code> (the default), the default regularizer
passed in the variable scope will be used (if that is <code>None</code> too,
then by default no regularization is performed).</p>
<p>If a partitioner is provided, first a sharded <code>Variable</code> is created
via <code>_get_partitioned_variable</code>, and the return value is a
<code>Tensor</code> composed of the shards concatenated along the partition axis.</p>
<p>Some useful partitioners are available.  See, e.g.,
<code>variable_axis_size_partitioner</code> and <code>min_max_variable_partitioner</code>.</p>
<p>Args:
  name: The name of the new or existing variable.
  shape: Shape of the new or existing variable.
  dtype: Type of the new or existing variable (defaults to <code>DT_FLOAT</code>).
  initializer: Initializer for the variable if one is created.
  regularizer: A (Tensor -&gt; Tensor or None) function; the result of
    applying it on a newly created variable will be added to the collection
    GraphKeys.REGULARIZATION_LOSSES and can be used for regularization.
  trainable: If <code>True</code> also add the variable to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  collections: List of graph collections keys to add the Variable to.
    Defaults to <code>[GraphKeys.VARIABLES]</code> (see tf.Variable).
  caching_device: Optional device string or function describing where the
    Variable should be cached for reading.  Defaults to the Variable's
    device.  If not <code>None</code>, caches on another device.  Typical use is to
    cache on the device where the Ops using the Variable reside, to
    deduplicate copying through <code>Switch</code> and other conditional statements.
  partitioner: Optional callable that accepts a fully defined <code>TensorShape</code>
    and <code>dtype</code> of the Variable to be created, and returns a list of
    partitions for each axis (currently only one axis can be partitioned).
  validate_shape: If False, allows the variable to be initialized with a
      value of unknown shape. If True, the default, the shape of initial_value
      must be known.
  custom_getter: Callable that takes as a first argument the true getter, and
    allows overwriting the internal get_variable method.
    The signature of <code>custom_getter</code> should match that of this method,
    but the most future-proof version will allow for changes:
    <code>def custom_getter(getter, *args, **kwargs)</code>.  Direct access to
    all <code>get_variable</code> parameters is also allowed:
    <code>def custom_getter(getter, name, *args, **kwargs)</code>.  A simple identity
    custom getter that simply creates variables with modified names is:
    <code>python
    def custom_getter(getter, name, *args, **kwargs):
      return getter(name + '_suffix', *args, **kwargs)</code></p>
<p>Returns:
  The created or existing variable.</p>
<p>Raises:
  ValueError: when creating a new variable and shape is not declared,
    when violating reuse during variable creation, or when <code>initializer</code> dtype
    and <code>dtype</code> don't match. Reuse is set inside <code>variable_scope</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_variable', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_variable" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_variable_scope">
    <p>def <span class="ident">get_variable_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.get_variable_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_variable_scope</code>. 
However, a partial with the arguments is returned which expects any argument <code>x</code> and complete ignores it, such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_variable_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.get_variable_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.get_variable_scope</strong></p>
<div class="codehilite"><pre><span></span>Returns the current variable scope.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_variable_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_variable_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.global_norm">
    <p>def <span class="ident">global_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.global_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.global_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.global_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.global_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.global_norm</strong></p>
<div class="codehilite"><pre><span></span>Computes the global norm of multiple tensors.
</pre></div>


<p>Given a tuple or list of tensors <code>t_list</code>, this operation returns the
global norm of the elements in all tensors in <code>t_list</code>. The global norm is
computed as:</p>
<p><code>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</code></p>
<p>Any entries in <code>t_list</code> that are of type None are ignored.</p>
<p>Args:
  t_list: A tuple or list of mixed <code>Tensors</code>, <code>IndexedSlices</code>, or None.
  name: A name for the operation (optional).</p>
<p>Returns:
  A 0-D (scalar) <code>Tensor</code> of type <code>float</code>.</p>
<p>Raises:
  TypeError: If <code>t_list</code> is not a sequence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.global_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.global_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.gradients">
    <p>def <span class="ident">gradients</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.gradients(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.gradients</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.gradients(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.gradients(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.gradients</strong></p>
<div class="codehilite"><pre><span></span>Constructs symbolic partial derivatives of sum of `ys` w.r.t. x in `xs`.
</pre></div>


<p><code>ys</code> and <code>xs</code> are each a <code>Tensor</code> or a list of tensors.  <code>grad_ys</code>
is a list of <code>Tensor</code>, holding the gradients received by the
<code>ys</code>. The list must be the same length as <code>ys</code>.</p>
<p><code>gradients()</code> adds ops to the graph to output the partial
derivatives of <code>ys</code> with respect to <code>xs</code>.  It returns a list of
<code>Tensor</code> of length <code>len(xs)</code> where each tensor is the <code>sum(dy/dx)</code>
for y in <code>ys</code>.</p>
<p><code>grad_ys</code> is a list of tensors of the same length as <code>ys</code> that holds
the initial gradients for each y in <code>ys</code>.  When <code>grad_ys</code> is None,
we fill in a tensor of '1's of the shape of y for each y in <code>ys</code>.  A
user can provide their own initial <code>grad_ys</code> to compute the
derivatives using a different initial gradient for each y (e.g., if
one wanted to weight the gradient differently for each value in
each y).</p>
<p>Args:
  ys: A <code>Tensor</code> or list of tensors to be differentiated.
  xs: A <code>Tensor</code> or list of tensors to be used for differentiation.
  grad_ys: Optional. A <code>Tensor</code> or list of tensors the same size as
    <code>ys</code> and holding the gradients computed for each y in <code>ys</code>.
  name: Optional name to use for grouping all the gradient ops together.
    defaults to 'gradients'.
  colocate_gradients_with_ops: If True, try colocating gradients with
    the corresponding op.
  gate_gradients: If True, add a tuple around the gradients returned
    for an operations.  This avoids some race conditions.
  aggregation_method: Specifies the method used to combine gradient terms.
    Accepted values are constants defined in the class <code>AggregationMethod</code>.</p>
<p>Returns:
  A list of <code>sum(dy/dx)</code> for each x in <code>xs</code>.</p>
<p>Raises:
  LookupError: if one of the operations between <code>x</code> and <code>y</code> does not
    have a registered gradient function.
  ValueError: if the arguments are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.gradients', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.gradients" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.greater">
    <p>def <span class="ident">greater</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.greater(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.greater</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.greater(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.greater(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.greater</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &gt; y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Greater</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.greater', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.greater" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.greater_equal">
    <p>def <span class="ident">greater_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.greater_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.greater_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.greater_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.greater_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.greater_equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &gt;= y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>GreaterEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.greater_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.greater_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.group">
    <p>def <span class="ident">group</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.group(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.group</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.group(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.group(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.group</strong></p>
<div class="codehilite"><pre><span></span>Create an op that groups multiple operations.
</pre></div>


<p>When this op finishes, all ops in <code>input</code> have finished. This op has no
output.</p>
<p>See also <code>tuple</code> and <code>with_dependencies</code>.</p>
<p>Args:
  <em>inputs: Zero or more tensors to group.
  </em>*kwargs: Optional parameters to pass when constructing the NodeDef.
  name: A name for this operation (optional).</p>
<p>Returns:
  An Operation that executes all its inputs.</p>
<p>Raises:
  ValueError: If an unknown keyword argument is provided.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.group', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.group" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.histogram_fixed_width">
    <p>def <span class="ident">histogram_fixed_width</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.histogram_fixed_width(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.histogram_fixed_width</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.histogram_fixed_width(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.histogram_fixed_width(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.histogram_fixed_width</strong></p>
<div class="codehilite"><pre><span></span>Return histogram of values.
</pre></div>


<p>Given the tensor <code>values</code>, this operation returns a rank 1 histogram counting
the number of entries in <code>values</code> that fell into every bin.  The bins are
equal width and determined by the arguments <code>value_range</code> and <code>nbins</code>.</p>
<p>Args:
  values:  Numeric <code>Tensor</code>.
  value_range:  Shape [2] <code>Tensor</code>.  new_values &lt;= value_range[0] will be
    mapped to hist[0], values &gt;= value_range[1] will be mapped to hist[-1].
    Must be same dtype as new_values.
  nbins:  Scalar <code>int32 Tensor</code>.  Number of histogram bins.
  dtype:  dtype for returned histogram.
  name:  A name for this operation (defaults to 'histogram_fixed_width').</p>
<p>Returns:
  A 1-D <code>Tensor</code> holding histogram of values.</p>
<p>Examples:</p>
<p>```python</p>
<h1>Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)</h1>
<p>nbins = 5
value_range = [0.0, 5.0]
new_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]</p>
<p>with tf.default_session() as sess:
  hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)
  variables.initialize_all_variables().run()
  sess.run(hist) =&gt; [2, 1, 1, 0, 2]
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.histogram_fixed_width', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.histogram_fixed_width" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.histogram_summary">
    <p>def <span class="ident">histogram_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.histogram_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.histogram_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.histogram_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.histogram_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.histogram_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with a histogram.
</pre></div>


<p>The generated
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
has one summary value containing a histogram for <code>values</code>.</p>
<p>This op reports an <code>InvalidArgument</code> error if any value is not finite.</p>
<p>Args:
  tag: A <code>string</code> <code>Tensor</code>. 0-D.  Tag to use for the summary value.
  values: A real numeric <code>Tensor</code>. Any shape. Values to use to
    build the histogram.
  collections: Optional list of graph collections keys. The new summary op is
    added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.histogram_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.histogram_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.identity">
    <p>def <span class="ident">identity</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.identity(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.identity</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.identity(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.identity(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.identity</strong></p>
<div class="codehilite"><pre><span></span>Return a tensor with the same shape and contents as the input tensor or value.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.identity', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.identity" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ifft">
    <p>def <span class="ident">ifft</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ifft(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ifft</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ifft(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ifft(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ifft</strong></p>
<div class="codehilite"><pre><span></span>Compute the inverse 1-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>dimension of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most
  dimension of <code>input</code> is replaced with its inverse 1D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ifft', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ifft" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ifft2d">
    <p>def <span class="ident">ifft2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ifft2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ifft2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ifft2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ifft2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ifft2d</strong></p>
<div class="codehilite"><pre><span></span>Compute the inverse 2-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>2 dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 2
  dimensions of <code>input</code> are replaced with their inverse 2D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ifft2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ifft2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ifft3d">
    <p>def <span class="ident">ifft3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ifft3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ifft3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ifft3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ifft3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ifft3d</strong></p>
<div class="codehilite"><pre><span></span>Compute the inverse 3-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>3 dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
  dimensions of <code>input</code> are replaced with their inverse 3D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ifft3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ifft3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.igamma">
    <p>def <span class="ident">igamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.igamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.igamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.igamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.igamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.igamma</strong></p>
<div class="codehilite"><pre><span></span>Compute the lower regularized incomplete Gamma function `Q(a, x)`.
</pre></div>


<p>The lower regularized incomplete Gamma function is defined as:</p>
<p><code>P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)</code>
where
<code>gamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt</code>
is the lower incomplete Gamma function.</p>
<p>Note, above <code>Q(a, x)</code> (<code>Igammac</code>) is the upper regularized complete
Gamma function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.igamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.igamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.igammac">
    <p>def <span class="ident">igammac</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.igammac(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.igammac</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.igammac(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.igammac(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.igammac</strong></p>
<div class="codehilite"><pre><span></span>Compute the upper regularized incomplete Gamma function `Q(a, x)`.
</pre></div>


<p>The upper regularized incomplete Gamma function is defined as:</p>
<p><code>Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)</code>
where
<code>Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt</code>
is the upper incomplete Gama function.</p>
<p>Note, above <code>P(a, x)</code> (<code>Igamma</code>) is the lower regularized complete
Gamma function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.igammac', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.igammac" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.imag">
    <p>def <span class="ident">imag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.imag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.imag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.imag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.imag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.imag</strong></p>
<div class="codehilite"><pre><span></span>Returns the imaginary part of a complex number.
</pre></div>


<p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
type <code>float32</code> or <code>float64</code> that is the imaginary part of each element in
<code>input</code>. All elements in <code>input</code> must be complex numbers of the form (a +
bj), where <em>a</em> is the real part and <em>b</em> is the imaginary part returned by
this operation.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]</h1>
<p>tf.imag(input) ==&gt; [4.75, 5.75]
```</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.imag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.imag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.image_summary">
    <p>def <span class="ident">image_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.image_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.image_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.image_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.image_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.image_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with images.
</pre></div>


<p>The summary has up to <code>max_images</code> summary values containing images. The
images are built from <code>tensor</code> which must be 4-D with shape <code>[batch_size,
height, width, channels]</code> and where <code>channels</code> can be:</p>
<ul>
<li>1: <code>tensor</code> is interpreted as Grayscale.</li>
<li>3: <code>tensor</code> is interpreted as RGB.</li>
<li>4: <code>tensor</code> is interpreted as RGBA.</li>
</ul>
<p>The images have the same number of channels as the input tensor. For float
input, the values are normalized one image at a time to fit in the range
<code>[0, 255]</code>.  <code>uint8</code> values are unchanged.  The op uses two different
normalization algorithms:</p>
<ul>
<li>
<p>If the input values are all positive, they are rescaled so the largest one
   is 255.</p>
</li>
<li>
<p>If any input value is negative, the values are shifted so input value 0.0
   is at 127.  They are then rescaled so that either the smallest value is 0,
   or the largest one is 255.</p>
</li>
</ul>
<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
build the <code>tag</code> of the summary values:</p>
<ul>
<li>If <code>max_images</code> is 1, the summary value tag is '<em>tag</em>/image'.</li>
<li>If <code>max_images</code> is greater than 1, the summary value tags are
   generated sequentially as '<em>tag</em>/image/0', '<em>tag</em>/image/1', etc.</li>
</ul>
<p>Args:
  tag: A scalar <code>Tensor</code> of type <code>string</code>. Used to build the <code>tag</code>
    of the summary values.
  tensor: A 4-D <code>uint8</code> or <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, height,
    width, channels]</code> where <code>channels</code> is 1, 3, or 4.
  max_images: Max number of batch elements to generate images for.
  collections: Optional list of ops.GraphKeys.  The collections to add the
    summary to.  Defaults to [ops.GraphKeys.SUMMARIES]
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.image_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.image_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.import_graph_def">
    <p>def <span class="ident">import_graph_def</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.import_graph_def(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.import_graph_def</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.import_graph_def(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.import_graph_def(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.import_graph_def</strong></p>
<div class="codehilite"><pre><span></span>Imports the TensorFlow graph in `graph_def` into the Python `Graph`.
</pre></div>


<p>This function provides a way to import a serialized TensorFlow
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto"><code>GraphDef</code></a>
protocol buffer, and extract individual objects in the <code>GraphDef</code> as
<a href="#Tensor"><code>Tensor</code></a> and <a href="#Operation"><code>Operation</code></a> objects. See
<a href="#Graph.as_graph_def"><code>Graph.as_graph_def()</code></a> for a way to create a
<code>GraphDef</code> proto.</p>
<p>Args:
  graph_def: A <code>GraphDef</code> proto containing operations to be imported into
    the default graph.
  input_map: A dictionary mapping input names (as strings) in <code>graph_def</code>
    to <code>Tensor</code> objects. The values of the named input tensors in the
    imported graph will be re-mapped to the respective <code>Tensor</code> values.
  return_elements: A list of strings containing operation names in
    <code>graph_def</code> that will be returned as <code>Operation</code> objects; and/or
    tensor names in <code>graph_def</code> that will be returned as <code>Tensor</code> objects.
  name: (Optional.) A prefix that will be prepended to the names in
    <code>graph_def</code>. Defaults to <code>"import"</code>.
  op_dict: (Optional.) A dictionary mapping op type names to <code>OpDef</code> protos.
    Must contain an <code>OpDef</code> proto for each op type named in <code>graph_def</code>.
    If omitted, uses the <code>OpDef</code> protos registered in the global registry.
  producer_op_list: (Optional.) An <code>OpList</code> proto with the (possibly stripped)
    list of <code>OpDef</code>s used by the producer of the graph. If provided, attrs
    for ops in <code>graph_def</code> that are not in <code>op_dict</code> that have their default
    value according to <code>producer_op_list</code> will be removed. This will allow
    some more <code>GraphDef</code>s produced by later binaries to be accepted by
    earlier binaries.</p>
<p>Returns:
  A list of <code>Operation</code> and/or <code>Tensor</code> objects from the imported graph,
  corresponding to the names in <code>return_elements</code>.</p>
<p>Raises:
  TypeError: If <code>graph_def</code> is not a <code>GraphDef</code> proto,
    <code>input_map</code> is not a dictionary mapping strings to <code>Tensor</code> objects,
    or <code>return_elements</code> is not a list of strings.
  ValueError: If <code>input_map</code>, or <code>return_elements</code> contains names that
    do not appear in <code>graph_def</code>, or <code>graph_def</code> is not well-formed (e.g.
    it refers to an unknown tensor).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.import_graph_def', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.import_graph_def" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.in_top_k">
    <p>def <span class="ident">in_top_k</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.in_top_k(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.in_top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.in_top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.in_top_k(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.in_top_k</strong></p>
<div class="codehilite"><pre><span></span>Says whether the targets are in the top `K` predictions.
</pre></div>


<p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
prediction for the target class is among the top <code>k</code> predictions among
all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
from the <code>TopK</code> op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-<code>k</code> boundary, all of those
classes are considered to be in the top <code>k</code>.</p>
<p>More formally, let</p>
<p>\(predictions_i\) be the predictions for all classes for example <code>i</code>,
  \(targets_i\) be the target class for example <code>i</code>,
  \(out_i\) be the output for example <code>i</code>,</p>
<p>$$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$</p>
<p>Args:
  predictions: A <code>Tensor</code> of type <code>float32</code>.
    A <code>batch_size</code> x <code>classes</code> tensor.
  targets: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A <code>batch_size</code> vector of class ids.
  k: An <code>int</code>. Number of top elements to look at for computing precision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>. Computed Precision at <code>k</code> as a <code>bool Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.in_top_k', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.in_top_k" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer">
    <p>def <span class="ident">in_top_k_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.in_top_k_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.in_top_k_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.in_top_k`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.in_top_k_layer">
    <p>def <span class="ident">in_top_k_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.in_top_k_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.in_top_k_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.in_top_k`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.in_top_k_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.in_top_k_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.inception_layer">
    <p>def <span class="ident">inception_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.inception_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.inception_layer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.inception_layer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.inception_layer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tb.inception_layer</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.inception_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.inception_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_all_tables">
    <p>def <span class="ident">initialize_all_tables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.initialize_all_tables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_all_tables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_all_tables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.initialize_all_tables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_all_tables</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes all tables of the default graph.
</pre></div>


<p>Args:
  name: Optional name for the initialization op.</p>
<p>Returns:
  An Op that initializes all tables.  Note that if there are
  not tables the returned Op is a NoOp.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_all_tables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_all_tables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_all_variables">
    <p>def <span class="ident">initialize_all_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.initialize_all_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_all_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_all_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.initialize_all_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_all_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes all variables.
</pre></div>


<p>This is just a shortcut for <code>initialize_variables(all_variables())</code></p>
<p>Returns:
  An Op that initializes all variables in the graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_all_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_all_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_local_variables">
    <p>def <span class="ident">initialize_local_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.initialize_local_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_local_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_local_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.initialize_local_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_local_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes all local variables.
</pre></div>


<p>This is just a shortcut for <code>initialize_variables(local_variables())</code></p>
<p>Returns:
  An Op that initializes all local variables in the graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_local_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_local_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_variables">
    <p>def <span class="ident">initialize_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.initialize_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.initialize_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes a list of variables.
</pre></div>


<p>After you launch the graph in a session, you can run the returned Op to
initialize all the variables in <code>var_list</code>. This Op runs all the
initializers of the variables in <code>var_list</code> in parallel.</p>
<p>Calling <code>initialize_variables()</code> is equivalent to passing the list of
initializers to <code>Group()</code>.</p>
<p>If <code>var_list</code> is empty, however, the function still returns an Op that can
be run. That Op just has no effect.</p>
<p>Args:
  var_list: List of <code>Variable</code> objects to initialize.
  name: Optional name for the returned operation.</p>
<p>Returns:
  An Op that run the initializers of all the specified variables.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.inv">
    <p>def <span class="ident">inv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.inv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.inv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.inv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.inv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.inv</strong></p>
<div class="codehilite"><pre><span></span>Computes the reciprocal of x element-wise.
</pre></div>


<p>I.e., \(y = 1 / x\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.inv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.inv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.invert_permutation">
    <p>def <span class="ident">invert_permutation</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.invert_permutation(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.invert_permutation</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.invert_permutation(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.invert_permutation(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.invert_permutation</strong></p>
<div class="codehilite"><pre><span></span>Computes the inverse permutation of a tensor.
</pre></div>


<p>This operation computes the inverse of an index permutation. It takes a 1-D
integer tensor <code>x</code>, which represents the indices of a zero-based array, and
swaps each value with its index position. In other words, for an output tensor
<code>y</code> and an input tensor <code>x</code>, this operation computes the following:</p>
<p><code>y[x[i]] = i for i in [0, 1, ..., len(x) - 1]</code></p>
<p>The values must include 0. There can be no duplicate values or negative values.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor <code>x</code> is [3, 4, 0, 2, 1]</h1>
<p>invert_permutation(x) ==&gt; [2, 4, 3, 0, 1]
```</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>. 1-D.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.invert_permutation', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.invert_permutation" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_finite">
    <p>def <span class="ident">is_finite</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_finite(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_finite</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_finite(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_finite(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_finite</strong></p>
<div class="codehilite"><pre><span></span>Returns which elements of x are finite.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_finite', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_finite" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_inf">
    <p>def <span class="ident">is_inf</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_inf(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_inf</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_inf(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_inf(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_inf</strong></p>
<div class="codehilite"><pre><span></span>Returns which elements of x are Inf.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_inf', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_inf" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_nan">
    <p>def <span class="ident">is_nan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_nan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_nan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_nan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_nan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_nan</strong></p>
<div class="codehilite"><pre><span></span>Returns which elements of x are NaN.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_nan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_nan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_non_decreasing">
    <p>def <span class="ident">is_non_decreasing</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_non_decreasing(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_non_decreasing</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_non_decreasing(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_non_decreasing(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_non_decreasing</strong></p>
<div class="codehilite"><pre><span></span>Returns `True` if `x` is non-decreasing.
</pre></div>


<p>Elements of <code>x</code> are compared in row-major order.  The tensor <code>[x[0],...]</code>
is non-decreasing if for every adjacent pair we have <code>x[i] &lt;= x[i+1]</code>.
If <code>x</code> has less than two elements, it is trivially non-decreasing.</p>
<p>See also:  <code>is_strictly_increasing</code></p>
<p>Args:
  x: Numeric <code>Tensor</code>.
  name: A name for this operation (optional).  Defaults to "is_non_decreasing"</p>
<p>Returns:
  Boolean <code>Tensor</code>, equal to <code>True</code> iff <code>x</code> is non-decreasing.</p>
<p>Raises:
  TypeError: if <code>x</code> is not a numeric tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_non_decreasing', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_non_decreasing" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_numeric_tensor">
    <p>def <span class="ident">is_numeric_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_numeric_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_numeric_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_numeric_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_numeric_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_numeric_tensor</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_numeric_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_numeric_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_strictly_increasing">
    <p>def <span class="ident">is_strictly_increasing</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_strictly_increasing(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_strictly_increasing</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_strictly_increasing(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_strictly_increasing(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_strictly_increasing</strong></p>
<div class="codehilite"><pre><span></span>Returns `True` if `x` is strictly increasing.
</pre></div>


<p>Elements of <code>x</code> are compared in row-major order.  The tensor <code>[x[0],...]</code>
is strictly increasing if for every adjacent pair we have <code>x[i] &lt; x[i+1]</code>.
If <code>x</code> has less than two elements, it is trivially strictly increasing.</p>
<p>See also:  <code>is_non_decreasing</code></p>
<p>Args:
  x: Numeric <code>Tensor</code>.
  name: A name for this operation (optional).
    Defaults to "is_strictly_increasing"</p>
<p>Returns:
  Boolean <code>Tensor</code>, equal to <code>True</code> iff <code>x</code> is strictly increasing.</p>
<p>Raises:
  TypeError: if <code>x</code> is not a numeric tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_strictly_increasing', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_strictly_increasing" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_variable_initialized">
    <p>def <span class="ident">is_variable_initialized</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.is_variable_initialized(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_variable_initialized</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_variable_initialized(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.is_variable_initialized(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_variable_initialized</strong></p>
<div class="codehilite"><pre><span></span>Tests if a variable has been initialized.
</pre></div>


<p>Args:
  variable: A <code>Variable</code>.</p>
<p>Returns:
  Returns a scalar boolean Tensor, <code>True</code> if the variable has been
  initialized, <code>False</code> otherwise.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_variable_initialized', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_variable_initialized" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_loss">
    <p>def <span class="ident">l2_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.l2_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.l2_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.l2_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.l2_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.l2_loss</strong></p>
<div class="codehilite"><pre><span></span>L2 Loss.
</pre></div>


<p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>
<div class="codehilite"><pre><span></span>output = sum(t ** 2) / 2
</pre></div>


<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Typically 2-D, but may have any dimensions.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>t</code>. 0-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer">
    <p>def <span class="ident">l2_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.l2_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.l2_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_loss`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_loss_layer">
    <p>def <span class="ident">l2_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.l2_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.l2_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_loss`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_normalize">
    <p>def <span class="ident">l2_normalize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.l2_normalize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.l2_normalize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.l2_normalize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.l2_normalize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.l2_normalize</strong></p>
<div class="codehilite"><pre><span></span>Normalizes along dimension `dim` using an L2 norm.
</pre></div>


<p>For a 1-D tensor with <code>dim = 0</code>, computes</p>
<div class="codehilite"><pre><span></span>output = x / sqrt(max(sum(x**2), epsilon))
</pre></div>


<p>For <code>x</code> with more dimensions, independently normalizes each 1-D slice along
dimension <code>dim</code>.</p>
<p>Args:
  x: A <code>Tensor</code>.
  dim: Dimension along which to normalize.  A scalar or a vector of
    integers.
  epsilon: A lower bound value for the norm. Will use <code>sqrt(epsilon)</code> as the
    divisor if <code>norm &lt; sqrt(epsilon)</code>.
  name: A name for this operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same shape as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_normalize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_normalize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer">
    <p>def <span class="ident">l2_normalize_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.l2_normalize_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.l2_normalize_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_normalize`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_normalize_layer">
    <p>def <span class="ident">l2_normalize_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.l2_normalize_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.l2_normalize_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_normalize`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_normalize_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_normalize_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lbeta">
    <p>def <span class="ident">lbeta</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.lbeta(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.lbeta</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.lbeta(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.lbeta(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.lbeta</strong></p>
<div class="codehilite"><pre><span></span>Computes `ln(|Beta(x)|)`, reducing along the last dimension.
</pre></div>


<p>Given one-dimensional <code>z = [z_0,...,z_{K-1}]</code>, we define</p>
<p><code>Beta(z) = \prod_j Gamma(z_j) / Gamma(\sum_j z_j)</code></p>
<p>And for <code>n + 1</code> dimensional <code>x</code> with shape <code>[N1, ..., Nn, K]</code>, we define
<code>lbeta(x)[i1, ..., in] = Log(|Beta(x[i1, ..., in, :])|)</code>.  In other words,
the last dimension is treated as the <code>z</code> vector.</p>
<p>Note that if <code>z = [u, v]</code>, then
<code>Beta(z) = int_0^1 t^{u-1} (1 - t)^{v-1} dt</code>, which defines the traditional
bivariate beta function.</p>
<p>Args:
  x: A rank <code>n + 1</code> <code>Tensor</code> with type <code>float</code>, or <code>double</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  The logarithm of <code>|Beta(x)|</code> reducing along the last dimension.</p>
<p>Raises:
  ValueError:  If <code>x</code> is empty with rank one or less.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lbeta', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lbeta" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler">
    <p>def <span class="ident">learned_unigram_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.learned_unigram_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.learned_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.learned_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.learned_unigram_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.learned_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes from a distribution learned during training.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is constructed on the fly
during training.  It is a unigram distribution over the target
classes seen so far during training.  Every integer in <code>[0, range_max)</code>
begins with a weight of 1, and is incremented by 1 each time it is
seen as a target class.  The base distribution is not saved to checkpoints,
so it is reset when the model is reloaded.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">learned_unigram_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.learned_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.learned_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.learned_unigram_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer">
    <p>def <span class="ident">learned_unigram_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.learned_unigram_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.learned_unigram_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.learned_unigram_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.less">
    <p>def <span class="ident">less</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.less(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.less</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.less(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.less(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.less</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &lt; y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Less</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.less', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.less" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.less_equal">
    <p>def <span class="ident">less_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.less_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.less_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.less_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.less_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.less_equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &lt;= y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>LessEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.less_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.less_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lgamma">
    <p>def <span class="ident">lgamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.lgamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.lgamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.lgamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.lgamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.lgamma</strong></p>
<div class="codehilite"><pre><span></span>Computes the log of the absolute value of `Gamma(x)` element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lgamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lgamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lin_space">
    <p>def <span class="ident">lin_space</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.lin_space(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.lin_space</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.lin_space(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.lin_space(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.lin_space</strong></p>
<div class="codehilite"><pre><span></span>Generates values in an interval.
</pre></div>


<p>A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>.
If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>,
so that the last one is exactly <code>stop</code>.</p>
<p>For example:</p>
<p><code>tf.linspace(10.0, 12.0, 3, name="linspace") =&gt; [ 10.0  11.0  12.0]</code></p>
<p>Args:
  start: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    First entry in the range.
  stop: A <code>Tensor</code>. Must have the same type as <code>start</code>.
    Last entry in the range.
  num: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Number of values to generate.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>start</code>. 1-D. The generated values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lin_space', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lin_space" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.linear_conv2d_layer">
    <p>def <span class="ident">linear_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.linear_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.linear_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `None`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.linear_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.linear_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.linear_layer">
    <p>def <span class="ident">linear_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.linear_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.linear_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `None`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.linear_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.linear_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.list_diff">
    <p>def <span class="ident">list_diff</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.list_diff(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.list_diff</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.list_diff(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.list_diff(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.list_diff</strong></p>
<div class="codehilite"><pre><span></span>Computes the difference between two lists of numbers or strings.
</pre></div>


<p>Given a list <code>x</code> and a list <code>y</code>, this operation returns a list <code>out</code> that
represents all values that are in <code>x</code> but not in <code>y</code>. The returned list <code>out</code>
is sorted in the same order that the numbers appear in <code>x</code> (duplicates are
preserved). This operation also returns a list <code>idx</code> that represents the
position of each <code>out</code> element in <code>x</code>. In other words:</p>
<p><code>out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]</code></p>
<p>For example, given this input:</p>
<p><code>prettyprint
x = [1, 2, 3, 4, 5, 6]
y = [1, 3, 5]</code></p>
<p>This operation would return:</p>
<p><code>prettyprint
out ==&gt; [2, 4, 6]
idx ==&gt; [1, 3, 5]</code></p>
<p>Args:
  x: A <code>Tensor</code>. 1-D. Values to keep.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>. 1-D. Values to remove.
  out_idx: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (out, idx).
  out: A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D. Values present in <code>x</code> but not in <code>y</code>.
  idx: A <code>Tensor</code> of type <code>out_idx</code>. 1-D. Positions of <code>x</code> values preserved in <code>out</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.list_diff', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.list_diff" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.load_file_system_library">
    <p>def <span class="ident">load_file_system_library</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.load_file_system_library(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.load_file_system_library</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.load_file_system_library(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.load_file_system_library(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.load_file_system_library</strong></p>
<div class="codehilite"><pre><span></span>Loads a TensorFlow plugin, containing file system implementation.
</pre></div>


<p>Pass <code>library_filename</code> to a platform-specific mechanism for dynamically
loading a library. The rules for determining the exact location of the
library are platform-specific and are not documented here.</p>
<p>Args:
  library_filename: Path to the plugin.
    Relative or absolute filesystem path to a dynamic library file.</p>
<p>Returns:
  None.</p>
<p>Raises:
  RuntimeError: when unable to load the library.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.load_file_system_library', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.load_file_system_library" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.load_op_library">
    <p>def <span class="ident">load_op_library</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.load_op_library(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.load_op_library</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.load_op_library(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.load_op_library(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.load_op_library</strong></p>
<div class="codehilite"><pre><span></span>Loads a TensorFlow plugin, containing custom ops and kernels.
</pre></div>


<p>Pass "library_filename" to a platform-specific mechanism for dynamically
loading a library. The rules for determining the exact location of the
library are platform-specific and are not documented here. When the
library is loaded, ops and kernels registered in the library via the
REGISTER_* macros are made available in the TensorFlow process. Note
that ops with the same name as an existing op are rejected and not
registered with the process.</p>
<p>Args:
  library_filename: Path to the plugin.
    Relative or absolute filesystem path to a dynamic library file.</p>
<p>Returns:
  A python module containing the Python wrappers for Ops defined in
  the plugin.</p>
<p>Raises:
  RuntimeError: when unable to load the library or get the python wrappers.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.load_op_library', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.load_op_library" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer">
    <p>def <span class="ident">local_response_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.local_response_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.local_response_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.local_response_normalization`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_response_normalization_layer">
    <p>def <span class="ident">local_response_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.local_response_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.local_response_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.local_response_normalization`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_response_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_response_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_variables">
    <p>def <span class="ident">local_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.local_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.local_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.local_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.local_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.local_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables created with collection=[LOCAL_VARIABLES].
</pre></div>


<p>Returns:
  A list of local Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log">
    <p>def <span class="ident">log</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.log</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.log(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.log</strong></p>
<div class="codehilite"><pre><span></span>Computes natural logarithm of x element-wise.
</pre></div>


<p>I.e., \(y = \log_e x\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_poisson_loss">
    <p>def <span class="ident">log_poisson_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_poisson_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.log_poisson_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.log_poisson_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_poisson_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.log_poisson_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes log poisson loss given `log_input`.
</pre></div>


<p>Gives the log-likelihood loss between the prediction and the target under the
assumption that the target has a poisson distribution.
Caveat: By default, this is not the exact loss, but the loss minus a
  constant term [log(z!)]. That has no effect for optimization, but
  does not play well with relative loss comparisons. To compute an
  approximation of the log factorial term, specify
  compute_full_loss=True to enable Stirling's Approximation.</p>
<p>For brevity, let <code>c = log(x) = log_input</code>, <code>z = targets</code>.  The log poisson
loss is</p>
<div class="codehilite"><pre><span></span>  -log(exp(-x) * (x^z) / z!)
= -log(exp(-x) * (x^z)) + log(z!)
~ -log(exp(-x)) - log(x^z) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
    [ Note the second term is the Stirling&#39;s Approximation for log(z!).
      It is invariant to x and does not affect optimization, though
      important for correct relative loss comparisons. It is only
      computed when compute_full_loss == True. ]
= x - z * log(x) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
= exp(c) - z * c [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
</pre></div>


<p>Args:
  log_input: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>log_input</code>.
  compute_full_loss: whether to compute the full loss. If false, a constant
    term is dropped in favor of more efficient optimization.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>log_input</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>log_input</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_poisson_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_poisson_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer">
    <p>def <span class="ident">log_poisson_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_poisson_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_poisson_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_poisson_loss`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer">
    <p>def <span class="ident">log_poisson_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_poisson_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_poisson_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_poisson_loss`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_softmax">
    <p>def <span class="ident">log_softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.log_softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.log_softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.log_softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes log softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>logsoftmax = logits - reduce_sum(exp(logits), dim)
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.</p>
<p>Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer">
    <p>def <span class="ident">log_softmax_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_softmax_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_softmax_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_softmax`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_softmax_layer">
    <p>def <span class="ident">log_softmax_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_softmax_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_softmax_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_softmax`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_softmax_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_softmax_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler">
    <p>def <span class="ident">log_uniform_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_uniform_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.log_uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.log_uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_uniform_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.log_uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a log-uniform (Zipfian) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is an approximately log-uniform
or Zipfian distribution:</p>
<p><code>P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)</code></p>
<p>This sampler is useful when the target classes approximately follow such
a distribution - for example, if the classes represent words in a lexicon
sorted in decreasing order of frequency. If your classes are not ordered by
decreasing frequency, do not use this op.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">log_uniform_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_uniform_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_uniform_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_uniform_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer">
    <p>def <span class="ident">log_uniform_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.log_uniform_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.log_uniform_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_uniform_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_and">
    <p>def <span class="ident">logical_and</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.logical_and(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_and</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_and(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.logical_and(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_and</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of x AND y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>LogicalAnd</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code> of type <code>bool</code>.
  y: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_and', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_and" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_not">
    <p>def <span class="ident">logical_not</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.logical_not(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_not</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_not(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.logical_not(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_not</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of NOT x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_not', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_not" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_or">
    <p>def <span class="ident">logical_or</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.logical_or(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_or</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_or(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.logical_or(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_or</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of x OR y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>LogicalOr</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code> of type <code>bool</code>.
  y: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_or', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_or" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_xor">
    <p>def <span class="ident">logical_xor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.logical_xor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_xor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_xor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.logical_xor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_xor</strong></p>
<div class="codehilite"><pre><span></span>x ^ y = (x | y) &amp; ~(x &amp; y).
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_xor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_xor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lrn">
    <p>def <span class="ident">lrn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.lrn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.lrn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.lrn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.lrn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.lrn</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see [Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)]
(http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lrn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lrn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer">
    <p>def <span class="ident">lrn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.lrn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.lrn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.lrn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lrn_layer">
    <p>def <span class="ident">lrn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.lrn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.lrn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.lrn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lrn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lrn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_all">
    <p>def <span class="ident">make_all</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_all(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.make_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.make_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_all(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.make_all</strong></p>
<div class="codehilite"><pre><span></span>Generates `__all__` from the docstring of one or more modules.
</pre></div>


<p>Usage: <code>make_all(__name__)</code> or
<code>make_all(__name__, [sys.modules(__name__), other_module])</code>. The doc string
modules must each a docstring, and <code>__all__</code> will contain all symbols with
<code>@@</code> references, where that symbol currently exists in the module named
<code>module_name</code>.</p>
<p>Args:
  module_name: The name of the module (usually <code>__name__</code>).
  doc_string_modules: a list of modules from which to take docstring.
  If None, then a list containing only the module named <code>module_name</code> is used.</p>
<p>Returns:
  A list suitable for use as <code>__all__</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_all', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_all" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer">
    <p>def <span class="ident">make_all_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_all_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_all_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.make_all`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_all_layer">
    <p>def <span class="ident">make_all_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_all_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_all_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.make_all`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_all_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_all_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_audio_summary">
    <p>def <span class="ident">make_audio_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_audio_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.audio_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tf.audio_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_audio_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tf.audio_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with audio.
</pre></div>


<p>The summary has up to <code>max_outputs</code> summary values containing audio. The
audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,
frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are
assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of
<code>sample_rate</code>.</p>
<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
build the <code>tag</code> of the summary values:</p>
<ul>
<li>If <code>max_outputs</code> is 1, the summary value tag is '<em>tag</em>/audio'.</li>
<li>If <code>max_outputs</code> is greater than 1, the summary value tags are
   generated sequentially as '<em>tag</em>/audio/0', '<em>tag</em>/audio/1', etc.</li>
</ul>
<p>Args:
  tag: A scalar <code>Tensor</code> of type <code>string</code>. Used to build the <code>tag</code>
    of the summary values.
  tensor: A 3-D <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, frames, channels]</code>
    or a 2-D <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, frames]</code>.
  sample_rate: The sample rate of the signal in hertz.
  max_outputs: Max number of batch elements to generate audio for.
  collections: Optional list of ops.GraphKeys.  The collections to add the
    summary to.  Defaults to [ops.GraphKeys.SUMMARIES]
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_audio_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_audio_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_histogram_summary">
    <p>def <span class="ident">make_histogram_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_histogram_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.histogram_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tf.histogram_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_histogram_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tf.histogram_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with a histogram.
</pre></div>


<p>The generated
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
has one summary value containing a histogram for <code>values</code>.</p>
<p>This op reports an <code>InvalidArgument</code> error if any value is not finite.</p>
<p>Args:
  tag: A <code>string</code> <code>Tensor</code>. 0-D.  Tag to use for the summary value.
  values: A real numeric <code>Tensor</code>. Any shape. Values to use to
    build the histogram.
  collections: Optional list of graph collections keys. The new summary op is
    added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_histogram_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_histogram_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_image_summary">
    <p>def <span class="ident">make_image_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_image_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.image_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tf.image_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_image_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tf.image_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with images.
</pre></div>


<p>The summary has up to <code>max_images</code> summary values containing images. The
images are built from <code>tensor</code> which must be 4-D with shape <code>[batch_size,
height, width, channels]</code> and where <code>channels</code> can be:</p>
<ul>
<li>1: <code>tensor</code> is interpreted as Grayscale.</li>
<li>3: <code>tensor</code> is interpreted as RGB.</li>
<li>4: <code>tensor</code> is interpreted as RGBA.</li>
</ul>
<p>The images have the same number of channels as the input tensor. For float
input, the values are normalized one image at a time to fit in the range
<code>[0, 255]</code>.  <code>uint8</code> values are unchanged.  The op uses two different
normalization algorithms:</p>
<ul>
<li>
<p>If the input values are all positive, they are rescaled so the largest one
   is 255.</p>
</li>
<li>
<p>If any input value is negative, the values are shifted so input value 0.0
   is at 127.  They are then rescaled so that either the smallest value is 0,
   or the largest one is 255.</p>
</li>
</ul>
<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
build the <code>tag</code> of the summary values:</p>
<ul>
<li>If <code>max_images</code> is 1, the summary value tag is '<em>tag</em>/image'.</li>
<li>If <code>max_images</code> is greater than 1, the summary value tags are
   generated sequentially as '<em>tag</em>/image/0', '<em>tag</em>/image/1', etc.</li>
</ul>
<p>Args:
  tag: A scalar <code>Tensor</code> of type <code>string</code>. Used to build the <code>tag</code>
    of the summary values.
  tensor: A 4-D <code>uint8</code> or <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, height,
    width, channels]</code> where <code>channels</code> is 1, 3, or 4.
  max_images: Max number of batch elements to generate images for.
  collections: Optional list of ops.GraphKeys.  The collections to add the
    summary to.  Defaults to [ops.GraphKeys.SUMMARIES]
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_image_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_image_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_merge_summary">
    <p>def <span class="ident">make_merge_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_merge_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.merge_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tf.merge_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_merge_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tf.merge_summary</strong></p>
<div class="codehilite"><pre><span></span>Merges summaries.
</pre></div>


<p>This op creates a
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
protocol buffer that contains the union of all the values in the input
summaries.</p>
<p>When the Op is run, it reports an <code>InvalidArgument</code> error if multiple values
in the summaries to merge use the same tag.</p>
<p>Args:
  inputs: A list of <code>string</code> <code>Tensor</code> objects containing serialized <code>Summary</code>
    protocol buffers.
  collections: Optional list of graph collections keys. The new summary op is
    added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer resulting from the merging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_merge_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_merge_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_scalar_summary">
    <p>def <span class="ident">make_scalar_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_scalar_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.scalar_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tf.scalar_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_scalar_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tf.scalar_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with scalar values.
</pre></div>


<p>The input <code>tags</code> and <code>values</code> must have the same shape.  The generated
summary has a summary value for each tag-value pair in <code>tags</code> and <code>values</code>.</p>
<p>Args:
  tags: A <code>string</code> <code>Tensor</code>.  Tags for the summaries.
  values: A real numeric Tensor.  Values for the summaries.
  collections: Optional list of graph collections keys. The new summary op is
    added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_scalar_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_scalar_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_template">
    <p>def <span class="ident">make_template</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.make_template(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.make_template</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.make_template(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.make_template(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.make_template</strong></p>
<div class="codehilite"><pre><span></span>Given an arbitrary function, wrap it so that it does variable sharing.
</pre></div>


<p>This wraps <code>func_</code> in a Template and partially evaluates it. Templates are
functions that create variables the first time they are called and reuse them
thereafter. In order for <code>func_</code> to be compatible with a <code>Template</code> it must
have the following properties:</p>
<ul>
<li>The function should create all trainable variables and any variables that
   should be reused by calling <code>tf.get_variable</code>. If a trainable variable is
   created using <code>tf.Variable</code>, then a ValueError will be thrown. Variables
   that are intended to be locals can be created by specifying
   <code>tf.Variable(..., trainable=false)</code>.</li>
<li>The function may use variable scopes and other templates internally to
    create and reuse variables, but it shouldn't use <code>tf.get_variables</code> to
    capture variables that are defined outside of the scope of the function.</li>
<li>Internal scopes and variable names should not depend on any arguments that
    are not supplied to <code>make_template</code>. In general you will get a ValueError
    telling you that you are trying to reuse a variable that doesn't exist
    if you make a mistake.</li>
</ul>
<p>In the following example, both <code>z</code> and <code>w</code> will be scaled by the same <code>y</code>. It
is important to note that if we didn't assign <code>scalar_name</code> and used a
different name for z and w that a <code>ValueError</code> would be thrown because it
couldn't reuse the variable.</p>
<p>```python
def my_op(x, scalar_name):
  var1 = tf.get_variable(scalar_name,
                         shape=[],
                         initializer=tf.constant_initializer(1))
  return x * var1</p>
<p>scale_by_y = tf.make_template('scale_by_y', my_op, scalar_name='y')</p>
<p>z = scale_by_y(input1)
w = scale_by_y(input2)
```</p>
<p>As a safe-guard, the returned function will raise a <code>ValueError</code> after the
first call if trainable variables are created by calling <code>tf.Variable</code>.</p>
<p>If all of these are true, then 2 properties are enforced by the template:</p>
<ol>
<li>Calling the same template multiple times will share all non-local
    variables.</li>
<li>Two different templates are guaranteed to be unique, unless you reenter the
    same variable scope as the initial definition of a template and redefine
    it. An examples of this exception:</li>
</ol>
<p>```python
def my_op(x, scalar_name):
  var1 = tf.get_variable(scalar_name,
                         shape=[],
                         initializer=tf.constant_initializer(1))
  return x * var1</p>
<p>with tf.variable_scope('scope') as vs:
  scale_by_y = tf.make_template('scale_by_y', my_op, scalar_name='y')
  z = scale_by_y(input1)
  w = scale_by_y(input2)</p>
<h1>Creates a template that reuses the variables above.</h1>
<p>with tf.variable_scope(vs, reuse=True):
  scale_by_y2 = tf.make_template('scale_by_y', my_op, scalar_name='y')
  z2 = scale_by_y2(input1)
  w2 = scale_by_y2(input2)
```</p>
<p>Depending on the value of <code>create_scope_now_</code>, the full variable scope may be
captured either at the time of first call or at the time of construction. If
this option is set to True, then all Tensors created by repeated calls to the
template will have an extra trailing _N+1 to their name, as the first time the
scope is entered in the Template constructor no Tensors are created.</p>
<p>Note: <code>name_</code>, <code>func_</code> and <code>create_scope_now_</code> have a trailing underscore to
reduce the likelihood of collisions with kwargs.</p>
<p>Args:
  name_: A name for the scope created by this template. If necessary, the name
    will be made unique by appending <code>_N</code> to the name.
  func_: The function to wrap.
  create_scope_now_: Boolean controlling whether the scope should be created
    when the template is constructed or when the template is called. Default
    is False, meaning the scope is created when the template is called.
  unique_name_: When used, it overrides name_ and is not made unique. If a
    template of the same scope/unique_name already exists and reuse is false,
    an error is raised. Defaults to None.
  **kwargs: Keyword arguments to apply to <code>func_</code>.</p>
<p>Returns:
  A function to encapsulate a set of variables which should be created once
  and reused. An enclosing scope will created, either where <code>make_template</code>
  is called, or wherever the result is called, depending on the value of
  <code>create_scope_now_</code>. Regardless of the value, the first time the template
  is called it will enter the scope with no reuse, and call <code>func_</code> to create
  variables, which are guaranteed to be unique. All subsequent calls will
  re-enter the scope and reuse those variables.</p>
<p>Raises:
  ValueError: if the name is None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_template', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_template" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.map_fn">
    <p>def <span class="ident">map_fn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.map_fn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.map_fn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.map_fn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.map_fn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.map_fn</strong></p>
<div class="codehilite"><pre><span></span>map on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>The simplest version of <code>map</code> repeatedly applies the callable <code>fn</code> to a
sequence of elements from first to last. The elements are made of the
tensors unpacked from <code>elems</code>. <code>dtype</code> is the data type of the return
value of <code>fn</code>. Users must provide <code>dtype</code> if it is different from
the data type of <code>elems</code>.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is <code>[values.shape[0]] + fn(values[0]).shape</code>.</p>
<p>This method also allows multi-arity <code>elems</code> and output of <code>fn</code>.  If <code>elems</code>
is a (possibly nested) list or tuple of tensors, then each of these tensors
must have a matching first (unpack) dimension.  The signature of <code>fn</code> may
match the structure of <code>elems</code>.  That is, if <code>elems</code> is
<code>(t1, [t2, t3, [t4, t5]])</code>, then an appropriate signature for <code>fn</code> is:
<code>fn = lambda (t1, [t2, t3, [t4, t5]]):</code>.</p>
<p>Furthermore, <code>fn</code> may emit a different structure than its input.  For example,
<code>fn</code> may look like: <code>fn = lambda t1: return (t1 + 1, t1 - 1)</code>.  In this case,
the <code>dtype</code> parameter is not optional: <code>dtype</code> must be a type or (possibly
nested) tuple of types matching the output of <code>fn</code>.</p>
<p>Args:
  fn: The callable to be performed.  It accepts one argument, which will
    have the same (possibly nested) structure as <code>elems</code>.  Its output
    must have the same structure as <code>dtype</code> if one is provided, otherwise
    it must have the same structure as <code>elems</code>.
  elems: A tensor or (possibly nested) sequence of tensors, each of which
    will be unpacked along their first dimension.  The nested sequence
    of the resulting slices will be applied to <code>fn</code>.
  dtype: (optional) The output type(s) of <code>fn</code>.  If <code>fn</code> returns a structure
    of Tensors differing from the structure of <code>elems</code>, then <code>dtype</code> is not
    optional and must have the same structure as the output of <code>fn</code>.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  infer_shape: (optional) False disables tests for consistent output shapes.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor or (possibly nested) sequence of tensors.  Each tensor packs the
  results of applying <code>fn</code> to tensors unpacked from <code>elems</code> along the first
  dimension, from first to last.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable or the structure of the output of
    <code>fn</code> and <code>dtype</code> do not match.
  ValueError: if the lengths of the output of <code>fn</code> and <code>dtype</code> do not match.</p>
<p>Examples:
  <code>python
  elems = np.array([1, 2, 3, 4, 5, 6])
  squares = map_fn(lambda x: x * x, elems)
  # squares == [1, 4, 9, 16, 25, 36]</code></p>
<p><code>python
  elems = (np.array([1, 2, 3]), np.array([-1, 1, -1]))
  alternate = map_fn(lambda x: x[0] * x[1], elems, dtype=tf.int64)
  # alternate == [-1, 2, -3]</code></p>
<p><code>python
  elems = np.array([1, 2, 3])
  alternates = map_fn(lambda x: (x, -x), elems, dtype=(tf.int64, tf.int64))
  # alternates[0] == [1, 2, 3]
  # alternates[1] == [-1, -2, -3]</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.map_fn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.map_fn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matching_files">
    <p>def <span class="ident">matching_files</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matching_files(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matching_files</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matching_files(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matching_files(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matching_files</strong></p>
<div class="codehilite"><pre><span></span>Returns the set of files matching a pattern.
</pre></div>


<p>Note that this routine only supports wildcard characters in the
basename portion of the pattern, not in the directory portion.</p>
<p>Args:
  pattern: A <code>Tensor</code> of type <code>string</code>. A (scalar) shell wildcard pattern.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. A vector of matching filenames.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matching_files', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matching_files" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matmul">
    <p>def <span class="ident">matmul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matmul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matmul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matmul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matmul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matmul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies matrix `a` by matrix `b`, producing `a` * `b`.
</pre></div>


<p>The inputs must be two-dimensional matrices, with matching inner dimensions,
possibly after transposition.</p>
<p>Both matrices must be of the same type. The supported types are:
<code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>.</p>
<p>Either matrix can be transposed on the fly by setting the corresponding flag
to <code>True</code>. This is <code>False</code> by default.</p>
<p>If one or both of the matrices contain a lot of zeros, a more efficient
multiplication algorithm can be used by setting the corresponding
<code>a_is_sparse</code> or <code>b_is_sparse</code> flag to <code>True</code>. These are <code>False</code> by default.</p>
<p>For example:</p>
<p>```python</p>
<h1>2-D tensor <code>a</code></h1>
<p>a = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3]) =&gt; [[1. 2. 3.]
                                                      [4. 5. 6.]]</p>
<h1>2-D tensor <code>b</code></h1>
<p>b = tf.constant([7, 8, 9, 10, 11, 12], shape=[3, 2]) =&gt; [[7. 8.]
                                                         [9. 10.]
                                                         [11. 12.]]
c = tf.matmul(a, b) =&gt; [[58 64]
                        [139 154]]
```</p>
<p>Args:
  a: <code>Tensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code> or <code>complex64</code>.
  b: <code>Tensor</code> with same type as <code>a</code>.
  transpose_a: If <code>True</code>, <code>a</code> is transposed before multiplication.
  transpose_b: If <code>True</code>, <code>b</code> is transposed before multiplication.
  a_is_sparse: If <code>True</code>, <code>a</code> is treated as a sparse matrix.
  b_is_sparse: If <code>True</code>, <code>b</code> is treated as a sparse matrix.
  name: Name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matmul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matmul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_band_part">
    <p>def <span class="ident">matrix_band_part</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_band_part(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_band_part</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_band_part(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_band_part(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_band_part</strong></p>
<div class="codehilite"><pre><span></span>Copy a tensor setting everything outside a central band in each innermost matrix
</pre></div>


<p>to zero.</p>
<p>The <code>band</code> part is computed as follows:
Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., M, N]</code>, then the output is a
tensor with the same shape where</p>
<p><code>band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]</code>.</p>
<p>The indicator function 'in_band(m, n)<code>is one if</code>(num_lower &lt; 0 || (m-n) &lt;= num_lower)) &amp;&amp;
(num_upper &lt; 0 || (n-m) &lt;= num_upper)`, and zero otherwise.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>if 'input' is [[ 0,  1,  2, 3]</h1>
<div class="codehilite"><pre><span></span>             [-1,  0,  1, 2]
             [-2, -1,  0, 1]
             [-3, -2, -1, 0]],
</pre></div>


<p>tf.matrix_band_part(input, 1, -1) ==&gt; [[ 0,  1,  2, 3]
                                             [-1,  0,  1, 2]
                                             [ 0, -1,  0, 1]
                                             [ 0,  0, -1, 0]],</p>
<p>tf.matrix_band_part(input, 2, 1) ==&gt; [[ 0,  1,  0, 0]
                                            [-1,  0,  1, 0]
                                            [-2, -1,  0, 1]
                                            [ 0, -2, -1, 0]]
```</p>
<p>Useful special cases:</p>
<p><code>prettyprint
 tf.matrix_band_part(input, 0, -1) ==&gt; Upper triangular part.
 tf.matrix_band_part(input, -1, 0) ==&gt; Lower triangular part.
 tf.matrix_band_part(input, 0, 0) ==&gt; Diagonal.</code></p>
<p>Args:
  input: A <code>Tensor</code>. Rank <code>k</code> tensor.
  num_lower: A <code>Tensor</code> of type <code>int64</code>.
    0-D tensor. Number of subdiagonals to keep. If negative, keep entire
    lower triangle.
  num_upper: A <code>Tensor</code> of type <code>int64</code>.
    0-D tensor. Number of superdiagonals to keep. If negative, keep
    entire upper triangle.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Rank <code>k</code> tensor of the same shape as input. The extracted banded tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_band_part', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_band_part" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_determinant">
    <p>def <span class="ident">matrix_determinant</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_determinant(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_determinant</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_determinant(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_determinant(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_determinant</strong></p>
<div class="codehilite"><pre><span></span>Computes the determinant of one ore more square matrices.
</pre></div>


<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. The output is a tensor containing the determinants
for all input submatrices <code>[..., :, :]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    Shape is <code>[..., M, M]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. Shape is <code>[...]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_determinant', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_determinant" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_diag">
    <p>def <span class="ident">matrix_diag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_diag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_diag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_diag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_diag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_diag</strong></p>
<div class="codehilite"><pre><span></span>Returns a batched diagonal tensor with a given batched diagonal values.
</pre></div>


<p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
everything else padded with zeros. The diagonal is computed as follows:</p>
<p>Assume <code>diagonal</code> has <code>k</code> dimensions <code>[I, J, K, ..., N]</code>, then the output is a
tensor of rank <code>k+1</code> with dimensions [I, J, K, ..., N, N]` where:</p>
<p><code>output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]</h1>
<p>and diagonal.shape = (2, 4)</p>
<p>tf.matrix_diag(diagonal) ==&gt; [[[1, 0, 0, 0]
                                     [0, 2, 0, 0]
                                     [0, 0, 3, 0]
                                     [0, 0, 0, 4]],
                                    [[5, 0, 0, 0]
                                     [0, 6, 0, 0]
                                     [0, 0, 7, 0]
                                     [0, 0, 0, 8]]]</p>
<p>which has shape (2, 4, 4)
```</p>
<p>Args:
  diagonal: A <code>Tensor</code>. Rank <code>k</code>, where <code>k &gt;= 1</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>diagonal</code>.
  Rank <code>k+1</code>, with <code>output.shape = diagonal.shape + [diagonal.shape[-1]]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_diag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_diag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_diag_part">
    <p>def <span class="ident">matrix_diag_part</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_diag_part(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_diag_part</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_diag_part(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_diag_part(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_diag_part</strong></p>
<div class="codehilite"><pre><span></span>Returns the batched diagonal part of a batched tensor.
</pre></div>


<p>This operation returns a tensor with the <code>diagonal</code> part
of the batched <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>
<p>Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., N, N]</code>, then the output is a
tensor of rank <code>k - 1</code> with dimensions <code>[I, J, K, ..., N]</code> where:</p>
<p><code>diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]</code>.</p>
<p>The input must be at least a matrix.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'input' is [[[1, 0, 0, 0]</h1>
<div class="codehilite"><pre><span></span>           [0, 2, 0, 0]
           [0, 0, 3, 0]
           [0, 0, 0, 4]],
          [[5, 0, 0, 0]
           [0, 6, 0, 0]
           [0, 0, 7, 0]
           [0, 0, 0, 8]]]
</pre></div>


<p>and input.shape = (2, 4, 4)</p>
<p>tf.matrix_diag_part(input) ==&gt; [[1, 2, 3, 4], [5, 6, 7, 8]]</p>
<p>which has shape (2, 4)
```</p>
<p>Args:
  input: A <code>Tensor</code>.
    Rank <code>k</code> tensor where <code>k &gt;= 2</code> and the last two dimensions are equal.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The extracted diagonal(s) having shape
  <code>diagonal.shape = input.shape[:-1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_diag_part', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_diag_part" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_inverse">
    <p>def <span class="ident">matrix_inverse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_inverse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_inverse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_inverse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_inverse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_inverse</strong></p>
<div class="codehilite"><pre><span></span>Computes the inverse of one or more square invertible matrices or their
</pre></div>


<p>adjoints (conjugate transposes).</p>
<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. The output is a tensor of the same shape as the input
containing the inverse for all input submatrices <code>[..., :, :]</code>.</p>
<p>The op uses LU decomposition with partial pivoting to compute the inverses.</p>
<p>If a matrix is not invertible there is no guarantee what the op does. It
may detect the condition and raise an exception or it may simply return a
garbage result.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  adjoint: An optional <code>bool</code>. Defaults to <code>False</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. Shape is <code>[..., M, M]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_inverse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_inverse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_set_diag">
    <p>def <span class="ident">matrix_set_diag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_set_diag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_set_diag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_set_diag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_set_diag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_set_diag</strong></p>
<div class="codehilite"><pre><span></span>Returns a batched matrix tensor with new batched diagonal values.
</pre></div>


<p>Given <code>input</code> and <code>diagonal</code>, this operation returns a tensor with the
same shape and values as <code>input</code>, except for the diagonals of the innermost
matrices.  These will be overwritten by the values in <code>diagonal</code>.
The batched matrices must be square.</p>
<p>The output is computed as follows:</p>
<p>Assume <code>input</code> has <code>k+1</code> dimensions <code>[I, J, K, ..., N, N]</code> and <code>diagonal</code> has
<code>k</code> dimensions <code>[I, J, K, ..., N]</code>.  Then the output is a
tensor of rank <code>k+1</code> with dimensions [I, J, K, ..., N, N]` where:</p>
<ul>
<li><code>output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]</code> for <code>m == n</code>.</li>
<li><code>output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]</code> for <code>m != n</code>.</li>
</ul>
<p>Args:
  input: A <code>Tensor</code>. Rank <code>k+1</code>, where <code>k &gt;= 1</code>.
  diagonal: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Rank <code>k</code>, where <code>k &gt;= 1</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Rank <code>k+1</code>, with <code>output.shape = input.shape</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_set_diag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_set_diag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_solve">
    <p>def <span class="ident">matrix_solve</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_solve(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_solve</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_solve(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_solve(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_solve</strong></p>
<div class="codehilite"><pre><span></span>Solves systems of linear equations.
</pre></div>


<p><code>Matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. <code>Rhs</code> is a tensor of shape <code>[..., M, K]</code>. The <code>output</code> is
a tensor shape <code>[..., M, K]</code>.  If <code>adjoint</code> is <code>False</code> then each output matrix
satisfies <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code>.
If <code>adjoint</code> is <code>True</code> then each output matrix satisfies
<code>adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]</code>.</p>
<p>Args:
  matrix: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  rhs: A <code>Tensor</code>. Must have the same type as <code>matrix</code>.
    Shape is <code>[..., M, K]</code>.
  adjoint: An optional <code>bool</code>. Defaults to <code>False</code>.
    Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
    adjoint.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>matrix</code>. Shape is <code>[..., M, K]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_solve', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_solve" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_solve_ls">
    <p>def <span class="ident">matrix_solve_ls</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_solve_ls(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_solve_ls</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_solve_ls(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_solve_ls(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_solve_ls</strong></p>
<div class="codehilite"><pre><span></span>Solves one or more linear least-squares problems.
</pre></div>


<p><code>matrix</code> is a tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
form <code>M</code>-by-<code>N</code> matrices. Rhs is a tensor of shape <code>[..., M, K]</code> whose
inner-most 2 dimensions form <code>M</code>-by-<code>K</code> matrices.   The computed output is a
<code>Tensor</code> of shape <code>[..., N, K]</code> whose inner-most 2 dimensions form <code>M</code>-by-<code>K</code>
matrices that solve the equations
<code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code> in the least squares
sense.</p>
<p>Below we will use the following notation for each pair of matrix and
right-hand sides in the batch:</p>
<p><code>matrix</code>=\(A \in \Re^{m \times n}\),
<code>rhs</code>=\(B  \in \Re^{m \times k}\),
<code>output</code>=\(X  \in \Re^{n \times k}\),
<code>l2_regularizer</code>=\(\lambda\).</p>
<p>If <code>fast</code> is <code>True</code>, then the solution is computed by solving the normal
equations using Cholesky decomposition. Specifically, if \(m \ge n\) then
\(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares
problem \(X = \mathrm{argmin}<em>{Z \in \Re^{n \times k}} ||A Z - B||_F^2 +
\lambda ||Z||_F^2\). If \(m \lt n\) then <code>output</code> is computed as
\(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is
the minimum-norm solution to the under-determined linear system, i.e.
\(X = \mathrm{argmin}</em>{Z \in \Re^{n \times k}} ||Z||<em>F^2 \), subject to
\(A Z = B\). Notice that the fast path is only numerically stable when
\(A\) is numerically full rank and has a condition number
\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon</em>{mach}}}\) or\(\lambda\)
is sufficiently large.</p>
<p>If <code>fast</code> is <code>False</code> an algorithm based on the numerically robust complete
orthogonal decomposition is used. This computes the minimum-norm
least-squares solution, even when \(A\) is rank deficient. This path is
typically 6-7 times slower than the fast path. If <code>fast</code> is <code>False</code> then
<code>l2_regularizer</code> is ignored.</p>
<p>Args:
  matrix: <code>Tensor</code> of shape <code>[..., M, N]</code>.
  rhs: <code>Tensor</code> of shape <code>[..., M, K]</code>.
  l2_regularizer: 0-D <code>double</code> <code>Tensor</code>. Ignored if <code>fast=False</code>.
  fast: bool. Defaults to <code>True</code>.
  name: string, optional name of the operation.</p>
<p>Returns:
  output: <code>Tensor</code> of shape <code>[..., N, K]</code> whose inner-most 2 dimensions form
    <code>M</code>-by-<code>K</code> matrices that solve the equations
    <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code> in the least
    squares sense.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_solve_ls', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_solve_ls" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_transpose">
    <p>def <span class="ident">matrix_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_transpose</strong></p>
<div class="codehilite"><pre><span></span>Transposes last two dimensions of tensor `a`.
</pre></div>


<p>For example:</p>
<p>```python</p>
<h1>Matrix with no batch dimension.</h1>
<h1>'x' is [[1 2 3]</h1>
<h1>[4 5 6]]</h1>
<p>tf.matrix_transpose(x) ==&gt; [[1 4]
                                 [2 5]
                                 [3 6]]</p>
<h1>Matrix with two batch dimensions.</h1>
<h1>x.shape is [1, 2, 3, 4]</h1>
<h1>tf.matrix_transpose(x) is shape [1, 2, 4, 3]</h1>
<p>```</p>
<p>Args:
  a: A <code>Tensor</code> with <code>rank &gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A transposed batch matrix <code>Tensor</code>.</p>
<p>Raises:
  ValueError:  If <code>a</code> is determined statically to have <code>rank &lt; 2</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_triangular_solve">
    <p>def <span class="ident">matrix_triangular_solve</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.matrix_triangular_solve(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_triangular_solve</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_triangular_solve(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.matrix_triangular_solve(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_triangular_solve</strong></p>
<div class="codehilite"><pre><span></span>Solves systems of linear equations with upper or lower triangular matrices by
</pre></div>


<p>backsubstitution.</p>
<p><code>matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions form
square matrices. If <code>lower</code> is <code>True</code> then the strictly upper triangular part
of each inner-most matrix is assumed to be zero and not accessed.
If <code>lower</code> is False then the strictly lower triangular part of each inner-most
matrix is assumed to be zero and not accessed.
<code>rhs</code> is a tensor of shape <code>[..., M, K]</code>.</p>
<p>The output is a tensor of shape <code>[..., M, K]</code>. If <code>adjoint</code> is
<code>True</code> then the innermost matrices in output<code>satisfy matrix equations</code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]<code>.
If</code>adjoint<code>is</code>False<code>then the strictly then the  innermost matrices in</code>output<code>satisfy matrix equations</code>adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.</p>
<p>Args:
  matrix: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  rhs: A <code>Tensor</code>. Must have the same type as <code>matrix</code>.
    Shape is <code>[..., M, K]</code>.
  lower: An optional <code>bool</code>. Defaults to <code>True</code>.
    Boolean indicating whether the innermost matrices in <code>matrix</code> are
    lower or upper triangular.
  adjoint: An optional <code>bool</code>. Defaults to <code>False</code>.
    Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
    adjoint.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>matrix</code>. Shape is <code>[..., M, K]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_triangular_solve', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_triangular_solve" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool">
    <p>def <span class="ident">max_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the max pooling on the input.
</pre></div>


<p>Args:
  value: A 4-D <code>Tensor</code> with shape <code>[batch, height, width, channels]</code> and
    type <code>tf.float32</code>.
  ksize: A list of ints that has length &gt;= 4.  The size of the window for
    each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.  The stride of the sliding
    window for each dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with type <code>tf.float32</code>.  The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool2d">
    <p>def <span class="ident">max_pool2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.max_pool2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.max_pool2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layers.max_pool2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D Max Pooling op.
</pre></div>


<p>It is assumed that the pooling is done per image but not in batch or channels.</p>
<p>Args:
  inputs: A <code>Tensor</code> of size [batch_size, height, width, channels].
  kernel_size: A list of length 2: [kernel_height, kernel_width] of the
    pooling kernel over which the op is computed. Can be an int if both
    values are the same.
  stride: A list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: The padding method, either 'VALID' or 'SAME'.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p>
<p>Raises:
  ValueError: If 'kernel_size' is not a 2-D list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d">
    <p>def <span class="ident">max_pool3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.max_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.max_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.max_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D max pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer">
    <p>def <span class="ident">max_pool3d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_grad">
    <p>def <span class="ident">max_pool3d_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.max_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.max_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.max_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of max pooling function.
</pre></div>


<p>Args:
  orig_input: A <code>Tensor</code> of type <code>float32</code>. The original input tensor.
  orig_output: A <code>Tensor</code> of type <code>float32</code>. The original output tensor.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer">
    <p>def <span class="ident">max_pool3d_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d_grad`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer">
    <p>def <span class="ident">max_pool3d_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d_grad`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_layer">
    <p>def <span class="ident">max_pool3d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool3d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer">
    <p>def <span class="ident">max_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_layer">
    <p>def <span class="ident">max_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_with_argmax">
    <p>def <span class="ident">max_pool_with_argmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool_with_argmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.max_pool_with_argmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.max_pool_with_argmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool_with_argmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.max_pool_with_argmax</strong></p>
<div class="codehilite"><pre><span></span>Performs max pooling on the input and outputs both max values and indices.
</pre></div>


<p>The indices in <code>argmax</code> are flattened, so that a maximum value at position
<code>[b, y, x, c]</code> becomes flattened index
<code>((b * height + y) * width + x) * channels + c</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The size of the window for each dimension of the input tensor.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  Targmax: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, argmax).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.
  argmax: A <code>Tensor</code> of type <code>Targmax</code>. 4-D.  The flattened indices of the max values chosen for each output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer">
    <p>def <span class="ident">max_pool_with_argmax_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool_with_argmax_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool_with_argmax_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool_with_argmax`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer">
    <p>def <span class="ident">max_pool_with_argmax_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.max_pool_with_argmax_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.max_pool_with_argmax_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool_with_argmax`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.maximize">
    <p>def <span class="ident">maximize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.maximize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.maximize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.maximize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.maximize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tb.maximize</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.maximize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.maximize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.maximum">
    <p>def <span class="ident">maximum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.maximum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.maximum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.maximum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.maximum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.maximum</strong></p>
<div class="codehilite"><pre><span></span>Returns the max of x and y (i.e. x &gt; y ? x : y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Maximum</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.maximum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.maximum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.merge_all_summaries">
    <p>def <span class="ident">merge_all_summaries</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.merge_all_summaries(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.merge_all_summaries</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.merge_all_summaries(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.merge_all_summaries(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.merge_all_summaries</strong></p>
<div class="codehilite"><pre><span></span>Merges all summaries collected in the default graph.
</pre></div>


<p>Args:
  key: <code>GraphKey</code> used to collect the summaries.  Defaults to
    <code>GraphKeys.SUMMARIES</code>.</p>
<p>Returns:
  If no summaries were collected, returns None.  Otherwise returns a scalar
  <code>Tensor</code> of type <code>string</code> containing the serialized <code>Summary</code> protocol
  buffer resulting from the merging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.merge_all_summaries', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.merge_all_summaries" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.merge_summary">
    <p>def <span class="ident">merge_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.merge_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.merge_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.merge_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.merge_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.merge_summary</strong></p>
<div class="codehilite"><pre><span></span>Merges summaries.
</pre></div>


<p>This op creates a
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
protocol buffer that contains the union of all the values in the input
summaries.</p>
<p>When the Op is run, it reports an <code>InvalidArgument</code> error if multiple values
in the summaries to merge use the same tag.</p>
<p>Args:
  inputs: A list of <code>string</code> <code>Tensor</code> objects containing serialized <code>Summary</code>
    protocol buffers.
  collections: Optional list of graph collections keys. The new summary op is
    added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer resulting from the merging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.merge_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.merge_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.meshgrid">
    <p>def <span class="ident">meshgrid</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.meshgrid(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.meshgrid</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.meshgrid(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.meshgrid(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.meshgrid</strong></p>
<div class="codehilite"><pre><span></span>Broadcasts parameters for evaluation on an N-D grid.
</pre></div>


<p>Given N one-dimensional coordinate arrays <code>*args</code>, returns a list <code>outputs</code>
of N-D coordinate arrays for evaluating expressions on an N-D grid.</p>
<p>Notes:</p>
<p><code>meshgrid</code> supports cartesian ('xy') and matrix ('ij') indexing conventions.
When the <code>indexing</code> argument is set to 'xy' (the default), the broadcasting
instructions for the first two dimensions are swapped.</p>
<p>Examples:</p>
<p>Calling <code>X, Y = meshgrid(x, y)</code> with the tensors</p>
<p><code>prettyprint
  x = [1, 2, 3]
  y = [4, 5, 6]</code></p>
<p>results in</p>
<p><code>prettyprint
  X = [[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]]
  Y = [[4, 5, 6],
       [4, 5, 6],
       [4, 5, 6]]</code></p>
<p>Args:
  *args: <code>Tensor</code>s with rank 1
  indexing: Either 'xy' or 'ij' (optional, default: 'xy')
  name: A name for the operation (optional).</p>
<p>Returns:
  outputs: A list of N <code>Tensor</code>s with rank N</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.meshgrid', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.meshgrid" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner">
    <p>def <span class="ident">min_max_variable_partitioner</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.min_max_variable_partitioner(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.min_max_variable_partitioner</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.min_max_variable_partitioner(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.min_max_variable_partitioner(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.min_max_variable_partitioner</strong></p>
<div class="codehilite"><pre><span></span>Partitioner to allocate minimum size per slice.
</pre></div>


<p>Returns a partitioner that partitions the variable of given shape and dtype
such that each partition has a minimum of <code>min_slice_size</code> slice of the
variable. The maximum number of such partitions (upper bound) is given by
<code>max_partitions</code>.</p>
<p>Args:
  max_partitions: Upper bound on the number of partitions. Defaults to 1.
  axis: Axis along which to partition the variable. Defaults to 0.
  min_slice_size: Minimum size of the variable slice per partition. Defaults
    to 256K.
  bytes_per_string_element: If the <code>Variable</code> is of type string, this provides
    an estimate of how large each scalar in the <code>Variable</code> is.</p>
<p>Returns:
  A partition function usable as the <code>partitioner</code> argument to
  <code>variable_scope</code>, <code>get_variable</code>, and <code>get_partitioned_variable_list</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.minimize">
    <p>def <span class="ident">minimize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.minimize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.minimize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.minimize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.minimize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tb.minimize</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.minimize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.minimize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.minimum">
    <p>def <span class="ident">minimum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.minimum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.minimum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.minimum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.minimum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.minimum</strong></p>
<div class="codehilite"><pre><span></span>Returns the min of x and y (i.e. x &lt; y ? x : y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Minimum</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.minimum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.minimum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.mod">
    <p>def <span class="ident">mod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.mod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.mod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.mod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.mod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.mod</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise remainder of division.
</pre></div>


<p><em>NOTE</em>: <code>Mod</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>, <code>float32</code>, <code>float64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.mod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.mod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.model_variables">
    <p>def <span class="ident">model_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.model_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.model_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.model_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.model_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.model_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables in the MODEL_VARIABLES collection.
</pre></div>


<p>Returns:
  A list of local Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.model_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.model_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moments">
    <p>def <span class="ident">moments</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.moments(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.moments(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of `x`.
</pre></div>


<p>The mean and variance are calculated by aggregating the contents of <code>x</code>
across <code>axes</code>.  If <code>x</code> is 1-D and <code>axes = [0]</code> this is just the mean
and variance of a vector.</p>
<p>When using these moments for batch normalization (see
<code>tf.nn.batch_normalization</code>):
  * for so-called "global normalization", used with convolutional filters with
    shape <code>[batch, height, width, depth]</code>, pass <code>axes=[0, 1, 2]</code>.
  * for simple batch normalization pass <code>axes=[0]</code> (batch only).</p>
<p>Args:
  x: A <code>Tensor</code>.
  axes: array of ints.  Axes along which to compute mean and
    variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  name: Name used to scope the operations that compute the moments.
  keep_dims: produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moments', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moments" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moments_conv2d_layer">
    <p>def <span class="ident">moments_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.moments_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.moments_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.moments`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moments_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moments_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moments_layer">
    <p>def <span class="ident">moments_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.moments_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.moments_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.moments`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moments_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moments_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moving_average_variables">
    <p>def <span class="ident">moving_average_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.moving_average_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.moving_average_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.moving_average_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.moving_average_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.moving_average_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables that maintain their moving averages.
</pre></div>


<p>If an <code>ExponentialMovingAverage</code> object is created and the <code>apply()</code>
method is called on a list of variables, these variables will
be added to the <code>GraphKeys.MOVING_AVERAGE_VARIABLES</code> collection.
This convenience function returns the contents of that collection.</p>
<p>Returns:
  A list of Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moving_average_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moving_average_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.mul">
    <p>def <span class="ident">mul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.mul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.mul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.mul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.mul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.mul</strong></p>
<div class="codehilite"><pre><span></span>Returns x * y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Mul</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.mul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.mul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.multinomial">
    <p>def <span class="ident">multinomial</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.multinomial(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.multinomial</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.multinomial(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.multinomial(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.multinomial</strong></p>
<div class="codehilite"><pre><span></span>Draws samples from a multinomial distribution.
</pre></div>


<p>Example:</p>
<p>```python</p>
<h1>samples has shape [1, 5], where each value is either 0 or 1 with equal</h1>
<h1>probability.</h1>
<p>samples = tf.multinomial(tf.log([[10., 10.]]), 5)
```</p>
<p>Args:
  logits: 2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice
    <code>[i, :]</code> represents the unnormalized log probabilities for all classes.
  num_samples: 0-D.  Number of independent samples to draw for each row slice.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: Optional name for the operation.</p>
<p>Returns:
  The drawn samples of shape <code>[batch_size, num_samples]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.multinomial', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.multinomial" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.name_scope">
    <p>def <span class="ident">name_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.name_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.name_scope</code>. 
However, a partial with the arguments is returned which expects any argument <code>x</code> and complete ignores it, such that</p>
<div class="codehilite"><pre><span></span>tensorflow.name_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.name_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.name_scope</strong></p>
<div class="codehilite"><pre><span></span>Returns a context manager for use when defining a Python op.
</pre></div>


<p>This context manager validates that the given <code>values</code> are from the
same graph, makes that graph the default graph, and pushes a
name scope in that graph (see
<a href="../../api_docs/python/framework.md#Graph.name_scope"><code>Graph.name_scope()</code></a>
for more details on that).</p>
<p>For example, to define a new Python op called <code>my_op</code>:</p>
<p><code>python
def my_op(a, b, c, name=None):
  with tf.name_scope(name, "MyOp", [a, b, c]) as scope:
    a = tf.convert_to_tensor(a, name="a")
    b = tf.convert_to_tensor(b, name="b")
    c = tf.convert_to_tensor(c, name="c")
    # Define some computation that uses `a`, `b`, and `c`.
    return foo_op(..., name=scope)</code></p>
<p>Args:
  name: The name argument that is passed to the op function.
  default_name: The default name to use if the <code>name</code> argument is <code>None</code>.
  values: The list of <code>Tensor</code> arguments that are passed to the op function.</p>
<p>Returns:
  A context manager for use in defining Python ops. Yields the name scope.</p>
<p>Raises:
  ValueError: if neither <code>name</code> nor <code>default_name</code> is provided
    but <code>values</code> are.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.name_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.name_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.nce_loss">
    <p>def <span class="ident">nce_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.nce_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.nce_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.nce_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.nce_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.nce_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the noise-contrastive estimation training loss.
</pre></div>


<p>See [Noise-contrastive estimation: A new estimation principle for
unnormalized statistical models]
(http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf).
Also see our [Candidate Sampling Algorithms Reference]
(../../extras/candidate_sampling.pdf)</p>
<p>Note: By default this uses a log-uniform (Zipfian) distribution for sampling,
so your labels must be sorted in order of decreasing frequency to achieve
good results.  For more details, see
<a href="#log_uniform_candidate_sampler">log_uniform_candidate_sampler</a>.</p>
<p>Note: In the case where <code>num_true</code> &gt; 1, we assign to each target class
the target probability 1 / <code>num_true</code> so that the target probabilities
sum to 1 per-example.</p>
<p>Note: It would be useful to allow a variable number of target classes per
example.  We hope to provide this functionality in a future release.
For now, if you have a variable number of target classes, you can pad them
out to a constant number by either repeating them or by padding
with an otherwise unused class.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-partitioned) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  Whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  If set to
      <code>True</code>, this is a "Sampled Logistic" loss instead of NCE, and we are
      learning to generate log-odds instead of log probabilities.  See
      our [Candidate Sampling Algorithms Reference]
      (../../extras/candidate_sampling.pdf).
      Default is False.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example NCE losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.nce_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.nce_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer">
    <p>def <span class="ident">nce_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.nce_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.nce_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.nce_loss`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.nce_loss_layer">
    <p>def <span class="ident">nce_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.nce_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.nce_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.nce_loss`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.nce_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.nce_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.neg">
    <p>def <span class="ident">neg</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.neg(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.neg</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.neg(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.neg(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.neg</strong></p>
<div class="codehilite"><pre><span></span>Computes numerical negative value element-wise.
</pre></div>


<p>I.e., (y = -x).</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.neg', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.neg" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.no_op">
    <p>def <span class="ident">no_op</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.no_op(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.no_op</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.no_op(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.no_op(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.no_op</strong></p>
<div class="codehilite"><pre><span></span>Does nothing. Only useful as a placeholder for control edges.
</pre></div>


<p>Args:
  name: A name for the operation (optional).</p>
<p>Returns:
  The created Operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.no_op', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.no_op" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.no_regularizer">
    <p>def <span class="ident">no_regularizer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.no_regularizer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.no_regularizer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.no_regularizer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.no_regularizer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.no_regularizer</strong></p>
<div class="codehilite"><pre><span></span>Use this function to prevent regularization of variables.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.no_regularizer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.no_regularizer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.normalize_moments">
    <p>def <span class="ident">normalize_moments</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.normalize_moments(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.normalize_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.normalize_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.normalize_moments(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.normalize_moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of based on the sufficient statistics.
</pre></div>


<p>Args:
  counts: A <code>Tensor</code> containing a the total count of the data (one value).
  mean_ss: A <code>Tensor</code> containing the mean sufficient statistics: the (possibly
    shifted) sum of the elements to average over.
  variance_ss: A <code>Tensor</code> containing the variance sufficient statistics: the
    (possibly shifted) squared sum of the data to compute the variance over.
  shift: A <code>Tensor</code> containing the value by which the data is shifted for
    numerical stability, or <code>None</code> if no shift was performed.
  name: Name used to scope the operations that compute the moments.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.normalize_moments', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.normalize_moments" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer">
    <p>def <span class="ident">normalize_moments_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.normalize_moments_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.normalize_moments_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.normalize_moments`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.normalize_moments_layer">
    <p>def <span class="ident">normalize_moments_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.normalize_moments_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.normalize_moments_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.normalize_moments`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.normalize_moments_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.normalize_moments_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.not_equal">
    <p>def <span class="ident">not_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.not_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.not_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.not_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.not_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.not_equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x != y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>NotEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>quint8</code>, <code>qint8</code>, <code>qint32</code>, <code>string</code>, <code>bool</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.not_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.not_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.one_hot">
    <p>def <span class="ident">one_hot</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.one_hot(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.one_hot</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.one_hot(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.one_hot(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.one_hot</strong></p>
<div class="codehilite"><pre><span></span>Returns a one-hot tensor.
</pre></div>


<p>The locations represented by indices in <code>indices</code> take value <code>on_value</code>,
while all other locations take value <code>off_value</code>.</p>
<p><code>on_value</code> and <code>off_value</code> must have matching data types. If <code>dtype</code> is also
provided, they must be the same data type as specified by <code>dtype</code>.</p>
<p>If <code>on_value</code> is not provided, it will default to the value <code>1</code> with type
<code>dtype</code></p>
<p>If <code>off_value</code> is not provided, it will default to the value <code>0</code> with type
<code>dtype</code></p>
<p>If the input <code>indices</code> is rank <code>N</code>, the output will have rank <code>N+1</code>. The
new axis is created at dimension <code>axis</code> (default: the new axis is appended
at the end).</p>
<p>If <code>indices</code> is a scalar the output shape will be a vector of length <code>depth</code></p>
<p>If <code>indices</code> is a vector of length <code>features</code>, the output shape will be:
<code>features x depth if axis == -1
  depth x features if axis == 0</code></p>
<p>If <code>indices</code> is a matrix (batch) with shape <code>[batch, features]</code>, the output
shape will be:
<code>batch x features x depth if axis == -1
  batch x depth x features if axis == 1
  depth x batch x features if axis == 0</code></p>
<p>If <code>dtype</code> is not provided, it will attempt to assume the data type of
<code>on_value</code> or <code>off_value</code>, if one or both are passed in. If none of
<code>on_value</code>, <code>off_value</code>, or <code>dtype</code> are provided, <code>dtype</code> will default to the
value <code>tf.float32</code></p>
<p>Note: If a non-numeric data type output is desired (tf.string, tf.bool, etc.),
both <code>on_value</code> and <code>off_value</code> <em>must</em> be provided to <code>one_hot</code></p>
<h1>Examples</h1>
<p>Suppose that</p>
<p><code>indices = [0, 2, -1, 1]
  depth = 3
  on_value = 5.0
  off_value = 0.0
  axis = -1</code></p>
<p>Then output is <code>[4 x 3]</code>:</p>
<p><code>output =
  [5.0 0.0 0.0]  // one_hot(0)
  [0.0 0.0 5.0]  // one_hot(2)
  [0.0 0.0 0.0]  // one_hot(-1)
  [0.0 5.0 0.0]  // one_hot(1)</code></p>
<p>Suppose that</p>
<p><code>indices = [[0, 2], [1, -1]]
  depth = 3
  on_value = 1.0
  off_value = 0.0
  axis = -1</code></p>
<p>Then output is <code>[2 x 2 x 3]</code>:</p>
<p><code>output =
  [
    [1.0, 0.0, 0.0]  // one_hot(0)
    [0.0, 0.0, 1.0]  // one_hot(2)
  ][
    [0.0, 1.0, 0.0]  // one_hot(1)
    [0.0, 0.0, 0.0]  // one_hot(-1)
  ]</code></p>
<p>Using default values for <code>on_value</code> and <code>off_value</code>:</p>
<p><code>indices = [0, 1, 2]
  depth = 3</code></p>
<p>The output will be</p>
<p><code>output =
  [[1., 0., 0.],
   [0., 1., 0.],
   [0., 0., 1.]]</code></p>
<p>Args:
  indices: A <code>Tensor</code> of indices.
  depth: A scalar defining the depth of the one hot dimension.
  on_value: A scalar defining the value to fill in output when <code>indices[j]
    = i</code>. (default: 1)
  off_value: A scalar defining the value to fill in output when <code>indices[j]
    != i</code>. (default: 0)
  axis: The axis to fill (default: -1, a new inner-most axis).
  dtype: The data type of the output tensor.</p>
<p>Returns:
  output: The one-hot tensor.</p>
<p>Raises:
  TypeError: If dtype of either <code>on_value</code> or <code>off_value</code> don't match <code>dtype</code>
  TypeError: If dtype of <code>on_value</code> and <code>off_value</code> don't match one another</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.one_hot', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.one_hot" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ones">
    <p>def <span class="ident">ones</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ones(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ones</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ones(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ones(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ones</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to 1.
</pre></div>


<p>This operation returns a tensor of type <code>dtype</code> with shape <code>shape</code> and all
elements set to 1.</p>
<p>For example:</p>
<p><code>python
tf.ones([2, 3], tf.int32) ==&gt; [[1, 1, 1], [1, 1, 1]]</code></p>
<p>Args:
  shape: Either a list of integers, or a 1-D <code>Tensor</code> of type <code>int32</code>.
  dtype: The type of an element in the resulting <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ones', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ones" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ones_initializer">
    <p>def <span class="ident">ones_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ones_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ones_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ones_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ones_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ones_initializer</strong></p>
<div class="codehilite"><pre><span></span>An adaptor for ones() to match the Initializer spec.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ones_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ones_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ones_like">
    <p>def <span class="ident">ones_like</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.ones_like(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ones_like</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ones_like(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.ones_like(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ones_like</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to 1.
</pre></div>


<p>Given a single tensor (<code>tensor</code>), this operation returns a tensor of the same
type and shape as <code>tensor</code> with all elements set to 1. Optionally, you can
specify a new type (<code>dtype</code>) for the returned tensor.</p>
<p>For example:</p>
<p>```python</p>
<h1>'tensor' is [[1, 2, 3], [4, 5, 6]]</h1>
<p>tf.ones_like(tensor) ==&gt; [[1, 1, 1], [1, 1, 1]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  dtype: A type for the returned <code>Tensor</code>. Must be <code>float32</code>, <code>float64</code>,
    <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>complex64</code>, <code>complex128</code> or
    <code>bool</code>.
  name: A name for the operation (optional).
  optimize: if true, attempt to statically determine the shape of 'tensor'
  and encode it as a constant.</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ones_like', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ones_like" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.op_scope">
    <p>def <span class="ident">op_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.op_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.op_scope</code>. 
However, a partial with the arguments is returned which expects any argument <code>x</code> and complete ignores it, such that</p>
<div class="codehilite"><pre><span></span>tensorflow.op_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.op_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.op_scope</strong></p>
<div class="codehilite"><pre><span></span>DEPRECATED. Same as name_scope above, just different argument order.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.op_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.op_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pack">
    <p>def <span class="ident">pack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.pack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.pack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.pack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.pack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.pack</strong></p>
<div class="codehilite"><pre><span></span>Packs a list of rank-`R` tensors into one rank-`(R+1)` tensor.
</pre></div>


<p>Packs the list of tensors in <code>values</code> into a tensor with rank one higher than
each tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.
Given a list of length <code>N</code> of tensors of shape <code>(A, B, C)</code>;</p>
<p>if <code>axis == 0</code> then the <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>.
if <code>axis == 1</code> then the <code>output</code> tensor will have the shape <code>(A, N, B, C)</code>.
Etc.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'x' is [1, 4]</h1>
<h1>'y' is [2, 5]</h1>
<h1>'z' is [3, 6]</h1>
<p>pack([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
pack([x, y, z], axis=1) =&gt; [[1, 2, 3], [4, 5, 6]]
```</p>
<p>This is the opposite of unpack.  The numpy equivalent is</p>
<div class="codehilite"><pre><span></span>tf.pack([x, y, z]) = np.asarray([x, y, z])
</pre></div>


<p>Args:
  values: A list of <code>Tensor</code> objects with the same shape and type.
  axis: An <code>int</code>. The axis to pack along. Defaults to the first dimension.
    Supports negative indexes.
  name: A name for this operation (optional).</p>
<p>Returns:
  output: A packed <code>Tensor</code> with the same type as <code>values</code>.</p>
<p>Raises:
  ValueError: If <code>axis</code> is out of the range [-(R+1), R+1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pad">
    <p>def <span class="ident">pad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.pad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.pad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.pad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.pad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.pad</strong></p>
<div class="codehilite"><pre><span></span>Pads a tensor.
</pre></div>


<p>This operation pads a <code>tensor</code> according to the <code>paddings</code> you specify.
<code>paddings</code> is an integer tensor with shape <code>[n, 2]</code>, where n is the rank of
<code>tensor</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates how
many values to add before the contents of <code>tensor</code> in that dimension, and
<code>paddings[D, 1]</code> indicates how many values to add after the contents of
<code>tensor</code> in that dimension. If <code>mode</code> is "REFLECT" then both <code>paddings[D, 0]</code>
and <code>paddings[D, 1]</code> must be no greater than <code>tensor.dim_size(D) - 1</code>. If
<code>mode</code> is "SYMMETRIC" then both <code>paddings[D, 0]</code> and <code>paddings[D, 1]</code> must be
no greater than <code>tensor.dim_size(D)</code>.</p>
<p>The padded size of each dimension D of the output is:</p>
<p><code>paddings[D, 0] + tensor.dim_size(D) + paddings[D, 1]</code></p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[1, 2, 3], [4, 5, 6]].</h1>
<h1>'paddings' is [[1, 1,], [2, 2]].</h1>
<h1>rank of 't' is 2.</h1>
<p>pad(t, paddings, "CONSTANT") ==&gt; [[0, 0, 0, 0, 0, 0, 0],
                                  [0, 0, 1, 2, 3, 0, 0],
                                  [0, 0, 4, 5, 6, 0, 0],
                                  [0, 0, 0, 0, 0, 0, 0]]</p>
<p>pad(t, paddings, "REFLECT") ==&gt; [[6, 5, 4, 5, 6, 5, 4],
                                 [3, 2, 1, 2, 3, 2, 1],
                                 [6, 5, 4, 5, 6, 5, 4],
                                 [3, 2, 1, 2, 3, 2, 1]]</p>
<p>pad(t, paddings, "SYMMETRIC") ==&gt; [[2, 1, 1, 2, 3, 3, 2],
                                   [2, 1, 1, 2, 3, 3, 2],
                                   [5, 4, 4, 5, 6, 6, 5],
                                   [5, 4, 4, 5, 6, 6, 5]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
  mode: One of "CONSTANT", "REFLECT", or "SYMMETRIC".
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>.</p>
<p>Raises:
  ValueError: When mode is not one of "CONSTANT", "REFLECT", or "SYMMETRIC".</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_example">
    <p>def <span class="ident">parse_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.parse_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.parse_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_example</strong></p>
<div class="codehilite"><pre><span></span>Parses `Example` protos into a `dict` of tensors.
</pre></div>


<p>Parses a number of serialized [<code>Example</code>]
(https://www.tensorflow.org/code/tensorflow/core/example/example.proto)
protos given in <code>serialized</code>.</p>
<p><code>example_names</code> may contain descriptive names for the corresponding serialized
protos. These may be useful for debugging purposes, but they have no effect on
the output. If not <code>None</code>, <code>example_names</code> must be the same length as <code>serialized</code>.</p>
<p>This op parses serialized examples into a dictionary mapping keys to <code>Tensor</code>
and <code>SparseTensor</code> objects. <code>features</code> is a dict from keys to <code>VarLenFeature</code>
and <code>FixedLenFeature</code> objects. Each <code>VarLenFeature</code> is mapped to a
<code>SparseTensor</code>, and each <code>FixedLenFeature</code> is mapped to a <code>Tensor</code>.</p>
<p>Each <code>VarLenFeature</code> maps to a <code>SparseTensor</code> of the specified type
representing a ragged matrix. Its indices are <code>[batch, index]</code> where <code>batch</code>
is the batch entry the value is from in <code>serialized</code>, and <code>index</code> is the
value's index in the list of values associated with that feature and example.</p>
<p>Each <code>FixedLenFeature</code> <code>df</code> maps to a <code>Tensor</code> of the specified type (or
<code>tf.float32</code> if not specified) and shape <code>(serialized.size(),) + df.shape</code>.</p>
<p><code>FixedLenFeature</code> entries with a <code>default_value</code> are optional. With no default
value, we will fail if that <code>Feature</code> is missing from any example in
<code>serialized</code>.</p>
<p>Examples:</p>
<p>For example, if one expects a <code>tf.float32</code> sparse feature <code>ft</code> and three
serialized <code>Example</code>s are provided:</p>
<p><code>serialized = [
  features
    { feature { key: "ft" value { float_list { value: [1.0, 2.0] } } } },
  features
    { feature []},
  features
    { feature { key: "ft" value { float_list { value: [3.0] } } }
]</code></p>
<p>then the output will look like:</p>
<p><code>{"ft": SparseTensor(indices=[[0, 0], [0, 1], [2, 0]],
                    values=[1.0, 2.0, 3.0],
                    shape=(3, 2)) }</code></p>
<p>Given two <code>Example</code> input protos in <code>serialized</code>:</p>
<p><code>[
  features {
    feature { key: "kw" value { bytes_list { value: [ "knit", "big" ] } } }
    feature { key: "gps" value { float_list { value: [] } } }
  },
  features {
    feature { key: "kw" value { bytes_list { value: [ "emmy" ] } } }
    feature { key: "dank" value { int64_list { value: [ 42 ] } } }
    feature { key: "gps" value { } }
  }
]</code></p>
<p>And arguments</p>
<p><code>example_names: ["input0", "input1"],
features: {
    "kw": VarLenFeature(tf.string),
    "dank": VarLenFeature(tf.int64),
    "gps": VarLenFeature(tf.float32),
}</code></p>
<p>Then the output is a dictionary:</p>
<p><code>python
{
  "kw": SparseTensor(
      indices=[[0, 0], [0, 1], [1, 0]],
      values=["knit", "big", "emmy"]
      shape=[2, 2]),
  "dank": SparseTensor(
      indices=[[1, 0]],
      values=[42],
      shape=[2, 1]),
  "gps": SparseTensor(
      indices=[],
      values=[],
      shape=[2, 0]),
}</code></p>
<p>For dense results in two serialized <code>Example</code>s:</p>
<p><code>[
  features {
    feature { key: "age" value { int64_list { value: [ 0 ] } } }
    feature { key: "gender" value { bytes_list { value: [ "f" ] } } }
   },
   features {
    feature { key: "age" value { int64_list { value: [] } } }
    feature { key: "gender" value { bytes_list { value: [ "f" ] } } }
  }
]</code></p>
<p>We can use arguments:</p>
<p><code>example_names: ["input0", "input1"],
features: {
    "age": FixedLenFeature([], dtype=tf.int64, default_value=-1),
    "gender": FixedLenFeature([], dtype=tf.string),
}</code></p>
<p>And the expected output is:</p>
<p><code>python
{
  "age": [[0], [-1]],
  "gender": [["f"], ["f"]],
}</code></p>
<p>Args:
  serialized: A vector (1-D Tensor) of strings, a batch of binary
    serialized <code>Example</code> protos.
  features: A <code>dict</code> mapping feature keys to <code>FixedLenFeature</code> or
    <code>VarLenFeature</code> values.
  name: A name for this operation (optional).
  example_names: A vector (1-D Tensor) of strings (optional), the names of
    the serialized protos in the batch.</p>
<p>Returns:
  A <code>dict</code> mapping feature keys to <code>Tensor</code> and <code>SparseTensor</code> values.</p>
<p>Raises:
  ValueError: if any feature is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_single_example">
    <p>def <span class="ident">parse_single_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.parse_single_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_single_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_single_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.parse_single_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_single_example</strong></p>
<div class="codehilite"><pre><span></span>Parses a single `Example` proto.
</pre></div>


<p>Similar to <code>parse_example</code>, except:</p>
<p>For dense tensors, the returned <code>Tensor</code> is identical to the output of
<code>parse_example</code>, except there is no batch dimension, the output shape is the
same as the shape given in <code>dense_shape</code>.</p>
<p>For <code>SparseTensor</code>s, the first (batch) column of the indices matrix is removed
(the indices matrix is a column vector), the values vector is unchanged, and
the first (<code>batch_size</code>) entry of the shape vector is removed (it is now a
single element vector).</p>
<p>Args:
  serialized: A scalar string Tensor, a single serialized Example.
    See <code>_parse_single_example_raw</code> documentation for more details.
  features: A <code>dict</code> mapping feature keys to <code>FixedLenFeature</code> or
    <code>VarLenFeature</code> values.
  name: A name for this operation (optional).
  example_names: (Optional) A scalar string Tensor, the associated name.
    See <code>_parse_single_example_raw</code> documentation for more details.</p>
<p>Returns:
  A <code>dict</code> mapping feature keys to <code>Tensor</code> and <code>SparseTensor</code> values.</p>
<p>Raises:
  ValueError: if any feature is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_single_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_single_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_single_sequence_example">
    <p>def <span class="ident">parse_single_sequence_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.parse_single_sequence_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_single_sequence_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_single_sequence_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.parse_single_sequence_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_single_sequence_example</strong></p>
<div class="codehilite"><pre><span></span>Parses a single `SequenceExample` proto.
</pre></div>


<p>Parses a single serialized [<code>SequenceExample</code>]
(https://www.tensorflow.org/code/tensorflow/core/example/example.proto)
proto given in <code>serialized</code>.</p>
<p>This op parses a serialize sequence example into a tuple of dictionaries
mapping keys to <code>Tensor</code> and <code>SparseTensor</code> objects respectively.
The first dictionary contains mappings for keys appearing in
<code>context_features</code>, and the second dictionary contains mappings for keys
appearing in <code>sequence_features</code>.</p>
<p>At least one of <code>context_features</code> and <code>sequence_features</code> must be provided
and non-empty.</p>
<p>The <code>context_features</code> keys are associated with a <code>SequenceExample</code> as a
whole, independent of time / frame.  In contrast, the <code>sequence_features</code> keys
provide a way to access variable-length data within the <code>FeatureList</code> section
of the <code>SequenceExample</code> proto.  While the shapes of <code>context_features</code> values
are fixed with respect to frame, the frame dimension (the first dimension)
of <code>sequence_features</code> values may vary between <code>SequenceExample</code> protos,
and even between <code>feature_list</code> keys within the same <code>SequenceExample</code>.</p>
<p><code>context_features</code> contains <code>VarLenFeature</code> and <code>FixedLenFeature</code> objects.
Each <code>VarLenFeature</code> is mapped to a <code>SparseTensor</code>, and each <code>FixedLenFeature</code>
is mapped to a <code>Tensor</code>, of the specified type, shape, and default value.</p>
<p><code>sequence_features</code> contains <code>VarLenFeature</code> and <code>FixedLenSequenceFeature</code>
objects. Each <code>VarLenFeature</code> is mapped to a <code>SparseTensor</code>, and each
<code>FixedLenSequenceFeature</code> is mapped to a <code>Tensor</code>, each of the specified type.
The shape will be <code>(T,) + df.shape</code> for <code>FixedLenSequenceFeature</code> <code>df</code>, where
<code>T</code> is the length of the associated <code>FeatureList</code> in the <code>SequenceExample</code>.
For instance, <code>FixedLenSequenceFeature([])</code> yields a scalar 1-D <code>Tensor</code> of
static shape <code>[None]</code> and dynamic shape <code>[T]</code>, while
<code>FixedLenSequenceFeature([k])</code> (for <code>int k &gt;= 1</code>) yields a 2-D matrix <code>Tensor</code>
of static shape <code>[None, k]</code> and dynamic shape <code>[T, k]</code>.</p>
<p>Each <code>SparseTensor</code> corresponding to <code>sequence_features</code> represents a ragged
vector.  Its indices are <code>[time, index]</code>, where <code>time</code> is the <code>FeatureList</code>
entry and <code>index</code> is the value's index in the list of values associated with
that time.</p>
<p><code>FixedLenFeature</code> entries with a <code>default_value</code> and <code>FixedLenSequenceFeature</code>
entries with <code>allow_missing=True</code> are optional; otherwise, we will fail if
that <code>Feature</code> or <code>FeatureList</code> is missing from any example in <code>serialized</code>.</p>
<p><code>example_name</code> may contain a descriptive name for the corresponding serialized
proto. This may be useful for debugging purposes, but it has no effect on the
output. If not <code>None</code>, <code>example_name</code> must be a scalar.</p>
<p>Args:
  serialized: A scalar (0-D Tensor) of type string, a single binary
    serialized <code>SequenceExample</code> proto.
  context_features: A <code>dict</code> mapping feature keys to <code>FixedLenFeature</code> or
    <code>VarLenFeature</code> values. These features are associated with a
    <code>SequenceExample</code> as a whole.
  sequence_features: A <code>dict</code> mapping feature keys to
    <code>FixedLenSequenceFeature</code> or <code>VarLenFeature</code> values. These features are
    associated with data within the <code>FeatureList</code> section of the
    <code>SequenceExample</code> proto.
  example_name: A scalar (0-D Tensor) of strings (optional), the name of
    the serialized proto.
  name: A name for this operation (optional).</p>
<p>Returns:
  A tuple of two <code>dict</code>s, each mapping keys to <code>Tensor</code>s and <code>SparseTensor</code>s.
  The first dict contains the context key/values.
  The second dict contains the feature_list key/values.</p>
<p>Raises:
  ValueError: if any feature is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_single_sequence_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_single_sequence_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_tensor">
    <p>def <span class="ident">parse_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.parse_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.parse_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_tensor</strong></p>
<div class="codehilite"><pre><span></span>Transforms a serialized tensorflow.TensorProto proto into a Tensor.
</pre></div>


<p>Args:
  serialized: A <code>Tensor</code> of type <code>string</code>.
    A scalar string containing a serialized TensorProto proto.
  out_type: A <code>tf.DType</code>.
    The type of the serialized tensor.  The provided type must match the
    type of the serialized tensor and no implicit conversion will take place.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>. A Tensor of type <code>out_type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.placeholder">
    <p>def <span class="ident">placeholder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.placeholder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.placeholder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.placeholder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.placeholder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.placeholder</strong></p>
<div class="codehilite"><pre><span></span>Inserts a placeholder for a tensor that will be always fed.
</pre></div>


<p><strong>Important</strong>: This tensor will produce an error if evaluated. Its value must
be fed using the <code>feed_dict</code> optional argument to <code>Session.run()</code>,
<code>Tensor.eval()</code>, or <code>Operation.run()</code>.</p>
<p>For example:</p>
<p>```python
x = tf.placeholder(tf.float32, shape=(1024, 1024))
y = tf.matmul(x, x)</p>
<p>with tf.Session() as sess:
  print(sess.run(y))  # ERROR: will fail because x was not fed.</p>
<p>rand_array = np.random.rand(1024, 1024)
  print(sess.run(y, feed_dict={x: rand_array}))  # Will succeed.
```</p>
<p>Args:
  dtype: The type of elements in the tensor to be fed.
  shape: The shape of the tensor to be fed (optional). If the shape is not
    specified, you can feed a tensor of any shape.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> that may be used as a handle for feeding a value, but not
  evaluated directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.placeholder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.placeholder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.placeholder_with_default">
    <p>def <span class="ident">placeholder_with_default</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.placeholder_with_default(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.placeholder_with_default</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.placeholder_with_default(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.placeholder_with_default(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.placeholder_with_default</strong></p>
<div class="codehilite"><pre><span></span>A placeholder op that passes though `input` when its output is not fed.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. The default value to produce when <code>output</code> is not fed.
  shape: A <code>tf.TensorShape</code> or list of <code>ints</code>.
    The (possibly partial) shape of the tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  A placeholder tensor that defaults to <code>input</code> if it is not fed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.placeholder_with_default', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.placeholder_with_default" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.polygamma">
    <p>def <span class="ident">polygamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.polygamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.polygamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.polygamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.polygamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.polygamma</strong></p>
<div class="codehilite"><pre><span></span>Compute the polygamma function \\(\psi^{(n)}(x)\\).
</pre></div>


<p>The polygamma function is defined as:</p>
<p><code>\psi^{(n)}(x) = \frac{d^n}{dx^n} \psi(x)</code>
where \(\psi(x)\) is the digamma function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.polygamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.polygamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.polynomial_layer">
    <p>def <span class="ident">polynomial_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.polynomial_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tb.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.polynomial_layer(*args, **kwargs)(x1)
</pre></div>


<p>However, it uses an activation function of the form
<code>y(i) = z(i)^(i+1)</code>
where <code>z = w*x + b</code></p>
<p><strong>tb.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.polynomial_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.polynomial_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pow">
    <p>def <span class="ident">pow</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.pow(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.pow</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.pow(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.pow(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.pow</strong></p>
<div class="codehilite"><pre><span></span>Computes the power of one value to another.
</pre></div>


<p>Given a tensor <code>x</code> and a tensor <code>y</code>, this operation computes \(x^y\) for
corresponding elements in <code>x</code> and <code>y</code>. For example:</p>
<p>```</p>
<h1>tensor 'x' is [[2, 2], [3, 3]]</h1>
<h1>tensor 'y' is [[8, 16], [2, 3]]</h1>
<p>tf.pow(x, y) ==&gt; [[256, 65536], [9, 27]]
```</p>
<p>Args:
  x: A <code>Tensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>,
   or <code>complex128</code>.
  y: A <code>Tensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>,
   or <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pow', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pow" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.py_func">
    <p>def <span class="ident">py_func</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.py_func(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.py_func</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.py_func(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.py_func(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.py_func</strong></p>
<div class="codehilite"><pre><span></span>Wraps a python function and uses it as a tensorflow op.
</pre></div>


<p>Given a python function <code>func</code>, which takes numpy arrays as its
inputs and returns numpy arrays as its outputs. E.g.,</p>
<p><code>python
def my_func(x):
  # x will be a numpy array with the contents of the placeholder below
  return np.sinh(x)
inp = tf.placeholder(tf.float32, [...])
y = py_func(my_func, [inp], [tf.float32])</code></p>
<p>The above snippet constructs a tf graph which invokes a numpy
sinh(x) as an op in the graph.</p>
<p>Args:
  func: A python function.
  inp: A list of <code>Tensor</code>.
  Tout: A list or tuple of tensorflow data types or a single tensorflow data
        type if there is only one, indicating what <code>func</code> returns.
  stateful: A boolean indicating whether the function should be considered
            stateful or stateless. I.e. whether it, given the same input, will
            return the same output and at the same time does not change state
            in an observable way. Optimizations such as common subexpression
            elimination are only possible when operations are stateless.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list of <code>Tensor</code> or a single <code>Tensor</code> which <code>func</code> computes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.py_func', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.py_func" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_crop">
    <p>def <span class="ident">random_crop</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_crop(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_crop</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_crop(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_crop(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_crop</strong></p>
<div class="codehilite"><pre><span></span>Randomly crops a tensor to a given size.
</pre></div>


<p>Slices a shape <code>size</code> portion out of <code>value</code> at a uniformly chosen offset.
Requires <code>value.shape &gt;= size</code>.</p>
<p>If a dimension should not be cropped, pass the full size of that dimension.
For example, RGB images can be cropped with
<code>size = [crop_height, crop_width, 3]</code>.</p>
<p>Args:
  value: Input tensor to crop.
  size: 1-D tensor with size the rank of <code>value</code>.
  seed: Python integer. Used to create a random seed. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).</p>
<p>Returns:
  A cropped tensor of the same rank as <code>value</code> and shape <code>size</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_crop', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_crop" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_gamma">
    <p>def <span class="ident">random_gamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_gamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_gamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_gamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_gamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_gamma</strong></p>
<div class="codehilite"><pre><span></span>Draws `shape` samples from each of the given Gamma distribution(s).
</pre></div>


<p><code>alpha</code> is the shape parameter describing the distribution(s), and <code>beta</code> is
the inverse scale parameter(s).</p>
<p>Example:</p>
<p>samples = tf.random_gamma([10], [0.5, 1.5])
  # samples has shape [10, 2], where each slice [:, 0] and [:, 1] represents
  # the samples drawn from each distribution</p>
<p>samples = tf.random_gamma([7, 5], [0.5, 1.5])
  # samples has shape [7, 5, 2], where each slice [:, :, 0] and [:, :, 1]
  # represents the 7x5 samples drawn from each of the two distributions</p>
<p>samples = tf.random_gamma([30], [[1.],[3.],[5.]], beta=[[3., 4.]])
  # samples has shape [30, 3, 2], with 30 samples each of 3x2 distributions.</p>
<p>Note that for small alpha values, there is a chance you will draw a value of
  exactly 0, which gets worse for lower-precision dtypes, even though zero is
  not in the support of the gamma distribution.</p>
<p>Relevant cdfs (~chance you will draw a exactly-0 value):
  <code>stats.gamma(.01).cdf(np.finfo(np.float16).tiny)
        0.91269738769897879
    stats.gamma(.01).cdf(np.finfo(np.float32).tiny)
        0.41992668622045726
    stats.gamma(.01).cdf(np.finfo(np.float64).tiny)
        0.00084322740680686662
    stats.gamma(.35).cdf(np.finfo(np.float16).tiny)
        0.037583276135263931
    stats.gamma(.35).cdf(np.finfo(np.float32).tiny)
        5.9514895726818067e-14
    stats.gamma(.35).cdf(np.finfo(np.float64).tiny)
        2.3529843400647272e-108</code></p>
<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output samples
    to be drawn per alpha/beta-parameterized distribution.
  alpha: A Tensor or Python value or N-D array of type <code>dtype</code>. <code>alpha</code>
    provides the shape parameter(s) describing the gamma distribution(s) to
    sample. Must be broadcastable with <code>beta</code>.
  beta: A Tensor or Python value or N-D array of type <code>dtype</code>. Defaults to 1.
    <code>beta</code> provides the inverse scale parameter(s) of the gamma
    distribution(s) to sample. Must be broadcastable with <code>alpha</code>.
  dtype: The type of alpha, beta, and the output: <code>float16</code>, <code>float32</code>, or
    <code>float64</code>.
  seed: A Python integer. Used to create a random seed for the distributions.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: Optional name for the operation.</p>
<p>Returns:
  samples: a <code>Tensor</code> of shape <code>tf.concat(shape, tf.shape(alpha + beta))</code> with
    values of type <code>dtype</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_gamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_gamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_normal">
    <p>def <span class="ident">random_normal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_normal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_normal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_normal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_normal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_normal</strong></p>
<div class="codehilite"><pre><span></span>Outputs random values from a normal distribution.
</pre></div>


<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output tensor.
  mean: A 0-D Tensor or Python value of type <code>dtype</code>. The mean of the normal
    distribution.
  stddev: A 0-D Tensor or Python value of type <code>dtype</code>. The standard deviation
    of the normal distribution.
  dtype: The type of the output.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of the specified shape filled with random normal values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_normal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_normal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_normal_initializer">
    <p>def <span class="ident">random_normal_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_normal_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_normal_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_normal_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_normal_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_normal_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors with a normal distribution.
</pre></div>


<p>Args:
  mean: a python scalar or a scalar tensor. Mean of the random values
    to generate.
  stddev: a python scalar or a scalar tensor. Standard deviation of the
    random values to generate.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with a normal distribution.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_normal_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_normal_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_shuffle">
    <p>def <span class="ident">random_shuffle</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_shuffle(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_shuffle</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_shuffle(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_shuffle(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_shuffle</strong></p>
<div class="codehilite"><pre><span></span>Randomly shuffles a tensor along its first dimension.
</pre></div>


<p>The tensor is shuffled along dimension 0, such that each <code>value[j]</code> is mapped
to one and only one <code>output[i]</code>. For example, a mapping that might occur for a
3x2 tensor is:</p>
<p><code>python
[[1, 2],       [[5, 6],
 [3, 4],  ==&gt;   [1, 2],
 [5, 6]]        [3, 4]]</code></p>
<p>Args:
  value: A Tensor to be shuffled.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of same shape and type as <code>value</code>, shuffled along its first
  dimension.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_shuffle', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_shuffle" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_uniform">
    <p>def <span class="ident">random_uniform</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_uniform(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_uniform</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_uniform(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_uniform(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_uniform</strong></p>
<div class="codehilite"><pre><span></span>Outputs random values from a uniform distribution.
</pre></div>


<p>The generated values follow a uniform distribution in the range
<code>[minval, maxval)</code>. The lower bound <code>minval</code> is included in the range, while
the upper bound <code>maxval</code> is excluded.</p>
<p>For floats, the default range is <code>[0, 1)</code>.  For ints, at least <code>maxval</code> must
be specified explicitly.</p>
<p>In the integer case, the random integers are slightly biased unless
<code>maxval - minval</code> is an exact power of two.  The bias is small for values of
<code>maxval - minval</code> significantly smaller than the range of the output (either
<code>2**32</code> or <code>2**64</code>).</p>
<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output tensor.
  minval: A 0-D Tensor or Python value of type <code>dtype</code>. The lower bound on the
    range of random values to generate.  Defaults to 0.
  maxval: A 0-D Tensor or Python value of type <code>dtype</code>. The upper bound on
    the range of random values to generate.  Defaults to 1 if <code>dtype</code> is
    floating point.
  dtype: The type of the output: <code>float32</code>, <code>float64</code>, <code>int32</code>, or <code>int64</code>.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of the specified shape filled with random uniform values.</p>
<p>Raises:
  ValueError: If <code>dtype</code> is integral and <code>maxval</code> is not specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_uniform', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_uniform" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_uniform_initializer">
    <p>def <span class="ident">random_uniform_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.random_uniform_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_uniform_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_uniform_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.random_uniform_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_uniform_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors with a uniform distribution.
</pre></div>


<p>Args:
  minval: A python scalar or a scalar tensor. Lower bound of the range
    of random values to generate.
  maxval: A python scalar or a scalar tensor. Upper bound of the range
    of random values to generate.  Defaults to 1 for float types.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type.</p>
<p>Returns:
  An initializer that generates tensors with a uniform distribution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_uniform_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_uniform_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.range">
    <p>def <span class="ident">range</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.range(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.range</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.range(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.range(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.range</strong></p>
<div class="codehilite"><pre><span></span>Creates a sequence of integers.
</pre></div>


<p>Creates a sequence of integers that begins at <code>start</code> and extends by
increments of <code>delta</code> up to but not including <code>limit</code>.</p>
<p>Like the Python builtin <code>range</code>, <code>start</code> defaults to 0, so that
<code>range(n) = range(0, n)</code>.</p>
<p>For example:</p>
<p>```</p>
<h1>'start' is 3</h1>
<h1>'limit' is 18</h1>
<h1>'delta' is 3</h1>
<p>tf.range(start, limit, delta) ==&gt; [3, 6, 9, 12, 15]</p>
<h1>'limit' is 5</h1>
<p>tf.range(limit) ==&gt; [0, 1, 2, 3, 4]
```</p>
<p>Args:
  start: A 0-D (scalar) of type <code>int32</code>. Acts as first entry in the range if
    <code>limit</code> is not None; otherwise, acts as range limit and first entry
    defaults to 0.
  limit: A 0-D (scalar) of type <code>int32</code>. Upper limit of sequence,
    exclusive. If None, defaults to the value of <code>start</code> while the first
    entry of the range defaults to 0.
  delta: A 0-D <code>Tensor</code> (scalar) of type <code>int32</code>. Number that increments
    <code>start</code>. Defaults to 1.
  name: A name for the operation. Defaults to "range".</p>
<p>Returns:
  An 1-D <code>int32</code> <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.range', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.range" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rank">
    <p>def <span class="ident">rank</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rank(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.rank</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.rank(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.rank(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.rank</strong></p>
<div class="codehilite"><pre><span></span>Returns the rank of a tensor.
</pre></div>


<p>This operation returns an integer representing the rank of <code>input</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1>
<h1>shape of tensor 't' is [2, 2, 3]</h1>
<p>rank(t) ==&gt; 3
```</p>
<p><strong>Note</strong>: The rank of a tensor is not the same as the rank of a matrix. The
rank of a tensor is the number of indices required to uniquely select each
element of the tensor. Rank is also known as "order", "degree", or "ndims."</p>
<p>Args:
  input: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rank', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rank" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.raw_rnn">
    <p>def <span class="ident">raw_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.raw_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.raw_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.raw_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.raw_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.raw_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates an `RNN` specified by RNNCell `cell` and loop function `loop_fn`.
</pre></div>


<p><strong>NOTE: This method is still in testing, and the API may change.</strong></p>
<p>This function is a more primitive version of <code>dynamic_rnn</code> that provides
more direct access to the inputs each iteration.  It also provides more
control over when to start and finish reading the sequence, and
what to emit for the output.</p>
<p>For example, it can be used to implement the dynamic decoder of a seq2seq
model.</p>
<p>Instead of working with <code>Tensor</code> objects, most operations work with
<code>TensorArray</code> objects directly.</p>
<p>The operation of <code>raw_rnn</code>, in pseudo-code, is basically the following:</p>
<p><code>time = tf.constant(0, dtype=tf.int32)
(finished, next_input, initial_state, _, loop_state) = loop_fn(
    time=time, cell_output=None, cell_state=None, loop_state=None)
emit_ta = TensorArray(dynamic_size=True, dtype=initial_state.dtype)
state = initial_state
while not all(finished):
  (output, cell_state) = cell(next_input, state)
  (next_finished, next_input, next_state, emit, loop_state) = loop_fn(
      time=time + 1, cell_output=output, cell_state=cell_state,
      loop_state=loop_state)
  # Emit zeros and copy forward state for minibatch entries that are finished.
  state = tf.select(finished, state, next_state)
  emit = tf.select(finished, tf.zeros_like(emit), emit)
  emit_ta = emit_ta.write(time, emit)
  # If any new minibatch entries are marked as finished, mark these
  finished = tf.logical_or(finished, next_finished)
  time += 1
return (emit_ta, state, loop_state)</code></p>
<p>with the additional properties that output and state may be (possibly nested)
tuples, as determined by <code>cell.output_size</code> and <code>cell.state_size</code>, and
as a result the final <code>state</code> and <code>emit_ta</code> may themselves be tuples.</p>
<p>A simple implementation of <code>dynamic_rnn</code> via <code>raw_rnn</code> looks like this:</p>
<p>```python
inputs = tf.placeholder(shape=(max_time, batch_size, input_depth),
                        dtype=tf.float32)
sequence_length = tf.placeholder(shape=(batch_size,), dtype=tf.int32)
inputs_ta = tf.TensorArray(dtype=tf.float32, size=max_time)
inputs_ta = inputs_ta.unpack(inputs)</p>
<p>cell = tf.nn.rnn_cell.LSTMCell(num_units)</p>
<p>def loop_fn(time, cell_output, cell_state, loop_state):
  emit_output = cell_output  # == None for time == 0
  if cell_output is None:  # time == 0
    next_cell_state = cell.zero_state(batch_size, tf.float32)
  else:
    next_cell_state = cell_state
  elements_finished = (time &gt;= sequence_length)
  finished = tf.reduce_all(elements_finished)
  next_input = tf.cond(
      finished,
      lambda: tf.zeros([batch_size, input_depth], dtype=tf.float32),
      lambda: inputs_ta.read(time))
  next_loop_state = None
  return (elements_finished, next_input, next_cell_state,
          emit_output, next_loop_state)</p>
<p>outputs_ta, final_state, _ = raw_rnn(cell, loop_fn)
outputs = outputs_ta.pack()
```</p>
<p>Args:
  cell: An instance of RNNCell.
  loop_fn: A callable that takes inputs
    <code>(time, cell_output, cell_state, loop_state)</code>
    and returns the tuple
    <code>(finished, next_input, next_cell_state, emit_output, next_loop_state)</code>.
    Here <code>time</code> is an int32 scalar <code>Tensor</code>, <code>cell_output</code> is a
    <code>Tensor</code> or (possibly nested) tuple of tensors as determined by
    <code>cell.output_size</code>, and <code>cell_state</code> is a <code>Tensor</code>
    or (possibly nested) tuple of tensors, as determined by the <code>loop_fn</code>
    on its first call (and should match <code>cell.state_size</code>).
    The outputs are: <code>finished</code>, a boolean <code>Tensor</code> of
    shape <code>[batch_size]</code>, <code>next_input</code>: the next input to feed to <code>cell</code>,
    <code>next_cell_state</code>: the next state to feed to <code>cell</code>,
    and <code>emit_output</code>: the output to store for this iteration.</p>
<div class="codehilite"><pre><span></span>Note that `emit_output` should be a `Tensor` or (possibly nested)
tuple of tensors with shapes and structure matching `cell.output_size`
and `cell_output` above.  The parameter `cell_state` and output
`next_cell_state` may be either a single or (possibly nested) tuple
of tensors.  The parameter `loop_state` and
output `next_loop_state` may be either a single or (possibly nested) tuple
of `Tensor` and `TensorArray` objects.  This last parameter
may be ignored by `loop_fn` and the return value may be `None`.  If it
is not `None`, then the `loop_state` will be propagated through the RNN
loop, for use purely by `loop_fn` to keep track of its own state.
The `next_loop_state` parameter returned may be `None`.

The first call to `loop_fn` will be `time = 0`, `cell_output = None`,
`cell_state = None`, and `loop_state = None`.  For this call:
The `next_cell_state` value should be the value with which to initialize
the cell&#39;s state.  It may be a final state from a previous RNN or it
may be the output of `cell.zero_state()`.  It should be a
(possibly nested) tuple structure of tensors.
If `cell.state_size` is an integer, this must be
a `Tensor` of appropriate type and shape `[batch_size, cell.state_size]`.
If `cell.state_size` is a `TensorShape`, this must be a `Tensor` of
appropriate type and shape `[batch_size] + cell.state_size`.
If `cell.state_size` is a (possibly nested) tuple of ints or
`TensorShape`, this will be a tuple having the corresponding shapes.
The `emit_output` value may be  either `None` or a (possibly nested)
tuple structure of tensors, e.g.,
`(tf.zeros(shape_0, dtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1))`.
If this first `emit_output` return value is `None`,
then the `emit_ta` result of `raw_rnn` will have the same structure and
dtypes as `cell.output_size`.  Otherwise `emit_ta` will have the same
structure, shapes (prepended with a `batch_size` dimension), and dtypes
as `emit_output`.  The actual values returned for `emit_output` at this
initializing call are ignored.  Note, this emit structure must be
consistent across all time steps.
</pre></div>


<p>parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A tuple <code>(emit_ta, final_state, final_loop_state)</code> where:</p>
<p><code>emit_ta</code>: The RNN output <code>TensorArray</code>.
     If <code>loop_fn</code> returns a (possibly nested) set of Tensors for
     <code>emit_output</code> during initialization, (inputs <code>time = 0</code>,
     <code>cell_output = None</code>, and <code>loop_state = None</code>), then <code>emit_ta</code> will
     have the same structure, dtypes, and shapes as <code>emit_output</code> instead.
     If <code>loop_fn</code> returns <code>emit_output = None</code> during this call,
     the structure of <code>cell.output_size</code> is used:
     If <code>cell.output_size</code> is a (possibly nested) tuple of integers
     or <code>TensorShape</code> objects, then <code>emit_ta</code> will be a tuple having the
     same structure as <code>cell.output_size</code>, containing TensorArrays whose
     elements' shapes correspond to the shape data in <code>cell.output_size</code>.</p>
<p><code>final_state</code>: The final cell state.  If <code>cell.state_size</code> is an int, this
    will be shaped <code>[batch_size, cell.state_size]</code>.  If it is a
    <code>TensorShape</code>, this will be shaped <code>[batch_size] + cell.state_size</code>.
    If it is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will
    be a tuple having the corresponding shapes.</p>
<p><code>final_loop_state</code>: The final loop state as returned by <code>loop_fn</code>.</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell, or <code>loop_fn</code> is not
    a <code>callable</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.raw_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.raw_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer">
    <p>def <span class="ident">raw_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.raw_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.raw_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.raw_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.raw_rnn_layer">
    <p>def <span class="ident">raw_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.raw_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.raw_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.raw_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.raw_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.raw_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.read_file">
    <p>def <span class="ident">read_file</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.read_file(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.read_file</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.read_file(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.read_file(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.read_file</strong></p>
<div class="codehilite"><pre><span></span>Reads and outputs the entire contents of the input filename.
</pre></div>


<p>Args:
  filename: A <code>Tensor</code> of type <code>string</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.read_file', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.read_file" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.real">
    <p>def <span class="ident">real</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.real(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.real</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.real(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.real(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.real</strong></p>
<div class="codehilite"><pre><span></span>Returns the real part of a complex number.
</pre></div>


<p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
type <code>float32</code> or <code>float64</code> that is the real part of each element in <code>input</code>.
All elements in <code>input</code> must be complex numbers of the form (a + bj),
where <em>a</em> is the real part returned by this operation and <em>b</em> is the
imaginary part.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]</h1>
<p>tf.real(input) ==&gt; [-2.25, 3.25]
```</p>
<p>If <code>input</code> is already real, it is returned unchanged.</p>
<p>Args:
  input: A <code>Tensor</code>. Must have numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.real', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.real" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_all">
    <p>def <span class="ident">reduce_all</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_all(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_all(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_all</strong></p>
<div class="codehilite"><pre><span></span>Computes the &quot;logical and&quot; of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[True,  True]</h1>
<h1>[False, False]]</h1>
<p>tf.reduce_all(x) ==&gt; False
tf.reduce_all(x, 0) ==&gt; [False, False]
tf.reduce_all(x, 1) ==&gt; [True, False]
```</p>
<p>Args:
  input_tensor: The boolean tensor to reduce.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_all', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_all" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_any">
    <p>def <span class="ident">reduce_any</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_any(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_any</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_any(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_any(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_any</strong></p>
<div class="codehilite"><pre><span></span>Computes the &quot;logical or&quot; of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[True,  True]</h1>
<h1>[False, False]]</h1>
<p>tf.reduce_any(x) ==&gt; True
tf.reduce_any(x, 0) ==&gt; [True, True]
tf.reduce_any(x, 1) ==&gt; [True, False]
```</p>
<p>Args:
  input_tensor: The boolean tensor to reduce.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_any', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_any" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_join">
    <p>def <span class="ident">reduce_join</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_join(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_join</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_join(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_join(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_join</strong></p>
<div class="codehilite"><pre><span></span>Joins a string Tensor across the given dimensions.
</pre></div>


<p>Computes the string join across dimensions in the given string Tensor of shape
<code>[d_0, d_1, ..., d_n-1]</code>.  Returns a new Tensor created by joining the input
strings with the given separator (default: empty string).  Negative indices are
counted backwards from the end, with <code>-1</code> being equivalent to <code>n - 1</code>.  Passing
an empty <code>reduction_indices</code> joins all strings in linear index order and outputs
a scalar string.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor <code>a</code> is [["a", "b"], ["c", "d"]]</h1>
<p>tf.reduce_join(a, 0) ==&gt; ["ac", "bd"]
tf.reduce_join(a, 1) ==&gt; ["ab", "cd"]
tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==&gt; ["ac", "bd"]
tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==&gt; ["ab", "cd"]
tf.reduce_join(a, 0, keep_dims=True) ==&gt; [["ac", "bd"]]
tf.reduce_join(a, 1, keep_dims=True) ==&gt; [["ab"], ["cd"]]
tf.reduce_join(a, 0, separator=".") ==&gt; ["a.c", "b.d"]
tf.reduce_join(a, [0, 1]) ==&gt; ["acbd"]
tf.reduce_join(a, [1, 0]) ==&gt; ["abcd"]
tf.reduce_join(a, []) ==&gt; ["abcd"]
```</p>
<p>Args:
  inputs: A <code>Tensor</code> of type <code>string</code>.
    The input to be joined.  All reduced indices must have non-zero size.
  reduction_indices: A <code>Tensor</code> of type <code>int32</code>.
    The dimensions to reduce over.  Dimensions are reduced in the
    order specified.  Omitting <code>reduction_indices</code> is equivalent to passing
    <code>[n-1, n-2, ..., 0]</code>.  Negative indices from <code>-n</code> to <code>-1</code> are supported.
  keep_dims: An optional <code>bool</code>. Defaults to <code>False</code>.
    If <code>True</code>, retain reduced dimensions with length <code>1</code>.
  separator: An optional <code>string</code>. Defaults to <code>""</code>.
    The separator to use when joining.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.
  Has shape equal to that of the input with reduced dimensions removed or
  set to <code>1</code> depending on <code>keep_dims</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_join', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_join" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_logsumexp">
    <p>def <span class="ident">reduce_logsumexp</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_logsumexp(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_logsumexp</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_logsumexp(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_logsumexp(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_logsumexp</strong></p>
<div class="codehilite"><pre><span></span>Computes log(sum(exp(elements across dimensions of a tensor))).
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>This funciton is more numerically stable than log(sum(exp(input))). It avoids
overflows caused by taking the exp of large inputs and underflows caused by
taking the log of small inputs.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[0, 0, 0]]</h1>
<h1>[0, 0, 0]]</h1>
<p>tf.reduce_logsumexp(x) ==&gt; log(6)
tf.reduce_logsumexp(x, 0) ==&gt; [log(2), log(2), log(2)]
tf.reduce_logsumexp(x, 1) ==&gt; [log(3), log(3)]
tf.reduce_logsumexp(x, 1, keep_dims=True) ==&gt; [[log(3)], [log(3)]]
tf.reduce_logsumexp(x, [0, 1]) ==&gt; log(6)
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the defaut),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_logsumexp', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_logsumexp" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_max">
    <p>def <span class="ident">reduce_max</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_max(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_max</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_max(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_max(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_max</strong></p>
<div class="codehilite"><pre><span></span>Computes the maximum of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_max', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_max" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_mean">
    <p>def <span class="ident">reduce_mean</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_mean(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_mean</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_mean(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_mean(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_mean</strong></p>
<div class="codehilite"><pre><span></span>Computes the mean of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1., 1.]</h1>
<h1>[2., 2.]]</h1>
<p>tf.reduce_mean(x) ==&gt; 1.5
tf.reduce_mean(x, 0) ==&gt; [1.5, 1.5]
tf.reduce_mean(x, 1) ==&gt; [1.,  2.]
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_mean', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_mean" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_min">
    <p>def <span class="ident">reduce_min</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_min(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_min</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_min(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_min(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_min</strong></p>
<div class="codehilite"><pre><span></span>Computes the minimum of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_min', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_min" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_prod">
    <p>def <span class="ident">reduce_prod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_prod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_prod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_prod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_prod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_prod</strong></p>
<div class="codehilite"><pre><span></span>Computes the product of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_prod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_prod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_sum">
    <p>def <span class="ident">reduce_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reduce_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reduce_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>reduction_indices</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>reduction_indices</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1, 1, 1]</h1>
<h1>[1, 1, 1]]</h1>
<p>tf.reduce_sum(x) ==&gt; 6
tf.reduce_sum(x, 0) ==&gt; [2, 2, 2]
tf.reduce_sum(x, 1) ==&gt; [3, 3]
tf.reduce_sum(x, 1, keep_dims=True) ==&gt; [[3], [3]]
tf.reduce_sum(x, [0, 1]) ==&gt; 6
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  reduction_indices: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function">
    <p>def <span class="ident">register_tensor_conversion_function</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.register_tensor_conversion_function(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.register_tensor_conversion_function</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.register_tensor_conversion_function(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.register_tensor_conversion_function(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.register_tensor_conversion_function</strong></p>
<div class="codehilite"><pre><span></span>Registers a function for converting objects of `base_type` to `Tensor`.
</pre></div>


<p>The conversion function must have the following signature:</p>
<div class="codehilite"><pre><span></span>def conversion_func(value, dtype=None, name=None, as_ref=False):
  # ...
</pre></div>


<p>It must return a <code>Tensor</code> with the given <code>dtype</code> if specified. If the
conversion function creates a new <code>Tensor</code>, it should use the given
<code>name</code> if specified. All exceptions will be propagated to the caller.</p>
<p>The conversion function may return <code>NotImplemented</code> for some
inputs. In this case, the conversion process will continue to try
subsequent conversion functions.</p>
<p>If <code>as_ref</code> is true, the function must return a <code>Tensor</code> reference,
such as a <code>Variable</code>.</p>
<p>NOTE: The conversion functions will execute in order of priority,
followed by order of registration. To ensure that a conversion function
<code>F</code> runs before another conversion function <code>G</code>, ensure that <code>F</code> is
registered with a smaller priority than <code>G</code>.</p>
<p>Args:
  base_type: The base type or tuple of base types for all objects that
    <code>conversion_func</code> accepts.
  conversion_func: A function that converts instances of <code>base_type</code> to
    <code>Tensor</code>.
  priority: Optional integer that indicates the priority for applying this
    conversion function. Conversion functions with smaller priority values
    run earlier than conversion functions with larger priority values.
    Defaults to 100.</p>
<p>Raises:
  TypeError: If the arguments do not have the appropriate type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu">
    <p>def <span class="ident">relu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.relu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.relu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.relu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.relu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.relu</strong></p>
<div class="codehilite"><pre><span></span>Computes rectified linear: `max(features, 0)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu6">
    <p>def <span class="ident">relu6</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.relu6(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.relu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.relu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.relu6(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.relu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Rectified Linear 6: `min(max(features, 0), 6)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu6', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu6" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer">
    <p>def <span class="ident">relu6_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.relu6_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.relu6_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu6`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu6_layer">
    <p>def <span class="ident">relu6_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.relu6_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.relu6_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu6`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu6_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu6_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu_conv2d_layer">
    <p>def <span class="ident">relu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.relu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.relu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu_layer">
    <p>def <span class="ident">relu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.relu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.relu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.report_uninitialized_variables">
    <p>def <span class="ident">report_uninitialized_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.report_uninitialized_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.report_uninitialized_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.report_uninitialized_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.report_uninitialized_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.report_uninitialized_variables</strong></p>
<div class="codehilite"><pre><span></span>Adds ops to list the names of uninitialized variables.
</pre></div>


<p>When run, it returns a 1-D tensor containing the names of uninitialized
variables if there are any, or an empty array if there are none.</p>
<p>Args:
  var_list: List of <code>Variable</code> objects to check. Defaults to the
    value of <code>all_variables() + local_variables()</code>
  name: Optional name of the <code>Operation</code>.</p>
<p>Returns:
  A 1-D tensor containing names of the uninitialized variables, or an empty
  1-D tensor if there are no variables or no uninitialized variables.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.report_uninitialized_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.report_uninitialized_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings">
    <p>def <span class="ident">required_space_to_batch_paddings</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.required_space_to_batch_paddings(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.required_space_to_batch_paddings</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.required_space_to_batch_paddings(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.required_space_to_batch_paddings(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.required_space_to_batch_paddings</strong></p>
<div class="codehilite"><pre><span></span>Calculate padding required to make block_shape divide input_shape.
</pre></div>


<p>This function can be used to calculate a suitable paddings argument for use
with space_to_batch_nd and batch_to_space_nd.</p>
<p>Args:
  input_shape: int32 Tensor of shape [N].
  block_shape: int32 Tensor of shape [N].
  base_paddings: Optional int32 Tensor of shape [N, 2].  Specifies the minimum
    amount of padding to use.  All elements must be &gt;= 0.  If not specified,
    defaults to 0.
  name: string.  Optional name prefix.</p>
<p>Returns:
  (paddings, crops), where:</p>
<p><code>paddings</code> and <code>crops</code> are int32 Tensors of rank 2 and shape [N, 2]
  satisfying:</p>
<div class="codehilite"><pre><span></span>  paddings[i, 0] = base_paddings[i, 0].
  0 &lt;= paddings[i, 1] - base_paddings[i, 1] &lt; block_shape[i]
  (input_shape[i] + paddings[i, 0] + paddings[i, 1]) % block_shape[i] == 0

  crops[i, 0] = 0
  crops[i, 1] = paddings[i, 1] - base_paddings[i, 1]
</pre></div>


<p>Raises: ValueError if called with incompatible shapes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reset_default_graph">
    <p>def <span class="ident">reset_default_graph</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reset_default_graph(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reset_default_graph</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reset_default_graph(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reset_default_graph(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reset_default_graph</strong></p>
<div class="codehilite"><pre><span></span>Clears the default graph stack and resets the global default graph.
</pre></div>


<p>NOTE: The default graph is a property of the current thread. This
function applies only to the current thread.  Calling this function while
a <code>tf.Session</code> or <code>tf.InteractiveSession</code> is active will result in undefined
behavior. Using any previously created <code>tf.Operation</code> or <code>tf.Tensor</code> objects
after calling this function will result in undefined behavior.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reset_default_graph', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reset_default_graph" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reshape">
    <p>def <span class="ident">reshape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reshape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reshape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reshape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reshape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reshape</strong></p>
<div class="codehilite"><pre><span></span>Reshapes a tensor.
</pre></div>


<p>Given <code>tensor</code>, this operation returns a tensor that has the same values
as <code>tensor</code> with shape <code>shape</code>.</p>
<p>If one component of <code>shape</code> is the special value -1, the size of that dimension
is computed so that the total size remains constant.  In particular, a <code>shape</code>
of <code>[-1]</code> flattens into 1-D.  At most one component of <code>shape</code> can be -1.</p>
<p>If <code>shape</code> is 1-D or higher, then the operation returns a tensor with shape
<code>shape</code> filled with the values of <code>tensor</code>. In this case, the number of elements
implied by <code>shape</code> must be the same as the number of elements in <code>tensor</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]</h1>
<h1>tensor 't' has shape [9]</h1>
<p>reshape(t, [3, 3]) ==&gt; [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]]</p>
<h1>tensor 't' is [[[1, 1], [2, 2]],</h1>
<h1>[[3, 3], [4, 4]]]</h1>
<h1>tensor 't' has shape [2, 2, 2]</h1>
<p>reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2],
                        [3, 3, 4, 4]]</p>
<h1>tensor 't' is [[[1, 1, 1],</h1>
<h1>[2, 2, 2]],</h1>
<h1>[[3, 3, 3],</h1>
<h1>[4, 4, 4]],</h1>
<h1>[[5, 5, 5],</h1>
<h1>[6, 6, 6]]]</h1>
<h1>tensor 't' has shape [3, 2, 3]</h1>
<h1>pass '[-1]' to flatten 't'</h1>
<p>reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]</p>
<h1>-1 can also be used to infer the shape</h1>
<h1>-1 is inferred to be 9:</h1>
<p>reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]</p>
<h1>-1 is inferred to be 2:</h1>
<p>reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]</p>
<h1>-1 is inferred to be 3:</h1>
<p>reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1],
                              [2, 2, 2],
                              [3, 3, 3]],
                             [[4, 4, 4],
                              [5, 5, 5],
                              [6, 6, 6]]]</p>
<h1>tensor 't' is [7]</h1>
<h1>shape <code>[]</code> reshapes to a scalar</h1>
<p>reshape(t, []) ==&gt; 7
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  shape: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Defines the shape of the output tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reshape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reshape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reverse">
    <p>def <span class="ident">reverse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reverse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reverse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reverse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reverse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reverse</strong></p>
<div class="codehilite"><pre><span></span>Reverses specific dimensions of a tensor.
</pre></div>


<p>Given a <code>tensor</code>, and a <code>bool</code> tensor <code>dims</code> representing the dimensions
of <code>tensor</code>, this operation reverses each dimension i of <code>tensor</code> where
<code>dims[i]</code> is <code>True</code>.</p>
<p><code>tensor</code> can have up to 8 dimensions. The number of dimensions
of <code>tensor</code> must equal the number of elements in <code>dims</code>. In other words:</p>
<p><code>rank(tensor) = size(dims)</code></p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 't' is [[[[ 0,  1,  2,  3],</h1>
<h1>[ 4,  5,  6,  7],</h1>
<h1>[ 8,  9, 10, 11]],</h1>
<h1>[[12, 13, 14, 15],</h1>
<h1>[16, 17, 18, 19],</h1>
<h1>[20, 21, 22, 23]]]]</h1>
<h1>tensor 't' shape is [1, 2, 3, 4]</h1>
<h1>'dims' is [False, False, False, True]</h1>
<p>reverse(t, dims) ==&gt; [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]</p>
<h1>'dims' is [False, True, False, False]</h1>
<p>reverse(t, dims) ==&gt; [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]</p>
<h1>'dims' is [False, False, True, False]</h1>
<p>reverse(t, dims) ==&gt; [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>. Must be one of the following types: <code>uint8</code>, <code>int8</code>, <code>int32</code>, <code>int64</code>, <code>bool</code>, <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
    Up to 8-D.
  dims: A <code>Tensor</code> of type <code>bool</code>. 1-D. The dimensions to reverse.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>. The same shape as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reverse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reverse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reverse_sequence">
    <p>def <span class="ident">reverse_sequence</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.reverse_sequence(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reverse_sequence</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reverse_sequence(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.reverse_sequence(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reverse_sequence</strong></p>
<div class="codehilite"><pre><span></span>Reverses variable length slices.
</pre></div>


<p>This op first slices <code>input</code> along the dimension <code>batch_dim</code>, and for each
slice <code>i</code>, reverses the first <code>seq_lengths[i]</code> elements along
the dimension <code>seq_dim</code>.</p>
<p>The elements of <code>seq_lengths</code> must obey <code>seq_lengths[i] &lt; input.dims[seq_dim]</code>,
and <code>seq_lengths</code> must be a vector of length <code>input.dims[batch_dim]</code>.</p>
<p>The output slice <code>i</code> along dimension <code>batch_dim</code> is then given by input
slice <code>i</code>, with the first <code>seq_lengths[i]</code> slices along dimension
<code>seq_dim</code> reversed.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>Given this:</h1>
<p>batch_dim = 0
seq_dim = 1
input.dims = (4, 8, ...)
seq_lengths = [7, 2, 3, 5]</p>
<h1>then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1>
<p>output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]</p>
<h1>while entries past seq_lens are copied through:</h1>
<p>output[0, 7:, :, ...] = input[0, 7:, :, ...]
output[1, 2:, :, ...] = input[1, 2:, :, ...]
output[2, 3:, :, ...] = input[2, 3:, :, ...]
output[3, 2:, :, ...] = input[3, 2:, :, ...]
```</p>
<p>In contrast, if:</p>
<p>```prettyprint</p>
<h1>Given this:</h1>
<p>batch_dim = 2
seq_dim = 0
input.dims = (8, ?, 4, ...)
seq_lengths = [7, 2, 3, 5]</p>
<h1>then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1>
<p>output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]</p>
<h1>while entries past seq_lens are copied through:</h1>
<p>output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
```</p>
<p>Args:
  input: A <code>Tensor</code>. The input to reverse.
  seq_lengths: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D with length <code>input.dims(batch_dim)</code> and
    <code>max(seq_lengths) &lt; input.dims(seq_dim)</code>
  seq_dim: An <code>int</code>. The dimension which is partially reversed.
  batch_dim: An optional <code>int</code>. Defaults to <code>0</code>.
    The dimension along which reversal is performed.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The partially reversed input. It has the same shape as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reverse_sequence', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reverse_sequence" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn">
    <p>def <span class="ident">rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>The simplest form of RNN network generated is:
<code>python
  state = cell.zero_state(...)
  outputs = []
  for input_ in inputs:
    output, state = cell(input_, state)
    outputs.append(output)
  return (outputs, state)</code>
However, a few other options are available:</p>
<p>An initial state can be provided.
If the sequence_length vector is provided, dynamic calculation is performed.
This method of calculation does not compute the RNN steps past the maximum
sequence length of the minibatch (thus saving computational time),
and properly propagates the state at an example's sequence length
to the final state output.</p>
<p>The dynamic calculation performed is, at time <code>t</code> for batch row <code>b</code>,
<code>python
  (output, state)(b, t) =
    (t &gt;= sequence_length(b))
      ? (zeros(cell.output_size), states(b, sequence_length(b) - 1))
      : cell(input(b, t), state(b, t - 1))</code></p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>, or a nested tuple of such elements.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  sequence_length: Specifies the length of each sequence in inputs.
    An int32 or int64 vector (tensor) size <code>[batch_size]</code>, values in <code>[0, T)</code>.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:
    - outputs is a length T list of outputs (one for each input), or a nested
      tuple of such elements.
    - state is the final state</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the input depth
    (column size) cannot be inferred from inputs via shape inference.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer">
    <p>def <span class="ident">rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.rnn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_layer">
    <p>def <span class="ident">rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.rnn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state">
    <p>def <span class="ident">rnn_placeholders_from_state</span>(</p><p>self, zero_state, name=&#39;rnn_state&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rnn_placeholders_from_state(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.rnn_placeholders_from_state</code>. </p>
<p><strong>tb.rnn_placeholders_from_state</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.RegisterMethod</span><span class="p">(</span><span class="s2">&quot;tb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rnn_placeholders_from_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero_state</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rnn_state&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zero_state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rnn_placeholders_from_state</span><span class="p">(</span><span class="n">substate</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">substate</span> <span class="ow">in</span> <span class="n">zero_state</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">zero_state</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">zero_state</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict">
    <p>def <span class="ident">rnn_state_feed_dict</span>(</p><p>self, placeholders, values)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rnn_state_feed_dict(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tb.rnn_state_feed_dict</code>. </p>
<p><strong>tb.rnn_state_feed_dict</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.RegisterMethod</span><span class="p">(</span><span class="s2">&quot;tb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rnn_state_feed_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">placeholders</span><span class="p">),</span> <span class="n">utils</span><span class="o">.</span><span class="n">flatten_list</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.round">
    <p>def <span class="ident">round</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.round(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.round</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.round(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.round(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.round</strong></p>
<div class="codehilite"><pre><span></span>Rounds the values of a tensor to the nearest integer, element-wise.
</pre></div>


<p>For example:</p>
<p>```python</p>
<h1>'a' is [0.9, 2.5, 2.3, -4.4]</h1>
<p>tf.round(a) ==&gt; [ 1.0, 3.0, 2.0, -4.0 ]
```</p>
<p>Args:
  x: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of same shape and type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.round', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.round" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rsqrt">
    <p>def <span class="ident">rsqrt</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.rsqrt(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.rsqrt</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.rsqrt(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.rsqrt(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.rsqrt</strong></p>
<div class="codehilite"><pre><span></span>Computes reciprocal of square root of x element-wise.
</pre></div>


<p>I.e., \(y = 1 / \sqrt{x}\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rsqrt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rsqrt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sampled_softmax_loss">
    <p>def <span class="ident">sampled_softmax_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sampled_softmax_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.sampled_softmax_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.sampled_softmax_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sampled_softmax_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.sampled_softmax_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the sampled softmax training loss.
</pre></div>


<p>This is a faster way to train a softmax classifier over a huge number of
classes.</p>
<p>This operation is for training only.  It is generally an underestimate of
the full softmax loss.</p>
<p>At inference time, you can compute full softmax probabilities with the
expression <code>tf.nn.softmax(tf.matmul(inputs, tf.transpose(weights)) + biases)</code>.</p>
<p>See our [Candidate Sampling Algorithms Reference]
(../../extras/candidate_sampling.pdf)</p>
<p>Also see Section 3 of <a href="http://arxiv.org/abs/1412.2007">Jean et al., 2014</a>
(<a href="http://arxiv.org/pdf/1412.2007.pdf">pdf</a>) for the math.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-sharded) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.  Note that this format differs from
      the <code>labels</code> argument of <code>nn.softmax_cross_entropy_with_logits</code>.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  Default is
      True.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example sampled softmax losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer">
    <p>def <span class="ident">sampled_softmax_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sampled_softmax_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sampled_softmax_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sampled_softmax_loss`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer">
    <p>def <span class="ident">sampled_softmax_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sampled_softmax_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sampled_softmax_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sampled_softmax_loss`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.saturate_cast">
    <p>def <span class="ident">saturate_cast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.saturate_cast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.saturate_cast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.saturate_cast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.saturate_cast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.saturate_cast</strong></p>
<div class="codehilite"><pre><span></span>Performs a safe saturating cast of `value` to `dtype`.
</pre></div>


<p>This function casts the input to <code>dtype</code> without applying any scaling.  If
there is a danger that values would over or underflow in the cast, this op
applies the appropriate clamping before the cast.</p>
<p>Args:
  value: A <code>Tensor</code>.
  dtype: The desired output <code>DType</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>value</code> safely cast to <code>dtype</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.saturate_cast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.saturate_cast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scalar_mul">
    <p>def <span class="ident">scalar_mul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scalar_mul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scalar_mul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scalar_mul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scalar_mul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scalar_mul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies a scalar times a `Tensor` or `IndexedSlices` object.
</pre></div>


<p>Intended for use in gradient code which might deal with <code>IndexedSlices</code>
objects, which are easy to multiply by a scalar but more expensive to
multiply with arbitrary tensors.</p>
<p>Args:
  scalar: A 0-D scalar <code>Tensor</code>. Must have known shape.
  x: A <code>Tensor</code> or <code>IndexedSlices</code> to be scaled.</p>
<p>Returns:
  <code>scalar * x</code> of the same type (<code>Tensor</code> or <code>IndexedSlices</code>) as <code>x</code>.</p>
<p>Raises:
  ValueError: if scalar is not a 0-D <code>scalar</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scalar_mul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scalar_mul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scalar_summary">
    <p>def <span class="ident">scalar_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scalar_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scalar_summary</code>. 
However, the 2nd argument is omitted, a partial with the rest of the arguments is returned which expects the 2nd argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scalar_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scalar_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.scalar_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with scalar values.
</pre></div>


<p>The input <code>tags</code> and <code>values</code> must have the same shape.  The generated
summary has a summary value for each tag-value pair in <code>tags</code> and <code>values</code>.</p>
<p>Args:
  tags: A <code>string</code> <code>Tensor</code>.  Tags for the summaries.
  values: A real numeric Tensor.  Values for the summaries.
  collections: Optional list of graph collections keys. The new summary op is
    added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
  buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scalar_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scalar_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scan">
    <p>def <span class="ident">scan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scan</strong></p>
<div class="codehilite"><pre><span></span>scan on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>The simplest version of <code>scan</code> repeatedly applies the callable <code>fn</code> to a
sequence of elements from first to last. The elements are made of the tensors
unpacked from <code>elems</code> on dimension 0. The callable fn takes two tensors as
arguments. The first argument is the accumulated value computed from the
preceding invocation of fn. If <code>initializer</code> is None, <code>elems</code> must contain
at least one element, and its first element is used as the initializer.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is <code>[len(values)] + fn(initializer, values[0]).shape</code>.</p>
<p>This method also allows multi-arity <code>elems</code> and accumulator.  If <code>elems</code>
is a (possibly nested) list or tuple of tensors, then each of these tensors
must have a matching first (unpack) dimension.  The second argument of
<code>fn</code> must match the structure of <code>elems</code>.</p>
<p>If no <code>initializer</code> is provided, the output structure and dtypes of <code>fn</code>
are assumed to be the same as its input; and in this case, the first
argument of <code>fn</code> must match the structure of <code>elems</code>.</p>
<p>If an <code>initializer</code> is provided, then the output of <code>fn</code> must have the same
structure as <code>initializer</code>; and the first argument of <code>fn</code> must match
this structure.</p>
<p>For example, if <code>elems</code> is <code>(t1, [t2, t3])</code> and <code>initializer</code> is
<code>[i1, i2]</code> then an appropriate signature for <code>fn</code> in <code>python2</code> is:
<code>fn = lambda (acc_p1, acc_p2), (t1 [t2, t3]):</code> and <code>fn</code> must return a list,
<code>[acc_n1, acc_n2]</code>.  An alternative correct signature for <code>fn</code>, and the
 one that works in <code>python3</code>, is:
<code>fn = lambda a, t:</code>, where <code>a</code> and <code>t</code> correspond to the input tuples.</p>
<p>Args:
  fn: The callable to be performed.  It accepts two arguments.  The first
    will have the same (possibly nested) structure as <code>elems</code>.  The second
    will have the same structure as <code>initializer</code> if one is provided,
    otherwise it will have the same structure as <code>elems</code>.  Its output
    must have the same structure as <code>initializer</code> if one is provided,
    otherwise it must have the same structure as <code>elems</code>.
  elems: A tensor or (possibly nested) sequence of tensors, each of which
    will be unpacked along their first dimension.  The nested sequence
    of the resulting slices will be the first argument to <code>fn</code>.
  initializer: (optional) A tensor or (possibly nested) sequence of tensors,
    initial value for the accumulator, and the expected output type of <code>fn</code>.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  infer_shape: (optional) False disables tests for consistent output shapes.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor or (possibly nested) sequence of tensors.  Each tensor packs the
  results of applying <code>fn</code> to tensors unpacked from <code>elems</code> along the first
  dimension, and the previous accumulator value(s), from first to last.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable or the structure of the output of
    <code>fn</code> and <code>initializer</code> do not match.
  ValueError: if the lengths of the output of <code>fn</code> and <code>initializer</code>
    do not match.</p>
<p>Examples:
  <code>python
  elems = np.array([1, 2, 3, 4, 5, 6])
  sum = scan(lambda a, x: a + x, elems)
  # sum == [1, 3, 6, 10, 15, 21]</code></p>
<p><code>python
  elems = np.array([1, 2, 3, 4, 5, 6])
  initializer = np.array(0)
  sum_one = scan(
      lambda a, x: x[0] - x[1] + a, (elems + 1, elems), initializer)
  # sum_one == [1, 2, 3, 4, 5, 6]</code></p>
<p><code>python
  elems = np.array([1, 0, 0, 0, 0, 0])
  initializer = (np.array(0), np.array(1))
  fibonaccis = scan(lambda a, _: (a[1], a[0] + a[1]), elems, initializer)
  # fibonaccis == ([1, 1, 2, 3, 5, 8], [1, 2, 3, 5, 8, 13])</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_add">
    <p>def <span class="ident">scatter_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scatter_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scatter_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_add</strong></p>
<div class="codehilite"><pre><span></span>Adds sparse updates to a variable reference.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] += updates[...]

# Vector indices (for each i)
ref[indices[i], ...] += updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions add.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterAdd.png" alt>
</div>

<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to add to <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the addition will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_div">
    <p>def <span class="ident">scatter_div</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scatter_div(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_div</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_div(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scatter_div(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_div</strong></p>
<div class="codehilite"><pre><span></span>Divides a variable reference by sparse updates.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] /= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] /= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions divide.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of values that <code>ref</code> is divided by.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the operation will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_div', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_div" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_mul">
    <p>def <span class="ident">scatter_mul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scatter_mul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_mul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_mul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scatter_mul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_mul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies sparse updates into a variable reference.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] *= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] *= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions multiply.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to multiply to <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the operation will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_mul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_mul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_sub">
    <p>def <span class="ident">scatter_sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scatter_sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scatter_sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_sub</strong></p>
<div class="codehilite"><pre><span></span>Subtracts sparse updates to a variable reference.

# Scalar indices
ref[indices, ...] -= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] -= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their (negated) contributions add.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterSub.png" alt>
</div>

<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to subtract from <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the subtraction will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_update">
    <p>def <span class="ident">scatter_update</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.scatter_update(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_update</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_update(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.scatter_update(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_update</strong></p>
<div class="codehilite"><pre><span></span>Applies sparse updates to a variable reference.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] = updates[...]

# Vector indices (for each i)
ref[indices[i], ...] = updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>If values in <code>ref</code> is to be updated more than once, because there are
duplicate entires in <code>indices</code>, the order at which the updates happen
for each value is undefined.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterUpdate.png" alt>
</div>

<p>Args:
  ref: A mutable <code>Tensor</code>. Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to store in <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>True</code>.
    If True, the assignment will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_update', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_update" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_max">
    <p>def <span class="ident">segment_max</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.segment_max(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_max</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_max(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.segment_max(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_max</strong></p>
<div class="codehilite"><pre><span></span>Computes the maximum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on Segmentation</a>
for an explanation of segments.</p>
<p>Computes a tensor such that
\(output_i = \max_j(data_j)\) where <code>max</code> is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMax.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_max', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_max" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_mean">
    <p>def <span class="ident">segment_mean</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.segment_mean(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_mean</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_mean(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.segment_mean(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_mean</strong></p>
<div class="codehilite"><pre><span></span>Computes the mean along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
\(output_i = \frac{\sum_j data_j}{N}\) where <code>mean</code> is
over <code>j</code> such that <code>segment_ids[j] == i</code> and <code>N</code> is the total number of
values summed.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMean.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_mean', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_mean" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_min">
    <p>def <span class="ident">segment_min</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.segment_min(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_min</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_min(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.segment_min(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_min</strong></p>
<div class="codehilite"><pre><span></span>Computes the minimum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
\(output_i = \min_j(data_j)\) where <code>min</code> is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMin.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_min', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_min" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_prod">
    <p>def <span class="ident">segment_prod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.segment_prod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_prod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_prod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.segment_prod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_prod</strong></p>
<div class="codehilite"><pre><span></span>Computes the product along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
\(output_i = \prod_j data_j\) where the product is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentProd.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_prod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_prod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_sum">
    <p>def <span class="ident">segment_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.segment_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.segment_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on Segmentation</a>
for an explanation of segments.</p>
<p>Computes a tensor such that
\(output_i = \sum_j data_j\) where sum is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentSum.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.select">
    <p>def <span class="ident">select</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.select(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.select</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.select(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.select(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.select</strong></p>
<div class="codehilite"><pre><span></span>Selects elements from `t` or `e`, depending on `condition`.
</pre></div>


<p>The <code>t</code>, and <code>e</code> tensors must all have the same shape,
and the output will also have that shape.  The <code>condition</code> tensor
must be a scalar if <code>t</code> and <code>e</code> are scalars.  If <code>t</code> and <code>e</code> are vectors
or higher rank, then <code>condition</code> must be either a vector with size
matching the first dimension of <code>t</code>, or must have the same shape as <code>t</code>.</p>
<p>The <code>condition</code> tensor acts as a mask that chooses, based on the value at each
element, whether the corresponding element / row in the output should be
taken from <code>t</code> (if true) or <code>e</code> (if false).</p>
<p>If <code>condition</code> is a vector and <code>t</code> and <code>e</code> are higher rank matrices, then
it chooses which row (outer dimension) to copy from <code>t</code> and <code>e</code>.
If <code>condition</code> has the same shape as <code>t</code> and <code>e</code>, then it chooses which
element to copy from <code>t</code> and <code>e</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'condition' tensor is [[True,  False]</h1>
<h1>[False, True]]</h1>
<h1>'t' is [[1, 2],</h1>
<h1>[3, 4]]</h1>
<h1>'e' is [[5, 6],</h1>
<h1>[7, 8]]</h1>
<p>select(condition, t, e) ==&gt; [[1, 6],
                             [7, 4]]</p>
<h1>'condition' tensor is [True, False]</h1>
<h1>'t' is [[1, 2],</h1>
<h1>[3, 4]]</h1>
<h1>'e' is [[5, 6],</h1>
<h1>[7, 8]]</h1>
<p>select(condition, t, e) ==&gt; [[1, 2],
                             [7, 8]]</p>
<p>```</p>
<p>Args:
  condition: A <code>Tensor</code> of type <code>bool</code>.
  t:  A <code>Tensor</code> which may have the same shape as <code>condition</code>.
    If <code>condition</code> is rank 1, <code>t</code> may have higher rank,
    but its first dimension must match the size of <code>condition</code>.
  e:  A <code>Tensor</code> with the same type and shape as <code>t</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type and shape as <code>t</code> and <code>e</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.select', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.select" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.self_adjoint_eig">
    <p>def <span class="ident">self_adjoint_eig</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.self_adjoint_eig(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.self_adjoint_eig</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.self_adjoint_eig(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.self_adjoint_eig(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.self_adjoint_eig</strong></p>
<div class="codehilite"><pre><span></span>Computes the eigen decomposition of a batch of self-adjoint matrices.
</pre></div>


<p>Computes the eigenvalues and eigenvectors of the innermost N-by-N matrices
in <code>tensor</code> such that
<code>tensor[...,:,:] * v[..., :,i] = e[..., i] * v[...,:,i]</code>, for i=0...N-1.</p>
<p>Args:
  tensor: <code>Tensor</code> of shape <code>[..., N, N]</code>. Only the lower triangular part of
    each inner inner matrix is referenced.
  name: string, optional name of the operation.</p>
<p>Returns:
  e: Eigenvalues. Shape is <code>[..., N]</code>.
  v: Eigenvectors. Shape is <code>[..., N, N]</code>. The columns of the inner most
    matrices contain eigenvectors of the corresponding matrices in <code>tensor</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.self_adjoint_eig', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.self_adjoint_eig" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals">
    <p>def <span class="ident">self_adjoint_eigvals</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.self_adjoint_eigvals(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.self_adjoint_eigvals</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.self_adjoint_eigvals(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.self_adjoint_eigvals(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.self_adjoint_eigvals</strong></p>
<div class="codehilite"><pre><span></span>Computes the eigenvalues of one or more self-adjoint matrices.
</pre></div>


<p>Args:
  tensor: <code>Tensor</code> of shape <code>[..., N, N]</code>.
  name: string, optional name of the operation.</p>
<p>Returns:
  e: Eigenvalues. Shape is <code>[..., N]</code>. The vector <code>e[..., :]</code> contains the <code>N</code>
    eigenvalues of <code>tensor[..., :, :]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.separable_conv2d">
    <p>def <span class="ident">separable_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.separable_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.separable_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.separable_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.separable_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.separable_conv2d</strong></p>
<div class="codehilite"><pre><span></span>2-D convolution with separable filters.
</pre></div>


<p>Performs a depthwise convolution that acts separately on channels followed by
a pointwise convolution that mixes channels.  Note that this is separability
between dimensions <code>[1, 2]</code> and <code>3</code>, not spatial separability between
dimensions <code>1</code> and <code>2</code>.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q, r]
    input[b, strides[1] * i + di, strides[2] * j + dj, q] *
    depthwise_filter[di, dj, q, r] *
    pointwise_filter[0, 0, q * channel_multiplier + r, k]
</pre></div>


<p><code>strides</code> controls the strides for the depthwise convolution only, since
the pointwise convolution has implicit strides of <code>[1, 1, 1, 1]</code>.  Must have
<code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D <code>Tensor</code> with shape <code>[batch, in_height, in_width, in_channels]</code>.
  depthwise_filter: 4-D <code>Tensor</code> with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
    Contains <code>in_channels</code> convolutional filters of depth 1.
  pointwise_filter: 4-D <code>Tensor</code> with shape
    <code>[1, 1, channel_multiplier * in_channels, out_channels]</code>.  Pointwise
    filter to mix channels after <code>depthwise_filter</code> has convolved spatially.
  strides: 1-D of size 4.  The strides for the depthwise convolution for
    each dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>.  The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape <code>[batch, out_height, out_width, out_channels]</code>.</p>
<p>Raises:
  ValueError: If channel_multiplier * in_channels &gt; out_channels,
    which means that the separable convolution is overparameterized.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.separable_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.separable_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer">
    <p>def <span class="ident">separable_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.separable_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.separable_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.separable_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.separable_conv2d_layer">
    <p>def <span class="ident">separable_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.separable_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.separable_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.separable_conv2d`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.separable_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.separable_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sequence_mask">
    <p>def <span class="ident">sequence_mask</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sequence_mask(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sequence_mask</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sequence_mask(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sequence_mask(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sequence_mask</strong></p>
<div class="codehilite"><pre><span></span>Return a mask tensor representing the first N positions of each row.
</pre></div>


<p>Example:
<code>python
tf.sequence_mask([1, 3, 2], 5) =
  [[True, False, False, False, False],
   [True, True, True, False, False],
   [True, True, False, False, False]]</code></p>
<p>Args:
  lengths: 1D integer tensor, all its values &lt; maxlen.
  maxlen: scalar integer tensor, maximum length of each row. Default: use
          maximum over lengths.
  dtype: output type of the resulting tensor.
  name: name of the op.
Returns:
  A 2D mask tensor, as shown in the example above, cast to specified dtype.</p>
<p>Raises:
  ValueError: if the arguments have invalid rank.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sequence_mask', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sequence_mask" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.serialize_many_sparse">
    <p>def <span class="ident">serialize_many_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.serialize_many_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.serialize_many_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.serialize_many_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.serialize_many_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.serialize_many_sparse</strong></p>
<div class="codehilite"><pre><span></span>Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`.
</pre></div>


<p>The <code>SparseTensor</code> must have rank <code>R</code> greater than 1, and the first dimension
is treated as the minibatch dimension.  Elements of the <code>SparseTensor</code>
must be sorted in increasing order of this first dimension.  The serialized
<code>SparseTensor</code> objects going into each row of the output <code>Tensor</code> will have
rank <code>R-1</code>.</p>
<p>The minibatch size <code>N</code> is extracted from <code>sparse_shape[0]</code>.</p>
<p>Args:
  sp_input: The input rank <code>R</code> <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A string matrix (2-D <code>Tensor</code>) with <code>N</code> rows and <code>3</code> columns.
  Each column represents serialized <code>SparseTensor</code>'s indices, values, and
  shape (respectively).</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.serialize_many_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.serialize_many_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.serialize_sparse">
    <p>def <span class="ident">serialize_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.serialize_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.serialize_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.serialize_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.serialize_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.serialize_sparse</strong></p>
<div class="codehilite"><pre><span></span>Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object.
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A string 3-vector (1D <code>Tensor</code>), with each column representing the
  serialized <code>SparseTensor</code>'s indices, values, and shape (respectively).</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.serialize_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.serialize_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.set_random_seed">
    <p>def <span class="ident">set_random_seed</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.set_random_seed(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.set_random_seed</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.set_random_seed(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.set_random_seed(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.set_random_seed</strong></p>
<div class="codehilite"><pre><span></span>Sets the graph-level random seed.
</pre></div>


<p>Operations that rely on a random seed actually derive it from two seeds:
the graph-level and operation-level seeds. This sets the graph-level seed.</p>
<p>Its interactions with operation-level seeds is as follows:</p>
<ol>
<li>If neither the graph-level nor the operation seed is set:
    A random seed is used for this op.</li>
<li>If the graph-level seed is set, but the operation seed is not:
    The system deterministically picks an operation seed in conjunction
    with the graph-level seed so that it gets a unique random sequence.</li>
<li>If the graph-level seed is not set, but the operation seed is set:
    A default graph-level seed and the specified operation seed are used to
    determine the random sequence.</li>
<li>If both the graph-level and the operation seed are set:
    Both seeds are used in conjunction to determine the random sequence.</li>
</ol>
<p>To illustrate the user-visible effects, consider these examples:</p>
<p>To generate different sequences across sessions, set neither
graph-level nor op-level seeds:</p>
<p>```python
a = tf.random_uniform([1])
b = tf.random_normal([1])</p>
<p>print("Session 1")
with tf.Session() as sess1:
  print(sess1.run(a))  # generates 'A1'
  print(sess1.run(a))  # generates 'A2'
  print(sess1.run(b))  # generates 'B1'
  print(sess1.run(b))  # generates 'B2'</p>
<p>print("Session 2")
with tf.Session() as sess2:
  print(sess2.run(a))  # generates 'A3'
  print(sess2.run(a))  # generates 'A4'
  print(sess2.run(b))  # generates 'B3'
  print(sess2.run(b))  # generates 'B4'
```</p>
<p>To generate the same repeatable sequence for an op across sessions, set the
seed for the op:</p>
<p>```python
a = tf.random_uniform([1], seed=1)
b = tf.random_normal([1])</p>
<h1>Repeatedly running this block with the same graph will generate the same</h1>
<h1>sequence of values for 'a', but different sequences of values for 'b'.</h1>
<p>print("Session 1")
with tf.Session() as sess1:
  print(sess1.run(a))  # generates 'A1'
  print(sess1.run(a))  # generates 'A2'
  print(sess1.run(b))  # generates 'B1'
  print(sess1.run(b))  # generates 'B2'</p>
<p>print("Session 2")
with tf.Session() as sess2:
  print(sess2.run(a))  # generates 'A1'
  print(sess2.run(a))  # generates 'A2'
  print(sess2.run(b))  # generates 'B3'
  print(sess2.run(b))  # generates 'B4'
```</p>
<p>To make the random sequences generated by all ops be repeatable across
sessions, set a graph-level seed:</p>
<p>```python
tf.set_random_seed(1234)
a = tf.random_uniform([1])
b = tf.random_normal([1])</p>
<h1>Repeatedly running this block with the same graph will generate different</h1>
<h1>sequences of 'a' and 'b'.</h1>
<p>print("Session 1")
with tf.Session() as sess1:
  print(sess1.run(a))  # generates 'A1'
  print(sess1.run(a))  # generates 'A2'
  print(sess1.run(b))  # generates 'B1'
  print(sess1.run(b))  # generates 'B2'</p>
<p>print("Session 2")
with tf.Session() as sess2:
  print(sess2.run(a))  # generates 'A1'
  print(sess2.run(a))  # generates 'A2'
  print(sess2.run(b))  # generates 'B1'
  print(sess2.run(b))  # generates 'B2'
```</p>
<p>Args:
  seed: integer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.set_random_seed', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.set_random_seed" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.shape">
    <p>def <span class="ident">shape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.shape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.shape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.shape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.shape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.shape</strong></p>
<div class="codehilite"><pre><span></span>Returns the shape of a tensor.
</pre></div>


<p>This operation returns a 1-D integer tensor representing the shape of <code>input</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1>
<p>shape(t) ==&gt; [2, 2, 3]
```</p>
<p>Args:
  input: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).
  out_type: (Optional) The specified output type of the operation
    (<code>int32</code> or <code>int64</code>). Defaults to tf.int32.</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.shape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.shape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.shape_n">
    <p>def <span class="ident">shape_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.shape_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.shape_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.shape_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.shape_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.shape_n</strong></p>
<div class="codehilite"><pre><span></span>Returns shape of tensors.
</pre></div>


<p>This operation returns N 1-D integer tensors representing shape of <code>input[i]s</code>.</p>
<p>Args:
  input: A list of at least 1 <code>Tensor</code> objects of the same type.
  out_type: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list with the same number of <code>Tensor</code> objects as <code>input</code> of <code>Tensor</code> objects of type out_type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.shape_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.shape_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid">
    <p>def <span class="ident">sigmoid</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sigmoid(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.sigmoid</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.sigmoid(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sigmoid(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.sigmoid</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid of `x` element-wise.
</pre></div>


<p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
<p>Args:
  x: A Tensor with type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>int64</code>,
    or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor with the same type as <code>x</code> if <code>x.dtype != qint32</code>
    otherwise the return type is <code>quint8</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer">
    <p>def <span class="ident">sigmoid_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.sigmoid_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.sigmoid_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.sigmoid_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid cross entropy given `logits`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which each
class is independent and not mutually exclusive.  For instance, one could
perform multilabel classification where a picture can contain both an elephant
and a dog at the same time.</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>.  The logistic loss is</p>
<div class="codehilite"><pre><span></span>  z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + log(1 + exp(-x))
= x - x * z + log(1 + exp(-x))
</pre></div>


<p>For x &lt; 0, to avoid overflow in exp(-x), we reformulate the above</p>
<div class="codehilite"><pre><span></span>  x - x * z + log(1 + exp(-x))
= log(exp(x)) - x * z + log(1 + exp(-x))
= - x * z + log(1 + exp(x))
</pre></div>


<p>Hence, to ensure stability and avoid overflow, the implementation uses this
equivalent formulation</p>
<div class="codehilite"><pre><span></span>max(x, 0) - x * z + log(1 + exp(-abs(x)))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_layer">
    <p>def <span class="ident">sigmoid_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sigmoid_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sign">
    <p>def <span class="ident">sign</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sign(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sign(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sign</strong></p>
<div class="codehilite"><pre><span></span>Returns an element-wise indication of the sign of a number.
</pre></div>


<p><code>y = sign(x) = -1</code> if <code>x &lt; 0</code>; 0 if <code>x == 0</code>; 1 if <code>x &gt; 0</code>.</p>
<p>For complex numbers, <code>y = sign(x) = x / |x|</code> if <code>x != 0</code>, otherwise <code>y = 0</code>.</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sign', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sign" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sin">
    <p>def <span class="ident">sin</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sin(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sin</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sin(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sin(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sin</strong></p>
<div class="codehilite"><pre><span></span>Computes sin of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sin', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sin" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.size">
    <p>def <span class="ident">size</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.size(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.size</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.size(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.size(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.size</strong></p>
<div class="codehilite"><pre><span></span>Returns the size of a tensor.
</pre></div>


<p>This operation returns an integer representing the number of elements in
<code>input</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]</h1>
<p>size(t) ==&gt; 12
```</p>
<p>Args:
  input: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).
  out_type: (Optional) The specified output type of the operation
    (<code>int32</code> or <code>int64</code>). Defaults to tf.int32.</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>. Defaults to tf.int32.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.size', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.size" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.slice">
    <p>def <span class="ident">slice</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.slice(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.slice</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.slice(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.slice(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.slice</strong></p>
<div class="codehilite"><pre><span></span>Extracts a slice from a tensor.
</pre></div>


<p>This operation extracts a slice of size <code>size</code> from a tensor <code>input</code> starting
at the location specified by <code>begin</code>. The slice <code>size</code> is represented as a
tensor shape, where <code>size[i]</code> is the number of elements of the 'i'th dimension
of <code>input</code> that you want to slice. The starting location (<code>begin</code>) for the
slice is represented as an offset in each dimension of <code>input</code>. In other
words, <code>begin[i]</code> is the offset into the 'i'th dimension of <code>input</code> that you
want to slice from.</p>
<p><code>begin</code> is zero-based; <code>size</code> is one-based. If <code>size[i]</code> is -1,
all remaining elements in dimension i are included in the
slice. In other words, this is equivalent to setting:</p>
<p><code>size[i] = input.dim_size(i) - begin[i]</code></p>
<p>This operation requires that:</p>
<p><code>0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n]</code></p>
<p>For example:</p>
<p>```</p>
<h1>'input' is [[[1, 1, 1], [2, 2, 2]],</h1>
<h1>[[3, 3, 3], [4, 4, 4]],</h1>
<h1>[[5, 5, 5], [6, 6, 6]]]</h1>
<p>tf.slice(input, [1, 0, 0], [1, 1, 3]) ==&gt; [[[3, 3, 3]]]
tf.slice(input, [1, 0, 0], [1, 2, 3]) ==&gt; [[[3, 3, 3],
                                            [4, 4, 4]]]
tf.slice(input, [1, 0, 0], [2, 1, 3]) ==&gt; [[[3, 3, 3]],
                                           [[5, 5, 5]]]
```</p>
<p>Args:
  input_: A <code>Tensor</code>.
  begin: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  size: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.slice', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.slice" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax">
    <p>def <span class="ident">softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes log softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>softmax = exp(logits) / reduce_sum(exp(logits), dim)
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.
Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer">
    <p>def <span class="ident">softmax_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softmax_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softmax_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits">
    <p>def <span class="ident">softmax_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softmax_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softmax_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  While the classes are mutually exclusive, their probabilities
need not be.  All that is required is that each row of <code>labels</code> is
a valid probability distribution.  If they are not, the computation of the
gradient will be incorrect.</p>
<p>If using exclusive <code>labels</code> (wherein one and only
one class is true at a time), see <code>sparse_softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a <code>softmax</code>
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p><code>logits</code> and <code>labels</code> must have the same shape <code>[batch_size, num_classes]</code>
and the same dtype (either <code>float16</code>, <code>float32</code>, or <code>float64</code>).</p>
<p>Args:
  logits: Unscaled log probabilities.
  labels: Each row <code>labels[i]</code> must be a valid probability distribution.
  dim: The class dimension. Defaulted to -1 which is the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A 1-D <code>Tensor</code> of length <code>batch_size</code> of the same type as <code>logits</code> with the
  softmax cross entropy loss.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">softmax_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">softmax_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softmax_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softmax_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_layer">
    <p>def <span class="ident">softmax_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softmax_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softmax_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softplus">
    <p>def <span class="ident">softplus</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softplus(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.softplus</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.softplus(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softplus(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.softplus</strong></p>
<div class="codehilite"><pre><span></span>Computes softplus: `log(exp(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softplus', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softplus" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer">
    <p>def <span class="ident">softplus_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softplus_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softplus_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softplus`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softplus_layer">
    <p>def <span class="ident">softplus_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softplus_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softplus_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softplus`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softplus_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softplus_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softsign">
    <p>def <span class="ident">softsign</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softsign(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.softsign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.softsign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softsign(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.softsign</strong></p>
<div class="codehilite"><pre><span></span>Computes softsign: `features / (abs(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softsign', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softsign" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer">
    <p>def <span class="ident">softsign_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softsign_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softsign_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softsign`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softsign_layer">
    <p>def <span class="ident">softsign_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.softsign_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.softsign_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softsign`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softsign_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softsign_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.space_to_batch">
    <p>def <span class="ident">space_to_batch</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.space_to_batch(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.space_to_batch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.space_to_batch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.space_to_batch(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.space_to_batch</strong></p>
<div class="codehilite"><pre><span></span>SpaceToBatch for 4-D tensors of type T.
</pre></div>


<p>This is a legacy version of the more general SpaceToBatchND.</p>
<p>Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
More specifically, this op outputs a copy of the input tensor where values from
the <code>height</code> and <code>width</code> dimensions are moved to the <code>batch</code> dimension. After
the zero-padding, both <code>height</code> and <code>width</code> of the input must be divisible by the
block size.</p>
<p>Args:
  input: A <code>Tensor</code>. 4-D with shape <code>[batch, height, width, depth]</code>.
  paddings: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
      the padding of the input with zeros across the spatial dimensions as follows:</p>
<div class="codehilite"><pre><span></span>      paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]

  The effective spatial dimensions of the zero-padded input tensor will be:

      height_pad = pad_top + height + pad_bottom
      width_pad = pad_left + width + pad_right

The attr `block_size` must be greater than one. It indicates the block size.

  * Non-overlapping blocks of size `block_size x block size` in the height and
    width dimensions are rearranged into the batch dimension at each location.
  * The batch of the output tensor is `batch * block_size * block_size`.
  * Both height_pad and width_pad must be divisible by block_size.

The shape of the output will be:

    [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
     depth]

Some examples:

(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:

```prettyprint
x = [[[[1], [2]], [[3], [4]]]]
```

The output tensor has shape `[4, 1, 1, 1]` and value:

```prettyprint
[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
```

(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

The output tensor has shape `[4, 1, 1, 3]` and value:

```prettyprint
[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
```

(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]],
      [[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[4, 2, 2, 1]` and value:

```prettyprint
x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
```

(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[8, 1, 2, 1]` and value:

```prettyprint
x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
```

Among others, this operation is useful for reducing atrous convolution into
regular convolution.
</pre></div>


<p>block_size: An <code>int</code> that is <code>&gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.space_to_batch', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.space_to_batch" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.space_to_batch_nd">
    <p>def <span class="ident">space_to_batch_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.space_to_batch_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.space_to_batch_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.space_to_batch_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.space_to_batch_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.space_to_batch_nd</strong></p>
<div class="codehilite"><pre><span></span>SpaceToBatch for N-D tensors of type T.
</pre></div>


<p>This operation divides "spatial" dimensions <code>[1, ..., M]</code> of the input into a
grid of blocks of shape <code>block_shape</code>, and interleaves these blocks with the
"batch" dimension (0) such that in the output, the spatial dimensions
<code>[1, ..., M]</code> correspond to the position within the grid, and the batch
dimension combines both the position within a spatial block and the original
batch position.  Prior to division into blocks, the spatial dimensions of the
input are optionally zero padded according to <code>paddings</code>.  See below for a
precise description.</p>
<p>Args:
  input: A <code>Tensor</code>.
    N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
    where spatial_shape has <code>M</code> dimensions.
  block_shape: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D with shape <code>[M]</code>, all values must be &gt;= 1.
  paddings: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.
      <code>paddings[i] = [pad_start, pad_end]</code> specifies the padding for input dimension
      <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is required that
      <code>block_shape[i]</code> divides <code>input_shape[i + 1] + pad_start + pad_end</code>.</p>
<div class="codehilite"><pre><span></span>This operation is equivalent to the following steps:

1. Zero-pad the start and end of dimensions `[1, ..., M]` of the
   input according to `paddings` to produce `padded` of shape `padded_shape`.

2. Reshape `padded` to `reshaped_padded` of shape:
     [batch] +
     [padded_shape[1] / block_shape[0],
       block_shape[0],
      ...,
      padded_shape[M] / block_shape[M-1],
      block_shape[M-1]] +
     remaining_shape

3. Permute dimensions of `reshaped_padded` to produce
   `permuted_reshaped_padded` of shape:
     block_shape +
     [batch] +
     [padded_shape[1] / block_shape[0],
      ...,
      padded_shape[M] / block_shape[M-1]] +
     remaining_shape

4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch
   dimension, producing an output tensor of shape:
     [batch * prod(block_shape)] +
     [padded_shape[1] / block_shape[0],
      ...,
      padded_shape[M] / block_shape[M-1]] +
     remaining_shape

Some examples:

(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1], [2]], [[3], [4]]]]
```

The output tensor has shape `[4, 1, 1, 1]` and value:

```prettyprint
[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
```

(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

The output tensor has shape `[4, 1, 1, 3]` and value:

```prettyprint
[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
```

(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]],
      [[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[4, 2, 2, 1]` and value:

```prettyprint
x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
```

(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and
    paddings = `[[0, 0], [2, 0]]`:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[8, 1, 3, 1]` and value:

```prettyprint
x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
     [[[0], [2], [4]]], [[[0], [10], [12]]],
     [[[0], [5], [7]]], [[[0], [13], [15]]],
     [[[0], [6], [8]]], [[[0], [14], [16]]]]
```

Among others, this operation is useful for reducing atrous convolution into
regular convolution.
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.space_to_batch_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.space_to_batch_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.space_to_depth">
    <p>def <span class="ident">space_to_depth</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.space_to_depth(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.space_to_depth</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.space_to_depth(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.space_to_depth(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.space_to_depth</strong></p>
<div class="codehilite"><pre><span></span>SpaceToDepth for tensors of type T.
</pre></div>


<p>Rearranges blocks of spatial data, into depth. More specifically,
this op outputs a copy of the input tensor where values from the <code>height</code>
and <code>width</code> dimensions are moved to the <code>depth</code> dimension.
The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>
<ul>
<li>Non-overlapping blocks of size <code>block_size x block size</code> are rearranged
    into depth at each location.</li>
<li>The depth of the output tensor is <code>input_depth * block_size * block_size</code>.</li>
<li>The input tensor's height and width must be divisible by block_size.</li>
</ul>
<p>That is, assuming the input is in the shape:
<code>[batch, height, width, depth]</code>,
the shape of the output will be:
<code>[batch, height/block_size, width/block_size, depth*block_size*block_size]</code></p>
<p>This operation requires that the input tensor be of rank 4, and that
<code>block_size</code> be &gt;=1 and a divisor of both the input <code>height</code> and <code>width</code>.</p>
<p>This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</p>
<p>For example, given this input of shape <code>[1, 2, 2, 1]</code>, and block_size of 2:</p>
<p><code>prettyprint
x = [[[[1], [2]],
      [[3], [4]]]]</code></p>
<p>This operation will output a tensor of shape <code>[1, 1, 1, 4]</code>:</p>
<p><code>prettyprint
[[[[1, 2, 3, 4]]]]</code></p>
<p>Here, the input has a batch of 1 and each batch element has shape <code>[2, 2, 1]</code>,
the corresponding output will have a single element (i.e. width and height are
both 1) and will have a depth of 4 channels (1 * block_size * block_size).
The output element shape is <code>[1, 1, 4]</code>.</p>
<p>For an input tensor with larger depth, here of shape <code>[1, 2, 2, 3]</code>, e.g.</p>
<p><code>prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]</code></p>
<p>This operation, for block_size of 2, will return the following tensor of shape
<code>[1, 1, 1, 12]</code></p>
<p><code>prettyprint
[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]</code></p>
<p>Similarly, for the following input of shape <code>[1 4 4 1]</code>, and a block size of 2:</p>
<p><code>prettyprint
x = [[[[1],   [2],  [5],  [6]],
      [[3],   [4],  [7],  [8]],
      [[9],  [10], [13],  [14]],
      [[11], [12], [15],  [16]]]]</code></p>
<p>the operator will return the following tensor of shape <code>[1 2 2 4]</code>:</p>
<p><code>prettyprint
x = [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]</code></p>
<p>Args:
  input: A <code>Tensor</code>.
  block_size: An <code>int</code> that is <code>&gt;= 2</code>. The size of the spatial block.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.space_to_depth', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.space_to_depth" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_add">
    <p>def <span class="ident">sparse_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_add</strong></p>
<div class="codehilite"><pre><span></span>Adds two tensors, at least one of each is a `SparseTensor`.
</pre></div>


<p>If one <code>SparseTensor</code> and one <code>Tensor</code> are passed in, returns a <code>Tensor</code>.  If
both arguments are <code>SparseTensor</code>s, this returns a <code>SparseTensor</code>.  The order
of arguments does not matter.  Use vanilla <code>tf.add()</code> for adding two dense
<code>Tensor</code>s.</p>
<p>The indices of any input <code>SparseTensor</code> are assumed ordered in standard
lexicographic order.  If this is not the case, before this step run
<code>SparseReorder</code> to restore index ordering.</p>
<p>If both arguments are sparse, we perform "clipping" as follows.  By default,
if two values sum to zero at some index, the output <code>SparseTensor</code> would still
include that particular location in its index, storing a zero in the
corresponding value slot.  To override this, callers can specify <code>thresh</code>,
indicating that if the sum has a magnitude strictly smaller than <code>thresh</code>, its
corresponding value and index would then not be included.  In particular,
<code>thresh == 0.0</code> (default) means everything is kept and actual thresholding
happens only for a positive value.</p>
<p>For example, suppose the logical sum of two sparse operands is (densified):</p>
<div class="codehilite"><pre><span></span><span class="k">[       2]</span>
<span class="k">[.1     0]</span>
<span class="k">[ 6   -.2]</span>
</pre></div>


<p>Then,</p>
<div class="codehilite"><pre><span></span>- thresh == 0 (the default): all 5 index/value pairs will be returned.
- thresh == 0.11: only .1 and 0  will vanish, and the remaining three
    index/value pairs will be returned.
- thresh == 0.21: .1, 0, and -.2 will vanish.
</pre></div>


<p>Args:
  a: The first operand; <code>SparseTensor</code> or <code>Tensor</code>.
  b: The second operand; <code>SparseTensor</code> or <code>Tensor</code>.  At least one operand
    must be sparse.
  thresh: A 0-D <code>Tensor</code>.  The magnitude threshold that determines if an
  output value/index pair takes space.  Its dtype should match that of the
  values if they are real; if the latter are complex64/complex128, then the
  dtype should be float32/float64, correspondingly.</p>
<p>Returns:
  A <code>SparseTensor</code> or a <code>Tensor</code>, representing the sum.</p>
<p>Raises:
  TypeError: If both <code>a</code> and <code>b</code> are <code>Tensor</code>s.  Use <code>tf.add()</code> instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_concat">
    <p>def <span class="ident">sparse_concat</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_concat(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_concat</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_concat(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_concat(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_concat</strong></p>
<div class="codehilite"><pre><span></span>Concatenates a list of `SparseTensor` along the specified dimension.
</pre></div>


<p>Concatenation is with respect to the dense versions of each sparse input.
It is assumed that each inputs is a <code>SparseTensor</code> whose elements are ordered
along increasing dimension number.</p>
<p>If expand_nonconcat_dim is False, all inputs' shapes must match, except for
the concat dimension. If expand_nonconcat_dim is True, then inputs' shapes are
allowd to vary among all inputs.</p>
<p>The <code>indices</code>, <code>values</code>, and <code>shapes</code> lists must have the same length.</p>
<p>If expand_nonconcat_dim is False, then the output shape is identical to the
inputs', except along the concat dimension, where it is the sum of the inputs'
sizes along that dimension.</p>
<p>If expand_nonconcat_dim is True, then the output shape along the non-concat
dimensions will be expand to be the largest among all inputs, and it is the
sum of the inputs sizes along the concat dimension.</p>
<p>The output elements will be resorted to preserve the sort order along
increasing dimension number.</p>
<p>This op runs in <code>O(M log M)</code> time, where <code>M</code> is the total number of non-empty
values across all inputs. This is due to the need for an internal sort in
order to concatenate efficiently across an arbitrary dimension.</p>
<p>For example, if <code>concat_dim = 1</code> and the inputs are</p>
<div class="codehilite"><pre><span></span>sp_inputs[0]: shape = [2, 3]
[0, 2]: &quot;a&quot;
[1, 0]: &quot;b&quot;
[1, 1]: &quot;c&quot;

sp_inputs[1]: shape = [2, 4]
[0, 1]: &quot;d&quot;
[0, 2]: &quot;e&quot;
</pre></div>


<p>then the output will be</p>
<div class="codehilite"><pre><span></span>shape = [2, 7]
[0, 2]: &quot;a&quot;
[0, 4]: &quot;d&quot;
[0, 5]: &quot;e&quot;
[1, 0]: &quot;b&quot;
[1, 1]: &quot;c&quot;
</pre></div>


<p>Graphically this is equivalent to doing</p>
<div class="codehilite"><pre><span></span><span class="k">[    a] concat [  d e  ] = [    a   d e  ]</span>
<span class="k">[b c  ]        [       ]   [b c          ]</span>
</pre></div>


<p>Another example, if 'concat_dim = 1' and the inputs are</p>
<div class="codehilite"><pre><span></span>sp_inputs[0]: shape = [3, 3]
[0, 2]: &quot;a&quot;
[1, 0]: &quot;b&quot;
[2, 1]: &quot;c&quot;

sp_inputs[1]: shape = [2, 4]
[0, 1]: &quot;d&quot;
[0, 2]: &quot;e&quot;
</pre></div>


<p>if expand_nonconcat_dim = False, this will result in an error. But if
expand_nonconcat_dim = True, this will result in:</p>
<div class="codehilite"><pre><span></span>shape = [3, 7]
[0, 2]: &quot;a&quot;
[0, 4]: &quot;d&quot;
[0, 5]: &quot;e&quot;
[1, 0]: &quot;b&quot;
[2, 1]: &quot;c&quot;
</pre></div>


<p>Graphically this is equivalent to doing</p>
<div class="codehilite"><pre><span></span><span class="k">[    a] concat [  d e  ] = [    a   d e  ]</span>
<span class="k">[b    ]        [       ]   [b            ]</span>
<span class="k">[  c  ]                    [  c          ]</span>
</pre></div>


<p>Args:
  concat_dim: Dimension to concatenate along. Must be in range [-rank, rank),
    where rank is the number of dimensions in each input <code>SparseTensor</code>.
  sp_inputs: List of <code>SparseTensor</code> to concatenate.
  name: A name prefix for the returned tensors (optional).
  expand_nonconcat_dim: Whether to allow the expansion in the non-concat
    dimensions. Defaulted to False.</p>
<p>Returns:
  A <code>SparseTensor</code> with the concatenated output.</p>
<p>Raises:
  TypeError: If <code>sp_inputs</code> is not a list of <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_concat', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_concat" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows">
    <p>def <span class="ident">sparse_fill_empty_rows</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_fill_empty_rows(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_fill_empty_rows</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_fill_empty_rows(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_fill_empty_rows(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_fill_empty_rows</strong></p>
<div class="codehilite"><pre><span></span>Fills empty rows in the input 2-D `SparseTensor` with a default value.
</pre></div>


<p>This op adds entries with the specified <code>default_value</code> at index
<code>[row, 0]</code> for any row in the input that does not already have a value.</p>
<p>For example, suppose <code>sp_input</code> has shape <code>[5, 6]</code> and non-empty values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
</pre></div>


<p>Rows 1 and 4 are empty, so the output will be of shape <code>[5, 6]</code> with values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[1, 0]: default_value
[2, 0]: c
[3, 1]: d
[4, 0]: default_value
</pre></div>


<p>Note that the input may have empty columns at the end, with no effect on
this op.</p>
<p>The output <code>SparseTensor</code> will be in row-major order and will have the
same shape as the input.</p>
<p>This op also returns an indicator vector such that</p>
<div class="codehilite"><pre><span></span>empty_row_indicator[i] = True iff row i was an empty row.
</pre></div>


<p>Args:
  sp_input: A <code>SparseTensor</code> with shape <code>[N, M]</code>.
  default_value: The value to fill for empty rows, with the same type as
    <code>sp_input.</code>
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  sp_ordered_output: A <code>SparseTensor</code> with shape <code>[N, M]</code>, and with all empty
    rows filled in with <code>default_value</code>.
  empty_row_indicator: A bool vector of length <code>N</code> indicating whether each
    input row was empty.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_mask">
    <p>def <span class="ident">sparse_mask</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_mask(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_mask</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_mask(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_mask(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_mask</strong></p>
<div class="codehilite"><pre><span></span>Masks elements of `IndexedSlices`.
</pre></div>


<p>Given an <code>IndexedSlices</code> instance <code>a</code>, returns another <code>IndexedSlices</code> that
contains a subset of the slices of <code>a</code>. Only the slices at indices not
specified in <code>mask_indices</code> are returned.</p>
<p>This is useful when you need to extract a subset of slices in an
<code>IndexedSlices</code> object.</p>
<p>For example:</p>
<p>```python</p>
<h1><code>a</code> contains slices at indices [12, 26, 37, 45] from a large tensor</h1>
<h1>with shape [1000, 10]</h1>
<p>a.indices =&gt; [12, 26, 37, 45]
tf.shape(a.values) =&gt; [4, 10]</p>
<h1><code>b</code> will be the subset of <code>a</code> slices at its second and third indices, so</h1>
<h1>we want to mask its first and last indices (which are at absolute</h1>
<h1>indices 12, 45)</h1>
<p>b = tf.sparse_mask(a, [12, 45])</p>
<p>b.indices =&gt; [26, 37]
tf.shape(b.values) =&gt; [2, 10]</p>
<p>```</p>
<p>Args:
  * <code>a</code>: An <code>IndexedSlices</code> instance.
  * <code>mask_indices</code>: Indices of elements to mask.
  * <code>name</code>: A name for the operation (optional).</p>
<p>Returns:
  The masked <code>IndexedSlices</code> instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_mask', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_mask" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_maximum">
    <p>def <span class="ident">sparse_maximum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_maximum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_maximum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_maximum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_maximum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_maximum</strong></p>
<div class="codehilite"><pre><span></span>Returns the element-wise max of two SparseTensors.
</pre></div>


<p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
Example:</p>
<p>```python
sp_zero = ops.SparseTensor([[0]], [0], [7])
sp_one = ops.SparseTensor([[1]], [1], [7])
res = tf.sparse_maximum(sp_zero, sp_one).eval()</p>
<h1>"res" should be equal to SparseTensor([[0], [1]], [0, 1], [7]).</h1>
<p>```</p>
<p>Args:
  sp_a: a <code>SparseTensor</code> operand whose dtype is real, and indices
    lexicographically ordered.
  sp_b: the other <code>SparseTensor</code> operand with the same requirements (and the
    same shape).
  name: optional name of the operation.
Returns:
  output: the output SparseTensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_maximum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_maximum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_merge">
    <p>def <span class="ident">sparse_merge</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_merge(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_merge</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_merge(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_merge(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_merge</strong></p>
<div class="codehilite"><pre><span></span>Combines a batch of feature ids and values into a single `SparseTensor`.
</pre></div>


<p>The most common use case for this function occurs when feature ids and
their corresponding values are stored in <code>Example</code> protos on disk.
<code>parse_example</code> will return a batch of ids and a batch of values, and this
function joins them into a single logical <code>SparseTensor</code> for use in
functions such as <code>sparse_tensor_dense_matmul</code>, <code>sparse_to_dense</code>, etc.</p>
<p>The <code>SparseTensor</code> returned by this function has the following properties:</p>
<ul>
<li><code>indices</code> is equivalent to <code>sp_ids.indices</code> with the last
    dimension discarded and replaced with <code>sp_ids.values</code>.</li>
<li><code>values</code> is simply <code>sp_values.values</code>.</li>
<li>If <code>sp_ids.shape = [D0, D1, ..., Dn, K]</code>, then
    <code>output.shape = [D0, D1, ..., Dn, vocab_size]</code>.</li>
</ul>
<p>For example, consider the following feature vectors:</p>
<p><code>python
  vector1 = [-3, 0, 0, 0, 0, 0]
  vector2 = [ 0, 1, 0, 4, 1, 0]
  vector3 = [ 5, 0, 0, 9, 0, 0]</code></p>
<p>These might be stored sparsely in the following Example protos by storing
only the feature ids (column number if the vectors are treated as a matrix)
of the non-zero elements and the corresponding values:</p>
<p><code>python
  examples = [Example(features={
                  "ids": Feature(int64_list=Int64List(value=[0])),
                  "values": Feature(float_list=FloatList(value=[-3]))}),
              Example(features={
                  "ids": Feature(int64_list=Int64List(value=[1, 4, 3])),
                  "values": Feature(float_list=FloatList(value=[1, 1, 4]))}),
              Example(features={
                  "ids": Feature(int64_list=Int64List(value=[0, 3])),
                  "values": Feature(float_list=FloatList(value=[5, 9]))})]</code></p>
<p>The result of calling parse_example on these examples will produce a
dictionary with entries for "ids" and "values". Passing those two objects
to this function along with vocab_size=6, will produce a <code>SparseTensor</code> that
sparsely represents all three instances. Namely, the <code>indices</code> property will
contain the coordinates of the non-zero entries in the feature matrix (the
first dimension is the row number in the matrix, i.e., the index within the
batch, and the second dimension is the column number, i.e., the feature id);
<code>values</code> will contain the actual values. <code>shape</code> will be the shape of the
original matrix, i.e., (3, 6). For our example above, the output will be
equal to:</p>
<p><code>python
  SparseTensor(indices=[[0, 0], [1, 1], [1, 3], [1, 4], [2, 0], [2, 3]],
               values=[-3, 1, 4, 1, 5, 9],
               shape=[3, 6])</code></p>
<p>Args:
  sp_ids: A <code>SparseTensor</code> with <code>values</code> property of type <code>int32</code>
    or <code>int64</code>.
  sp_values: A<code>SparseTensor</code> of any type.
  vocab_size: A scalar <code>int64</code> Tensor (or Python int) containing the new size
    of the last dimension, <code>all(0 &lt;= sp_ids.values &lt; vocab_size)</code>.
  name: A name prefix for the returned tensors (optional)
  already_sorted: A boolean to specify whether the per-batch values in
   <code>sp_values</code> are already sorted. If so skip sorting, False by default
   (optional).</p>
<p>Returns:
  A <code>SparseTensor</code> compactly representing a batch of feature ids and values,
  useful for passing to functions that expect such a <code>SparseTensor</code>.</p>
<p>Raises:
  TypeError: If <code>sp_ids</code> or <code>sp_values</code> are not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_merge', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_merge" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_minimum">
    <p>def <span class="ident">sparse_minimum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_minimum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_minimum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_minimum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_minimum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_minimum</strong></p>
<div class="codehilite"><pre><span></span>Returns the element-wise min of two SparseTensors.
</pre></div>


<p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
Example:</p>
<p>```python
sp_zero = ops.SparseTensor([[0]], [0], [7])
sp_one = ops.SparseTensor([[1]], [1], [7])
res = tf.sparse_minimum(sp_zero, sp_one).eval()</p>
<h1>"res" should be equal to SparseTensor([[0], [1]], [0, 0], [7]).</h1>
<p>```</p>
<p>Args:
  sp_a: a <code>SparseTensor</code> operand whose dtype is real, and indices
    lexicographically ordered.
  sp_b: the other <code>SparseTensor</code> operand with the same requirements (and the
    same shape).
  name: optional name of the operation.
Returns:
  output: the output SparseTensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_minimum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_minimum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_placeholder">
    <p>def <span class="ident">sparse_placeholder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_placeholder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_placeholder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_placeholder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_placeholder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_placeholder</strong></p>
<div class="codehilite"><pre><span></span>Inserts a placeholder for a sparse tensor that will be always fed.
</pre></div>


<p><strong>Important</strong>: This sparse tensor will produce an error if evaluated.
Its value must be fed using the <code>feed_dict</code> optional argument to
<code>Session.run()</code>, <code>Tensor.eval()</code>, or <code>Operation.run()</code>.</p>
<p>For example:</p>
<p>```python
x = tf.sparse_placeholder(tf.float32)
y = tf.sparse_reduce_sum(x)</p>
<p>with tf.Session() as sess:
  print(sess.run(y))  # ERROR: will fail because x was not fed.</p>
<p>indices = np.array([[3, 2, 0], [4, 5, 1]], dtype=np.int64)
  values = np.array([1.0, 2.0], dtype=np.float32)
  shape = np.array([7, 9, 2], dtype=np.int64)
  print(sess.run(y, feed_dict={
    x: tf.SparseTensorValue(indices, values, shape)}))  # Will succeed.
  print(sess.run(y, feed_dict={
    x: (indices, values, shape)}))  # Will succeed.</p>
<p>sp = tf.SparseTensor(indices=indices, values=values, shape=shape)
  sp_value = sp.eval(session)
  print(sess.run(y, feed_dict={x: sp_value}))  # Will succeed.
```</p>
<p>Args:
  dtype: The type of <code>values</code> elements in the tensor to be fed.
  shape: The shape of the tensor to be fed (optional). If the shape is not
    specified, you can feed a sparse tensor of any shape.
  name: A name for prefixing the operations (optional).</p>
<p>Returns:
  A <code>SparseTensor</code> that may be used as a handle for feeding a value, but not
  evaluated directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_placeholder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_placeholder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reduce_sum">
    <p>def <span class="ident">sparse_reduce_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_reduce_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reduce_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reduce_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_reduce_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reduce_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum of elements across dimensions of a SparseTensor.
</pre></div>


<p>This Op takes a SparseTensor and is the sparse counterpart to
<code>tf.reduce_sum()</code>.  In particular, this Op also returns a dense <code>Tensor</code>
instead of a sparse one.</p>
<p>Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained
with length 1.</p>
<p>If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
similar to the indexing rules in Python.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' represents [[1, ?, 1]</h1>
<h1>[?, 1, ?]]</h1>
<h1>where ? is implicitly-zero.</h1>
<p>tf.sparse_reduce_sum(x) ==&gt; 3
tf.sparse_reduce_sum(x, 0) ==&gt; [1, 1, 1]
tf.sparse_reduce_sum(x, 1) ==&gt; [2, 1]  # Can also use -1 as the axis.
tf.sparse_reduce_sum(x, 1, keep_dims=True) ==&gt; [[2], [1]]
tf.sparse_reduce_sum(x, [0, 1]) ==&gt; 3
```</p>
<p>Args:
  sp_input: The SparseTensor to reduce. Should have numeric type.
  reduction_axes: The dimensions to reduce; list or scalar. If <code>None</code> (the
    default), reduces all dimensions.
  keep_dims: If true, retain reduced dimensions with length 1.</p>
<p>Returns:
  The reduced Tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse">
    <p>def <span class="ident">sparse_reduce_sum_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_reduce_sum_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reduce_sum_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reduce_sum_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_reduce_sum_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reduce_sum_sparse</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum of elements across dimensions of a SparseTensor.
</pre></div>


<p>This Op takes a SparseTensor and is the sparse counterpart to
<code>tf.reduce_sum()</code>.  In contrast to SparseReduceSum, this Op returns a
SparseTensor.</p>
<p>Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained
with length 1.</p>
<p>If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
which are interpreted according to the indexing rules in Python.</p>
<p>Args:
  sp_input: The SparseTensor to reduce. Should have numeric type.
  reduction_axes: The dimensions to reduce; list or scalar. If <code>None</code> (the
    default), reduces all dimensions.
  keep_dims: If true, retain reduced dimensions with length 1.</p>
<p>Returns:
  The reduced SparseTensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reorder">
    <p>def <span class="ident">sparse_reorder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_reorder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reorder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reorder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_reorder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reorder</strong></p>
<div class="codehilite"><pre><span></span>Reorders a `SparseTensor` into the canonical, row-major ordering.
</pre></div>


<p>Note that by convention, all sparse ops preserve the canonical ordering
along increasing dimension number. The only time ordering can be violated
is during manual manipulation of the indices and values to add entries.</p>
<p>Reordering does not affect the shape of the <code>SparseTensor</code>.</p>
<p>For example, if <code>sp_input</code> has shape <code>[4, 5]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 3]: b
[0, 1]: a
[3, 1]: d
[2, 0]: c
</pre></div>


<p>then the output will be a <code>SparseTensor</code> of shape <code>[4, 5]</code> and
<code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A <code>SparseTensor</code> with the same shape and non-empty values, but in
  canonical ordering.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reorder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reorder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reset_shape">
    <p>def <span class="ident">sparse_reset_shape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_reset_shape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reset_shape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reset_shape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_reset_shape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reset_shape</strong></p>
<div class="codehilite"><pre><span></span>Resets the shape of a `SparseTensor` with indices and values unchanged.
</pre></div>


<p>If <code>new_shape</code> is None, returns a copy of <code>sp_input</code> with its shape reset
to the tight bounding box of <code>sp_input</code>.</p>
<p>If <code>new_shape</code> is provided, then it must be larger or equal in all dimensions
compared to the shape of <code>sp_input</code>. When this condition is met, the returned
SparseTensor will have its shape reset to <code>new_shape</code> and its indices and
values unchanged from that of <code>sp_input.</code></p>
<p>For example:</p>
<p>Consider a <code>sp_input</code> with shape [2, 3, 5]:</p>
<div class="codehilite"><pre><span></span>[0, 0, 1]: a
[0, 1, 0]: b
[0, 2, 2]: c
[1, 0, 3]: d
</pre></div>


<ul>
<li>
<p>It is an error to set <code>new_shape</code> as [3, 7] since this represents a
    rank-2 tensor while <code>sp_input</code> is rank-3. This is either a ValueError
    during graph construction (if both shapes are known) or an OpError during
    run time.</p>
</li>
<li>
<p>Setting <code>new_shape</code> as [2, 3, 6] will be fine as this shape is larger or
    equal in every dimension compared to the original shape [2, 3, 5].</p>
</li>
<li>
<p>On the other hand, setting new_shape as [2, 3, 4] is also an error: The
    third dimension is smaller than the original shape [2, 3, 5] (and an
    <code>InvalidArgumentError</code> will be raised).</p>
</li>
<li>
<p>If <code>new_shape</code> is None, the returned SparseTensor will have a shape
    [2, 3, 4], which is the tight bounding box of <code>sp_input</code>.</p>
</li>
</ul>
<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  new_shape: None or a vector representing the new shape for the returned
    <code>SparseTensor</code>.</p>
<p>Returns:
  A <code>SparseTensor</code> indices and values unchanged from <code>input_sp</code>. Its shape is
    <code>new_shape</code> if that is set. Otherwise it is  the tight bounding box of
     <code>input_sp</code></p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.
  ValueError: If <code>new_shape</code> represents a tensor with a different rank from
    that of <code>sp_input</code> (if shapes are known when graph is constructed).
  OpError:
    - If <code>new_shape</code> has dimension sizes that are too small.
    - If shapes are not known during graph construction time, and during run
      time it is found out that the ranks do not match.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reset_shape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reset_shape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reshape">
    <p>def <span class="ident">sparse_reshape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_reshape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reshape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reshape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_reshape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reshape</strong></p>
<div class="codehilite"><pre><span></span>Reshapes a `SparseTensor` to represent values in a new dense shape.
</pre></div>


<p>This operation has the same semantics as <code>reshape</code> on the represented dense
tensor.  The indices of non-empty values in <code>sp_input</code> are recomputed based
on the new dense shape, and a new <code>SparseTensor</code> is returned containing the
new indices and new shape.  The order of non-empty values in <code>sp_input</code> is
unchanged.</p>
<p>If one component of <code>shape</code> is the special value -1, the size of that
dimension is computed so that the total dense size remains constant.  At
most one component of <code>shape</code> can be -1.  The number of dense elements
implied by <code>shape</code> must be the same as the number of dense elements
originally represented by <code>sp_input</code>.</p>
<p>For example, if <code>sp_input</code> has shape <code>[2, 3, 6]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 0, 0]: a
[0, 0, 1]: b
[0, 1, 0]: c
[1, 0, 0]: d
[1, 2, 3]: e
</pre></div>


<p>and <code>shape</code> is <code>[9, -1]</code>, then the output will be a <code>SparseTensor</code> of
shape <code>[9, 4]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 0]: a
[0, 1]: b
[1, 2]: c
[4, 2]: d
[8, 1]: e
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  shape: A 1-D (vector) int64 <code>Tensor</code> specifying the new dense shape of the
    represented <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A <code>SparseTensor</code> with the same non-empty values but with indices calculated
  by the new dense shape.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reshape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reshape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_retain">
    <p>def <span class="ident">sparse_retain</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_retain(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_retain</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_retain(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_retain(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_retain</strong></p>
<div class="codehilite"><pre><span></span>Retains specified non-empty values within a `SparseTensor`.
</pre></div>


<p>For example, if <code>sp_input</code> has shape <code>[4, 5]</code> and 4 non-empty string values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
</pre></div>


<p>and <code>to_retain = [True, False, False, True]</code>, then the output will
be a <code>SparseTensor</code> of shape <code>[4, 5]</code> with 2 non-empty values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[3, 1]: d
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code> with <code>N</code> non-empty elements.
  to_retain: A bool vector of length <code>N</code> with <code>M</code> true values.</p>
<p>Returns:
  A <code>SparseTensor</code> with the same shape as the input and <code>M</code> non-empty
  elements corresponding to the true positions in <code>to_retain</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_retain', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_retain" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_segment_mean">
    <p>def <span class="ident">sparse_segment_mean</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_segment_mean(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_segment_mean</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_segment_mean(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_segment_mean(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_segment_mean</strong></p>
<div class="codehilite"><pre><span></span>Computes the mean along sparse segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Like <code>SegmentMean</code>, but <code>segment_ids</code> can have rank less than <code>data</code>'s first
dimension, selecting a subset of dimension 0, specified by <code>indices</code>.</p>
<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor. Has same rank as <code>segment_ids</code>.
  segment_ids: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D tensor. Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_segment_mean', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_segment_mean" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n">
    <p>def <span class="ident">sparse_segment_sqrt_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_segment_sqrt_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_segment_sqrt_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_segment_sqrt_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_segment_sqrt_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_segment_sqrt_n</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along sparse segments of a tensor divided by the sqrt of N.
</pre></div>


<p>N is the size of the segment being reduced.</p>
<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor. Has same rank as <code>segment_ids</code>.
  segment_ids: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D tensor. Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_segment_sum">
    <p>def <span class="ident">sparse_segment_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_segment_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_segment_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_segment_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_segment_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_segment_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along sparse segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Like <code>SegmentSum</code>, but <code>segment_ids</code> can have rank less than <code>data</code>'s first
dimension, selecting a subset of dimension 0, specified by <code>indices</code>.</p>
<p>For example:</p>
<p>```prettyprint
c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])</p>
<h1>Select two rows, one segment.</h1>
<p>tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
  ==&gt; [[0 0 0 0]]</p>
<h1>Select two rows, two segment.</h1>
<p>tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
  ==&gt; [[ 1  2  3  4]
       [-1 -2 -3 -4]]</p>
<h1>Select all rows, two segments.</h1>
<p>tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
  ==&gt; [[0 0 0 0]
       [5 6 7 8]]</p>
<h1>Which is equivalent to:</h1>
<p>tf.segment_sum(c, tf.constant([0, 0, 1]))
```</p>
<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor. Has same rank as <code>segment_ids</code>.
  segment_ids: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D tensor. Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_segment_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_segment_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax">
    <p>def <span class="ident">sparse_softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_softmax</strong></p>
<div class="codehilite"><pre><span></span>Applies softmax to a batched N-D `SparseTensor`.
</pre></div>


<p>The inputs represent an N-D SparseTensor  with logical shape <code>[..., B, C]</code>
(where <code>N &gt;= 2</code>), and with indices sorted in the canonical lexicographic
order.</p>
<p>This op is equivalent to applying the normal <code>tf.nn.softmax()</code> to each
innermost logical submatrix with shape <code>[B, C]</code>, but with the catch that <em>the
implicitly zero elements do not participate</em>.  Specifically, the algorithm is
equivalent to:</p>
<p>(1) Applies <code>tf.nn.softmax()</code> to a densified view of each innermost
      submatrix with shape <code>[B, C]</code>, along the size-C dimension;
  (2) Masks out the original implicitly-zero locations;
  (3) Renormalizes the remaining elements.</p>
<p>Hence, the <code>SparseTensor</code> result has exactly the same non-zero indices and
shape.</p>
<p>Example:</p>
<p>```python</p>
<h1>First batch:</h1>
<h1>[?   e.]</h1>
<h1>[1.  ? ]</h1>
<h1>Second batch:</h1>
<h1>[e   ? ]</h1>
<h1>[e   e ]</h1>
<p>shape = [2, 2, 2]  # 3-D SparseTensor
values = np.asarray([[[0., np.e], [1., 0.]], [[np.e, 0.], [np.e, np.e]]])
indices = np.vstack(np.where(values)).astype(np.int64).T</p>
<p>result = tf.sparse_softmax(tf.SparseTensor(indices, values, shape))</p>
<h1>...returning a 3-D SparseTensor, equivalent to:</h1>
<h1>[?   1.]     [1    ?]</h1>
<h1>[1.  ? ] and [.5  .5]</h1>
<h1>where ? means implicitly zero.</h1>
<p>```</p>
<p>Args:
  sp_input: N-D <code>SparseTensor</code>, where <code>N &gt;= 2</code>.
  name: optional name of the operation.
Returns:
  output: N-D <code>SparseTensor</code> representing the results.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.sparse_softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.sparse_softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.sparse_softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sparse softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  For this operation, the probability of a given label is considered
exclusive.  That is, soft classes are not allowed, and the <code>labels</code> vector
must provide a single specific index for the true class for each row of
<code>logits</code> (each minibatch entry).  For soft softmax classification with
a probability distribution for each entry, see
<code>softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a softmax
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p>A common use case is to have logits of shape <code>[batch_size, num_classes]</code> and
labels of shape <code>[batch_size]</code>. But higher dimensions are supported.</p>
<p>Args:</p>
<p>logits: Unscaled log probabilities of rank <code>r</code> and shape
    <code>[d_0, d_1, ..., d_{r-2}, num_classes]</code> and dtype <code>float32</code> or <code>float64</code>.
  labels: <code>Tensor</code> of shape <code>[d_0, d_1, ..., d_{r-2}]</code> and dtype <code>int32</code> or
    <code>int64</code>. Each entry in <code>labels</code> must be an index in <code>[0, num_classes)</code>.
    Other values will raise an exception when this op is run on CPU, and
    return <code>NaN</code> for corresponding corresponding loss and gradient rows
    on GPU.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>labels</code> and of the same type as <code>logits</code>
  with the softmax cross entropy loss.</p>
<p>Raises:
  ValueError: If logits are scalars (need to have rank &gt;= 1) or if the rank
    of the labels is not equal to the rank of the labels minus one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sparse_softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_softmax_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sparse_softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_split">
    <p>def <span class="ident">sparse_split</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_split(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_split</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_split(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_split(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_split</strong></p>
<div class="codehilite"><pre><span></span>Split a `SparseTensor` into `num_split` tensors along `split_dim`.
</pre></div>


<p>If the <code>sp_input.shape[split_dim]</code> is not an integer multiple of <code>num_split</code>
each slice starting from 0:<code>shape[split_dim] % num_split</code> gets extra one
dimension. For example, if <code>split_dim = 1</code> and <code>num_split = 2</code> and the
input is:</p>
<div class="codehilite"><pre><span></span>input_tensor = shape = [2, 7]
[    a   d e  ]
[b c          ]
</pre></div>


<p>Graphically the output tensors are:</p>
<div class="codehilite"><pre><span></span>output_tensor[0] =
[    a ]
[b c   ]

output_tensor[1] =
[ d e  ]
[      ]
</pre></div>


<p>Args:
  split_dim: A 0-D <code>int32</code> <code>Tensor</code>. The dimension along which to split.
  num_split: A Python integer. The number of ways to split.
  sp_input: The <code>SparseTensor</code> to split.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>num_split</code> <code>SparseTensor</code> objects resulting from splitting <code>value</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_split', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_split" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul">
    <p>def <span class="ident">sparse_tensor_dense_matmul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_tensor_dense_matmul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_tensor_dense_matmul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_tensor_dense_matmul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_tensor_dense_matmul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_tensor_dense_matmul</strong></p>
<div class="codehilite"><pre><span></span>Multiply SparseTensor (of rank 2) &quot;A&quot; by dense matrix &quot;B&quot;.
</pre></div>


<p>No validity checking is performed on the indices of A.  However, the following
input format is recommended for optimal behavior:</p>
<p>if adjoint_a == false:
  A should be sorted in lexicographically increasing order.  Use
  sparse_reorder if you're not sure.
if adjoint_a == true:
  A should be sorted in order of increasing dimension 1 (i.e., "column major"
  order instead of "row major" order).</p>
<p>Deciding when to use sparse_tensor_dense_matmul vs. matmul(sp_a=True):</p>
<p>There are a number of questions to ask in the decision process, including:</p>
<ul>
<li>Will the SparseTensor A fit in memory if densified?</li>
<li>Is the column count of the product large (&gt;&gt; 1)?</li>
<li>Is the density of A larger than approximately 15%?</li>
</ul>
<p>If the answer to several of these questions is yes, consider
converting the SparseTensor to a dense one and using tf.matmul with sp_a=True.</p>
<p>This operation tends to perform well when A is more sparse, if the column size
of the product is small (e.g. matrix-vector multiplication), if sp_a.shape
takes on large values.</p>
<p>Below is a rough speed comparison between sparse_tensor_dense_matmul,
labelled 'sparse', and matmul(sp_a=True), labelled 'dense'.  For purposes of
the comparison, the time spent converting from a SparseTensor to a dense
Tensor is not included, so it is overly conservative with respect to
the time ratio.</p>
<p>Benchmark system:
CPU: Intel Ivybridge with HyperThreading (6 cores) dL1:32KB dL2:256KB dL3:12MB
GPU: NVidia Tesla k40c</p>
<p>Compiled with:
-c opt --config=cuda --copt=-mavx</p>
<p>```tensorflow/python/sparse_tensor_dense_matmul_op_test --benchmarks
A sparse [m, k] with % nonzero values between 1% and 80%
B dense [k, n]</p>
<p>% nnz    n       gpu     m       k       dt(dense)       dt(sparse)      dt(sparse)/dt(dense)
0.01     1       True    100     100     0.000221166     0.00010154      0.459112
0.01     1       True    100     1000    0.00033858      0.000109275     0.322745
0.01     1       True    1000    100     0.000310557     9.85661e-05     0.317385
0.01     1       True    1000    1000    0.0008721       0.000100875     0.115669
0.01     1       False   100     100     0.000208085     0.000107603     0.51711
0.01     1       False   100     1000    0.000327112     9.51118e-05     0.290762
0.01     1       False   1000    100     0.000308222     0.00010345      0.335635
0.01     1       False   1000    1000    0.000865721     0.000101397     0.117124
0.01     10      True    100     100     0.000218522     0.000105537     0.482958
0.01     10      True    100     1000    0.000340882     0.000111641     0.327506
0.01     10      True    1000    100     0.000315472     0.000117376     0.372064
0.01     10      True    1000    1000    0.000905493     0.000123263     0.136128
0.01     10      False   100     100     0.000221529     9.82571e-05     0.44354
0.01     10      False   100     1000    0.000330552     0.000112615     0.340687
0.01     10      False   1000    100     0.000341277     0.000114097     0.334324
0.01     10      False   1000    1000    0.000819944     0.000120982     0.147549
0.01     25      True    100     100     0.000207806     0.000105977     0.509981
0.01     25      True    100     1000    0.000322879     0.00012921      0.400181
0.01     25      True    1000    100     0.00038262      0.000141583     0.370035
0.01     25      True    1000    1000    0.000865438     0.000202083     0.233504
0.01     25      False   100     100     0.000209401     0.000104696     0.499979
0.01     25      False   100     1000    0.000321161     0.000130737     0.407076
0.01     25      False   1000    100     0.000377012     0.000136801     0.362856
0.01     25      False   1000    1000    0.000861125     0.00020272      0.235413
0.2      1       True    100     100     0.000206952     9.69219e-05     0.46833
0.2      1       True    100     1000    0.000348674     0.000147475     0.422959
0.2      1       True    1000    100     0.000336908     0.00010122      0.300439
0.2      1       True    1000    1000    0.001022        0.000203274     0.198898
0.2      1       False   100     100     0.000207532     9.5412e-05      0.459746
0.2      1       False   100     1000    0.000356127     0.000146824     0.41228
0.2      1       False   1000    100     0.000322664     0.000100918     0.312764
0.2      1       False   1000    1000    0.000998987     0.000203442     0.203648
0.2      10      True    100     100     0.000211692     0.000109903     0.519165
0.2      10      True    100     1000    0.000372819     0.000164321     0.440753
0.2      10      True    1000    100     0.000338651     0.000144806     0.427596
0.2      10      True    1000    1000    0.00108312      0.000758876     0.70064
0.2      10      False   100     100     0.000215727     0.000110502     0.512231
0.2      10      False   100     1000    0.000375419     0.0001613       0.429653
0.2      10      False   1000    100     0.000336999     0.000145628     0.432132
0.2      10      False   1000    1000    0.00110502      0.000762043     0.689618
0.2      25      True    100     100     0.000218705     0.000129913     0.594009
0.2      25      True    100     1000    0.000394794     0.00029428      0.745402
0.2      25      True    1000    100     0.000404483     0.0002693       0.665788
0.2      25      True    1000    1000    0.0012002       0.00194494      1.62052
0.2      25      False   100     100     0.000221494     0.0001306       0.589632
0.2      25      False   100     1000    0.000396436     0.000297204     0.74969
0.2      25      False   1000    100     0.000409346     0.000270068     0.659754
0.2      25      False   1000    1000    0.00121051      0.00193737      1.60046
0.5      1       True    100     100     0.000214981     9.82111e-05     0.456836
0.5      1       True    100     1000    0.000415328     0.000223073     0.537101
0.5      1       True    1000    100     0.000358324     0.00011269      0.314492
0.5      1       True    1000    1000    0.00137612      0.000437401     0.317851
0.5      1       False   100     100     0.000224196     0.000101423     0.452386
0.5      1       False   100     1000    0.000400987     0.000223286     0.556841
0.5      1       False   1000    100     0.000368825     0.00011224      0.304318
0.5      1       False   1000    1000    0.00136036      0.000429369     0.31563
0.5      10      True    100     100     0.000222125     0.000112308     0.505608
0.5      10      True    100     1000    0.000461088     0.00032357      0.701753
0.5      10      True    1000    100     0.000394624     0.000225497     0.571422
0.5      10      True    1000    1000    0.00158027      0.00190898      1.20801
0.5      10      False   100     100     0.000232083     0.000114978     0.495418
0.5      10      False   100     1000    0.000454574     0.000324632     0.714146
0.5      10      False   1000    100     0.000379097     0.000227768     0.600817
0.5      10      False   1000    1000    0.00160292      0.00190168      1.18638
0.5      25      True    100     100     0.00023429      0.000151703     0.647501
0.5      25      True    100     1000    0.000497462     0.000598873     1.20386
0.5      25      True    1000    100     0.000460778     0.000557038     1.20891
0.5      25      True    1000    1000    0.00170036      0.00467336      2.74845
0.5      25      False   100     100     0.000228981     0.000155334     0.678371
0.5      25      False   100     1000    0.000496139     0.000620789     1.25124
0.5      25      False   1000    100     0.00045473      0.000551528     1.21287
0.5      25      False   1000    1000    0.00171793      0.00467152      2.71927
0.8      1       True    100     100     0.000222037     0.000105301     0.47425
0.8      1       True    100     1000    0.000410804     0.000329327     0.801664
0.8      1       True    1000    100     0.000349735     0.000131225     0.375212
0.8      1       True    1000    1000    0.00139219      0.000677065     0.48633
0.8      1       False   100     100     0.000214079     0.000107486     0.502085
0.8      1       False   100     1000    0.000413746     0.000323244     0.781261
0.8      1       False   1000    100     0.000348983     0.000131983     0.378193
0.8      1       False   1000    1000    0.00136296      0.000685325     0.50282
0.8      10      True    100     100     0.000229159     0.00011825      0.516017
0.8      10      True    100     1000    0.000498845     0.000532618     1.0677
0.8      10      True    1000    100     0.000383126     0.00029935      0.781336
0.8      10      True    1000    1000    0.00162866      0.00307312      1.88689
0.8      10      False   100     100     0.000230783     0.000124958     0.541452
0.8      10      False   100     1000    0.000493393     0.000550654     1.11606
0.8      10      False   1000    100     0.000377167     0.000298581     0.791642
0.8      10      False   1000    1000    0.00165795      0.00305103      1.84024
0.8      25      True    100     100     0.000233496     0.000175241     0.75051
0.8      25      True    100     1000    0.00055654      0.00102658      1.84458
0.8      25      True    1000    100     0.000463814     0.000783267     1.68875
0.8      25      True    1000    1000    0.00186905      0.00755344      4.04132
0.8      25      False   100     100     0.000240243     0.000175047     0.728625
0.8      25      False   100     1000    0.000578102     0.00104499      1.80763
0.8      25      False   1000    100     0.000485113     0.000776849     1.60138
0.8      25      False   1000    1000    0.00211448      0.00752736      3.55992
```</p>
<p>Args:
  sp_a: SparseTensor A, of rank 2.
  b: A dense Matrix with the same dtype as sp_a.
  adjoint_a: Use the adjoint of A in the matrix multiply.  If A is complex,
    this is transpose(conj(A)).  Otherwise it's transpose(A).
  adjoint_b: Use the adjoint of B in the matrix multiply.  If B is complex,
    this is transpose(conj(B)).  Otherwise it's transpose(B).
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A dense matrix (pseudo-code in dense np.matrix notation):
    A = A.H if adjoint_a else A
    B = B.H if adjoint_b else B
    return A*B</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense">
    <p>def <span class="ident">sparse_tensor_to_dense</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_tensor_to_dense(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_tensor_to_dense</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_tensor_to_dense(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_tensor_to_dense(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_tensor_to_dense</strong></p>
<div class="codehilite"><pre><span></span>Converts a `SparseTensor` into a dense tensor.
</pre></div>


<p>This op is a convenience wrapper around <code>sparse_to_dense</code> for <code>SparseTensor</code>s.</p>
<p>For example, if <code>sp_input</code> has shape <code>[3, 5]</code> and non-empty string values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
</pre></div>


<p>and <code>default_value</code> is <code>x</code>, then the output will be a dense <code>[3, 5]</code>
string tensor with values:</p>
<div class="codehilite"><pre><span></span><span class="k">[[x a x b x]</span>
 <span class="k">[x x x x x]</span>
 <span class="k">[c x x x x]]</span>
</pre></div>


<p>Indices must be without repeats.  This is only
tested if validate_indices is True.</p>
<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  default_value: Scalar value to set for indices not specified in
    <code>sp_input</code>.  Defaults to zero.
  validate_indices: A boolean value.  If <code>True</code>, indices are checked to make
    sure they are sorted in lexicographic order and that there are no repeats.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A dense tensor with shape <code>sp_input.shape</code> and values specified by
  the non-empty values in <code>sp_input</code>. Indices not in <code>sp_input</code> are assigned
  <code>default_value</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_to_dense">
    <p>def <span class="ident">sparse_to_dense</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_to_dense(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_to_dense</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_to_dense(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_to_dense(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_to_dense</strong></p>
<div class="codehilite"><pre><span></span>Converts a sparse representation into a dense tensor.
</pre></div>


<p>Builds an array <code>dense</code> with shape <code>output_shape</code> such that</p>
<p>```python</p>
<h1>If sparse_indices is scalar</h1>
<p>dense[i] = (i == sparse_indices ? sparse_values : default_value)</p>
<h1>If sparse_indices is a vector, then for each i</h1>
<p>dense[sparse_indices[i]] = sparse_values[i]</p>
<h1>If sparse_indices is an n by d matrix, then for each i in [0, n)</h1>
<p>dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
```</p>
<p>All other values in <code>dense</code> are set to <code>default_value</code>.  If <code>sparse_values</code>
is a scalar, all sparse indices are set to this single value.</p>
<p>Indices should be sorted in lexicographic order, and indices must not
contain any repeats. If <code>validate_indices</code> is True, these properties
are checked during execution.</p>
<p>Args:
  sparse_indices: A 0-D, 1-D, or 2-D <code>Tensor</code> of type <code>int32</code> or <code>int64</code>.
    <code>sparse_indices[i]</code> contains the complete index where <code>sparse_values[i]</code>
    will be placed.
  output_shape: A 1-D <code>Tensor</code> of the same type as <code>sparse_indices</code>.  Shape
    of the dense output tensor.
  sparse_values: A 0-D or 1-D <code>Tensor</code>.  Values corresponding to each row of
    <code>sparse_indices</code>, or a scalar value to be used for all sparse indices.
  default_value: A 0-D <code>Tensor</code> of the same type as <code>sparse_values</code>.  Value
    to set for indices not specified in <code>sparse_indices</code>.  Defaults to zero.
  validate_indices: A boolean value.  If True, indices are checked to make
    sure they are sorted in lexicographic order and that there are no repeats.
  name: A name for the operation (optional).</p>
<p>Returns:
  Dense <code>Tensor</code> of shape <code>output_shape</code>.  Has the same type as
  <code>sparse_values</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_to_dense', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_to_dense" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_to_indicator">
    <p>def <span class="ident">sparse_to_indicator</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_to_indicator(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_to_indicator</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_to_indicator(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_to_indicator(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_to_indicator</strong></p>
<div class="codehilite"><pre><span></span>Converts a `SparseTensor` of ids into a dense bool indicator tensor.
</pre></div>


<p>The last dimension of <code>sp_input.indices</code> is discarded and replaced with
the values of <code>sp_input</code>.  If <code>sp_input.shape = [D0, D1, ..., Dn, K]</code>, then
<code>output.shape = [D0, D1, ..., Dn, vocab_size]</code>, where</p>
<div class="codehilite"><pre><span></span>output[d_0, d_1, ..., d_n, sp_input[d_0, d_1, ..., d_n, k]] = True
</pre></div>


<p>and False elsewhere in <code>output</code>.</p>
<p>For example, if <code>sp_input.shape = [2, 3, 4]</code> with non-empty values:</p>
<div class="codehilite"><pre><span></span>[0, 0, 0]: 0
[0, 1, 0]: 10
[1, 0, 3]: 103
[1, 1, 2]: 150
[1, 1, 3]: 149
[1, 1, 4]: 150
[1, 2, 1]: 121
</pre></div>


<p>and <code>vocab_size = 200</code>, then the output will be a <code>[2, 3, 200]</code> dense bool
tensor with False everywhere except at positions</p>
<div class="codehilite"><pre><span></span>(0, 0, 0), (0, 1, 10), (1, 0, 103), (1, 1, 149), (1, 1, 150),
(1, 2, 121).
</pre></div>


<p>Note that repeats are allowed in the input SparseTensor.
This op is useful for converting <code>SparseTensor</code>s into dense formats for
compatibility with ops that expect dense tensors.</p>
<p>The input <code>SparseTensor</code> must be in row-major order.</p>
<p>Args:
  sp_input: A <code>SparseTensor</code> with <code>values</code> property of type <code>int32</code> or
    <code>int64</code>.
  vocab_size: A scalar int64 Tensor (or Python int) containing the new size
    of the last dimension, <code>all(0 &lt;= sp_input.values &lt; vocab_size)</code>.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A dense bool indicator tensor representing the indices with specified value.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_to_indicator', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_to_indicator" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_transpose">
    <p>def <span class="ident">sparse_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sparse_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sparse_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_transpose</strong></p>
<div class="codehilite"><pre><span></span>Transposes a `SparseTensor`
</pre></div>


<p>The returned tensor's dimension i will correspond to the input dimension
<code>perm[i]</code>. If <code>perm</code> is not given, it is set to (n-1...0), where n is
the rank of the input tensor. Hence by default, this operation performs a
regular matrix transpose on 2-D input Tensors.</p>
<p>For example, if <code>sp_input</code> has shape <code>[4, 5]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 3]: b
[0, 1]: a
[3, 1]: d
[2, 0]: c
</pre></div>


<p>then the output will be a <code>SparseTensor</code> of shape <code>[5, 4]</code> and
<code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 2]: c
[1, 0]: a
[1, 3]: d
[3, 0]: b
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  perm: A permutation of the dimensions of <code>sp_input</code>.
  name: A name prefix for the returned tensors (optional)
Returns:
  A transposed <code>SparseTensor</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.split">
    <p>def <span class="ident">split</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.split(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.split</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.split(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.split(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.split</strong></p>
<div class="codehilite"><pre><span></span>Splits a tensor into `num_split` tensors along one dimension.
</pre></div>


<p>Splits <code>value</code> along dimension <code>split_dim</code> into <code>num_split</code> smaller tensors.
Requires that <code>num_split</code> evenly divide <code>value.shape[split_dim]</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'value' is a tensor with shape [5, 30]</h1>
<h1>Split 'value' into 3 tensors along dimension 1</h1>
<p>split0, split1, split2 = tf.split(1, 3, value)
tf.shape(split0) ==&gt; [5, 10]
```</p>
<p>Note: If you are splitting along an axis by the length of that axis, consider
using unpack, e.g.</p>
<p><code>python
num_items = t.get_shape()[axis].value
[tf.squeeze(s, [axis]) for s in tf.split(axis, num_items, t)]</code></p>
<p>can be rewritten as</p>
<p><code>python
tf.unpack(t, axis=axis)</code></p>
<p>Args:
  split_dim: A 0-D <code>int32</code> <code>Tensor</code>. The dimension along which to split.
    Must be in the range <code>[0, rank(value))</code>.
  num_split: A Python integer. The number of ways to split.
  value: The <code>Tensor</code> to split.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>num_split</code> <code>Tensor</code> objects resulting from splitting <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.split', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.split" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sqrt">
    <p>def <span class="ident">sqrt</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sqrt(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sqrt</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sqrt(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sqrt(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sqrt</strong></p>
<div class="codehilite"><pre><span></span>Computes square root of x element-wise.
</pre></div>


<p>I.e., (y = \sqrt{x} = x^{1/2}).</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sqrt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sqrt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.square">
    <p>def <span class="ident">square</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.square(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.square</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.square(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.square(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.square</strong></p>
<div class="codehilite"><pre><span></span>Computes square of x element-wise.
</pre></div>


<p>I.e., (y = x * x = x^2).</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.square', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.square" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.squared_difference">
    <p>def <span class="ident">squared_difference</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.squared_difference(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.squared_difference</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.squared_difference(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.squared_difference(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.squared_difference</strong></p>
<div class="codehilite"><pre><span></span>Returns (x - y)(x - y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>SquaredDifference</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.squared_difference', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.squared_difference" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.squeeze">
    <p>def <span class="ident">squeeze</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.squeeze(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.squeeze</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.squeeze(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.squeeze(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.squeeze</strong></p>
<div class="codehilite"><pre><span></span>Removes dimensions of size 1 from the shape of a tensor.
</pre></div>


<p>Given a tensor <code>input</code>, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don't want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
<code>squeeze_dims</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1>
<p>shape(squeeze(t)) ==&gt; [2, 3]
```</p>
<p>Or, to remove specific size 1 dimensions:</p>
<p>```prettyprint</p>
<h1>'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1>
<p>shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1]
```</p>
<p>Args:
  input: A <code>Tensor</code>. The <code>input</code> to squeeze.
  squeeze_dims: An optional list of <code>ints</code>. Defaults to <code>[]</code>.
    If specified, only squeezes the dimensions listed. The dimension
    index starts at 0. It is an error to squeeze a dimension that is not 1.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Contains the same data as <code>input</code>, but has one or more dimensions of
  size 1 removed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.squeeze', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.squeeze" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.state_saving_rnn">
    <p>def <span class="ident">state_saving_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.state_saving_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.state_saving_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.state_saving_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.state_saving_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.state_saving_rnn</strong></p>
<div class="codehilite"><pre><span></span>RNN that accepts a state saver for time-truncated RNN calculation.
</pre></div>


<p>Args:
  cell: An instance of <code>RNNCell</code>.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>.
  state_saver: A state saver object with methods <code>state</code> and <code>save_state</code>.
  state_name: Python string or tuple of strings.  The name to use with the
    state_saver. If the cell returns tuples of states (i.e.,
    <code>cell.state_size</code> is a tuple) then <code>state_name</code> should be a tuple of
    strings having the same length as <code>cell.state_size</code>.  Otherwise it should
    be a single string.
  sequence_length: (optional) An int32/int64 vector size [batch_size].
    See the documentation for rnn() for more details about sequence_length.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:
    outputs is a length T list of outputs (one for each input)
    states is the final state</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the arity and
   type of <code>state_name</code> does not match that of <code>cell.state_size</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.state_saving_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.state_saving_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer">
    <p>def <span class="ident">state_saving_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.state_saving_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.state_saving_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.state_saving_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer">
    <p>def <span class="ident">state_saving_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.state_saving_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.state_saving_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.state_saving_rnn`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.stop_gradient">
    <p>def <span class="ident">stop_gradient</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.stop_gradient(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.stop_gradient</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.stop_gradient(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.stop_gradient(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.stop_gradient</strong></p>
<div class="codehilite"><pre><span></span>Stops gradient computation.
</pre></div>


<p>When executed in a graph, this op outputs its input tensor as-is.</p>
<p>When building ops to compute gradients, this op prevents the contribution of
its inputs to be taken into account.  Normally, the gradient generator adds ops
to a graph to compute the derivatives of a specified 'loss' by recursively
finding out inputs that contributed to its computation.  If you insert this op
in the graph it inputs are masked from the gradient generator.  They are not
taken into account for computing gradients.</p>
<p>This is useful any time you want to compute a value with TensorFlow but need
to pretend that the value was a constant. Some examples include:</p>
<ul>
<li>The <em>EM</em> algorithm where the <em>M-step</em> should not involve backpropagation
   through the output of the <em>E-step</em>.</li>
<li>Contrastive divergence training of Boltzmann machines where, when
   differentiating the energy function, the training must not backpropagate
   through the graph that generated the samples from the model.</li>
<li>Adversarial training, where no backprop should happen through the adversarial
   example generation process.</li>
</ul>
<p>Args:
  input: A <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.stop_gradient', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.stop_gradient" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.strided_slice">
    <p>def <span class="ident">strided_slice</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.strided_slice(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.strided_slice</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.strided_slice(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.strided_slice(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.strided_slice</strong></p>
<div class="codehilite"><pre><span></span>Extracts a strided slice from a tensor.
</pre></div>


<p>To a first order, this operation extracts a slice of size <code>end - begin</code>
from a tensor <code>input</code>
starting at the location specified by <code>begin</code>. The slice continues by adding
<code>stride</code> to the <code>begin</code> index until all dimensions are not less than <code>end</code>.
Note that components of stride can be negative, which causes a reverse
slice.</p>
<p>This operation can be thought of an encoding of a numpy style sliced
range. Given a python slice input[<spec0>, <spec1>, ..., <specn>]
this function will be called as follows.</p>
<p><code>begin</code>, <code>end</code>, and <code>strides</code> will be all length n. n is in general
not the same dimensionality as <code>input</code>.</p>
<p>For the ith spec,
<code>begin_mask</code>, <code>end_mask</code>, <code>ellipsis_mask</code>, <code>new_axis_mask</code>,
and <code>shrink_axis_mask</code> will have the ith bit corresponding to
the ith spec.</p>
<p>If the ith bit of <code>begin_mask</code> is non-zero, <code>begin[i]</code> is ignored and
the fullest possible range in that dimension is used instead.
<code>end_mask</code> works analogously, except with the end range.</p>
<p><code>foo[5:,:,:3]</code> on a 7x8x9 tensor is equivalent to <code>foo[5:7,0:8,0:3]</code>.
<code>foo[::-1]</code> reverses a tensor with shape 8.</p>
<p>If the ith bit of <code>ellipsis_mask</code>, as many unspecified dimensions
as needed will be inserted between other dimensions. Only one
non-zero bit is allowed in <code>ellipsis_mask</code>.</p>
<p>For example <code>foo[3:5,...,4:5]</code> on a shape 10x3x3x10 tensor is
equivalent to <code>foo[3:5,:,:,4:5]</code> and
<code>foo[3:5,...]</code> is equivalent to <code>foo[3:5,:,:,:]</code>.</p>
<p>If the ith bit of <code>new_axis_mask</code> is one, then a <code>begin</code>,
<code>end</code>, and <code>stride</code> are ignored and a new length 1 dimension is
added at this point in the output tensor.</p>
<p>For example <code>foo[3:5,4]</code> on a 10x8 tensor produces a shape 2 tensor
whereas <code>foo[3:5,4:5]</code> produces a shape 2x1 tensor with shrink_mask
being 1&lt;&lt;1 == 2.</p>
<p>If the ith bit of <code>shrink_axis_mask</code> is one, then <code>begin</code>,
<code>end[i]</code>, and <code>stride[i]</code> are used to do a slice in the appropriate
dimension, but the output tensor will be reduced in dimensionality
by one. This is only valid if the ith entry of slice[i]==1.</p>
<p>NOTE: <code>begin</code> and <code>end</code> are zero-indexed<code>.</code>strides` entries must be non-zero.</p>
<p>```</p>
<h1>'input' is [[[1, 1, 1], [2, 2, 2]],</h1>
<h1>[[3, 3, 3], [4, 4, 4]],</h1>
<h1>[[5, 5, 5], [6, 6, 6]]]</h1>
<p>tf.slice(input, [1, 0, 0], [2, 1, 3], [1, 1, 1]) ==&gt; [[[3, 3, 3]]]
tf.slice(input, [1, 0, 0], [2, 2, 3], [1, 1, 1]) ==&gt; [[[3, 3, 3],
                                                       [4, 4, 4]]]
tf.slice(input, [1, 1, 0], [2, -1, 3], [1, -1, 1]) ==&gt;[[[4, 4, 4],
                                                        [3, 3, 3]]]
```</p>
<p>Args:
  input_: A <code>Tensor</code>.
  begin: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  end: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  strides: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  begin_mask: An <code>int32</code> mask.
  end_mask: An <code>int32</code> mask.
  ellipsis_mask: An <code>int32</code> mask.
  new_axis_mask: An <code>int32</code> mask.
  shrink_axis_mask: An <code>int32</code> mask.
  var: The variable coresponding to <code>input_</code> or None
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.strided_slice', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.strided_slice" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_join">
    <p>def <span class="ident">string_join</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.string_join(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_join</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_join(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.string_join(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_join</strong></p>
<div class="codehilite"><pre><span></span>Joins the strings in the given list of string tensors into one tensor;
</pre></div>


<p>with the given separator (default is an empty separator).</p>
<p>Args:
  inputs: A list of at least 1 <code>Tensor</code> objects of type <code>string</code>.
    A list of string tensors.  The tensors must all have the same shape,
    or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
    of non-scalar inputs.
  separator: An optional <code>string</code>. Defaults to <code>""</code>.
    string, an optional join separator.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_join', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_join" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_split">
    <p>def <span class="ident">string_split</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.string_split(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_split</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_split(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.string_split(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_split</strong></p>
<div class="codehilite"><pre><span></span>Split elements of `source` based on `delimiter` into a `SparseTensor`.
</pre></div>


<p>Let N be the size of source (typically N will be the batch size). Split each
element of <code>source</code> based on <code>delimiter</code> and return a <code>SparseTensor</code>
containing the splitted tokens. Empty tokens are ignored.</p>
<p>If <code>delimiter</code> is an empty string, each element of the <code>source</code> is split
into individual 1 character strings.</p>
<p>For example:
N = 2, source[0] is 'hello world' and source[1] is 'a b c', then the output
will be</p>
<p>st.indices = [0, 0;
              0, 1;
              1, 0;
              1, 1;
              1, 2]
st.shape = [2, 3]
st.values = ['hello', 'world', 'a', 'b', 'c']</p>
<p>Args:
  source: <code>1-D</code> string <code>Tensor</code>, the strings to split.
  delimiter: <code>0-D</code> string <code>Tensor</code>, the delimiter character, the string should
    be length 0 or 1.</p>
<p>Returns:
  A <code>SparseTensor</code> of rank <code>2</code>, the strings split according to the delimiter.
  The first column of the indices corresponds to the row in <code>source</code> and the
  second column corresponds to the index of the split component in this row.</p>
<p>Raises:
  ValueError: If delimiter is not a character.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_split', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_split" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_hash_bucket">
    <p>def <span class="ident">string_to_hash_bucket</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.string_to_hash_bucket(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_hash_bucket</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_hash_bucket(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.string_to_hash_bucket(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_hash_bucket</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to its hash mod by a number of buckets.
</pre></div>


<p>The hash function is deterministic on the content of the string within the
process.</p>
<p>Note that the hash function may change from time to time.
This functionality will be deprecated and it's recommended to use
<code>tf.string_to_hash_bucket_fast()</code> or <code>tf.string_to_hash_bucket_strong()</code>.</p>
<p>Args:
  string_tensor: A <code>Tensor</code> of type <code>string</code>.
  num_buckets: An <code>int</code> that is <code>&gt;= 1</code>. The number of buckets.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast">
    <p>def <span class="ident">string_to_hash_bucket_fast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.string_to_hash_bucket_fast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_hash_bucket_fast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_hash_bucket_fast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.string_to_hash_bucket_fast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_hash_bucket_fast</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to its hash mod by a number of buckets.
</pre></div>


<p>The hash function is deterministic on the content of the string within the
process and will never change. However, it is not suitable for cryptography.
This function may be used when CPU time is scarce and inputs are trusted or
unimportant. There is a risk of adversaries constructing inputs that all hash
to the same bucket. To prevent this problem, use a strong hash function with
<code>tf.string_to_hash_bucket_strong</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. The strings to assign a hash bucket.
  num_buckets: An <code>int</code> that is <code>&gt;= 1</code>. The number of buckets.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong">
    <p>def <span class="ident">string_to_hash_bucket_strong</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.string_to_hash_bucket_strong(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_hash_bucket_strong</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_hash_bucket_strong(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.string_to_hash_bucket_strong(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_hash_bucket_strong</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to its hash mod by a number of buckets.
</pre></div>


<p>The hash function is deterministic on the content of the string within the
process. The hash function is a keyed hash function, where attribute <code>key</code>
defines the key of the hash function. <code>key</code> is an array of 2 elements.</p>
<p>A strong hash is important when inputs may be malicious, e.g. URLs with
additional components. Adversaries could try to make their inputs hash to the
same bucket for a denial-of-service attack or to skew the results. A strong
hash prevents this by making it dificult, if not infeasible, to compute inputs
that hash to the same bucket. This comes at a cost of roughly 4x higher compute
time than tf.string_to_hash_bucket_fast.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. The strings to assign a hash bucket.
  num_buckets: An <code>int</code> that is <code>&gt;= 1</code>. The number of buckets.
  key: A list of <code>ints</code>.
    The key for the keyed hash function passed as a list of two uint64
    elements.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_number">
    <p>def <span class="ident">string_to_number</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.string_to_number(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_number</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_number(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.string_to_number(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_number</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to the specified numeric type.
</pre></div>


<p>(Note that int32 overflow results in an error while float overflow
results in a rounded value.)</p>
<p>Args:
  string_tensor: A <code>Tensor</code> of type <code>string</code>.
  out_type: An optional <code>tf.DType</code> from: <code>tf.float32, tf.int32</code>. Defaults to <code>tf.float32</code>.
    The numeric type to interpret each string in string_tensor as.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_number', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_number" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sub">
    <p>def <span class="ident">sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sub</strong></p>
<div class="codehilite"><pre><span></span>Returns x - y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Sub</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sufficient_statistics">
    <p>def <span class="ident">sufficient_statistics</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sufficient_statistics(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.sufficient_statistics</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.sufficient_statistics(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sufficient_statistics(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.sufficient_statistics</strong></p>
<div class="codehilite"><pre><span></span>Calculate the sufficient statistics for the mean and variance of `x`.
</pre></div>


<p>These sufficient statistics are computed using the one pass algorithm on
an input that's optionally shifted. See:
https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</p>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints. Axes along which to compute mean and variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  keep_dims: produce statistics with the same dimensionality as the input.
  name: Name used to scope the operations that compute the sufficient stats.</p>
<p>Returns:
  Four <code>Tensor</code> objects of the same type as <code>x</code>:
  * the count (number of elements to average over).
  * the (possibly shifted) sum of the elements in the array.
  * the (possibly shifted) sum of squares of the elements in the array.
  * the shift by which the mean must be corrected or None if <code>shift</code> is None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sufficient_statistics', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sufficient_statistics" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer">
    <p>def <span class="ident">sufficient_statistics_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sufficient_statistics_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sufficient_statistics_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sufficient_statistics`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer">
    <p>def <span class="ident">sufficient_statistics_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.sufficient_statistics_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.sufficient_statistics_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sufficient_statistics`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.svd">
    <p>def <span class="ident">svd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.svd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.svd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.svd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.svd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.svd</strong></p>
<div class="codehilite"><pre><span></span>Computes the singular value decompositions of one or more matrices.
</pre></div>


<p>Computes the SVD of each inner matrix in <code>tensor</code> such that
<code>tensor[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :,
:])</code></p>
<p>```prettyprint</p>
<h1>a is a tensor.</h1>
<h1>s is a tensor of singular values.</h1>
<h1>u is a tensor of left singular vectors.</h1>
<h1>v is a tensor of right singular vectors.</h1>
<p>s, u, v = svd(a)
s = svd(a, compute_uv=False)
```</p>
<p>Args:
  matrix: <code>Tensor</code> of shape <code>[..., M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and
    <code>N</code>.
  compute_uv: If <code>True</code> then left and right singular vectors will be
    computed and returned in <code>u</code> and <code>v</code>, respectively. Otherwise, only the
    singular values will be computed, which can be significantly faster.
  full_matrices: If true, compute full-sized <code>u</code> and <code>v</code>. If false
    (the default), compute only the leading <code>P</code> singular vectors.
    Ignored if <code>compute_uv</code> is <code>False</code>.
  name: string, optional name of the operation.</p>
<p>Returns:
  s: Singular values. Shape is <code>[..., P]</code>.
  u: Right singular vectors. If <code>full_matrices</code> is <code>False</code> (default) then
    shape is <code>[..., M, P]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
    <code>[..., M, M]</code>. Not returned if <code>compute_uv</code> is <code>False</code>.
  v: Left singular vectors. If <code>full_matrices</code> is <code>False</code> (default) then
    shape is <code>[..., N, P]</code>. If <code>full_matrices</code> is <code>True</code> then shape is
    <code>[..., N, N]</code>. Not returned if <code>compute_uv</code> is <code>False</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.svd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.svd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tan">
    <p>def <span class="ident">tan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.tan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.tan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.tan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.tan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.tan</strong></p>
<div class="codehilite"><pre><span></span>Computes tan of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tanh">
    <p>def <span class="ident">tanh</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.tanh(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.tanh</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.tanh(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.tanh(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.tanh</strong></p>
<div class="codehilite"><pre><span></span>Computes hyperbolic tangent of `x` element-wise.
</pre></div>


<p>Args:
  x: A Tensor or SparseTensor with type <code>float</code>, <code>double</code>, <code>int32</code>,
    <code>complex64</code>, <code>int64</code>, or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor or SparseTensor respectively with the same type as <code>x</code> if
  <code>x.dtype != qint32</code> otherwise the return type is <code>quint8</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tanh', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tanh" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer">
    <p>def <span class="ident">tanh_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.tanh_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.tanh_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.tanh`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tanh_layer">
    <p>def <span class="ident">tanh_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.tanh_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.tanh_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.tanh`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tanh_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tanh_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tile">
    <p>def <span class="ident">tile</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.tile(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.tile</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.tile(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.tile(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.tile</strong></p>
<div class="codehilite"><pre><span></span>Constructs a tensor by tiling a given tensor.
</pre></div>


<p>This operation creates a new tensor by replicating <code>input</code> <code>multiples</code> times.
The output tensor's i'th dimension has <code>input.dims(i) * multiples[i]</code> elements,
and the values of <code>input</code> are replicated <code>multiples[i]</code> times along the 'i'th
dimension. For example, tiling <code>[a b c d]</code> by <code>[2]</code> produces
<code>[a b c d a b c d]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. 1-D or higher.
  multiples: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D. Length must be the same as the number of dimensions in <code>input</code>
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tile', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tile" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_bfloat16">
    <p>def <span class="ident">to_bfloat16</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.to_bfloat16(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_bfloat16</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_bfloat16(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.to_bfloat16(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_bfloat16</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `bfloat16`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>bfloat16</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>bfloat16</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_bfloat16', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_bfloat16" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_double">
    <p>def <span class="ident">to_double</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.to_double(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_double</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_double(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.to_double(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_double</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `float64`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>float64</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_double', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_double" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_float">
    <p>def <span class="ident">to_float</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.to_float(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_float</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_float(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.to_float(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_float</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `float32`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>float32</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_float', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_float" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_int32">
    <p>def <span class="ident">to_int32</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.to_int32(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_int32</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_int32(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.to_int32(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_int32</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `int32`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>int32</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>int32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_int32', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_int32" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_int64">
    <p>def <span class="ident">to_int64</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.to_int64(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_int64</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_int64(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.to_int64(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_int64</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `int64`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>int64</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_int64', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_int64" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.top_k">
    <p>def <span class="ident">top_k</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.top_k(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.top_k(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.top_k</strong></p>
<div class="codehilite"><pre><span></span>Finds values and indices of the `k` largest entries for the last dimension.
</pre></div>


<p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
<code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each
row (resp. vector along the last dimension).  Thus,</p>
<div class="codehilite"><pre><span></span><span class="s s-Atom">values</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">indices</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">input</span><span class="p">.</span><span class="s s-Atom">shape</span><span class="p">[:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">k</span><span class="p">]</span>
</pre></div>


<p>If two elements are equal, the lower-index element appears first.</p>
<p>Args:
  input: 1-D or higher <code>Tensor</code> with last dimension at least <code>k</code>.
  k: 0-D <code>int32</code> <code>Tensor</code>.  Number of top elements to look for along the last
    dimension (along each row for matrices).
  sorted: If true the resulting <code>k</code> elements will be sorted by the values in
    descending order.
  name: Optional name for the operation.</p>
<p>Returns:
  values: The <code>k</code> largest elements along each last dimensional slice.
  indices: The indices of <code>values</code> within the last dimension of <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.top_k', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.top_k" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer">
    <p>def <span class="ident">top_k_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.top_k_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.top_k_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.top_k`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.top_k_layer">
    <p>def <span class="ident">top_k_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.top_k_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.top_k_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.top_k`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.top_k_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.top_k_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.trace">
    <p>def <span class="ident">trace</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.trace(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.trace</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.trace(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.trace(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.trace</strong></p>
<div class="codehilite"><pre><span></span>Compute the trace of a tensor `x`.
</pre></div>


<p><code>trace(x)</code> returns the sum of along the diagonal.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1, 1],</h1>
<h1>[1, 1]]</h1>
<p>tf.trace(x) ==&gt; 2</p>
<h1>'x' is [[1,2,3],</h1>
<h1>[4,5,6],</h1>
<h1>[7,8,9]]</h1>
<p>tf.trace(x) ==&gt; 15
```</p>
<p>Args:
  x: 2-D tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  The trace of input tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.trace', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.trace" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.trainable_variables">
    <p>def <span class="ident">trainable_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.trainable_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.trainable_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.trainable_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.trainable_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.trainable_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables created with `trainable=True`.
</pre></div>


<p>When passed <code>trainable=True</code>, the <code>Variable()</code> constructor automatically
adds new variables to the graph collection
<code>GraphKeys.TRAINABLE_VARIABLES</code>. This convenience function returns the
contents of that collection.</p>
<p>Returns:
  A list of Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.trainable_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.trainable_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.transpose">
    <p>def <span class="ident">transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.transpose</strong></p>
<div class="codehilite"><pre><span></span>Transposes `a`. Permutes the dimensions according to `perm`.
</pre></div>


<p>The returned tensor's dimension i will correspond to the input dimension
<code>perm[i]</code>. If <code>perm</code> is not given, it is set to (n-1...0), where n is
the rank of the input tensor. Hence by default, this operation performs a
regular matrix transpose on 2-D input Tensors.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1 2 3]</h1>
<h1>[4 5 6]]</h1>
<p>tf.transpose(x) ==&gt; [[1 4]
                     [2 5]
                     [3 6]]</p>
<h1>Equivalently</h1>
<p>tf.transpose(x, perm=[1, 0]) ==&gt; [[1 4]
                                  [2 5]
                                  [3 6]]</p>
<h1>'perm' is more useful for n-dimensional tensors, for n &gt; 2</h1>
<h1>'x' is   [[[1  2  3]</h1>
<h1>[4  5  6]]</h1>
<h1>[[7  8  9]</h1>
<h1>[10 11 12]]]</h1>
<h1>Take the transpose of the matrices in dimension-0</h1>
<p>tf.transpose(x, perm=[0, 2, 1]) ==&gt; [[[1  4]
                                      [2  5]
                                      [3  6]]</p>
<div class="codehilite"><pre><span></span>                                 [[7 10]
                                  [8 11]
                                  [9 12]]]
</pre></div>


<p>```</p>
<p>Args:
  a: A <code>Tensor</code>.
  perm: A permutation of the dimensions of <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A transposed <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truediv">
    <p>def <span class="ident">truediv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.truediv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truediv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truediv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.truediv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truediv</strong></p>
<div class="codehilite"><pre><span></span>Divides x / y elementwise, always producing floating point results.
</pre></div>


<p>The same as <code>tf.div</code> for floating point arguments, but casts integer arguments
to floating point before dividing so that the result is always floating point.
This op is generated by normal <code>x / y</code> division in Python 3 and in Python 2.7
with <code>from __future__ import division</code>.  If you want integer division that
rounds down, use <code>x // y</code> or <code>tf.floordiv</code>.</p>
<p><code>x</code> and <code>y</code> must have the same numeric type.  If the inputs are floating
point, the output will have the same type.  If the inputs are integral, the
inputs are cast to <code>float32</code> for <code>int8</code> and <code>int16</code> and <code>float64</code> for <code>int32</code>
and <code>int64</code> (matching the behavior of Numpy).</p>
<p>Args:
  x: <code>Tensor</code> numerator of numeric type.
  y: <code>Tensor</code> denominator of numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>x / y</code> evaluated in floating point.</p>
<p>Raises:
  TypeError: If <code>x</code> and <code>y</code> have different dtypes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truediv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truediv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truncated_normal">
    <p>def <span class="ident">truncated_normal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.truncated_normal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truncated_normal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truncated_normal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.truncated_normal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truncated_normal</strong></p>
<div class="codehilite"><pre><span></span>Outputs random values from a truncated normal distribution.
</pre></div>


<p>The generated values follow a normal distribution with specified mean and
standard deviation, except that values whose magnitude is more than 2 standard
deviations from the mean are dropped and re-picked.</p>
<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output tensor.
  mean: A 0-D Tensor or Python value of type <code>dtype</code>. The mean of the
    truncated normal distribution.
  stddev: A 0-D Tensor or Python value of type <code>dtype</code>. The standard deviation
    of the truncated normal distribution.
  dtype: The type of the output.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of the specified shape filled with random truncated normal values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truncated_normal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truncated_normal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truncated_normal_initializer">
    <p>def <span class="ident">truncated_normal_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.truncated_normal_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truncated_normal_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truncated_normal_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.truncated_normal_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truncated_normal_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates a truncated normal distribution.
</pre></div>


<p>These values are similar to values from a <code>random_normal_initializer</code>
except that values more than two standard deviations from the mean
are discarded and re-drawn. This is the recommended initializer for
neural network weights and filters.</p>
<p>Args:
  mean: a python scalar or a scalar tensor. Mean of the random values
    to generate.
  stddev: a python scalar or a scalar tensor. Standard deviation of the
    random values to generate.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with a truncated normal
  distribution.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truncated_normal_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truncated_normal_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tuple">
    <p>def <span class="ident">tuple</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.tuple(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.tuple</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.tuple(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.tuple(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.tuple</strong></p>
<div class="codehilite"><pre><span></span>Group tensors together.
</pre></div>


<p>This creates a tuple of tensors with the same values as the <code>tensors</code>
argument, except that the value of each tensor is only returned after the
values of all tensors have been computed.</p>
<p><code>control_inputs</code> contains additional ops that have to finish before this op
finishes, but whose outputs are not returned.</p>
<p>This can be used as a "join" mechanism for parallel computations: all the
argument tensors can be computed in parallel, but the values of any tensor
returned by <code>tuple</code> are only available after all the parallel computations
are done.</p>
<p>See also <code>group</code> and <code>with_dependencies</code>.</p>
<p>Args:
  tensors: A list of <code>Tensor</code>s or <code>IndexedSlices</code>, some entries can be <code>None</code>.
  name: (optional) A name to use as a <code>name_scope</code> for the operation.
  control_inputs: List of additional ops to finish before returning.</p>
<p>Returns:
  Same as <code>tensors</code>.</p>
<p>Raises:
  ValueError: If <code>tensors</code> does not contain any <code>Tensor</code> or <code>IndexedSlices</code>.
  TypeError: If <code>control_inputs</code> is not a list of <code>Operation</code> or <code>Tensor</code>
    objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tuple', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tuple" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler">
    <p>def <span class="ident">uniform_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.uniform_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.uniform_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a uniform base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is the uniform distribution
over the range of integers <code>[0, range_max)</code>.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">uniform_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.uniform_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.uniform_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.uniform_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer">
    <p>def <span class="ident">uniform_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.uniform_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.uniform_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.uniform_candidate_sampler`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer">
    <p>def <span class="ident">uniform_unit_scaling_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.uniform_unit_scaling_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.uniform_unit_scaling_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.uniform_unit_scaling_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.uniform_unit_scaling_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.uniform_unit_scaling_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors without scaling variance.
</pre></div>


<p>When initializing a deep network, it is in principle advantageous to keep
the scale of the input variance constant, so it does not explode or diminish
by reaching the final layer. If the input is <code>x</code> and the operation <code>x * W</code>,
and we want to initialize <code>W</code> uniformly at random, we need to pick <code>W</code> from</p>
<div class="codehilite"><pre><span></span>[-sqrt(3) / sqrt(dim), sqrt(3) / sqrt(dim)]
</pre></div>


<p>to keep the scale intact, where <code>dim = W.shape[0]</code> (the size of the input).
A similar calculation for convolutional networks gives an analogous result
with <code>dim</code> equal to the product of the first 3 dimensions.  When
nonlinearities are present, we need to multiply this by a constant <code>factor</code>.
See <a href="https://arxiv.org/abs/1412.6558">Sussillo et al., 2014</a>
(<a href="http://arxiv.org/pdf/1412.6558.pdf">pdf</a>) for deeper motivation, experiments
and the calculation of constants. In section 2.3 there, the constants were
numerically computed: for a linear layer it's 1.0, relu: ~1.43, tanh: ~1.15.</p>
<p>Args:
  factor: Float.  A multiplicative factor by which the values will be scaled.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with unit variance.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unique">
    <p>def <span class="ident">unique</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.unique(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unique</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unique(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.unique(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unique</strong></p>
<div class="codehilite"><pre><span></span>Finds unique elements in a 1-D tensor.
</pre></div>


<p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
sorted in the same order that they occur in <code>x</code>. This operation also returns a
tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
in the unique output <code>y</code>. In other words:</p>
<p><code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code></p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1>
<p>y, idx = unique(x)
y ==&gt; [1, 2, 4, 7, 8]
idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
```</p>
<p>Args:
  x: A <code>Tensor</code>. 1-D.
  out_idx: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (y, idx).
  y: A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D.
  idx: A <code>Tensor</code> of type <code>out_idx</code>. 1-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unique', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unique" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unique_with_counts">
    <p>def <span class="ident">unique_with_counts</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.unique_with_counts(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unique_with_counts</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unique_with_counts(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.unique_with_counts(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unique_with_counts</strong></p>
<div class="codehilite"><pre><span></span>Finds unique elements in a 1-D tensor.
</pre></div>


<p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
sorted in the same order that they occur in <code>x</code>. This operation also returns a
tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
in the unique output <code>y</code>. Finally, it returns a third tensor <code>count</code> that
contains the count of each element of <code>y</code> in <code>x</code>. In other words:</p>
<p><code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code></p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1>
<p>y, idx, count = unique_with_counts(x)
y ==&gt; [1, 2, 4, 7, 8]
idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
count ==&gt; [2, 1, 3, 1, 2]
```</p>
<p>Args:
  x: A <code>Tensor</code>. 1-D.
  out_idx: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (y, idx, count).
  y: A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D.
  idx: A <code>Tensor</code> of type <code>out_idx</code>. 1-D.
  count: A <code>Tensor</code> of type <code>out_idx</code>. 1-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unique_with_counts', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unique_with_counts" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unpack">
    <p>def <span class="ident">unpack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.unpack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unpack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unpack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.unpack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unpack</strong></p>
<div class="codehilite"><pre><span></span>Unpacks the given dimension of a rank-`R` tensor into rank-`(R-1)` tensors.
</pre></div>


<p>Unpacks <code>num</code> tensors from <code>value</code> by chipping it along the <code>axis</code> dimension.
If <code>num</code> is not specified (the default), it is inferred from <code>value</code>'s shape.
If <code>value.shape[axis]</code> is not known, <code>ValueError</code> is raised.</p>
<p>For example, given a tensor of shape <code>(A, B, C, D)</code>;</p>
<p>If <code>axis == 0</code> then the i'th tensor in <code>output</code> is the slice
  <code>value[i, :, :, :]</code> and each tensor in <code>output</code> will have shape <code>(B, C, D)</code>.
  (Note that the dimension unpacked along is gone, unlike <code>split</code>).</p>
<p>If <code>axis == 1</code> then the i'th tensor in <code>output</code> is the slice
  <code>value[:, i, :, :]</code> and each tensor in <code>output</code> will have shape <code>(A, C, D)</code>.
Etc.</p>
<p>This is the opposite of pack.  The numpy equivalent is</p>
<div class="codehilite"><pre><span></span>tf.unpack(x, n) = list(x)
</pre></div>


<p>Args:
  value: A rank <code>R &gt; 0</code> <code>Tensor</code> to be unpacked.
  num: An <code>int</code>. The length of the dimension <code>axis</code>. Automatically inferred
    if <code>None</code> (the default).
  axis: An <code>int</code>. The axis to unpack along. Defaults to the first
    dimension. Supports negative indexes.
  name: A name for the operation (optional).</p>
<p>Returns:
  The list of <code>Tensor</code> objects unpacked from <code>value</code>.</p>
<p>Raises:
  ValueError: If <code>num</code> is unspecified and cannot be inferred.
  ValueError: If <code>axis</code> is out of the range [-R, R).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unpack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unpack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unsorted_segment_sum">
    <p>def <span class="ident">unsorted_segment_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.unsorted_segment_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unsorted_segment_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unsorted_segment_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.unsorted_segment_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unsorted_segment_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
<code>(output[i] = sum_{j...} data[j...]</code> where the sum is over tuples <code>j...</code> such
that <code>segment_ids[j...] == i</code>.  Unlike <code>SegmentSum</code>, <code>segment_ids</code>
need not be sorted and need not cover all values in the full
range of valid values.</p>
<p>If the sum is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.</p>
<p><code>num_segments</code> should equal the number of distinct segment IDs.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/UnsortedSegmentSum.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor whose shape is a prefix of <code>data.shape</code>.
  num_segments: A <code>Tensor</code> of type <code>int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for the first <code>segment_ids.rank</code>
  dimensions, which are replaced with a single dimension which has size
  <code>num_segments</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unsorted_segment_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unsorted_segment_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner">
    <p>def <span class="ident">variable_axis_size_partitioner</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.variable_axis_size_partitioner(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variable_axis_size_partitioner</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variable_axis_size_partitioner(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.variable_axis_size_partitioner(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.variable_axis_size_partitioner</strong></p>
<div class="codehilite"><pre><span></span>Get a partitioner for VariableScope to keep shards below `max_shard_bytes`.
</pre></div>


<p>This partitioner will shard a Variable along one axis, attempting to keep
the maximum shard size below <code>max_shard_bytes</code>.  In practice, this is not
always possible when sharding along only one axis.  When this happens,
this axis is sharded as much as possible (i.e., every dimension becomes
a separate shard).</p>
<p>If the partitioner hits the <code>max_shards</code> limit, then each shard may end up
larger than <code>max_shard_bytes</code>. By default <code>max_shards</code> equals <code>None</code> and no
limit on the number of shards is enforced.</p>
<p>One reasonable value for <code>max_shard_bytes</code> is <code>(64 &lt;&lt; 20) - 1</code>, or almost
<code>64MB</code>, to keep below the protobuf byte limit.</p>
<p>Args:
  max_shard_bytes: The maximum size any given shard is allowed to be.
  axis: The axis to partition along.  Default: outermost axis.
  bytes_per_string_element: If the <code>Variable</code> is of type string, this provides
    an estimate of how large each scalar in the <code>Variable</code> is.
  max_shards: The maximum number of shards in int created taking precedence
    over <code>max_shard_bytes</code>.</p>
<p>Returns:
  A partition function usable as the <code>partitioner</code> argument to
  <code>variable_scope</code>, <code>get_variable</code>, and <code>get_partitioned_variable_list</code>.</p>
<p>Raises:
  ValueError: If any of the byte counts are non-positive.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variable_op_scope">
    <p>def <span class="ident">variable_op_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.variable_op_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variable_op_scope</code>. 
However, a partial with the arguments is returned which expects any argument <code>x</code> and complete ignores it, such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variable_op_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.variable_op_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.variable_op_scope</strong></p>
<div class="codehilite"><pre><span></span>Deprecated: context manager for defining an op that creates variables.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variable_op_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variable_op_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variable_scope">
    <p>def <span class="ident">variable_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.variable_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variable_scope</code>. 
However, a partial with the arguments is returned which expects any argument <code>x</code> and complete ignores it, such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variable_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.variable_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.variable_scope</strong></p>
<div class="codehilite"><pre><span></span>Returns a context manager for defining ops that creates variables (layers).
</pre></div>


<p>This context manager validates that the (optional) <code>values</code> are from
the same graph, ensures that graph is the default graph, and pushes a
name scope and a variable scope.</p>
<p>If <code>name_or_scope</code> is not None, it is used as is. If <code>scope</code> is None, then
<code>default_name</code> is used.  In that case, if the same name has been previously
used in the same scope, it will made unique be appending <code>_N</code> to it.</p>
<p>Variable scope allows to create new variables and to share already created
ones while providing checks to not create or share by accident. For details,
see the <a href="../../how_tos/variable_scope/index.md">Variable Scope How To</a>,
here we present only a few basic examples.</p>
<p>Simple example of how to create a new variable:</p>
<p><code>python
with tf.variable_scope("foo"):
    with tf.variable_scope("bar"):
        v = tf.get_variable("v", [1])
        assert v.name == "foo/bar/v:0"</code></p>
<p>Basic example of sharing a variable:</p>
<p><code>python
with tf.variable_scope("foo"):
    v = tf.get_variable("v", [1])
with tf.variable_scope("foo", reuse=True):
    v1 = tf.get_variable("v", [1])
assert v1 == v</code></p>
<p>Sharing a variable by capturing a scope and setting reuse:</p>
<p><code>python
with tf.variable_scope("foo") as scope:
    v = tf.get_variable("v", [1])
    scope.reuse_variables()
    v1 = tf.get_variable("v", [1])
assert v1 == v</code></p>
<p>To prevent accidental sharing of variables, we raise an exception when
getting an existing variable in a non-reusing scope.</p>
<p><code>python
with tf.variable_scope("foo"):
    v = tf.get_variable("v", [1])
    v1 = tf.get_variable("v", [1])
    #  Raises ValueError("... v already exists ...").</code></p>
<p>Similarly, we raise an exception when trying to get a variable that
does not exist in reuse mode.</p>
<p><code>python
with tf.variable_scope("foo", reuse=True):
    v = tf.get_variable("v", [1])
    #  Raises ValueError("... v does not exists ...").</code></p>
<p>Note that the <code>reuse</code> flag is inherited: if we open a reusing scope,
then all its sub-scopes become reusing as well.</p>
<p>Args:
  name_or_scope: <code>string</code> or <code>VariableScope</code>: the scope to open.
  default_name: The default name to use if the <code>name_or_scope</code> argument is
    <code>None</code>, this name will be uniquified. If name_or_scope is provided it
    won't be used and therefore it is not required and can be None.
  values: The list of <code>Tensor</code> arguments that are passed to the op function.
  initializer: default initializer for variables within this scope.
  regularizer: default regularizer for variables within this scope.
  caching_device: default caching device for variables within this scope.
  partitioner: default partitioner for variables within this scope.
  custom_getter: default custom getter for variables within this scope.
  reuse: <code>True</code> or <code>None</code>; if <code>True</code>, we go into reuse mode for this scope as
    well as all sub-scopes; if <code>None</code>, we just inherit the parent scope reuse.
  dtype: type of variables created in this scope (defaults to the type
    in the passed scope, or inherited from parent scope).</p>
<p>Returns:
  A scope that can be to captured and reused.</p>
<p>Raises:
  ValueError: when trying to reuse within a create scope, or create within
    a reuse scope, or if reuse is not <code>None</code> or <code>True</code>.
  TypeError: when the types of some arguments are not appropriate.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variable_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variable_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite">
    <p>def <span class="ident">verify_tensor_all_finite</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.verify_tensor_all_finite(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.verify_tensor_all_finite</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.verify_tensor_all_finite(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.verify_tensor_all_finite(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.verify_tensor_all_finite</strong></p>
<div class="codehilite"><pre><span></span>Assert that the tensor does not contain any NaN&#39;s or Inf&#39;s.
</pre></div>


<p>Args:
  t: Tensor to check.
  msg: Message to log on failure.
  name: A name for this operation (optional).</p>
<p>Returns:
  Same tensor as <code>t</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits">
    <p>def <span class="ident">weighted_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.weighted_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.weighted_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.weighted_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.weighted_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.weighted_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes a weighted cross entropy.
</pre></div>


<p>This is like <code>sigmoid_cross_entropy_with_logits()</code> except that <code>pos_weight</code>,
allows one to trade off recall and precision by up- or down-weighting the
cost of a positive error relative to a negative error.</p>
<p>The usual cross-entropy cost is defined as:</p>
<p>targets * -log(sigmoid(logits)) + (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>The argument <code>pos_weight</code> is used as a multiplier for the positive targets:</p>
<p>targets * -log(sigmoid(logits)) * pos_weight +
      (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>, <code>q = pos_weight</code>.
The loss is:</p>
<div class="codehilite"><pre><span></span>  qz * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= qz * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + (qz +  1 - z) * log(1 + exp(-x))
= (1 - z) * x + (1 + (q - 1) * z) * log(1 + exp(-x))
</pre></div>


<p>Setting <code>l = (1 + (q - 1) * z)</code>, to ensure stability and avoid overflow,
the implementation uses</p>
<div class="codehilite"><pre><span></span>(1 - z) * x + l * (log(1 + exp(-abs(x))) + max(-x, 0))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  pos_weight: A coefficient to use on the positive examples.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  weightedlogistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">weighted_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.weighted_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.weighted_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.weighted_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer">
    <p>def <span class="ident">weighted_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.weighted_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.weighted_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.weighted_cross_entropy_with_logits`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.where">
    <p>def <span class="ident">where</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.where(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.where</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.where(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.where(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.where</strong></p>
<div class="codehilite"><pre><span></span>Returns locations of true values in a boolean tensor.
</pre></div>


<p>This operation returns the coordinates of true elements in <code>input</code>. The
coordinates are returned in a 2-D tensor where the first dimension (rows)
represents the number of true elements, and the second dimension (columns)
represents the coordinates of the true elements. Keep in mind, the shape of
the output tensor can vary depending on how many true values there are in
<code>input</code>. Indices are output in row-major order.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'input' tensor is [[True, False]</h1>
<h1>[True, False]]</h1>
<h1>'input' has two true values, so output has two coordinates.</h1>
<h1>'input' has rank of 2, so coordinates have two indices.</h1>
<p>where(input) ==&gt; [[0, 0],
                  [1, 0]]</p>
<h1><code>input</code> tensor is [[[True, False]</h1>
<h1>[True, False]]</h1>
<h1>[[False, True]</h1>
<h1>[False, True]]</h1>
<h1>[[False, False]</h1>
<h1>[False, True]]]</h1>
<h1>'input' has 5 true values, so output has 5 coordinates.</h1>
<h1>'input' has rank of 3, so coordinates have three indices.</h1>
<p>where(input) ==&gt; [[0, 0, 0],
                  [0, 1, 0],
                  [1, 0, 1],
                  [1, 1, 1],
                  [2, 1, 1]]
```</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.where', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.where" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.while_loop">
    <p>def <span class="ident">while_loop</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.while_loop(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.while_loop</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.while_loop(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.while_loop(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.while_loop</strong></p>
<div class="codehilite"><pre><span></span>Repeat `body` while the condition `cond` is true.
</pre></div>


<p><code>cond</code> is a callable returning a boolean scalar tensor. <code>body</code> is a callable
returning a (possibly nested) tuple or list of tensors of the same
arity (length and structure) and types as <code>loop_vars</code>. <code>loop_vars</code> is a
(possibly nested) tuple or list of tensors that is passed to both <code>cond</code>
and <code>body</code>. <code>cond</code> and <code>body</code> both take as many arguments as there are
<code>loop_vars</code>.</p>
<p>While <code>cond</code> evaluates to true, <code>body</code> is executed.</p>
<p>In addition to regular Tensors or IndexedSlices, the body may accept and
return TensorArray objects.  The flows of the TensorArray objects will
be appropriately forwarded between loops and during gradient calculations.</p>
<p>For correctness, <code>tf.while_loop()</code> strictly enforces shape invariants for
the loop variables. A shape invariant is a (possibly partial) shape that
is unchanged across the iterations of the loop. An error will be raised
if the shape of a loop variable after an iteration is determined to be more
general than or incompatible with its shape invariant. For example, a shape
of [11, None] is more general than a shape of [11, 17], and [11, 21] is not
compatible with [11, 17]. By default (if the argument <code>shape_invariants</code> is
not specified), it is assumed that the initial shape of each tensor in
<code>loop_vars</code> is the same in every iteration. The <code>shape_invariants</code> argument
allows the caller to specify a less specific shape invariant for each loop
variable, which is needed if the shape varies between iterations. The
<a href="../../api_docs/python/framework.md#Tensor.set_shape"><code>Tensor.set_shape()</code></a>
function may also be used in the <code>body</code> function to indicate that
the output loop variable has a particular shape. The shape invariant for
SparseTensor and IndexedSlices are treated specially as follows:</p>
<p>a) If a loop variable is a SparseTensor, the shape invariant must be
TensorShape([r]) where r is the rank of the dense tensor represented
by the sparse tensor. It means the shapes of the three tensors of the
SparseTensor are ([None], [None, r], [r]). NOTE: The shape invariant here
is the shape of the SparseTensor.shape property. It must be the shape of
a vector.</p>
<p>b) If a loop variable is an IndexedSlices, the shape invariant must be
a shape invariant of the values tensor of the IndexedSlices. It means
the shapes of the three tensors of the IndexedSlices are (shape, [shape[0]],
[shape.ndims]).</p>
<p><code>while_loop</code> implements non-strict semantics, enabling multiple iterations
to run in parallel. The maximum number of parallel iterations can be
controlled by <code>parallel_iterations</code>, which gives users some control over
memory consumption and execution order. For correct programs, <code>while_loop</code>
should return the same result for any parallel_iterations &gt; 0.</p>
<p>For training, TensorFlow remembers the tensors that are produced in the
forward inference but needed in back propagation. These tensors can be a
main source of memory consumption and often cause OOM problems when training
on GPUs.  When the flag swap_memory is true, we swap out these tensors from
GPU to CPU.  This for example allows us to train RNN models with very long
sequences and large batches.</p>
<p>Args:
  cond: A callable that represents the termination condition of the loop.
  body: A callable that represents the loop body.
  loop_vars: A (possibly nested) tuple or list of numpy array, <code>Tensor</code>,
    and <code>TensorArray</code> objects.
  shape_invariants: The shape invariants for the loop variables.
  parallel_iterations: The number of iterations allowed to run in parallel.
  back_prop: Whether backprop is enabled for this while loop.
  swap_memory: Whether GPU-CPU memory swap is enabled for this loop.
  name: Optional name prefix for the returned tensors.</p>
<p>Returns:
  The output tensors for the loop variables after the loop. When the length
  of <code>loop_vars</code> is 1 this is a Tensor, TensorArray or IndexedSlice and when
  the length of <code>loop_vars</code> is greater than 1 it returns a list.</p>
<p>Raises:
  TypeError: if <code>cond</code> or <code>body</code> is not callable.
  ValueError: if <code>loop_vars</code> is empty.</p>
<p>Example:</p>
<p><code>python
  i = tf.constant(0)
  c = lambda i: tf.less(i, 10)
  b = lambda i: tf.add(i, 1)
  r = tf.while_loop(c, b, [i])</code></p>
<p>Example with nesting:</p>
<p><code>python
  ijk_0 = (tf.constant(0), (tf.constant(1), tf.constant(2)))
  c = lambda i, (j, k): i &lt; 10
  b = lambda i, (j, k): (i + 1, ((j + k), (j - k)))
  ijk_final = tf.while_loop(c, b, ijk_0)</code></p>
<p>Example using shape_invariants:</p>
<p><code>python
  i0 = tf.constant(0)
  m0 = tf.ones([2, 2])
  c = lambda i, m: i &lt; 10
  b = lambda i, m: [i+1, tf.concat(0, [m, m])]
  tf.while_loop(
      c, b, loop_vars=[i0, m0],
      shape_invariants=[i0.get_shape(), tensor_shape.TensorShape([None, 2])])</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.while_loop', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.while_loop" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b">
    <p>def <span class="ident">xw_plus_b</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.xw_plus_b</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.xw_plus_b(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.xw_plus_b</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer">
    <p>def <span class="ident">xw_plus_b_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_layer">
    <p>def <span class="ident">xw_plus_b_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_v1">
    <p>def <span class="ident">xw_plus_b_v1</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_v1(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.xw_plus_b_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.xw_plus_b_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_v1(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.xw_plus_b_v1</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>This is a deprecated version of that will soon be removed.</p>
<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b_v1" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer">
    <p>def <span class="ident">xw_plus_b_v1_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_v1_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_v1_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b_v1`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer">
    <p>def <span class="ident">xw_plus_b_v1_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_v1_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.xw_plus_b_v1_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b_v1`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zero_fraction">
    <p>def <span class="ident">zero_fraction</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zero_fraction(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nn.zero_fraction</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nn.zero_fraction(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zero_fraction(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nn.zero_fraction</strong></p>
<div class="codehilite"><pre><span></span>Returns the fraction of zeros in `value`.
</pre></div>


<p>If <code>value</code> is empty, the result is <code>nan</code>.</p>
<p>This is useful in summaries to measure and report sparsity.  For example,</p>
<div class="codehilite"><pre><span></span>z = tf.Relu(...)
summ = tf.scalar_summary(&#39;sparsity&#39;, tf.nn.zero_fraction(z))
</pre></div>


<p>Args:
  value: A tensor of numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  The fraction of zeros in <code>value</code>, with type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zero_fraction', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zero_fraction" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer">
    <p>def <span class="ident">zero_fraction_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zero_fraction_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zero_fraction_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.zero_fraction`.
</pre></div>


<p><strong>tf.contrib.layers.convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D convolution followed by an optional batch_norm layer.
</pre></div>


<p><code>convolution2d</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved with the <code>inputs</code> to produce a
<code>Tensor</code> of activations. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the activations. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride equal to rate if rate is
greater than one.</p>
<p>Args:
  inputs: a 4-D tensor  <code>[batch_size, height, width, channels]</code>.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 <code>[kernel_height, kernel_width]</code> of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: one of <code>VALID</code> or <code>SAME</code>.
  rate: integer. If less than or equal to 1, a standard convolution is used.
    If greater than 1, than the a'trous convolution is applied and <code>stride</code>
    must be set to 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if both 'rate' and <code>stride</code> are larger than one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zero_fraction_layer">
    <p>def <span class="ident">zero_fraction_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zero_fraction_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layers.fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layers.fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zero_fraction_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.zero_fraction`.
</pre></div>


<p><strong>tf.contrib.layers.fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zero_fraction_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zero_fraction_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeros">
    <p>def <span class="ident">zeros</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zeros(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeros</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeros(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zeros(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeros</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to zero.
</pre></div>


<p>This operation returns a tensor of type <code>dtype</code> with shape <code>shape</code> and
all elements set to zero.</p>
<p>For example:</p>
<p><code>python
tf.zeros([3, 4], tf.int32) ==&gt; [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]</code></p>
<p>Args:
  shape: Either a list of integers, or a 1-D <code>Tensor</code> of type <code>int32</code>.
  dtype: The type of an element in the resulting <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to zero.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeros', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeros" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeros_initializer">
    <p>def <span class="ident">zeros_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zeros_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeros_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeros_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zeros_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeros_initializer</strong></p>
<div class="codehilite"><pre><span></span>An adaptor for zeros() to match the Initializer spec.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeros_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeros_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeros_like">
    <p>def <span class="ident">zeros_like</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zeros_like(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeros_like</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeros_like(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zeros_like(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeros_like</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to zero.
</pre></div>


<p>Given a single tensor (<code>tensor</code>), this operation returns a tensor of the
same type and shape as <code>tensor</code> with all elements set to zero. Optionally,
you can use <code>dtype</code> to specify a new type for the returned tensor.</p>
<p>For example:</p>
<p>```python</p>
<h1>'tensor' is [[1, 2, 3], [4, 5, 6]]</h1>
<p>tf.zeros_like(tensor) ==&gt; [[0, 0, 0], [0, 0, 0]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  dtype: A type for the returned <code>Tensor</code>. Must be <code>float32</code>, <code>float64</code>,
  <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>complex64</code>, or <code>complex128</code>.
  name: A name for the operation (optional).
  optimize: if true, attempt to statically determine the shape of 'tensor'
  and encode it as a constant.</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to zero.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeros_like', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeros_like" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeta">
    <p>def <span class="ident">zeta</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>builder.zeta(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeta</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeta(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>builder.zeta(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeta</strong></p>
<div class="codehilite"><pre><span></span>Compute the Hurwitz zeta function \\(\zeta(x, q)\\).
</pre></div>


<p>The Hurwitz zeta function is defined as:</p>
<p><code>\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  q: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeta', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeta" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>

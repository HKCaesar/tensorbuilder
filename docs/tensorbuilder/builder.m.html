<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>tensorbuilder.builder API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.builder.T">T</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.name">name</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.builder.f">f</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#tensorbuilder.builder.TensorBuilder">TensorBuilder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Context">Context</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.__init__">__init__</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Assert">Assert</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Dict">Dict</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Elif">Elif</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Else">Else</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.F">F</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.If">If</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.List">List</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.NoGradient">NoGradient</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.NotDifferentiable">NotDifferentiable</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.PatchAt">PatchAt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Pipe">Pipe</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Print">Print</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ReadList">ReadList</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register">Register</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register0">Register0</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register2">Register2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register3">Register3</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register4">Register4</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Register5">Register5</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterAt">RegisterAt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.RegisterMethod">RegisterMethod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Seq">Seq</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Set">Set</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then">Then</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then0">Then0</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then1">Then1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then2">Then2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then3">Then3</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then4">Then4</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Then5">Then5</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ThenAt">ThenAt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.TrainOp">TrainOp</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Trainer">Trainer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Tuple">Tuple</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Val">Val</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.With">With</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.Write">Write</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.abs">abs</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.accumulate_n">accumulate_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.acos">acos</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add">add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_check_numerics_ops">add_check_numerics_ops</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_n">add_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_regularization_loss">add_regularization_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.add_to_collection">add_to_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_candidate_sampler">all_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer">all_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer">all_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.all_variables">all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.arg_max">arg_max</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.arg_min">arg_min</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.argmax">argmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.argmin">argmin</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.as_dtype">as_dtype</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.as_string">as_string</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.asin">asin</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_equal">assert_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_greater">assert_greater</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_greater_equal">assert_greater_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_integer">assert_integer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_less">assert_less</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_less_equal">assert_less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_negative">assert_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_non_negative">assert_non_negative</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_non_positive">assert_non_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_positive">assert_positive</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_proper_iterable">assert_proper_iterable</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_rank">assert_rank</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_rank_at_least">assert_rank_at_least</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_type">assert_type</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assert_variables_initialized">assert_variables_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assign">assign</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assign_add">assign_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.assign_sub">assign_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atan">atan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atrous_conv2d">atrous_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer">atrous_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer">atrous_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.audio_summary">audio_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool">avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool2d">avg_pool2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d">avg_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer">avg_pool3d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_grad">avg_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer">avg_pool3d_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer">avg_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool3d_layer">avg_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer">avg_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.avg_pool_layer">avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_matmul">batch_matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization">batch_norm_with_global_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer">batch_norm_with_global_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer">batch_norm_with_global_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_normalization">batch_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer">batch_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_normalization_layer">batch_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_to_space">batch_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.batch_to_space_nd">batch_to_space_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.betainc">betainc</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add">bias_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer">bias_add_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_grad">bias_add_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer">bias_add_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_grad_layer">bias_add_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_layer">bias_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_v1">bias_add_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer">bias_add_v1_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bias_add_v1_layer">bias_add_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn">bidirectional_dynamic_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer">bidirectional_dynamic_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer">bidirectional_dynamic_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_rnn">bidirectional_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer">bidirectional_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer">bidirectional_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.bitcast">bitcast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.boolean_mask">boolean_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.case">case</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cast">cast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ceil">ceil</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.check_numerics">check_numerics</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cholesky">cholesky</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cholesky_solve">cholesky_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_average_norm">clip_by_average_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_global_norm">clip_by_global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_norm">clip_by_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.clip_by_value">clip_by_value</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.complex">complex</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.complex_abs">complex_abs</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.compute_accidental_hits">compute_accidental_hits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer">compute_accidental_hits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer">compute_accidental_hits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.concat">concat</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.concat_v2">concat_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cond">cond</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conj">conj</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.constant">constant</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.constant_initializer">constant_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.container">container</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.control_dependencies">control_dependencies</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv1d">conv1d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer">conv1d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv1d_layer">conv1d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d">conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter">conv2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer">conv2d_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer">conv2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_input">conv2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer">conv2d_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer">conv2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer">conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_layer">conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_transpose">conv2d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer">conv2d_transpose_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer">conv2d_transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d">conv3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter">conv3d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer">conv3d_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer">conv3d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2">conv3d_backprop_filter_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer">conv3d_backprop_filter_v2_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer">conv3d_backprop_filter_v2_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input">conv3d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer">conv3d_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer">conv3d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2">conv3d_backprop_input_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer">conv3d_backprop_input_v2_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer">conv3d_backprop_input_v2_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer">conv3d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_layer">conv3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_transpose">conv3d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer">conv3d_transpose_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer">conv3d_transpose_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convert_to_tensor">convert_to_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices">convert_to_tensor_or_indexed_slices</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convolution">convolution</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convolution2d">convolution2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convolution_conv2d_layer">convolution_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.convolution_layer">convolution_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cos">cos</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.count_nonzero">count_nonzero</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.count_up_to">count_up_to</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.create_partitioned_variables">create_partitioned_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.crelu">crelu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer">crelu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.crelu_layer">crelu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cross">cross</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder">ctc_beam_search_decoder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer">ctc_beam_search_decoder_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer">ctc_beam_search_decoder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder">ctc_greedy_decoder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer">ctc_greedy_decoder_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer">ctc_greedy_decoder_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_loss">ctc_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer">ctc_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ctc_loss_layer">ctc_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cumprod">cumprod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.cumsum">cumsum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.data">data</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_base64">decode_base64</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_csv">decode_csv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_json_example">decode_json_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.decode_raw">decode_raw</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.delete_session_tensor">delete_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depth_to_space">depth_to_space</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d">depthwise_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer">depthwise_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer">depthwise_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native">depthwise_conv2d_native</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter">depthwise_conv2d_native_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer">depthwise_conv2d_native_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer">depthwise_conv2d_native_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input">depthwise_conv2d_native_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer">depthwise_conv2d_native_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer">depthwise_conv2d_native_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer">depthwise_conv2d_native_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer">depthwise_conv2d_native_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dequantize">dequantize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.deserialize_many_sparse">deserialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.device">device</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.diag">diag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.diag_part">diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.digamma">digamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d">dilation2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter">dilation2d_backprop_filter</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer">dilation2d_backprop_filter_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer">dilation2d_backprop_filter_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input">dilation2d_backprop_input</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer">dilation2d_backprop_input_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer">dilation2d_backprop_input_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer">dilation2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dilation2d_layer">dilation2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.div">div</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.divide">divide</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.drop_layer">drop_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dropout">dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer">dropout_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dropout_layer">dropout_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_partition">dynamic_partition</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_rnn">dynamic_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer">dynamic_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer">dynamic_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.dynamic_stitch">dynamic_stitch</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.edit_distance">edit_distance</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.einsum">einsum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.elu">elu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.elu_conv2d_layer">elu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.elu_layer">elu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup">embedding_lookup</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer">embedding_lookup_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_layer">embedding_lookup_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse">embedding_lookup_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer">embedding_lookup_sparse_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer">embedding_lookup_sparse_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.encode_base64">encode_base64</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ensamble_dropout">ensamble_dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.equal">equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erf">erf</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erfc">erfc</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erosion2d">erosion2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer">erosion2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.erosion2d_layer">erosion2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.exp">exp</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.expand_dims">expand_dims</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.extract_image_patches">extract_image_patches</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.eye">eye</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args">fake_quant_with_min_max_args</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args_gradient">fake_quant_with_min_max_args_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars">fake_quant_with_min_max_vars</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_gradient">fake_quant_with_min_max_vars_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel">fake_quant_with_min_max_vars_per_channel</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel_gradient">fake_quant_with_min_max_vars_per_channel_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fft">fft</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fft2d">fft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fft3d">fft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fill">fill</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_size_partitioner">fixed_size_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler">fixed_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer">fixed_unigram_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer">fixed_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.flatten">flatten</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.floor">floor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.floor_div">floor_div</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.floordiv">floordiv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.floormod">floormod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.foldl">foldl</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.foldr">foldr</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_avg_pool">fractional_avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer">fractional_avg_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer">fractional_avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_max_pool">fractional_max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer">fractional_max_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer">fractional_max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_batch_norm">fused_batch_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_batch_norm_conv2d_layer">fused_batch_norm_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad">fused_batch_norm_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_conv2d_layer">fused_batch_norm_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_layer">fused_batch_norm_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_batch_norm_layer">fused_batch_norm_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_pad_conv2d">fused_pad_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_conv2d_layer">fused_pad_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_layer">fused_pad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d">fused_resize_and_pad_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer">fused_resize_and_pad_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer">fused_resize_and_pad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.gather">gather</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.gather_nd">gather_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_collection">get_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_collection_ref">get_collection_ref</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_default_graph">get_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_default_session">get_default_session</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_seed">get_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_session_handle">get_session_handle</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_session_tensor">get_session_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_variable">get_variable</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.get_variable_scope">get_variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.global_norm">global_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.global_variables">global_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.global_variables_initializer">global_variables_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.gradients">gradients</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.greater">greater</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.greater_equal">greater_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.group">group</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.hessians">hessians</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.histogram_fixed_width">histogram_fixed_width</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.histogram_summary">histogram_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.identity">identity</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ifft">ifft</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ifft2d">ifft2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ifft3d">ifft3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.igamma">igamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.igammac">igammac</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.imag">imag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.image_summary">image_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.import_graph_def">import_graph_def</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.in_top_k">in_top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer">in_top_k_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.in_top_k_layer">in_top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.inception_layer">inception_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_all_tables">initialize_all_tables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_all_variables">initialize_all_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_local_variables">initialize_local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.initialize_variables">initialize_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.invert_permutation">invert_permutation</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_finite">is_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_inf">is_inf</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_nan">is_nan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_non_decreasing">is_non_decreasing</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_numeric_tensor">is_numeric_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_strictly_increasing">is_strictly_increasing</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.is_variable_initialized">is_variable_initialized</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_loss">l2_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer">l2_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_loss_layer">l2_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_normalize">l2_normalize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer">l2_normalize_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.l2_normalize_layer">l2_normalize_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lbeta">lbeta</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler">learned_unigram_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer">learned_unigram_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer">learned_unigram_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.less">less</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.less_equal">less_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lgamma">lgamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lin_space">lin_space</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.linear_conv2d_layer">linear_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.linear_layer">linear_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.linspace">linspace</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.load_file_system_library">load_file_system_library</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.load_op_library">load_op_library</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_response_normalization">local_response_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer">local_response_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_response_normalization_layer">local_response_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_variables">local_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.local_variables_initializer">local_variables_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log">log</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log1p">log1p</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_poisson_loss">log_poisson_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer">log_poisson_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer">log_poisson_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_softmax">log_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer">log_softmax_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_softmax_layer">log_softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler">log_uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer">log_uniform_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer">log_uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_and">logical_and</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_not">logical_not</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_or">logical_or</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.logical_xor">logical_xor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lrn">lrn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer">lrn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.lrn_layer">lrn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_all">make_all</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer">make_all_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_all_layer">make_all_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.make_template">make_template</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.map_fn">map_fn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matching_files">matching_files</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matmul">matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_band_part">matrix_band_part</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_determinant">matrix_determinant</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_diag">matrix_diag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_diag_part">matrix_diag_part</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_inverse">matrix_inverse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_set_diag">matrix_set_diag</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_solve">matrix_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_solve_ls">matrix_solve_ls</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_transpose">matrix_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.matrix_triangular_solve">matrix_triangular_solve</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool">max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool2d">max_pool2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d">max_pool3d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer">max_pool3d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_grad">max_pool3d_grad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer">max_pool3d_grad_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer">max_pool3d_grad_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool3d_layer">max_pool3d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer">max_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_layer">max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_with_argmax">max_pool_with_argmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer">max_pool_with_argmax_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer">max_pool_with_argmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.maximize">maximize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.maximum">maximum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.merge_all_summaries">merge_all_summaries</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.merge_summary">merge_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.meshgrid">meshgrid</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner">min_max_variable_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.minimize">minimize</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.minimum">minimum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.mod">mod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.model_variables">model_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moments">moments</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moments_conv2d_layer">moments_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moments_layer">moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.moving_average_variables">moving_average_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.mul">mul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.multinomial">multinomial</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.multiply">multiply</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.name_scope">name_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.nce_loss">nce_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer">nce_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.nce_loss_layer">nce_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.neg">neg</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.negative">negative</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.no_op">no_op</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.no_regularizer">no_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.normalize_moments">normalize_moments</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer">normalize_moments_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.normalize_moments_layer">normalize_moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.not_equal">not_equal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.one_hot">one_hot</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ones">ones</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ones_initializer">ones_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.ones_like">ones_like</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.op_scope">op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.orthogonal_initializer">orthogonal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pack">pack</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pad">pad</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_example">parse_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_single_example">parse_single_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_single_sequence_example">parse_single_sequence_example</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.parse_tensor">parse_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.placeholder">placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.placeholder_with_default">placeholder_with_default</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.polygamma">polygamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.polynomial_layer">polynomial_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pool">pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pool_conv2d_layer">pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pool_layer">pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.pow">pow</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.py_func">py_func</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantize_v2">quantize_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_avg_pool">quantized_avg_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_avg_pool_conv2d_layer">quantized_avg_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_avg_pool_layer">quantized_avg_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization">quantized_batch_norm_with_global_normalization</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_conv2d_layer">quantized_batch_norm_with_global_normalization_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_layer">quantized_batch_norm_with_global_normalization_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_bias_add">quantized_bias_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_bias_add_conv2d_layer">quantized_bias_add_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_bias_add_layer">quantized_bias_add_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_concat">quantized_concat</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_conv2d">quantized_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_conv2d_conv2d_layer">quantized_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_conv2d_layer">quantized_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_max_pool">quantized_max_pool</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_max_pool_conv2d_layer">quantized_max_pool_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_max_pool_layer">quantized_max_pool_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu">quantized_relu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu6">quantized_relu6</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu6_conv2d_layer">quantized_relu6_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu6_layer">quantized_relu6_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu_conv2d_layer">quantized_relu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu_layer">quantized_relu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu_x">quantized_relu_x</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu_x_conv2d_layer">quantized_relu_x_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.quantized_relu_x_layer">quantized_relu_x_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_crop">random_crop</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_gamma">random_gamma</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_normal">random_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_normal_initializer">random_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_shuffle">random_shuffle</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_uniform">random_uniform</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.random_uniform_initializer">random_uniform_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.range">range</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rank">rank</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.raw_rnn">raw_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer">raw_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.raw_rnn_layer">raw_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.read_file">read_file</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.real">real</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.realdiv">realdiv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reciprocal">reciprocal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_all">reduce_all</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_any">reduce_any</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_join">reduce_join</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_logsumexp">reduce_logsumexp</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_max">reduce_max</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_mean">reduce_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_min">reduce_min</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_prod">reduce_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reduce_sum">reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function">register_tensor_conversion_function</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu">relu</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu6">relu6</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer">relu6_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu6_layer">relu6_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu_conv2d_layer">relu_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.relu_layer">relu_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.report_uninitialized_variables">report_uninitialized_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings">required_space_to_batch_paddings</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reset_default_graph">reset_default_graph</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reshape">reshape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reverse">reverse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reverse_sequence">reverse_sequence</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.reverse_v2">reverse_v2</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rint">rint</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn">rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer">rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_layer">rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state">rnn_placeholders_from_state</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict">rnn_state_feed_dict</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.round">round</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.rsqrt">rsqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sampled_softmax_loss">sampled_softmax_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer">sampled_softmax_loss_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer">sampled_softmax_loss_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.saturate_cast">saturate_cast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scalar_mul">scalar_mul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scalar_summary">scalar_summary</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scan">scan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_add">scatter_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_div">scatter_div</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_mul">scatter_mul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_nd">scatter_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_nd_add">scatter_nd_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_nd_sub">scatter_nd_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_nd_update">scatter_nd_update</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_sub">scatter_sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.scatter_update">scatter_update</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_max">segment_max</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_mean">segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_min">segment_min</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_prod">segment_prod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.segment_sum">segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.select">select</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.self_adjoint_eig">self_adjoint_eig</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals">self_adjoint_eigvals</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.separable_conv2d">separable_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer">separable_conv2d_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.separable_conv2d_layer">separable_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sequence_mask">sequence_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.serialize_many_sparse">serialize_many_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.serialize_sparse">serialize_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.set_random_seed">set_random_seed</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.setdiff1d">setdiff1d</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.shape">shape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.shape_n">shape_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid">sigmoid</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer">sigmoid_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits">sigmoid_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer">sigmoid_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer">sigmoid_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sigmoid_layer">sigmoid_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sign">sign</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sin">sin</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.size">size</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.slice">slice</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax">softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer">softmax_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits">softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer">softmax_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer">softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softmax_layer">softmax_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softplus">softplus</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer">softplus_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softplus_layer">softplus_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softsign">softsign</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer">softsign_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.softsign_layer">softsign_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.space_to_batch">space_to_batch</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.space_to_batch_nd">space_to_batch_nd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.space_to_depth">space_to_depth</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_add">sparse_add</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_concat">sparse_concat</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows">sparse_fill_empty_rows</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_mask">sparse_mask</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_matmul">sparse_matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_maximum">sparse_maximum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_merge">sparse_merge</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_minimum">sparse_minimum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_placeholder">sparse_placeholder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reduce_sum">sparse_reduce_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse">sparse_reduce_sum_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reorder">sparse_reorder</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reset_shape">sparse_reset_shape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_reshape">sparse_reshape</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_retain">sparse_retain</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_segment_mean">sparse_segment_mean</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n">sparse_segment_sqrt_n</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_segment_sum">sparse_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax">sparse_softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits">sparse_softmax_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer">sparse_softmax_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer">sparse_softmax_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_split">sparse_split</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul">sparse_tensor_dense_matmul</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense">sparse_tensor_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_to_dense">sparse_to_dense</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_to_indicator">sparse_to_indicator</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sparse_transpose">sparse_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.split">split</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.split_v">split_v</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sqrt">sqrt</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.square">square</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.squared_difference">squared_difference</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.squeeze">squeeze</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.stack">stack</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.state_saving_rnn">state_saving_rnn</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer">state_saving_rnn_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer">state_saving_rnn_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.stop_gradient">stop_gradient</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.strided_slice">strided_slice</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_join">string_join</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_split">string_split</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_hash_bucket">string_to_hash_bucket</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast">string_to_hash_bucket_fast</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong">string_to_hash_bucket_strong</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.string_to_number">string_to_number</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sub">sub</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.substr">substr</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.subtract">subtract</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sufficient_statistics">sufficient_statistics</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer">sufficient_statistics_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer">sufficient_statistics_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.svd">svd</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tan">tan</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tanh">tanh</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer">tanh_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tanh_layer">tanh_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tile">tile</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_bfloat16">to_bfloat16</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_double">to_double</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_float">to_float</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_int32">to_int32</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.to_int64">to_int64</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.top_k">top_k</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer">top_k_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.top_k_layer">top_k_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.trace">trace</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.trainable_variables">trainable_variables</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.transpose">transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truediv">truediv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truncated_normal">truncated_normal</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truncated_normal_initializer">truncated_normal_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truncatediv">truncatediv</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.truncatemod">truncatemod</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.tuple">tuple</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler">uniform_candidate_sampler</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer">uniform_candidate_sampler_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer">uniform_candidate_sampler_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer">uniform_unit_scaling_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unique">unique</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unique_with_counts">unique_with_counts</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unpack">unpack</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unsorted_segment_sum">unsorted_segment_sum</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.unstack">unstack</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner">variable_axis_size_partitioner</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variable_op_scope">variable_op_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variable_scope">variable_scope</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.variables_initializer">variables_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite">verify_tensor_all_finite</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits">weighted_cross_entropy_with_logits</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer">weighted_cross_entropy_with_logits_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer">weighted_cross_entropy_with_logits_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_moments">weighted_moments</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_moments_conv2d_layer">weighted_moments_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.weighted_moments_layer">weighted_moments_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.where">where</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.while_loop">while_loop</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.with_space_to_batch">with_space_to_batch</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.with_space_to_batch_conv2d_layer">with_space_to_batch_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.with_space_to_batch_layer">with_space_to_batch_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.write_file">write_file</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b">xw_plus_b</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer">xw_plus_b_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_layer">xw_plus_b_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_v1">xw_plus_b_v1</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer">xw_plus_b_v1_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer">xw_plus_b_v1_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zero_fraction">zero_fraction</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer">zero_fraction_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zero_fraction_layer">zero_fraction_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeros">zeros</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeros_initializer">zeros_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeros_like">zeros_like</a></li>
    <li class="mono"><a href="#tensorbuilder.builder.TensorBuilder.zeta">zeta</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">tensorbuilder.builder</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder" class="source">
    <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">Builder</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">.tensordata</span> <span class="kn">import</span> <span class="n">Data</span>

<span class="k">class</span> <span class="nc">TensorBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for TensorBuilder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">TensorBuilder</span><span class="o">.</span><span class="n">__core__</span> <span class="o">=</span> <span class="p">[</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">TensorBuilder</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">)</span> <span class="p">]</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TensorBuilder</span><span class="p">()</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="tensorbuilder.builder.T" class="name">var <span class="ident">T</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="tensorbuilder.builder.name" class="name">var <span class="ident">name</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.f">
    <p>def <span class="ident">f</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.f', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.f" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="tensorbuilder.builder.TensorBuilder" class="name">class <span class="ident">TensorBuilder</span></p>
      
  
    <div class="desc"><p>docstring for TensorBuilder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TensorBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for TensorBuilder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#tensorbuilder.builder.TensorBuilder">TensorBuilder</a></li>
          <li>phi.builder.Builder</li>
          <li>phi.dsl.Expression</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Context">
    <p>def <span class="ident">Context</span>(</p><p>*args)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>Builder Core</strong>. Also available as a global function as <code>phi.Context</code>.</p>
<p>Returns the context object of the current <code>dsl.With</code> statemente.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong>: By design <code>Context</code> accepts any number of arguments and completely ignores them.</li>
</ul>
<p>This is a classmethod and it doesnt return a <code>Builder</code>/<code>Expression</code> by design so it can be called directly:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span>
        <span class="n">read_file</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Here we called <code>Context</code> with no arguments to get the context back, however, since you can also give this function an argument (which it will ignore) it can be passed to the DSL so we can rewrite the previous as:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Obj</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span>
        <span class="n">Context</span><span class="p">,</span> <span class="c1"># f</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p><code>Context</code> yields an exception when used outside of a <code>With</code> block.</p>
<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Context', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Context" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">Context</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ilder Core**. Also available as a global function as `phi.Context`.</span>
<span class="sd">rns the context object of the current `dsl.With` statemente.</span>
<span class="sd">guments**</span>
<span class="sd">*args**: By design `Context` accepts any number of arguments and completely ignores them.</span>
<span class="sd"> is a classmethod and it doesnt return a `Builder`/`Expression` by design so it can be called directly:</span>
<span class="sd">from phi import P, Context, Obj</span>
<span class="sd">def read_file(z):</span>
<span class="sd">    f = Context()</span>
<span class="sd">    return f.read()</span>
<span class="sd">lines = P.Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    P.With( open,</span>
<span class="sd">        read_file,</span>
<span class="sd">        Obj.split(&quot;\\n&quot;)</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd"> we called `Context` with no arguments to get the context back, however, since you can also give this function an argument (which it will ignore) it can be passed to the DSL so we can rewrite the previous as:</span>
<span class="sd">from phi import P, Context, Obj</span>
<span class="sd">lines = P.Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    P.With( open,</span>
<span class="sd">        Context, # f</span>
<span class="sd">        Obj.read()</span>
<span class="sd">        Obj.split(&quot;\\n&quot;)</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">text` yields an exception when used outside of a `With` block.</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Obj`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_WithContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="ow">is</span> <span class="n">utils</span><span class="o">.</span><span class="n">NO_VALUE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot use &#39;Context&#39; outside of a &#39;With&#39; block&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_WithContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Obj" class="name">var <span class="ident">Obj</span></p>
            

            
  
    <div class="desc"><p><code>Obj</code> is a <code>property</code> that returns an object that defines the <code>__getattr__</code> method which when called helps you create a partial that emulates a method call. The following expression</p>
<div class="codehilite"><pre><span></span>Obj.some_method(x1, x2, ...)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda obj: obj.some_method(x1, x2, ...)
</pre></div>


<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">assert</span> <span class="s2">&quot;hello world&quot;</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;  HELLO HELLO {0}     &quot;</span><span class="p">,</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;WORLD&quot;</span><span class="p">),</span>  <span class="c1"># &quot;   HELLO HELLO WORLD     &quot;</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>          <span class="c1"># &quot;HELLO HELLO WORLD&quot;</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>           <span class="c1"># &quot;hello hello world&quot;</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>        <span class="c1"># [&quot;hello&quot;, &quot;hello&quot;, &quot;world&quot;]</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>    <span class="c1"># 2</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Rec</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write">dsl.Write</a></li>
<li><code>phi.builder.Builder.Write</code></li>
</ul></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Read" class="name">var <span class="ident">Read</span></p>
            

            
  
    <div class="desc"><p>Giving names and saving parts of your computation to use then latter is useful to say the least. In Phi the expression</p>
<div class="codehilite"><pre><span></span>Write(x = expr)
</pre></div>


<p>creates a reference <code>x</code> given the value of <code>expr</code> which you can call latter. To read the previous you would use any of the following expressions</p>
<div class="codehilite"><pre><span></span>Read(&#39;x&#39;)
Read.x
</pre></div>


<h3>Example</h3>
<p>Lets see a common situation where you would use this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Seq</span><span class="p">,</span> <span class="n">Read</span><span class="p">,</span> <span class="n">Write</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">ref</span> <span class="o">=</span> <span class="n">f1</span><span class="p">),</span>
    <span class="n">f2</span><span class="p">,</span>
    <span class="n">List</span><span class="p">(</span>
        <span class="n">f3</span>
    <span class="p">,</span>
        <span class="n">Seq</span><span class="p">(</span>
            <span class="n">Read</span><span class="p">(</span><span class="s1">&#39;ref&#39;</span><span class="p">),</span>
            <span class="n">f4</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Here you <em>save</em> the value outputed by <code>fun_1</code> and the load it as the initial value of the second branch. In normal python the previous would be <em>almost</em> equivalent to</p>
<div class="codehilite"><pre><span></span>x = f1(input)
ref = x
x = f2(x)

result = [
    f3(x)
,
    f4(ref)
]
</pre></div></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Rec" class="name">var <span class="ident">Rec</span></p>
            

            
  
    <div class="desc"><p><code>Rec</code> is a <code>property</code> that returns an object that defines the <code>__getattr__</code> and <code>__getitem__</code> methods which when called help you create lambdas that emulates a field access. The following expression</p>
<div class="codehilite"><pre><span></span>Rec.some_field
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda rec: rec.some_field
</pre></div>


<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Rec</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">flip_cords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">assert</span> <span class="mi">4</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>         <span class="c1"># point(x=1, y=2)</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">flip_cords</span><span class="p">(),</span>    <span class="c1"># point(x=2, y=1)</span>
    <span class="n">Rec</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>               <span class="c1"># point.x = 2</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span>                <span class="c1"># 2 * 2 = 4</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><code>phi.builder.Builder.Read</code></li>
<li><code>phi.builder.Builder.Write</code></li>
</ul></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.Ref" class="name">var <span class="ident">Ref</span></p>
            

            
  
    <div class="desc"><p>Returns an object that helps you to inmediatly create and <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read">read</a> <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Ref">references</a>.</p>
<p><strong>Creating Refences</strong></p>
<p>You can manually create a <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Ref">Ref</a> outside the DSL using <code>Ref</code> and then pass to as/to a <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read">Read</a> or <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write">Write</a> expression. Here is a contrived example</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Ref</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

<span class="k">assert</span> <span class="p">[</span><span class="mi">600</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">},</span>  <span class="c1"># a = 2 + 1 = 3</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">},</span>  <span class="c1"># b = 3 * 2 = 6</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">r</span> <span class="p">},</span>  <span class="c1"># c = r = 6 * 100 = 600</span>
    <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">r</span><span class="p">()</span> <span class="o">==</span> <span class="mi">600</span>
</pre></div>


<p><strong>Reading Refences from the Current Context</strong></p>
<p>While the expression <code>Read.a</code> with return a function that will discard its argument and return the value of the reference <code>x</code> in the current context, the expression <code>Ref.x</code> will return the value inmediatly, this is useful when using it inside pyton lambdas.</p>
<div class="codehilite"><pre><span></span>Read.x(None) &lt;=&gt; Ref.x
</pre></div>


<p>As an example</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Ref</span>

<span class="k">assert</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">97</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">98</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;a b c&quot;</span><span class="p">,</span> <span class="n">Obj</span>
    <span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Write</span><span class="o">.</span><span class="n">keys</span>  <span class="c1"># keys = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
    <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">ord</span><span class="p">),</span>  <span class="c1"># [ord(&#39;a&#39;), ord(&#39;b&#39;), ord(&#39;c&#39;)] == [97, 98, 99]</span>
    <span class="k">lambda</span> <span class="n">it</span><span class="p">:</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ref</span><span class="o">.</span><span class="n">keys</span><span class="p">,</span> <span class="n">it</span><span class="p">),</span>  <span class="c1"># [(&#39;a&#39;, 97), (&#39;b&#39;, 98), (&#39;c&#39;, 99)]</span>
    <span class="nb">dict</span>   <span class="c1"># {&#39;a&#39;: 97, &#39;b&#39;: 98, &#39;c&#39;: 99}</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.layers" class="name">var <span class="ident">layers</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.builder.TensorBuilder.summary" class="name">var <span class="ident">summary</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f=&lt;function state_identity at 0x7f9366297b18&gt;)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">state_identity</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Assert">
    <p>def <span class="ident">Assert</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.Assert(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.Assert</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.Assert(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.Assert(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.Assert</strong></p>
<div class="codehilite"><pre><span></span>Asserts that the given condition is true.
</pre></div>


<p>If <code>condition</code> evaluates to false, print the list of tensors in <code>data</code>.
<code>summarize</code> determines how many entries of the tensors to print.</p>
<p>NOTE: To ensure that Assert executes, one usually attaches a dependency:</p>
<p><code>python
 # Ensure maximum element of x is smaller or equal to 1
assert_op = tf.Assert(tf.less_equal(tf.reduce_max(x), 1.), [x])
x = tf.with_dependencies([assert_op], x)</code></p>
<p>Args:
  condition: The condition to evaluate.
  data: The tensors to print out when condition is false.
  summarize: Print this many entries of each tensor.
  name: A name for this operation (optional).</p>
<p>Returns:
  assert_op: An <code>Operation</code> that, when executed, raises a
  <code>tf.errors.InvalidArgumentError</code> if <code>condition</code> is not true.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Assert', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Assert" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Dict">
    <p>def <span class="ident">Dict</span>(</p><p>self, **branches)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Dict', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Dict" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">branches</span><span class="p">):</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="p">:</span> <span class="n">_parse</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">ys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span> <span class="n">_RecordObject</span><span class="p">(</span><span class="o">**</span><span class="n">ys</span><span class="p">),</span> <span class="n">state</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Elif">
    <p>def <span class="ident">Elif</span>(</p><p>self, condition, *then, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>See <code>phi.dsl.Expression.If</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Elif', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Elif" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Elif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="o">*</span><span class="n">then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;See `phi.dsl.Expression.If`&quot;&quot;&quot;</span>
    <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ast</span>
    <span class="n">cond_f</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">then_f</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">then</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">else_f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">state_identity</span>
    <span class="n">next_else</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond_f</span><span class="p">,</span> <span class="n">then_f</span><span class="p">,</span> <span class="n">else_f</span><span class="p">)</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">_add_else</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="n">next_else</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_compile_if</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_ast</span> <span class="o">=</span> <span class="n">ast</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_root</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">return</span> <span class="n">expr</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Else">
    <p>def <span class="ident">Else</span>(</p><p>self, *Else, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>See <code>phi.dsl.Expression.If</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Else', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Else" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Else</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">Else</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;See `phi.dsl.Expression.If`&quot;&quot;&quot;</span>
    <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ast</span>
    <span class="n">next_else</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">Else</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">_add_else</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="n">next_else</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_compile_if</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.F">
    <p>def <span class="ident">F</span>(</p><p>self, expr)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.F', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.F" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span> <span class="o">&gt;&gt;</span> <span class="n">expr</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.If">
    <p>def <span class="ident">If</span>(</p><p>self, condition, *then, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>If</strong></p>
<div class="codehilite"><pre><span></span>If(Predicate, *Then)
</pre></div>


<p>Having conditionals expressions a necesity in every language, Phi includes the <code>If</code> expression for such a purpose.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>Predicate</strong> : a predicate expression uses to determine if the <code>Then</code> or <code>Else</code> branches should be used.</li>
<li><strong>*Then</strong> : an expression to be excecuted if the <code>Predicate</code> yields <code>True</code>, since this parameter is variadic you can stack expression and they will be interpreted as a tuple <code>phi.dsl.Seq</code>.</li>
</ul>
<p>This class also includes the <code>Elif</code> and <code>Else</code> methods which let you write branched conditionals in sequence, however the following rules apply</p>
<ul>
<li>If no branch is entered the whole expression behaves like the identity</li>
<li><code>Elif</code> can only be used after an <code>If</code> or another <code>Elif</code> expression</li>
<li>Many <code>Elif</code> expressions can be stacked sequentially</li>
<li><code>Else</code> can only be used after an <code>If</code> or <code>Elif</code> expression</li>
</ul>
<p><strong> Examples </strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">If</span>

<span class="k">assert</span> <span class="s2">&quot;Between 2 and 10&quot;</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">5</span><span class="p">,</span>
    <span class="n">If</span><span class="p">(</span><span class="n">P</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s2">&quot;Greater than 10&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">Elif</span><span class="p">(</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;Less than 2&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">Else</span><span class="p">(</span>
        <span class="s2">&quot;Between 2 and 10&quot;</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.If', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.If" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="o">*</span><span class="n">then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**</span>
<span class="sd">If(Predicate, *Then)</span>
<span class="sd">ng conditionals expressions a necesity in every language, Phi includes the `If` expression for such a purpose.</span>
<span class="sd">guments**</span>
<span class="sd">Predicate** : a predicate expression uses to determine if the `Then` or `Else` branches should be used.</span>
<span class="sd">*Then** : an expression to be excecuted if the `Predicate` yields `True`, since this parameter is variadic you can stack expression and they will be interpreted as a tuple `phi.dsl.Seq`.</span>
<span class="sd"> class also includes the `Elif` and `Else` methods which let you write branched conditionals in sequence, however the following rules apply</span>
<span class="sd"> no branch is entered the whole expression behaves like the identity</span>
<span class="sd">lif` can only be used after an `If` or another `Elif` expression</span>
<span class="sd">ny `Elif` expressions can be stacked sequentially</span>
<span class="sd">lse` can only be used after an `If` or `Elif` expression</span>
<span class="sd">xamples **</span>
<span class="sd">from phi import P, If</span>
<span class="sd">assert &quot;Between 2 and 10&quot; == P.Pipe(</span>
<span class="sd">    5,</span>
<span class="sd">    If(P &gt; 10,</span>
<span class="sd">        &quot;Greater than 10&quot;</span>
<span class="sd">    ).Elif(P &lt; 2,</span>
<span class="sd">        &quot;Less than 2&quot;</span>
<span class="sd">    ).Else(</span>
<span class="sd">        &quot;Between 2 and 10&quot;</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cond_f</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">then_f</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">then</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">else_f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">state_identity</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond_f</span><span class="p">,</span> <span class="n">then_f</span><span class="p">,</span> <span class="n">else_f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_compile_if</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_ast</span> <span class="o">=</span> <span class="n">ast</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_root</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">return</span> <span class="n">expr</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.List">
    <p>def <span class="ident">List</span>(</p><p>self, *branches, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>While <code>Seq</code> is sequential, <code>phi.dsl.Expression.List</code> allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements <code>__iter__</code>) that is not a tuple and yields a valid expresion.</p>
<p>The expression</p>
<div class="codehilite"><pre><span></span>k = List(f, g)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k = lambda x: [ f(x), g(x) ]
</pre></div>


<p>In general, the following rules apply after compilation:</p>
<p><strong>General Branching</strong></p>
<div class="codehilite"><pre><span></span>List(f0, f1, ..., fn)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: [ f0(x), f1(x), ..., fn(x) ]
</pre></div>


<p><strong>Composing &amp; Branching</strong></p>
<p>It is interesting to see how braching interacts with composing. The expression</p>
<div class="codehilite"><pre><span></span>Seq(f, List(g, h))
</pre></div>


<p>is <em>almost</em> equivalent to</p>
<div class="codehilite"><pre><span></span>List( Seq(f, g), Seq(f, h) )
</pre></div>


<p>As you see its as if <code>f</code> where distributed over the List. We say <em>almost</em> because their implementation is different</p>
<div class="codehilite"><pre><span></span>def _lambda(x):
    x = f(x)
    return [ g(x), h(x) ]
</pre></div>


<p>vs</p>
<div class="codehilite"><pre><span></span>lambda x: [ g(f(x)), h(f(x)) ]
</pre></div>


<p>As you see <code>f</code> is only executed once in the first one. Both should yield the same result if <code>f</code> is a pure function.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="n">form</span> <span class="n">phi</span> <span class="kn">import</span> <span class="nn">P</span><span class="o">,</span> <span class="nn">List</span>

<span class="n">avg_word_length</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;1 22 333&quot;</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="c1"># [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="c1"># [1, 2, 3]</span>
    <span class="n">List</span><span class="p">(</span>
        <span class="nb">sum</span> <span class="c1"># 1 + 2 + 3 == 6</span>
    <span class="p">,</span>
        <span class="nb">len</span> <span class="c1"># len([1, 2, 3]) == 3</span>
    <span class="p">),</span>
    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># sum / len == 6 / 3 == 2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">avg_word_length</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>The previous could also be done more briefly like this</p>
<div class="codehilite"><pre><span></span><span class="n">form</span> <span class="n">phi</span> <span class="kn">import</span> <span class="nn">P</span><span class="o">,</span> <span class="nn">Obj</span><span class="o">,</span> <span class="nn">List</span>

<span class="n">avg_word_length</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;1 22 333&quot;</span><span class="p">,</span> <span class="n">Obj</span>
    <span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  <span class="c1"># [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
    <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>    <span class="c1"># [1, 2, 3]</span>
    <span class="o">.</span><span class="n">List</span><span class="p">(</span>
        <span class="nb">sum</span>  <span class="c1">#sum([1, 2, 3]) == 6</span>
    <span class="p">,</span>
        <span class="nb">len</span>  <span class="c1">#len([1, 2, 3]) == 3</span>
    <span class="p">),</span>
    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#6 / 3 == 2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">avg_word_length</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>In the example above the last expression</p>
<div class="codehilite"><pre><span></span>P[0] / P[1]
</pre></div>


<p>works for a couple of reasons</p>
<ol>
<li>The previous expression returns a list</li>
<li>In general the expression <code>P[x]</code> compiles to a function with the form <code>lambda obj: obj[x]</code></li>
<li>
<p>The class <code>Expression</code> (the class from which the object <code>P</code> inherits) overrides most operators to create functions easily. For example, the expression</p>
<p>(P * 2) / (P + 1)</p>
</li>
</ol>
<p>compile to a function of the form</p>
<div class="codehilite"><pre><span></span>lambda x: (x * 2) / (x + 1)
</pre></div>


<p>Check out the documentatio for Phi <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.List', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.List" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">List</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">branches</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">e `Seq` is sequential, `phi.dsl.Expression.List` allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements `__iter__`) that is not a tuple and yields a valid expresion.</span>
<span class="sd">expression</span>
<span class="sd">k = List(f, g)</span>
<span class="sd">quivalent to</span>
<span class="sd">k = lambda x: [ f(x), g(x) ]</span>
<span class="sd">eneral, the following rules apply after compilation:</span>
<span class="sd">neral Branching**</span>
<span class="sd">List(f0, f1, ..., fn)</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: [ f0(x), f1(x), ..., fn(x) ]</span>
<span class="sd">mposing &amp; Branching**</span>
<span class="sd">s interesting to see how braching interacts with composing. The expression</span>
<span class="sd">Seq(f, List(g, h))</span>
<span class="sd">almost* equivalent to</span>
<span class="sd">List( Seq(f, g), Seq(f, h) )</span>
<span class="sd">ou see its as if `f` where distributed over the List. We say *almost* because their implementation is different</span>
<span class="sd">def _lambda(x):</span>
<span class="sd">    x = f(x)</span>
<span class="sd">    return [ g(x), h(x) ]</span>
<span class="sd">lambda x: [ g(f(x)), h(f(x)) ]</span>
<span class="sd">ou see `f` is only executed once in the first one. Both should yield the same result if `f` is a pure function.</span>
<span class="sd">Examples</span>
<span class="sd">form phi import P, List</span>
<span class="sd">avg_word_length = P.Pipe(</span>
<span class="sd">    &quot;1 22 333&quot;,</span>
<span class="sd">    lambda s: s.split(&#39; &#39;), # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">    lambda l: map(len, l), # [1, 2, 3]</span>
<span class="sd">    List(</span>
<span class="sd">        sum # 1 + 2 + 3 == 6</span>
<span class="sd">    ,</span>
<span class="sd">        len # len([1, 2, 3]) == 3</span>
<span class="sd">    ),</span>
<span class="sd">    lambda l: l[0] / l[1] # sum / len == 6 / 3 == 2</span>
<span class="sd">)</span>
<span class="sd">assert avg_word_length == 2</span>
<span class="sd">previous could also be done more briefly like this</span>
<span class="sd">form phi import P, Obj, List</span>
<span class="sd">avg_word_length = P.Pipe(</span>
<span class="sd">    &quot;1 22 333&quot;, Obj</span>
<span class="sd">    .split(&#39; &#39;)  # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">    .map(len)    # [1, 2, 3]</span>
<span class="sd">    .List(</span>
<span class="sd">        sum  #sum([1, 2, 3]) == 6</span>
<span class="sd">    ,</span>
<span class="sd">        len  #len([1, 2, 3]) == 3</span>
<span class="sd">    ),</span>
<span class="sd">    P[0] / P[1]  #6 / 3 == 2</span>
<span class="sd">)</span>
<span class="sd">assert avg_word_length == 2</span>
<span class="sd">he example above the last expression</span>
<span class="sd">P[0] / P[1]</span>
<span class="sd">s for a couple of reasons</span>
<span class="sd">he previous expression returns a list</span>
<span class="sd">n general the expression `P[x]` compiles to a function with the form `lambda obj: obj[x]`</span>
<span class="sd">he class `Expression` (the class from which the object `P` inherits) overrides most operators to create functions easily. For example, the expression</span>
<span class="sd">(P * 2) / (P + 1)</span>
<span class="sd">ile to a function of the form</span>
<span class="sd">lambda x: (x * 2) / (x + 1)</span>
<span class="sd">k out the documentatio for Phi [lambdas](https://cgarciae.github.io/phi/lambdas.m.html).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">branches</span> <span class="p">]</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.NoGradient">
    <p>def <span class="ident">NoGradient</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.NoGradient(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.NoGradient</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.NoGradient(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.NoGradient(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.NoGradient</strong></p>
<div class="codehilite"><pre><span></span>Specifies that ops of type `op_type` is not differentiable.
</pre></div>


<p>This function should <em>not</em> be used for operations that have a
well-defined gradient that is not yet implemented.</p>
<p>This function is only used when defining a new op type. It may be
used for ops such as <code>tf.size()</code> that are not differentiable.  For
example:</p>
<p><code>python
tf.NotDifferentiable("Size")</code></p>
<p>The gradient computed for 'op_type' will then propagate zeros.</p>
<p>For ops that have a well-defined gradient but are not yet implemented,
no declaration should be made, and an error <em>must</em> be thrown if
an attempt to request its gradient is made.</p>
<p>Args:
  op_type: The string type of an operation. This corresponds to the
    <code>OpDef.name</code> field for the proto that defines the operation.</p>
<p>Raises:
  TypeError: If <code>op_type</code> is not a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.NoGradient', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.NoGradient" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.NotDifferentiable">
    <p>def <span class="ident">NotDifferentiable</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.NotDifferentiable(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.NotDifferentiable</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.NotDifferentiable(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.NotDifferentiable(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.NotDifferentiable</strong></p>
<div class="codehilite"><pre><span></span>Specifies that ops of type `op_type` is not differentiable.
</pre></div>


<p>This function should <em>not</em> be used for operations that have a
well-defined gradient that is not yet implemented.</p>
<p>This function is only used when defining a new op type. It may be
used for ops such as <code>tf.size()</code> that are not differentiable.  For
example:</p>
<p><code>python
tf.NotDifferentiable("Size")</code></p>
<p>The gradient computed for 'op_type' will then propagate zeros.</p>
<p>For ops that have a well-defined gradient but are not yet implemented,
no declaration should be made, and an error <em>must</em> be thrown if
an attempt to request its gradient is made.</p>
<p>Args:
  op_type: The string type of an operation. This corresponds to the
    <code>OpDef.name</code> field for the proto that defines the operation.</p>
<p>Raises:
  TypeError: If <code>op_type</code> is not a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.NotDifferentiable', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.NotDifferentiable" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.PatchAt">
    <p>def <span class="ident">PatchAt</span>(</p><p>cls, n, module, method_wrapper=None, module_alias=None, method_name_modifier=&lt;function identity at 0x7f9366297aa0&gt;, blacklist_predicate=&lt;function &lt;lambda&gt; at 0x7f93662458c0&gt;, whitelist_predicate=&lt;function &lt;lambda&gt; at 0x7f9366245848&gt;, return_type_predicate=&lt;function &lt;lambda&gt; at 0x7f9366245938&gt;, getmembers_predicate=&lt;function isfunction at 0x7f9367769488&gt;, admit_private=False, explanation=u&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>This classmethod lets you easily patch all of functions/callables from a module or class as methods a Builder class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>n</strong> : the position the the object being piped will take in the arguments when the function being patched is applied. See <code>RegisterMethod</code> and <code>ThenAt</code>.</li>
<li><strong>module</strong> : a module or class from which the functions/methods/callables will be taken.</li>
<li><code>module_alias = None</code> : an optional alias for the module used for documentation purposes.</li>
<li><code>method_name_modifier = lambda f_name: None</code> : a function that can modify the name of the method will take. If <code>None</code> the name of the function will be used.</li>
<li><code>blacklist_predicate = lambda f_name: name[0] != "_"</code> : A predicate that determines which functions are banned given their name. By default it excludes all function whose name start with <code>'_'</code>. <code>blacklist_predicate</code> can also be of type list, in which case all names contained in this list will be banned.</li>
<li><code>whitelist_predicate = lambda f_name: True</code> : A predicate that determines which functions are admitted given their name. By default it include any function. <code>whitelist_predicate</code> can also be of type list, in which case only names contained in this list will be admitted. You can use both <code>blacklist_predicate</code> and <code>whitelist_predicate</code> at the same time.</li>
<li><code>return_type_predicate = lambda f_name: None</code> : a predicate that determines the <code>_return_type</code> of the Builder. By default it will always return <code>None</code>. See <code>phi.builder.Builder.ThenAt</code>.</li>
<li><code>getmembers_predicate = inspect.isfunction</code> : a predicate that determines what type of elements/members will be fetched by the <code>inspect</code> module, defaults to <a href="https://docs.python.org/2/library/inspect.html#inspect.isfunction">inspect.isfunction</a>. See <a href="https://docs.python.org/2/library/inspect.html#inspect.getmembers">getmembers</a>.</li>
</ul>
<p><strong>Examples</strong></p>
<p>Lets patch ALL the main functions from numpy into a custom builder!</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">PythonBuilder</span> <span class="c1">#or Builder</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">NumpyBuilder</span><span class="p">(</span><span class="n">PythonBuilder</span><span class="p">):</span> <span class="c1">#or Builder</span>
    <span class="s2">&quot;A Builder for numpy functions!&quot;</span>
    <span class="k">pass</span>

<span class="n">NumpyBuilder</span><span class="o">.</span><span class="n">PatchAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="n">NumpyBuilder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
</pre></div>


<p>Thats it! Although a serious patch would involve filtering out functions that don't take arrays. Another common task would be to use <code>NumpyBuilder.PatchAt(2, ...)</code> (<code>PatchAt(n, ..)</code> in general) when convenient to send the object being pipe to the relevant argument of the function. The previous is usually done with and a combination of <code>whitelist_predicate</code>s and <code>blacklist_predicate</code>s on <code>PatchAt(1, ...)</code> and <code>PatchAt(2, ...)</code> to filter or include the approriate functions on each kind of patch. Given the previous code we could now do</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">N</span>
    <span class="o">.</span><span class="kp">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="o">.</span><span class="kp">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="o">.</span><span class="kp">transpose</span><span class="p">()</span>
    <span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Which is strictly equivalent to</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">add</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">transpose</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<p>The thing to notice is that with the <code>NumpyBuilder</code> we avoid the repetitive and needless passing and reassigment of the <code>z</code> variable, this removes a lot of noise from our code.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.PatchAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.PatchAt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">PatchAt</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">method_wrapper</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">module_alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method_name_modifier</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">blacklist_predicate</span><span class="o">=</span><span class="n">_False</span><span class="p">,</span> <span class="n">whitelist_predicate</span><span class="o">=</span><span class="n">_True</span><span class="p">,</span> <span class="n">return_type_predicate</span><span class="o">=</span><span class="n">_None</span><span class="p">,</span> <span class="n">getmembers_predicate</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">,</span> <span class="n">admit_private</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> classmethod lets you easily patch all of functions/callables from a module or class as methods a Builder class.</span>
<span class="sd">guments**</span>
<span class="sd">n** : the position the the object being piped will take in the arguments when the function being patched is applied. See `RegisterMethod` and `ThenAt`.</span>
<span class="sd">module** : a module or class from which the functions/methods/callables will be taken.</span>
<span class="sd">odule_alias = None` : an optional alias for the module used for documentation purposes.</span>
<span class="sd">ethod_name_modifier = lambda f_name: None` : a function that can modify the name of the method will take. If `None` the name of the function will be used.</span>
<span class="sd">lacklist_predicate = lambda f_name: name[0] != &quot;_&quot;` : A predicate that determines which functions are banned given their name. By default it excludes all function whose name start with `&#39;_&#39;`. `blacklist_predicate` can also be of type list, in which case all names contained in this list will be banned.</span>
<span class="sd">hitelist_predicate = lambda f_name: True` : A predicate that determines which functions are admitted given their name. By default it include any function. `whitelist_predicate` can also be of type list, in which case only names contained in this list will be admitted. You can use both `blacklist_predicate` and `whitelist_predicate` at the same time.</span>
<span class="sd">eturn_type_predicate = lambda f_name: None` : a predicate that determines the `_return_type` of the Builder. By default it will always return `None`. See `phi.builder.Builder.ThenAt`.</span>
<span class="sd">etmembers_predicate = inspect.isfunction` : a predicate that determines what type of elements/members will be fetched by the `inspect` module, defaults to [inspect.isfunction](https://docs.python.org/2/library/inspect.html#inspect.isfunction). See [getmembers](https://docs.python.org/2/library/inspect.html#inspect.getmembers).</span>
<span class="sd">amples**</span>
<span class="sd"> patch ALL the main functions from numpy into a custom builder!</span>
<span class="sd">from phi import PythonBuilder #or Builder</span>
<span class="sd">import numpy as np</span>
<span class="sd">class NumpyBuilder(PythonBuilder): #or Builder</span>
<span class="sd">    &quot;A Builder for numpy functions!&quot;</span>
<span class="sd">    pass</span>
<span class="sd">NumpyBuilder.PatchAt(1, np)</span>
<span class="sd">N = NumpyBuilder(lambda x: x)</span>
<span class="sd">s it! Although a serious patch would involve filtering out functions that don&#39;t take arrays. Another common task would be to use `NumpyBuilder.PatchAt(2, ...)` (`PatchAt(n, ..)` in general) when convenient to send the object being pipe to the relevant argument of the function. The previous is usually done with and a combination of `whitelist_predicate`s and `blacklist_predicate`s on `PatchAt(1, ...)` and `PatchAt(2, ...)` to filter or include the approriate functions on each kind of patch. Given the previous code we could now do</span>
<span class="sd">import numpy as np</span>
<span class="sd">x = np.array([[1,2],[3,4]])</span>
<span class="sd">y = np.array([[5,6],[7,8]])</span>
<span class="sd">z = N.Pipe(</span>
<span class="sd">    x, N</span>
<span class="sd">    .dot(y)</span>
<span class="sd">    .add(x)</span>
<span class="sd">    .transpose()</span>
<span class="sd">    .sum(axis=1)</span>
<span class="sd">)</span>
<span class="sd">h is strictly equivalent to</span>
<span class="sd">import numpy as np</span>
<span class="sd">x = np.array([[1,2],[3,4]])</span>
<span class="sd">y = np.array([[5,6],[7,8]])</span>
<span class="sd">z = np.dot(x, y)</span>
<span class="sd">z = np.add(z, x)</span>
<span class="sd">z = np.transpose(z)</span>
<span class="sd">z = np.sum(z, axis=1)</span>
<span class="sd">thing to notice is that with the `NumpyBuilder` we avoid the repetitive and needless passing and reassigment of the `z` variable, this removes a lot of noise from our code.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_rtp</span> <span class="o">=</span> <span class="n">return_type_predicate</span>
    <span class="n">return_type_predicate</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_rtp</span><span class="p">)</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">_rtp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_rtp</span><span class="p">,</span> <span class="n">Builder</span><span class="p">)</span> <span class="k">else</span> <span class="n">_rtp</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="n">module_alias</span> <span class="k">if</span> <span class="n">module_alias</span> <span class="k">else</span> <span class="n">module</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
    <span class="n">patch_members</span> <span class="o">=</span> <span class="n">_get_patch_members</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">blacklist_predicate</span><span class="o">=</span><span class="n">blacklist_predicate</span><span class="p">,</span> <span class="n">whitelist_predicate</span><span class="o">=</span><span class="n">whitelist_predicate</span><span class="p">,</span> <span class="n">getmembers_predicate</span><span class="o">=</span><span class="n">getmembers_predicate</span><span class="p">,</span> <span class="n">admit_private</span><span class="o">=</span><span class="n">admit_private</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">patch_members</span><span class="p">:</span>
        <span class="n">wrapped</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">method_wrapper</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">method_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">wrapped</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">return_type_predicate</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">alias</span><span class="o">=</span><span class="n">method_name_modifier</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Pipe">
    <p>def <span class="ident">Pipe</span>(</p><p>self, *sequence, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Pipe</code> runs any <code>phi.dsl.Expression</code>. Its highly inspired by Elixir's <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2">|&gt; (pipe)</a> operator.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*sequence</strong>: any variable amount of expressions. All expressions inside of <code>sequence</code> will be composed together using <code>phi.dsl.Expression.Seq</code>.</li>
<li><strong>**kwargs</strong>: <code>Pipe</code> forwards all <code>kwargs</code> to <code>phi.builder.Builder.Seq</code>, visit its documentation for more info.</li>
</ul>
<p>The expression</p>
<div class="codehilite"><pre><span></span>Pipe(*sequence, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>Seq(*sequence, **kwargs)(None)
</pre></div>


<p>Normally the first argument or <code>Pipe</code> is a value, that is reinterpreted as a <code>phi.dsl.Expression.Val</code>, therfore, the input <code>None</code> is discarded.</p>
<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">mul3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>     <span class="c1">#input</span>
    <span class="n">add1</span><span class="p">,</span>  <span class="c1">#1 + 1 == 2</span>
    <span class="n">mul3</span>   <span class="c1">#2 * 3 == 6</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p>The previous using <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a> to create the functions</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>      <span class="c1">#input</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">#1 + 1 == 2</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">#2 * 3 == 6</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Seq</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
<li><a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Pipe', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Pipe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">e` runs any `phi.dsl.Expression`. Its highly inspired by Elixir&#39;s [|&gt; (pipe)](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2) operator.</span>
<span class="sd">guments**</span>
<span class="sd">*sequence**: any variable amount of expressions. All expressions inside of `sequence` will be composed together using `phi.dsl.Expression.Seq`.</span>
<span class="sd">**kwargs**: `Pipe` forwards all `kwargs` to `phi.builder.Builder.Seq`, visit its documentation for more info.</span>
<span class="sd">expression</span>
<span class="sd">Pipe(*sequence, **kwargs)</span>
<span class="sd">quivalent to</span>
<span class="sd">Seq(*sequence, **kwargs)(None)</span>
<span class="sd">ally the first argument or `Pipe` is a value, that is reinterpreted as a `phi.dsl.Expression.Val`, therfore, the input `None` is discarded.</span>
<span class="sd">amples**</span>
<span class="sd">from phi import P</span>
<span class="sd">def add1(x): return x + 1</span>
<span class="sd">def mul3(x): return x * 3</span>
<span class="sd">x = P.Pipe(</span>
<span class="sd">    1,     #input</span>
<span class="sd">    add1,  #1 + 1 == 2</span>
<span class="sd">    mul3   #2 * 3 == 6</span>
<span class="sd">)</span>
<span class="sd">assert x == 6</span>
<span class="sd">previous using [lambdas](https://cgarciae.github.io/phi/lambdas.m.html) to create the functions</span>
<span class="sd">from phi import P</span>
<span class="sd">x = P.Pipe(</span>
<span class="sd">    1,      #input</span>
<span class="sd">    P + 1,  #1 + 1 == 2</span>
<span class="sd">    P * 3   #2 * 3 == 6</span>
<span class="sd">)</span>
<span class="sd">assert x == 6</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Seq`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">ambdas](https://cgarciae.github.io/phi/lambdas.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;refs&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">state</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Print">
    <p>def <span class="ident">Print</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.Print(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.Print</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.Print(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.Print(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.Print</strong></p>
<div class="codehilite"><pre><span></span>Prints a list of tensors.
</pre></div>


<p>This is an identity op with the side effect of printing <code>data</code> when
evaluating.</p>
<p>Args:
  input_: A tensor passed through this op.
  data: A list of tensors to print out when op is evaluated.
  message: A string, prefix of the error message.
  first_n: Only log <code>first_n</code> number of times. Negative numbers log always;
           this is the default.
  summarize: Only print this many entries of each tensor. If None, then a
             maximum of 3 elements are printed per input tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same tensor as <code>input_</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Print', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Print" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ReadList">
    <p>def <span class="ident">ReadList</span>(</p><p>self, *branches, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Same as <code>phi.dsl.Expression.List</code> but any string argument <code>x</code> is translated to <code>Read(x)</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ReadList', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ReadList" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ReadList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">branches</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> as `phi.dsl.Expression.List` but any string argument `x` is translated to `Read(x)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">E</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">,</span> <span class="n">branches</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="o">*</span><span class="n">branches</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register">
    <p>def <span class="ident">Register</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register(...)</code> is a shortcut for <code>RegisterAt(1, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister(...)` is a shortcut for `RegisterAt(1, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register0">
    <p>def <span class="ident">Register0</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register0(...)</code> is a shortcut for <code>RegisterAt(0, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register0" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register0</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister0(...)` is a shortcut for `RegisterAt(0, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register2">
    <p>def <span class="ident">Register2</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register2(...)</code> is a shortcut for <code>RegisterAt(2, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register2</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister2(...)` is a shortcut for `RegisterAt(2, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register3">
    <p>def <span class="ident">Register3</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register3(...)</code> is a shortcut for <code>RegisterAt(3, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register3" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register3</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister3(...)` is a shortcut for `RegisterAt(3, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register4">
    <p>def <span class="ident">Register4</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register4(...)</code> is a shortcut for <code>RegisterAt(4, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register4" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register4</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister4(...)` is a shortcut for `RegisterAt(4, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Register5">
    <p>def <span class="ident">Register5</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register5(...)</code> is a shortcut for <code>RegisterAt(5, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Register5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Register5" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register5</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister5(...)` is a shortcut for `RegisterAt(5, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterAt">
    <p>def <span class="ident">RegisterAt</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>RegisterAt</strong></p>
<div class="codehilite"><pre><span></span>RegisterAt(n, f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True, _return_type=None)
</pre></div>


<p>Most of the time you don't want to register an method as such, that is, you don't care about the <code>self</code> builder object, instead you want to register a function that transforms the value being piped down the DSL. For this you can use <code>RegisterAt</code> so e.g.</p>
<div class="codehilite"><pre><span></span>def some_fun(obj, arg1, arg2):
    # code

@MyBuilder.RegisterMethod(&quot;my_lib.&quot;)
def some_fun_wrapper(self, arg1, arg2):
    return self.ThenAt(1, some_fun, arg1, arg2)
</pre></div>


<p>can be written directly as</p>
<div class="codehilite"><pre><span></span>@MyBuilder.RegisterAt(1, &quot;my_lib.&quot;)
def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p>For this case you can just use <code>Register</code> which is a shortcut for <code>RegisterAt(1, ...)</code></p>
<div class="codehilite"><pre><span></span>@MyBuilder.Register(&quot;my_lib.&quot;)
def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterAt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterAt</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">gisterAt**</span>
<span class="sd">RegisterAt(n, f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True, _return_type=None)</span>
<span class="sd"> of the time you don&#39;t want to register an method as such, that is, you don&#39;t care about the `self` builder object, instead you want to register a function that transforms the value being piped down the DSL. For this you can use `RegisterAt` so e.g.</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">@MyBuilder.RegisterMethod(&quot;my_lib.&quot;)</span>
<span class="sd">def some_fun_wrapper(self, arg1, arg2):</span>
<span class="sd">    return self.ThenAt(1, some_fun, arg1, arg2)</span>
<span class="sd">be written directly as</span>
<span class="sd">@MyBuilder.RegisterAt(1, &quot;my_lib.&quot;)</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">this case you can just use `Register` which is a shortcut for `RegisterAt(1, ...)`</span>
<span class="sd">@MyBuilder.Register(&quot;my_lib.&quot;)</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unpack_error</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">library_path</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.RegisterMethod">
    <p>def <span class="ident">RegisterMethod</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>RegisterMethod</strong></p>
<div class="codehilite"><pre><span></span>RegisterMethod(f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True)
</pre></div>


<p><code>classmethod</code> for registering functions as methods of this class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>f</strong> : the particular function being registered as a method</li>
<li><strong>library_path</strong> : library from where <code>f</code> comes from, unless you pass an empty string, put a period <code>"."</code> at the end of the library name.</li>
<li><code>alias=None</code> : alias for the name/method being registered</li>
<li><code>original_name=None</code> : name of the original function, used for documentation purposes.</li>
<li><code>doc=None</code> : complete documentation of the method being registered</li>
<li><code>wrapped=None</code> : if you are registering a function which wraps around another function, pass this other function through <code>wrapped</code> to get better documentation, this is specially useful is you register a bunch of functions in a for loop. Please include an <code>explanation</code> to tell how the actual function differs from the wrapped one.</li>
<li><code>explanation=""</code> : especify any additional information for the documentation of the method being registered, you can use any of the following format tags within this string and they will be replace latter on: <code>{original_name}</code>, <code>{name}</code>, <code>{fn_docs}</code>, <code>{library_path}</code>, <code>{builder_class}</code>.</li>
<li><code>method_type=identity</code> : by default its applied but does nothing, you might also want to register functions as <code>property</code>, <code>classmethod</code>, <code>staticmethod</code></li>
<li><code>explain=True</code> : decide whether or not to show any kind of explanation, its useful to set it to <code>False</code> if you are using a <code>Register*</code> decorator and will only use the function as a registered method.</li>
</ul>
<p>A main feature of <code>phi</code> is that it enables you to integrate your library or even an existing library with the DSL. You can achieve three levels of integration</p>
<ol>
<li>Passing your functions to the DSL. This a very general machanism -since you could actually do everything with python lamdas- but in practice functions often receive multiple parameters.</li>
<li>Creating partials with the <code>Then*</code> method family. Using this you could integrate any function, but it will add a lot of noise if you use heavily on it.</li>
<li>Registering functions as methods of a <code>Builder</code> derived class. This produces the most readable code and its the approach you should take if you want to create a Phi-based library or a helper class.</li>
</ol>
<p>While point 3 is the most desirable it has a cost: you need to create your own <code>phi.builder.Builder</code>-derived class. This is because SHOULD NOT register functions to existing builders e.g. the <code>phi.builder.Builder</code> or <a href="https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder">PythonBuilder</a> provided by phi because that would pollute the <code>P</code> object. Instead you should create a custom class that derives from <code>phi.builder.Builder</code>,  <a href="https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder">PythonBuilder</a> or another custom builder depending on your needs and register your functions to that class.</p>
<p><strong>Examples</strong></p>
<p>Say you have a function on a library called <code>"my_lib"</code></p>
<div class="codehilite"><pre><span></span>def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p>You could use it with the dsl like this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Then</span>

<span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">Then</span><span class="p">(</span><span class="n">some_fun</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>


<p>assuming the first parameter <code>obj</code> is being piped down. However if you do this very often or you are creating a library, you are better off creating a custom class derived from <code>Builder</code> or <code>PythonBuilder</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">Builder</span> <span class="c1">#or PythonBuilder</span>

<span class="k">class</span> <span class="nc">MyBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span> <span class="c1"># or PythonBuilder</span>
    <span class="k">pass</span>
</pre></div>


<p>and registering your function as a method. The first way you could do this is by creating a wrapper function for <code>some_fun</code> and registering it as a method</p>
<div class="codehilite"><pre><span></span>def some_fun_wrapper(self, arg1, arg2):
    return self.Then(some_fun, arg1, arg2)

MyBuilder.RegisterMethod(some_fun_wrapper, &quot;my_lib.&quot;, wrapped=some_fun)
</pre></div>


<p>Here we basically created a shortcut for the original expression <code>Then(some_fun, arg1, arg2)</code>. You could also do this using a decorator</p>
<div class="codehilite"><pre><span></span>@MyBuilder.RegisterMethod(&quot;my_lib.&quot;, wrapped=some_fun)
def some_fun_wrapper(self, arg1, arg2):
    return self.Then(some_fun, arg1, arg2)
</pre></div>


<p>However, this is such a common task that we've created the method <code>Register</code> to avoid you from having to create the wrapper. With it you could register the function <code>some_fun</code> directly as a method like this</p>
<div class="codehilite"><pre><span></span>MyBuilder.Register(some_fun, &quot;my_lib.&quot;)
</pre></div>


<p>or by using a decorator over the original function definition</p>
<div class="codehilite"><pre><span></span>@MyBuilder.Register(&quot;my_lib.&quot;)
def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p>Once done you've done any of the previous approaches you can create a custom global object e.g. <code>M</code> and use it instead of/along with <code>P</code></p>
<div class="codehilite"><pre><span></span>M = MyBuilder(lambda x: x)

M.Pipe(
    input,
    ...
    M.some_fun(arg1, args)
    ...
)
</pre></div>


<p><strong>Argument position</strong></p>
<p><code>phi.builder.Builder.Register</code> internally uses <code>phi.builder.Builder.Then</code>, this is only useful if the object being piped is intended to be passed as the first argument of the function being registered, if this is not the case you could use <code>phi.builder.Builder.Register2</code>, <code>phi.builder.Builder.Register3</code>, ..., <code>phi.builder.Builder.Register5</code> or <code>phi.builder.Builder.RegisterAt</code> to set an arbitrary position, these functions will internally use <code>phi.builder.Builder.Then2</code>, <code>phi.builder.Builder.Then3</code>, ..., <code>phi.builder.Builder.Then5</code> or <code>phi.builder.Builder.ThenAt</code> respectively.</p>
<p><strong>Wrapping functions</strong></p>
<p>Sometimes you have an existing function that you would like to modify slightly so it plays nicely with the DSL, what you normally do is create a function that wraps around it and passes the arguments to it in a way that is convenient</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">some_lib</span>

<span class="nd">@MyBuilder.Register</span><span class="p">(</span><span class="s2">&quot;some_lib.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">some_lib</span><span class="o">.</span><span class="n">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># forward the args, n slightly modified</span>
</pre></div>


<p>When you do this -as a side effect- you loose the original documentation, to avoid this you can use the Registers <code>wrapped</code> argument along with the <code>explanation</code> argument to clarity the situation</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">some_lib</span>

<span class="n">some_fun_explanation</span> <span class="o">=</span> <span class="s2">&quot;However, it differs in that `n` is automatically subtracted `1`&quot;</span>

<span class="nd">@MyBuilder.Register</span><span class="p">(</span><span class="s2">&quot;some_lib.&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">some_lib</span><span class="o">.</span><span class="n">some_fun</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">some_fun_explanation</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">some_lib</span><span class="o">.</span><span class="n">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># forward the args, n slightly modified</span>
</pre></div>


<p>Now the documentation for <code>MyBuilder.some_fun</code> will be a little bit nicer since it includes the original documentation from <code>some_lib.some_fun</code>. This behaviour is specially useful if you are wrapping an entire 3rd party library, you usually automate the process iterating over all the funcitions in a for loop. The <code>phi.builder.Builder.PatchAt</code> method lets you register and entire module using a few lines of code, however, something you have to do thing more manually and do the iteration yourself.</p>
<p><strong>See Also</strong></p>
<ul>
<li><code>phi.builder.Builder.PatchAt</code></li>
<li><code>phi.builder.Builder.RegisterAt</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.RegisterMethod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.RegisterMethod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterMethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">gisterMethod**</span>
<span class="sd">RegisterMethod(f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True)</span>
<span class="sd">ssmethod` for registering functions as methods of this class.</span>
<span class="sd">guments**</span>
<span class="sd">f** : the particular function being registered as a method</span>
<span class="sd">library_path** : library from where `f` comes from, unless you pass an empty string, put a period `&quot;.&quot;` at the end of the library name.</span>
<span class="sd">lias=None` : alias for the name/method being registered</span>
<span class="sd">riginal_name=None` : name of the original function, used for documentation purposes.</span>
<span class="sd">oc=None` : complete documentation of the method being registered</span>
<span class="sd">rapped=None` : if you are registering a function which wraps around another function, pass this other function through `wrapped` to get better documentation, this is specially useful is you register a bunch of functions in a for loop. Please include an `explanation` to tell how the actual function differs from the wrapped one.</span>
<span class="sd">xplanation=&quot;&quot;` : especify any additional information for the documentation of the method being registered, you can use any of the following format tags within this string and they will be replace latter on: `{original_name}`, `{name}`, `{fn_docs}`, `{library_path}`, `{builder_class}`.</span>
<span class="sd">ethod_type=identity` : by default its applied but does nothing, you might also want to register functions as `property`, `classmethod`, `staticmethod`</span>
<span class="sd">xplain=True` : decide whether or not to show any kind of explanation, its useful to set it to `False` if you are using a `Register*` decorator and will only use the function as a registered method.</span>
<span class="sd">in feature of `phi` is that it enables you to integrate your library or even an existing library with the DSL. You can achieve three levels of integration</span>
<span class="sd">assing your functions to the DSL. This a very general machanism -since you could actually do everything with python lamdas- but in practice functions often receive multiple parameters.</span>
<span class="sd">reating partials with the `Then*` method family. Using this you could integrate any function, but it will add a lot of noise if you use heavily on it.</span>
<span class="sd">egistering functions as methods of a `Builder` derived class. This produces the most readable code and its the approach you should take if you want to create a Phi-based library or a helper class.</span>
<span class="sd">e point 3 is the most desirable it has a cost: you need to create your own `phi.builder.Builder`-derived class. This is because SHOULD NOT register functions to existing builders e.g. the `phi.builder.Builder` or [PythonBuilder](https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder) provided by phi because that would pollute the `P` object. Instead you should create a custom class that derives from `phi.builder.Builder`,  [PythonBuilder](https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder) or another custom builder depending on your needs and register your functions to that class.</span>
<span class="sd">amples**</span>
<span class="sd">you have a function on a library called `&quot;my_lib&quot;`</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">could use it with the dsl like this</span>
<span class="sd">from phi import P, Then</span>
<span class="sd">P.Pipe(</span>
<span class="sd">    input,</span>
<span class="sd">    ...</span>
<span class="sd">    Then(some_fun, arg1, arg2)</span>
<span class="sd">    ...</span>
<span class="sd">)</span>
<span class="sd">ming the first parameter `obj` is being piped down. However if you do this very often or you are creating a library, you are better off creating a custom class derived from `Builder` or `PythonBuilder`</span>
<span class="sd">from phi import Builder #or PythonBuilder</span>
<span class="sd">class MyBuilder(Builder): # or PythonBuilder</span>
<span class="sd">    pass</span>
<span class="sd">registering your function as a method. The first way you could do this is by creating a wrapper function for `some_fun` and registering it as a method</span>
<span class="sd">def some_fun_wrapper(self, arg1, arg2):</span>
<span class="sd">    return self.Then(some_fun, arg1, arg2)</span>
<span class="sd">MyBuilder.RegisterMethod(some_fun_wrapper, &quot;my_lib.&quot;, wrapped=some_fun)</span>
<span class="sd"> we basically created a shortcut for the original expression `Then(some_fun, arg1, arg2)`. You could also do this using a decorator</span>
<span class="sd">@MyBuilder.RegisterMethod(&quot;my_lib.&quot;, wrapped=some_fun)</span>
<span class="sd">def some_fun_wrapper(self, arg1, arg2):</span>
<span class="sd">    return self.Then(some_fun, arg1, arg2)</span>
<span class="sd">ver, this is such a common task that we&#39;ve created the method `Register` to avoid you from having to create the wrapper. With it you could register the function `some_fun` directly as a method like this</span>
<span class="sd">MyBuilder.Register(some_fun, &quot;my_lib.&quot;)</span>
<span class="sd">y using a decorator over the original function definition</span>
<span class="sd">@MyBuilder.Register(&quot;my_lib.&quot;)</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd"> done you&#39;ve done any of the previous approaches you can create a custom global object e.g. `M` and use it instead of/along with `P`</span>
<span class="sd">M = MyBuilder(lambda x: x)</span>
<span class="sd">M.Pipe(</span>
<span class="sd">    input,</span>
<span class="sd">    ...</span>
<span class="sd">    M.some_fun(arg1, args)</span>
<span class="sd">    ...</span>
<span class="sd">)</span>
<span class="sd">gument position**</span>
<span class="sd">.builder.Builder.Register` internally uses `phi.builder.Builder.Then`, this is only useful if the object being piped is intended to be passed as the first argument of the function being registered, if this is not the case you could use `phi.builder.Builder.Register2`, `phi.builder.Builder.Register3`, ..., `phi.builder.Builder.Register5` or `phi.builder.Builder.RegisterAt` to set an arbitrary position, these functions will internally use `phi.builder.Builder.Then2`, `phi.builder.Builder.Then3`, ..., `phi.builder.Builder.Then5` or `phi.builder.Builder.ThenAt` respectively.</span>
<span class="sd">apping functions**</span>
<span class="sd">times you have an existing function that you would like to modify slightly so it plays nicely with the DSL, what you normally do is create a function that wraps around it and passes the arguments to it in a way that is convenient</span>
<span class="sd">import some_lib</span>
<span class="sd">@MyBuilder.Register(&quot;some_lib.&quot;)</span>
<span class="sd">def some_fun(a, n):</span>
<span class="sd">    return some_lib.some_fun(a, n - 1) # forward the args, n slightly modified</span>
<span class="sd"> you do this -as a side effect- you loose the original documentation, to avoid this you can use the Registers `wrapped` argument along with the `explanation` argument to clarity the situation</span>
<span class="sd">import some_lib</span>
<span class="sd">some_fun_explanation = &quot;However, it differs in that `n` is automatically subtracted `1`&quot;</span>
<span class="sd">@MyBuilder.Register(&quot;some_lib.&quot;, wrapped=some_lib.some_fun, explanation=some_fun_explanation)</span>
<span class="sd">def some_fun(a, n):</span>
<span class="sd">    return some_lib.some_fun(a, n - 1) # forward the args, n slightly modified</span>
<span class="sd">the documentation for `MyBuilder.some_fun` will be a little bit nicer since it includes the original documentation from `some_lib.some_fun`. This behaviour is specially useful if you are wrapping an entire 3rd party library, you usually automate the process iterating over all the funcitions in a for loop. The `phi.builder.Builder.PatchAt` method lets you register and entire module using a few lines of code, however, something you have to do thing more manually and do the iteration yourself.</span>
<span class="sd">e Also**</span>
<span class="sd">hi.builder.Builder.PatchAt`</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterMethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unpack_error</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">library_path</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterMethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Seq">
    <p>def <span class="ident">Seq</span>(</p><p>self, *sequence, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Seq</code> is used to express function composition. The expression</p>
<div class="codehilite"><pre><span></span>Seq(f, g)
</pre></div>


<p>be equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: g(f(x))
</pre></div>


<p>As you see, its a little different from the mathematical definition. Excecution order flow from left to right, this makes reading and reasoning about code way more easy. This bahaviour is based upon the <code>|&gt;</code> (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</p>
<p>In general, the following rules apply for Seq:</p>
<p><strong>General Sequence</strong></p>
<div class="codehilite"><pre><span></span>Seq(f0, f1, ..., fn-1, fn)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: fn(fn-1(...(f1(f0(x)))))
</pre></div>


<p><strong>Single Function</strong></p>
<div class="codehilite"><pre><span></span>Seq(f)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>f
</pre></div>


<p><strong>Identity</strong></p>
<p>The empty Seq</p>
<div class="codehilite"><pre><span></span>Seq()
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: x
</pre></div>


<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Seq</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span> <span class="c1"># ((1 * 2) + 1) ** 2</span>
</pre></div>


<p>The previous example using <code>P.Pipe</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">9</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1">#1 * 2 == 2</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">#2 + 1 == 3</span>
    <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1">#3 ** 2 == 9</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Seq', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Seq" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">` is used to express function composition. The expression</span>
<span class="sd">Seq(f, g)</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: g(f(x))</span>
<span class="sd">ou see, its a little different from the mathematical definition. Excecution order flow from left to right, this makes reading and reasoning about code way more easy. This bahaviour is based upon the `|&gt;` (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</span>
<span class="sd">eneral, the following rules apply for Seq:</span>
<span class="sd">neral Sequence**</span>
<span class="sd">Seq(f0, f1, ..., fn-1, fn)</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: fn(fn-1(...(f1(f0(x)))))</span>
<span class="sd">ngle Function**</span>
<span class="sd">Seq(f)</span>
<span class="sd">quivalent to</span>
<span class="sd">f</span>
<span class="sd">entity**</span>
<span class="sd">empty Seq</span>
<span class="sd">Seq()</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: x</span>
<span class="sd">Examples</span>
<span class="sd">from phi import P, Seq</span>
<span class="sd">f = Seq(</span>
<span class="sd">    P * 2,</span>
<span class="sd">    P + 1,</span>
<span class="sd">    P ** 2</span>
<span class="sd">)</span>
<span class="sd">assert f(1) == 9 # ((1 * 2) + 1) ** 2</span>
<span class="sd">previous example using `P.Pipe`</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 9 == P.Pipe(</span>
<span class="sd">    1,</span>
<span class="sd">    P * 2,  #1 * 2 == 2</span>
<span class="sd">    P + 1,  #2 + 1 == 3</span>
<span class="sd">    P ** 2  #3 ** 2 == 9</span>
<span class="sd">)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="p">]</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">args</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">fs</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Set">
    <p>def <span class="ident">Set</span>(</p><p>self, *expressions, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Set', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Set" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="o">*</span><span class="n">expressions</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nb">set</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then">
    <p>def <span class="ident">Then</span>(</p><p>self, f, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then(f, ...)</code> is equivalent to <code>ThenAt(1, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n(f, ...)` is equivalent to `ThenAt(1, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then0">
    <p>def <span class="ident">Then0</span>(</p><p>self, f, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then0(f, ...)</code> is equivalent to <code>ThenAt(0, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then0" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n0(f, ...)` is equivalent to `ThenAt(0, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then1">
    <p>def <span class="ident">Then1</span>(</p><p>self, f, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then(f, ...)</code> is equivalent to <code>ThenAt(1, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then1" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n(f, ...)` is equivalent to `ThenAt(1, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then2">
    <p>def <span class="ident">Then2</span>(</p><p>self, f, arg1, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then2(f, ...)</code> is equivalent to <code>ThenAt(2, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then2" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n2(f, ...)` is equivalent to `ThenAt(2, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then3">
    <p>def <span class="ident">Then3</span>(</p><p>self, f, arg1, arg2, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then3(f, ...)</code> is equivalent to <code>ThenAt(3, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then3" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n3(f, ...)` is equivalent to `ThenAt(3, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then4">
    <p>def <span class="ident">Then4</span>(</p><p>self, f, arg1, arg2, arg3, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then4(f, ...)</code> is equivalent to <code>ThenAt(4, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then4" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n4(f, ...)` is equivalent to `ThenAt(4, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Then5">
    <p>def <span class="ident">Then5</span>(</p><p>self, f, arg1, arg2, arg3, arg4, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then5(f, ...)</code> is equivalent to <code>ThenAt(5, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Then5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Then5" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n5(f, ...)` is equivalent to `ThenAt(5, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ThenAt">
    <p>def <span class="ident">ThenAt</span>(</p><p>self, n, f, *_args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>ThenAt</code> enables you to create a partially apply many arguments to a function, the returned partial expects a single arguments which will be applied at the <code>n</code>th position of the original function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>n</strong>: position at which the created partial will apply its awaited argument on the original function.</li>
<li><strong>f</strong>: function which the partial will be created.</li>
<li><strong>_args &amp; kwargs</strong>: all <code>*_args</code> and <code>**kwargs</code> will be passed to the function <code>f</code>.</li>
<li><code>_return_type = None</code>: type of the returned <code>builder</code>, if <code>None</code> it will return the same type of the current <code>builder</code>. This special kwarg will NOT be passed to <code>f</code>.</li>
</ul>
<p>You can think of <code>n</code> as the position that the value being piped down will pass through the <code>f</code>. Say you have the following expression</p>
<div class="codehilite"><pre><span></span>D == fun(A, B, C)
</pre></div>


<p>all the following are equivalent</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">ThenAt</span>

<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">ThenAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">ThenAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
</pre></div>


<p>you could also use the shortcuts <code>Then</code>, <code>Then2</code>,..., <code>Then5</code>, which are more readable</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then3</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
</pre></div>


<p>There is a special case not discussed above: <code>n = 0</code>. When this happens only the arguments given will be applied to <code>f</code>, this method it will return a partial that expects a single argument but completely ignores it</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
</pre></div>


<p><strong>Examples</strong></p>
<p>Max of 6 and the argument:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">6</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Previous is equivalent to</p>
<div class="codehilite"><pre><span></span>assert 6 == max(2, 6)
</pre></div>


<p>Open a file in read mode (<code>'r'</code>)</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;file.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="nb">open</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Previous is equivalent to</p>
<div class="codehilite"><pre><span></span>f = open(&quot;file.txt&quot;, &#39;r&#39;)
</pre></div>


<p>Split a string by whitespace and then get the length of each word</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;Again hello world&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Previous is equivalent to</p>
<div class="codehilite"><pre><span></span>x = &quot;Again hello world&quot;

x = str.split(x, &#39; &#39;)
x = map(len, x)

assert [5, 5, 5] == x
</pre></div>


<p>As you see, <code>Then2</code> was very useful because <code>map</code> accepts and <code>iterable</code> as its <code>2nd</code> parameter. You can rewrite the previous using the <a href="https://cgarciae.github.io/phi/python_builder.m.html">PythonBuilder</a> and the <code>phi.builder.Builder.Obj</code> object</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">assert</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;Again hello world&quot;</span><span class="p">,</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span>
    <span class="n">P</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><a href="https://cgarciae.github.io/phi/python_builder.m.html">PythonBuilder</a></li>
<li><code>phi.builder.Builder.RegisterAt</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ThenAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ThenAt" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ThenAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">nAt` enables you to create a partially apply many arguments to a function, the returned partial expects a single arguments which will be applied at the `n`th position of the original function.</span>
<span class="sd">guments**</span>
<span class="sd">n**: position at which the created partial will apply its awaited argument on the original function.</span>
<span class="sd">f**: function which the partial will be created.</span>
<span class="sd">_args &amp; kwargs**: all `*_args` and `**kwargs` will be passed to the function `f`.</span>
<span class="sd">return_type = None`: type of the returned `builder`, if `None` it will return the same type of the current `builder`. This special kwarg will NOT be passed to `f`.</span>
<span class="sd">can think of `n` as the position that the value being piped down will pass through the `f`. Say you have the following expression</span>
<span class="sd">D == fun(A, B, C)</span>
<span class="sd">the following are equivalent</span>
<span class="sd">from phi import P, Pipe, ThenAt</span>
<span class="sd">D == Pipe(A, ThenAt(1, fun, B, C))</span>
<span class="sd">D == Pipe(B, ThenAt(2, fun, A, C))</span>
<span class="sd">D == Pipe(C, ThenAt(3, fun, A, B))</span>
<span class="sd">could also use the shortcuts `Then`, `Then2`,..., `Then5`, which are more readable</span>
<span class="sd">from phi import P, Pipe</span>
<span class="sd">D == Pipe(A, P.Then(fun, B, C))</span>
<span class="sd">D == Pipe(B, P.Then2(fun, A, C))</span>
<span class="sd">D == Pipe(C, P.Then3(fun, A, B))</span>
<span class="sd">e is a special case not discussed above: `n = 0`. When this happens only the arguments given will be applied to `f`, this method it will return a partial that expects a single argument but completely ignores it</span>
<span class="sd">from phi import P</span>
<span class="sd">D == Pipe(None, P.ThenAt(0, fun, A, B, C))</span>
<span class="sd">D == Pipe(None, P.Then0(fun, A, B, C))</span>
<span class="sd">amples**</span>
<span class="sd">of 6 and the argument:</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 6 == P.Pipe(</span>
<span class="sd">    2,</span>
<span class="sd">    P.Then(max, 6)</span>
<span class="sd">)</span>
<span class="sd">ious is equivalent to</span>
<span class="sd">assert 6 == max(2, 6)</span>
<span class="sd"> a file in read mode (`&#39;r&#39;`)</span>
<span class="sd">from phi import P</span>
<span class="sd">f = P.Pipe(</span>
<span class="sd">    &quot;file.txt&quot;,</span>
<span class="sd">    P.Then(open, &#39;r&#39;)</span>
<span class="sd">)</span>
<span class="sd">ious is equivalent to</span>
<span class="sd">f = open(&quot;file.txt&quot;, &#39;r&#39;)</span>
<span class="sd">t a string by whitespace and then get the length of each word</span>
<span class="sd">from phi import P</span>
<span class="sd">assert [5, 5, 5] == P.Pipe(</span>
<span class="sd">    &quot;Again hello world&quot;,</span>
<span class="sd">    P.Then(str.split, &#39; &#39;)</span>
<span class="sd">    .Then2(map, len)</span>
<span class="sd">)</span>
<span class="sd">ious is equivalent to</span>
<span class="sd">x = &quot;Again hello world&quot;</span>
<span class="sd">x = str.split(x, &#39; &#39;)</span>
<span class="sd">x = map(len, x)</span>
<span class="sd">assert [5, 5, 5] == x</span>
<span class="sd">ou see, `Then2` was very useful because `map` accepts and `iterable` as its `2nd` parameter. You can rewrite the previous using the [PythonBuilder](https://cgarciae.github.io/phi/python_builder.m.html) and the `phi.builder.Builder.Obj` object</span>
<span class="sd">from phi import P, Obj</span>
<span class="sd">assert [5, 5, 5] == P.Pipe(</span>
<span class="sd">    &quot;Again hello world&quot;,</span>
<span class="sd">    Obj.split(&#39; &#39;),</span>
<span class="sd">    P.map(len)</span>
<span class="sd">)</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Obj`</span>
<span class="sd">ythonBuilder](https://cgarciae.github.io/phi/python_builder.m.html)</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_return_type</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">n_args</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s1">&#39;_return_type&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">_return_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span>
    <span class="nd">@utils.lift</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="n">_args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_args</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">+</span> <span class="n">_args</span><span class="p">[</span><span class="n">n_args</span><span class="p">:]</span> <span class="k">if</span> <span class="n">n_args</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">_args</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.TrainOp">
    <p>def <span class="ident">TrainOp</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.TrainOp(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tflearn.TrainOp</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tflearn.TrainOp(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.TrainOp(*args, **kwargs)(x1)
</pre></div>


<p><strong>tflearn.TrainOp</strong></p>
<div class="codehilite"><pre><span></span>TrainOp.
</pre></div>


<p>TrainOp represents a set of operation used for optimizing a network.</p>
<p>A TrainOp is meant to hold all training parameters of an optimizer.
<code>Trainer</code> class will then instantiate them all specifically considering all
optimizers of the network (set names, scopes... set optimization ops...).</p>
<p>Arguments:
    loss: <code>Tensor</code>. Loss operation to evaluate network cost.
        Optimizer will use this cost function to train network.
    optimizer: <code>Optimizer</code>. Tensorflow Optimizer. The optimizer to
        use to train network.
    metric:  <code>Tensor</code>. The metric tensor to be used for evaluation.
    batch_size: <code>int</code>. Batch size for data feeded to this optimizer.
        Default: 64.
    ema: <code>float</code>. Exponential moving averages.
    trainable_vars: list of <code>tf.Variable</code>. List of trainable variables to
        use for training. Default: all trainable variables.
    shuffle: <code>bool</code>. Shuffle data.
    step_tensor: <code>tf.Tensor</code>. A variable holding training step. If not
        provided, it will be created. Early defining the step tensor
        might be useful for network creation, such as for learning rate
        decay.
    input_vars: list of <code>Variable</code>. The input data for this training op
        to be transformed by data augmentation. Default:
        tf.GraphKeys.INPUTS collection. (optional) Only necessary when
        using data augmentation.
    data_preprocessing: A <code>DataPreprocessing</code> subclass object to manage
        real-time data pre-processing when training and predicting (such
        as zero center data, std normalization...).
    data_augmentation: <code>DataAugmentation</code>. A <code>DataAugmentation</code> subclass
        object to manage real-time data augmentation while training (
        such as random image crop, random image flip, random sequence
        reverse...).
    name: <code>str</code>. A name for this class (optional).
    graph: <code>tf.Graph</code>. Tensorflow Graph to use for training. Default:
        default tf graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.TrainOp', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.TrainOp" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Trainer">
    <p>def <span class="ident">Trainer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.Trainer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tflearn.Trainer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tflearn.Trainer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.Trainer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tflearn.Trainer</strong></p>
<div class="codehilite"><pre><span></span>Trainer.
</pre></div>


<p>Generic class to handle any TensorFlow graph training. It requires
the use of <code>TrainOp</code> to specify all optimization parameters.</p>
<p>Arguments:
    train_ops: list of <code>TrainOp</code>. A list of a network training
        operations for performing optimizations.
    graph: <code>tf.Graph</code>. The TensorFlow graph to use. Default: default tf
        graph.
    clip_gradients: <code>float</code>. Clip gradient. Default: 5.0.
    tensorboard_dir: <code>str</code>. Tensorboard log directory.
        Default: "/tmp/tflearn_logs/".
    tensorboard_verbose: <code>int</code>. Verbose level. It supports:
        <code>python
        0 - Loss, Accuracy. (Best Speed)
        1 - Loss, Accuracy, Gradients.
        2 - Loss, Accuracy, Gradients, Weights.
        3 - Loss, Accuracy, Gradients, Weights, Activations, Sparsity.
            (Best Visualization)</code>
    checkpoint_path: <code>str</code>. Path to store model checkpoints. If None,
        no model checkpoint will be saved. Default: None.
    max_checkpoints: <code>int</code> or None. Maximum amount of checkpoints. If
        None, no limit. Default: None.
    keep_checkpoint_every_n_hours: <code>float</code>. Number of hours between each
        model checkpoints.
    random_seed: <code>int</code>. Random seed, for test reproductivity.
        Default: None.
    session: <code>Session</code>. A session for running ops. If None, a new one will
        be created. Note: When providing a session, variables must have been
        initialized already, otherwise an error will be raised.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Trainer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Trainer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Tuple">
    <p>def <span class="ident">Tuple</span>(</p><p>self, *expressions, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Tuple', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Tuple" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="o">*</span><span class="n">expressions</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nb">tuple</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Val">
    <p>def <span class="ident">Val</span>(</p><p>self, val, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>The expression</p>
<div class="codehilite"><pre><span></span>Val(a)
</pre></div>


<p>is equivalent to the constant function</p>
<div class="codehilite"><pre><span></span>lambda x: a
</pre></div>


<p>All expression in this module interprete values that are not functions as constant functions using <code>Val</code>, for example</p>
<div class="codehilite"><pre><span></span>Seq(1, P + 1)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>Seq(Val(1), P + 1)
</pre></div>


<p>The previous expression as a whole is a constant function since it will return <code>2</code> no matter what input you give it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Val', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Val" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">expression</span>
<span class="sd">Val(a)</span>
<span class="sd">quivalent to the constant function</span>
<span class="sd">lambda x: a</span>
<span class="sd">expression in this module interprete values that are not functions as constant functions using `Val`, for example</span>
<span class="sd">Seq(1, P + 1)</span>
<span class="sd">quivalent to</span>
<span class="sd">Seq(Val(1), P + 1)</span>
<span class="sd">previous expression as a whole is a constant function since it will return `2` no matter what input you give it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.With">
    <p>def <span class="ident">With</span>(</p><p>self, context_manager, *body, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>With</strong></p>
<div class="codehilite"><pre><span></span>def With(context_manager, *body):
</pre></div>


<p><strong>Arguments</strong></p>
<ul>
<li><strong>context_manager</strong>: a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> object or valid expression from the DSL that returns a context manager.</li>
<li><strong>*body</strong>: any valid expression of the DSL to be evaluated inside the context. <code>*body</code> is interpreted as a tuple so all expression contained are composed.</li>
</ul>
<p>As with normal python programs you sometimes might want to create a context for a block of code. You normally give a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> to the <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement">with</a> statemente, in Phi you use <code>P.With</code> or <code>phi.With</code></p>
<p><strong>Context</strong></p>
<p>Python's <code>with</code> statemente returns a context object through <code>as</code> keyword, in the DSL this object can be obtained using the <code>P.Context</code> method or the <code>phi.Context</code> function.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">With</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">text</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>The previous is equivalent to</p>
<div class="codehilite"><pre><span></span>with open(&quot;text.txt&quot;) as f:
    text = f.read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.With', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.With" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">With</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context_manager</span><span class="p">,</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">th**</span>
<span class="sd">def With(context_manager, *body):</span>
<span class="sd">guments**</span>
<span class="sd">context_manager**: a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) object or valid expression from the DSL that returns a context manager.</span>
<span class="sd">*body**: any valid expression of the DSL to be evaluated inside the context. `*body` is interpreted as a tuple so all expression contained are composed.</span>
<span class="sd">ith normal python programs you sometimes might want to create a context for a block of code. You normally give a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) to the [with](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement) statemente, in Phi you use `P.With` or `phi.With`</span>
<span class="sd">ntext**</span>
<span class="sd">on&#39;s `with` statemente returns a context object through `as` keyword, in the DSL this object can be obtained using the `P.Context` method or the `phi.Context` function.</span>
<span class="sd">Examples</span>
<span class="sd">from phi import P, Obj, Context, With, Pipe</span>
<span class="sd">text = Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    With( open, Context,</span>
<span class="sd">        Obj.read()</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">previous is equivalent to</span>
<span class="sd">with open(&quot;text.txt&quot;) as f:</span>
<span class="sd">    text = f.read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context_f</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">context_manager</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">body_f</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">body</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">context</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">context_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">context</span> <span class="k">as</span> <span class="n">scope</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_WithContextManager</span><span class="p">(</span><span class="n">scope</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">body_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.Write">
    <p>def <span class="ident">Write</span>(</p><p>self, *state_args, **state_dict)</p>
    </div>
    

    
  
    <div class="desc"><p>See <code>phi.dsl.Expression.Read</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.Write', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.Write" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">state_args</span><span class="p">,</span> <span class="o">**</span><span class="n">state_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;See `phi.dsl.Expression.Read`&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please include at-least 1 state variable, got {0} and {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state_args</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please include at-most 1 keyword argument expression, got {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state_dict</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">state_key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">state_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">write_expr</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="n">state_key</span><span class="p">]</span>
        <span class="n">state_args</span> <span class="o">+=</span> <span class="p">(</span><span class="n">state_key</span><span class="p">,)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;&gt;</span> <span class="n">write_expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">update</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">state_args</span> <span class="p">}</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">update</span><span class="p">)</span>
        <span class="c1">#side effect for convenience</span>
        <span class="n">_StateContextManager</span><span class="o">.</span><span class="n">REFS</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.abs">
    <p>def <span class="ident">abs</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.abs(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.abs</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.abs(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.abs(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.abs</strong></p>
<div class="codehilite"><pre><span></span>Computes the absolute value of a tensor.
</pre></div>


<p>Given a tensor of real numbers <code>x</code>, this operation returns a tensor
containing the absolute value of each element in <code>x</code>. For example, if x is
an input element and y is an output element, this operation computes
\(y = |x|\).</p>
<p>See <a href="#tf_complex_abs"><code>tf.complex_abs()</code></a> to compute the absolute value of a
complex
number.</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code>, or
    <code>int64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> the same size and type as <code>x</code> with absolute
    values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.abs', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.abs" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.accumulate_n">
    <p>def <span class="ident">accumulate_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.accumulate_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.accumulate_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.accumulate_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.accumulate_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.accumulate_n</strong></p>
<div class="codehilite"><pre><span></span>Returns the element-wise sum of a list of tensors.
</pre></div>


<p>Optionally, pass <code>shape</code> and <code>tensor_dtype</code> for shape and type checking,
otherwise, these are inferred.</p>
<p>NOTE: This operation is not differentiable and cannot be used if inputs depend
on trainable variables. Please use <code>tf.add_n</code> for such cases.</p>
<p>For example:</p>
<p>```python</p>
<h1>tensor 'a' is [[1, 2], [3, 4]]</h1>
<h1>tensor <code>b</code> is [[5, 0], [0, 6]]</h1>
<p>tf.accumulate_n([a, b, a]) ==&gt; [[7, 4], [6, 14]]</p>
<h1>Explicitly pass shape and type</h1>
<p>tf.accumulate_n([a, b, a], shape=[2, 2], tensor_dtype=tf.int32)
  ==&gt; [[7, 4], [6, 14]]
```</p>
<p>Args:
  inputs: A list of <code>Tensor</code> objects, each with same shape and type.
  shape: Shape of elements of <code>inputs</code>.
  tensor_dtype: The type of <code>inputs</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of same shape and type as the elements of <code>inputs</code>.</p>
<p>Raises:
  ValueError: If <code>inputs</code> don't all have same shape and dtype or the shape
  cannot be inferred.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.accumulate_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.accumulate_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.acos">
    <p>def <span class="ident">acos</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.acos(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.acos</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.acos(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.acos(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.acos</strong></p>
<div class="codehilite"><pre><span></span>Computes acos of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.acos', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.acos" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add">
    <p>def <span class="ident">add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add</strong></p>
<div class="codehilite"><pre><span></span>Returns x + y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>, <code>string</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_check_numerics_ops">
    <p>def <span class="ident">add_check_numerics_ops</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_check_numerics_ops(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add_check_numerics_ops</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add_check_numerics_ops(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_check_numerics_ops(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add_check_numerics_ops</strong></p>
<div class="codehilite"><pre><span></span>Connect a `check_numerics` to every floating point tensor.
</pre></div>


<p><code>check_numerics</code> operations themselves are added for each <code>half</code>, <code>float</code>,
or <code>double</code> tensor in the graph. For all ops in the graph, the
<code>check_numerics</code> op for all of its (<code>half</code>, <code>float</code>, or <code>double</code>) inputs
is guaranteed to run before the <code>check_numerics</code> op on any of its outputs.</p>
<p>Returns:
  A <code>group</code> op depending on all <code>check_numerics</code> ops added.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_check_numerics_ops', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_check_numerics_ops" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_n">
    <p>def <span class="ident">add_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add_n</strong></p>
<div class="codehilite"><pre><span></span>Adds all input tensors element-wise.
</pre></div>


<p>Args:
  inputs: A list of <code>Tensor</code> objects, each with same shape and type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of same shape and type as the elements of <code>inputs</code>.</p>
<p>Raises:
  ValueError: If <code>inputs</code> don't all have same shape and dtype or the shape
  cannot be inferred.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_regularization_loss">
    <p>def <span class="ident">add_regularization_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_regularization_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderadd_regularization_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuilderadd_regularization_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_regularization_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorbuilderadd_regularization_loss</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_regularization_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_regularization_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.add_to_collection">
    <p>def <span class="ident">add_to_collection</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_to_collection(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.add_to_collection</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.add_to_collection(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.add_to_collection(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.add_to_collection</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.add_to_collection()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.add_to_collection"><code>Graph.add_to_collection()</code></a>
for more details.</p>
<p>Args:
  name: The key for the collection. For example, the <code>GraphKeys</code> class
    contains many standard names for collections.
  value: The value to add to the collection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.add_to_collection', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.add_to_collection" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_candidate_sampler">
    <p>def <span class="ident">all_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnall_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnall_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnall_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Generate the set of all classes.
</pre></div>


<p>Deterministically generates and returns the set of all possible classes.
For testing purposes.  There is no need to use this, since you might as
well use full softmax or full logistic regression.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of possible classes.
  unique: A <code>bool</code>. Ignored.
    unique.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    This operation deterministically returns the entire range
    <code>[0, num_sampled]</code>.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>. All returned values are 1.0.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>. All returned values are 1.0.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">all_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.all_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.all_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.all_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.all_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Generate the set of all classes.
</pre></div>


<p>Deterministically generates and returns the set of all possible classes.
For testing purposes.  There is no need to use this, since you might as
well use full softmax or full logistic regression.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of possible classes.
  unique: A <code>bool</code>. Ignored.
    unique.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    This operation deterministically returns the entire range
    <code>[0, num_sampled]</code>.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>. All returned values are 1.0.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>. All returned values are 1.0.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer">
    <p>def <span class="ident">all_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.all_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.all_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.all_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.all_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Generate the set of all classes.
</pre></div>


<p>Deterministically generates and returns the set of all possible classes.
For testing purposes.  There is no need to use this, since you might as
well use full softmax or full logistic regression.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of possible classes.
  unique: A <code>bool</code>. Ignored.
    unique.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    This operation deterministically returns the entire range
    <code>[0, num_sampled]</code>.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>. All returned values are 1.0.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>. All returned values are 1.0.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.all_variables">
    <p>def <span class="ident">all_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.all_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.all_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.all_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.all_variables</strong></p>
<div class="codehilite"><pre><span></span>See `tf.global_variables`. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2017-03-02.
Instructions for updating:
Please use tf.global_variables instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.all_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.all_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.arg_max">
    <p>def <span class="ident">arg_max</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.arg_max(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.arg_max</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.arg_max(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.arg_max(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.arg_max</strong></p>
<div class="codehilite"><pre><span></span>Returns the index with the largest value across dimensions of a tensor.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  dimension: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    int32, 0 &lt;= dimension &lt; rank(input).  Describes which dimension
    of the input Tensor to reduce across. For vectors, use dimension = 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.arg_max', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.arg_max" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.arg_min">
    <p>def <span class="ident">arg_min</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.arg_min(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.arg_min</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.arg_min(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.arg_min(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.arg_min</strong></p>
<div class="codehilite"><pre><span></span>Returns the index with the smallest value across dimensions of a tensor.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  dimension: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    int32, 0 &lt;= dimension &lt; rank(input).  Describes which dimension
    of the input Tensor to reduce across. For vectors, use dimension = 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.arg_min', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.arg_min" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.argmax">
    <p>def <span class="ident">argmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.argmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.argmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.argmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.argmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.argmax</strong></p>
<div class="codehilite"><pre><span></span>Returns the index with the largest value across axiss of a tensor.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  axis: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    int32, 0 &lt;= axis &lt; rank(input).  Describes which axis
    of the input Tensor to reduce across. For vectors, use axis = 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.argmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.argmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.argmin">
    <p>def <span class="ident">argmin</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.argmin(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.argmin</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.argmin(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.argmin(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.argmin</strong></p>
<div class="codehilite"><pre><span></span>Returns the index with the smallest value across axiss of a tensor.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  axis: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    int32, 0 &lt;= axis &lt; rank(input).  Describes which axis
    of the input Tensor to reduce across. For vectors, use axis = 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.argmin', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.argmin" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.as_dtype">
    <p>def <span class="ident">as_dtype</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.as_dtype(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.as_dtype</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.as_dtype(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.as_dtype(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.as_dtype</strong></p>
<div class="codehilite"><pre><span></span>Converts the given `type_value` to a `DType`.
</pre></div>


<p>Args:
  type_value: A value that can be converted to a <code>tf.DType</code>
    object. This may currently be a <code>tf.DType</code> object, a
    <a href="https://www.tensorflow.org/code/tensorflow/core/framework/types.proto"><code>DataType</code> enum</a>,
    a string type name, or a <code>numpy.dtype</code>.</p>
<p>Returns:
  A <code>DType</code> corresponding to <code>type_value</code>.</p>
<p>Raises:
  TypeError: If <code>type_value</code> cannot be converted to a <code>DType</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.as_dtype', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.as_dtype" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.as_string">
    <p>def <span class="ident">as_string</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.as_string(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.as_string</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.as_string(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.as_string(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.as_string</strong></p>
<div class="codehilite"><pre><span></span>Converts each entry in the given tensor to strings.  Supports many numeric
</pre></div>


<p>types and boolean.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>float32</code>, <code>float64</code>, <code>bool</code>, <code>int8</code>.
  precision: An optional <code>int</code>. Defaults to <code>-1</code>.
    The post-decimal precision to use for floating point numbers.
    Only used if precision &gt; -1.
  scientific: An optional <code>bool</code>. Defaults to <code>False</code>.
    Use scientific notation for floating point numbers.
  shortest: An optional <code>bool</code>. Defaults to <code>False</code>.
    Use shortest representation (either scientific or standard) for
    floating point numbers.
  width: An optional <code>int</code>. Defaults to <code>-1</code>.
    Pad pre-decimal numbers to this width.
    Applies to both floating point and integer numbers.
    Only used if width &gt; -1.
  fill: An optional <code>string</code>. Defaults to <code>""</code>.
    The value to pad if width &gt; -1.  If empty, pads with spaces.
    Another typical value is '0'.  String cannot be longer than 1 character.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.as_string', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.as_string" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.asin">
    <p>def <span class="ident">asin</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.asin(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.asin</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.asin(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.asin(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.asin</strong></p>
<div class="codehilite"><pre><span></span>Computes asin of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.asin', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.asin" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_equal">
    <p>def <span class="ident">assert_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_equal</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x == y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_equal(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_equal(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] == y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_equal".</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x == y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_greater">
    <p>def <span class="ident">assert_greater</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_greater(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_greater</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_greater(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_greater(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_greater</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt; y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_greater(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_greater(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &gt; y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_greater".</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &gt; y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_greater', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_greater" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_greater_equal">
    <p>def <span class="ident">assert_greater_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_greater_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_greater_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_greater_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_greater_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_greater_equal</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt;= y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_greater_equal(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_greater_equal(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &gt;= y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to
    "assert_greater_equal"</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &gt;= y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_greater_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_greater_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_integer">
    <p>def <span class="ident">assert_integer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_integer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_integer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_integer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_integer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_integer</strong></p>
<div class="codehilite"><pre><span></span>Assert that `x` is of integer dtype.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_integer(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_integer(x)], x)</code></p>
<p>Args:
  x: <code>Tensor</code> whose basetype is integer and is not quantized.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_integer".</p>
<p>Raises:
  TypeError:  If <code>x.dtype</code> is anything other than non-quantized integer.</p>
<p>Returns:
  A <code>no_op</code> that does nothing.  Type can be determined statically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_integer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_integer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_less">
    <p>def <span class="ident">assert_less</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_less(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_less</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_less(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_less(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_less</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt; y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_less(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_less(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &lt; y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_less".</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &lt; y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_less', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_less" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_less_equal">
    <p>def <span class="ident">assert_less_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_less_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_less_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_less_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_less_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_less_equal</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt;= y` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_less_equal(x, y)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_less_equal(x, y)], x)</code></p>
<p>This condition holds if for every pair of (possibly broadcast) elements
<code>x[i]</code>, <code>y[i]</code>, we have <code>x[i] &lt;= y[i]</code>.
If both <code>x</code> and <code>y</code> are empty, this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  y:  Numeric <code>Tensor</code>, same dtype as and broadcastable to <code>x</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>, <code>y</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_less_equal"</p>
<p>Returns:
  Op that raises <code>InvalidArgumentError</code> if <code>x &lt;= y</code> is False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_less_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_less_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_negative">
    <p>def <span class="ident">assert_negative</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_negative(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_negative</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_negative(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_negative(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_negative</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt; 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_negative(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_negative(x)], x)</code></p>
<p>Negative means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &lt; 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_negative".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all negative.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_negative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_negative" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_non_negative">
    <p>def <span class="ident">assert_non_negative</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_non_negative(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_non_negative</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_non_negative(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_non_negative(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_non_negative</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt;= 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_non_negative(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_non_negative(x)], x)</code></p>
<p>Non-negative means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &gt;= 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).
    Defaults to "assert_non_negative".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all non-negative.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_non_negative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_non_negative" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_non_positive">
    <p>def <span class="ident">assert_non_positive</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_non_positive(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_non_positive</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_non_positive(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_non_positive(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_non_positive</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &lt;= 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_non_positive(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_non_positive(x)], x)</code></p>
<p>Non-positive means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &lt;= 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).
    Defaults to "assert_non_positive".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all non-positive.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_non_positive', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_non_positive" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_positive">
    <p>def <span class="ident">assert_positive</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_positive(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_positive</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_positive(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_positive(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_positive</strong></p>
<div class="codehilite"><pre><span></span>Assert the condition `x &gt; 0` holds element-wise.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_positive(x)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_positive(x)], x)</code></p>
<p>Positive means, for every element <code>x[i]</code> of <code>x</code>, we have <code>x[i] &gt; 0</code>.
If <code>x</code> is empty this is trivially satisfied.</p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_positive".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> is all positive.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_positive', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_positive" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_proper_iterable">
    <p>def <span class="ident">assert_proper_iterable</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_proper_iterable(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_proper_iterable</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_proper_iterable(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_proper_iterable(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_proper_iterable</strong></p>
<div class="codehilite"><pre><span></span>Static assert that values is a &quot;proper&quot; iterable.
</pre></div>


<p><code>Ops</code> that expect iterables of <code>Tensor</code> can call this to validate input.
Useful since <code>Tensor</code>, <code>ndarray</code>, byte/text type are all iterables themselves.</p>
<p>Args:
  values:  Object to be checked.</p>
<p>Raises:
  TypeError:  If <code>values</code> is not iterable or is one of
    <code>Tensor</code>, <code>SparseTensor</code>, <code>np.array</code>, <code>tf.compat.bytes_or_text_types</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_proper_iterable', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_proper_iterable" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_rank">
    <p>def <span class="ident">assert_rank</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_rank(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_rank</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_rank(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_rank(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_rank</strong></p>
<div class="codehilite"><pre><span></span>Assert `x` has rank equal to `rank`.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_rank(x, 2)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_rank(x, 2)], x)</code></p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  rank:  Scalar integer <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).  Defaults to "assert_rank".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> has specified rank.
  If static checks determine <code>x</code> has correct rank, a <code>no_op</code> is returned.</p>
<p>Raises:
  ValueError:  If static checks determine <code>x</code> has wrong rank.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_rank', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_rank" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_rank_at_least">
    <p>def <span class="ident">assert_rank_at_least</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_rank_at_least(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_rank_at_least</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_rank_at_least(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_rank_at_least(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_rank_at_least</strong></p>
<div class="codehilite"><pre><span></span>Assert `x` has rank equal to `rank` or higher.
</pre></div>


<p>Example of adding a dependency to an operation:</p>
<p><code>python
with tf.control_dependencies([tf.assert_rank_at_least(x, 2)]):
  output = tf.reduce_sum(x)</code></p>
<p>Example of adding dependency to the tensor being checked:</p>
<p><code>python
x = tf.with_dependencies([tf.assert_rank_at_least(x, 2)], x)</code></p>
<p>Args:
  x:  Numeric <code>Tensor</code>.
  rank:  Scalar <code>Tensor</code>.
  data:  The tensors to print out if the condition is False.  Defaults to
    error message and first few entries of <code>x</code>.
  summarize: Print this many entries of each tensor.
  message: A string to prefix to the default message.
  name: A name for this operation (optional).
    Defaults to "assert_rank_at_least".</p>
<p>Returns:
  Op raising <code>InvalidArgumentError</code> unless <code>x</code> has specified rank or higher.
  If static checks determine <code>x</code> has correct rank, a <code>no_op</code> is returned.</p>
<p>Raises:
  ValueError:  If static checks determine <code>x</code> has wrong rank.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_rank_at_least', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_rank_at_least" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_type">
    <p>def <span class="ident">assert_type</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_type(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_type</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_type(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_type(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_type</strong></p>
<div class="codehilite"><pre><span></span>Statically asserts that the given `Tensor` is of the specified type.
</pre></div>


<p>Args:
  tensor: A tensorflow <code>Tensor</code>.
  tf_type: A tensorflow type (<code>dtypes.float32</code>, <code>tf.int64</code>, <code>dtypes.bool</code>,
    etc).
  message: A string to prefix to the default message.
  name:  A name to give this <code>Op</code>.  Defaults to "assert_type"</p>
<p>Raises:
  TypeError: If the tensors data type doesn't match <code>tf_type</code>.</p>
<p>Returns:
  A <code>no_op</code> that does nothing.  Type can be determined statically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_type', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_type" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assert_variables_initialized">
    <p>def <span class="ident">assert_variables_initialized</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_variables_initialized(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assert_variables_initialized</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assert_variables_initialized(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assert_variables_initialized(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assert_variables_initialized</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op to check if variables are initialized.
</pre></div>


<p>NOTE: This function is obsolete and will be removed in 6 months.  Please
change your implementation to use <code>report_uninitialized_variables()</code>.</p>
<p>When run, the returned Op will raise the exception <code>FailedPreconditionError</code>
if any of the variables has not yet been initialized.</p>
<p>Note: This function is implemented by trying to fetch the values of the
variables. If one of the variables is not initialized a message may be
logged by the C++ runtime. This is expected.</p>
<p>Args:
  var_list: List of <code>Variable</code> objects to check. Defaults to the
    value of <code>global_variables().</code></p>
<p>Returns:
  An Op, or None if there are no variables.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assert_variables_initialized', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assert_variables_initialized" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assign">
    <p>def <span class="ident">assign</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assign(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assign(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assign</strong></p>
<div class="codehilite"><pre><span></span>Update &#39;ref&#39; by assigning &#39;value&#39; to it.
</pre></div>


<p>This operation outputs "ref" after the assignment is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>.
    Should be from a <code>Variable</code> node. May be uninitialized.
  value: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    The value to be assigned to the variable.
  validate_shape: An optional <code>bool</code>. Defaults to <code>True</code>.
    If true, the operation will validate that the shape
    of 'value' matches the shape of the Tensor being assigned to.  If false,
    'ref' will take on the shape of 'value'.
  use_locking: An optional <code>bool</code>. Defaults to <code>True</code>.
    If True, the assignment will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as "ref".  Returned as a convenience for operations that want
  to use the new value after the variable has been reset.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assign', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assign" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assign_add">
    <p>def <span class="ident">assign_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assign_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assign_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assign_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assign_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assign_add</strong></p>
<div class="codehilite"><pre><span></span>Update &#39;ref&#39; by adding &#39;value&#39; to it.
</pre></div>


<p>This operation outputs "ref" after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  value: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    The value to be added to the variable.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the addition will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as "ref".  Returned as a convenience for operations that want
  to use the new value after the variable has been updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assign_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assign_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.assign_sub">
    <p>def <span class="ident">assign_sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assign_sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.assign_sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.assign_sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.assign_sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.assign_sub</strong></p>
<div class="codehilite"><pre><span></span>Update &#39;ref&#39; by subtracting &#39;value&#39; from it.
</pre></div>


<p>This operation outputs "ref" after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  value: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    The value to be subtracted to the variable.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the subtraction will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as "ref".  Returned as a convenience for operations that want
  to use the new value after the variable has been updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.assign_sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.assign_sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atan">
    <p>def <span class="ident">atan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.atan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.atan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.atan</strong></p>
<div class="codehilite"><pre><span></span>Computes atan of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atrous_conv2d">
    <p>def <span class="ident">atrous_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atrous_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnatrous_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnatrous_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atrous_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnatrous_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Atrous convolution (a.k.a. convolution with holes or dilated convolution).
</pre></div>


<p>Computes a 2-D atrous convolution, also known as convolution with holes or
dilated convolution, given 4-D <code>value</code> and <code>filters</code> tensors. If the <code>rate</code>
parameter is equal to one, it performs regular 2-D convolution. If the <code>rate</code>
parameter is greater than one, it performs convolution with holes, sampling
the input values every <code>rate</code> pixels in the <code>height</code> and <code>width</code> dimensions.
This is equivalent to convolving the input with a set of upsampled filters,
produced by inserting <code>rate - 1</code> zeros between two consecutive values of the
filters along the <code>height</code> and <code>width</code> dimensions, hence the name atrous
convolution or convolution with holes (the French word trous means holes in
English).</p>
<p>More specifically:</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q} filters[di, dj, q, k] *
      value[b, i + rate * di, j + rate * dj, q]
</pre></div>


<p>Atrous convolution allows us to explicitly control how densely to compute
feature responses in fully convolutional networks. Used in conjunction with
bilinear interpolation, it offers an alternative to <code>conv2d_transpose</code> in
dense prediction tasks such as semantic image segmentation, optical flow
computation, or depth estimation. It also allows us to effectively enlarge
the field of view of filters without increasing the number of parameters or
the amount of computation.</p>
<p>For a description of atrous convolution and how it can be used for dense
feature extraction, please see: <a href="http://arxiv.org/abs/1412.7062">Semantic Image Segmentation with Deep
Convolutional Nets and Fully Connected CRFs</a>.
The same operation is investigated further in <a href="http://arxiv.org/abs/1511.07122">Multi-Scale Context Aggregation
by Dilated Convolutions</a>. Previous works
that effectively use atrous convolution in different ways are, among others,
<a href="http://arxiv.org/abs/1312.6229">OverFeat: Integrated Recognition, Localization and Detection using
Convolutional Networks</a> and <a href="http://arxiv.org/abs/1302.1700">Fast Image
Scanning with Deep Max-Pooling Convolutional Neural Networks</a>.
Atrous convolution is also closely related to the so-called noble identities
in multi-rate signal processing.</p>
<p>There are many different ways to implement atrous convolution (see the refs
above). The implementation here reduces</p>
<p><code>python
    atrous_conv2d(value, filters, rate, padding=padding)</code></p>
<p>to the following three operations:</p>
<p><code>python
    paddings = ...
    net = space_to_batch(value, paddings, block_size=rate)
    net = conv2d(net, filters, strides=[1, 1, 1, 1], padding="VALID")
    crops = ...
    net = batch_to_space(net, crops, block_size=rate)</code></p>
<p>Advanced usage. Note the following optimization: A sequence of <code>atrous_conv2d</code>
operations with identical <code>rate</code> parameters, 'SAME' <code>padding</code>, and filters
with odd heights/ widths:</p>
<p><code>python
    net = atrous_conv2d(net, filters1, rate, padding="SAME")
    net = atrous_conv2d(net, filters2, rate, padding="SAME")
    ...
    net = atrous_conv2d(net, filtersK, rate, padding="SAME")</code></p>
<p>can be equivalently performed cheaper in terms of computation and memory as:</p>
<p><code>python
    pad = ...  # padding so that the input dims are multiples of rate
    net = space_to_batch(net, paddings=pad, block_size=rate)
    net = conv2d(net, filters1, strides=[1, 1, 1, 1], padding="SAME")
    net = conv2d(net, filters2, strides=[1, 1, 1, 1], padding="SAME")
    ...
    net = conv2d(net, filtersK, strides=[1, 1, 1, 1], padding="SAME")
    net = batch_to_space(net, crops=pad, block_size=rate)</code></p>
<p>because a pair of consecutive <code>space_to_batch</code> and <code>batch_to_space</code> ops with
the same <code>block_size</code> cancel out when their respective <code>paddings</code> and <code>crops</code>
inputs are identical.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code>. It needs to be in the default "NHWC"
    format. Its shape is <code>[batch, in_height, in_width, in_channels]</code>.
  filters: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>. <code>filters</code>'
    <code>in_channels</code> dimension must match that of <code>value</code>. Atrous convolution is
    equivalent to standard convolution with upsampled filters with effective
    height <code>filter_height + (filter_height - 1) * (rate - 1)</code> and effective
    width <code>filter_width + (filter_width - 1) * (rate - 1)</code>, produced by
    inserting <code>rate - 1</code> zeros along consecutive elements across the
    <code>filters</code>' spatial dimensions.
  rate: A positive int32. The stride with which we sample input values across
    the <code>height</code> and <code>width</code> dimensions. Equivalently, the rate by which we
    upsample the filter values by inserting zeros across the <code>height</code> and
    <code>width</code> dimensions. In the literature, the same parameter is sometimes
    called <code>input stride</code> or <code>dilation</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filters</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atrous_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atrous_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer">
    <p>def <span class="ident">atrous_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atrous_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.atrous_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.atrous_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atrous_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.atrous_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.atrous_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Atrous convolution (a.k.a. convolution with holes or dilated convolution).
</pre></div>


<p>Computes a 2-D atrous convolution, also known as convolution with holes or
dilated convolution, given 4-D <code>value</code> and <code>filters</code> tensors. If the <code>rate</code>
parameter is equal to one, it performs regular 2-D convolution. If the <code>rate</code>
parameter is greater than one, it performs convolution with holes, sampling
the input values every <code>rate</code> pixels in the <code>height</code> and <code>width</code> dimensions.
This is equivalent to convolving the input with a set of upsampled filters,
produced by inserting <code>rate - 1</code> zeros between two consecutive values of the
filters along the <code>height</code> and <code>width</code> dimensions, hence the name atrous
convolution or convolution with holes (the French word trous means holes in
English).</p>
<p>More specifically:</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q} filters[di, dj, q, k] *
      value[b, i + rate * di, j + rate * dj, q]
</pre></div>


<p>Atrous convolution allows us to explicitly control how densely to compute
feature responses in fully convolutional networks. Used in conjunction with
bilinear interpolation, it offers an alternative to <code>conv2d_transpose</code> in
dense prediction tasks such as semantic image segmentation, optical flow
computation, or depth estimation. It also allows us to effectively enlarge
the field of view of filters without increasing the number of parameters or
the amount of computation.</p>
<p>For a description of atrous convolution and how it can be used for dense
feature extraction, please see: <a href="http://arxiv.org/abs/1412.7062">Semantic Image Segmentation with Deep
Convolutional Nets and Fully Connected CRFs</a>.
The same operation is investigated further in <a href="http://arxiv.org/abs/1511.07122">Multi-Scale Context Aggregation
by Dilated Convolutions</a>. Previous works
that effectively use atrous convolution in different ways are, among others,
<a href="http://arxiv.org/abs/1312.6229">OverFeat: Integrated Recognition, Localization and Detection using
Convolutional Networks</a> and <a href="http://arxiv.org/abs/1302.1700">Fast Image
Scanning with Deep Max-Pooling Convolutional Neural Networks</a>.
Atrous convolution is also closely related to the so-called noble identities
in multi-rate signal processing.</p>
<p>There are many different ways to implement atrous convolution (see the refs
above). The implementation here reduces</p>
<p><code>python
    atrous_conv2d(value, filters, rate, padding=padding)</code></p>
<p>to the following three operations:</p>
<p><code>python
    paddings = ...
    net = space_to_batch(value, paddings, block_size=rate)
    net = conv2d(net, filters, strides=[1, 1, 1, 1], padding="VALID")
    crops = ...
    net = batch_to_space(net, crops, block_size=rate)</code></p>
<p>Advanced usage. Note the following optimization: A sequence of <code>atrous_conv2d</code>
operations with identical <code>rate</code> parameters, 'SAME' <code>padding</code>, and filters
with odd heights/ widths:</p>
<p><code>python
    net = atrous_conv2d(net, filters1, rate, padding="SAME")
    net = atrous_conv2d(net, filters2, rate, padding="SAME")
    ...
    net = atrous_conv2d(net, filtersK, rate, padding="SAME")</code></p>
<p>can be equivalently performed cheaper in terms of computation and memory as:</p>
<p><code>python
    pad = ...  # padding so that the input dims are multiples of rate
    net = space_to_batch(net, paddings=pad, block_size=rate)
    net = conv2d(net, filters1, strides=[1, 1, 1, 1], padding="SAME")
    net = conv2d(net, filters2, strides=[1, 1, 1, 1], padding="SAME")
    ...
    net = conv2d(net, filtersK, strides=[1, 1, 1, 1], padding="SAME")
    net = batch_to_space(net, crops=pad, block_size=rate)</code></p>
<p>because a pair of consecutive <code>space_to_batch</code> and <code>batch_to_space</code> ops with
the same <code>block_size</code> cancel out when their respective <code>paddings</code> and <code>crops</code>
inputs are identical.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code>. It needs to be in the default "NHWC"
    format. Its shape is <code>[batch, in_height, in_width, in_channels]</code>.
  filters: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>. <code>filters</code>'
    <code>in_channels</code> dimension must match that of <code>value</code>. Atrous convolution is
    equivalent to standard convolution with upsampled filters with effective
    height <code>filter_height + (filter_height - 1) * (rate - 1)</code> and effective
    width <code>filter_width + (filter_width - 1) * (rate - 1)</code>, produced by
    inserting <code>rate - 1</code> zeros along consecutive elements across the
    <code>filters</code>' spatial dimensions.
  rate: A positive int32. The stride with which we sample input values across
    the <code>height</code> and <code>width</code> dimensions. Equivalently, the rate by which we
    upsample the filter values by inserting zeros across the <code>height</code> and
    <code>width</code> dimensions. In the literature, the same parameter is sometimes
    called <code>input stride</code> or <code>dilation</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filters</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer">
    <p>def <span class="ident">atrous_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atrous_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.atrous_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.atrous_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.atrous_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.atrous_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.atrous_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Atrous convolution (a.k.a. convolution with holes or dilated convolution).
</pre></div>


<p>Computes a 2-D atrous convolution, also known as convolution with holes or
dilated convolution, given 4-D <code>value</code> and <code>filters</code> tensors. If the <code>rate</code>
parameter is equal to one, it performs regular 2-D convolution. If the <code>rate</code>
parameter is greater than one, it performs convolution with holes, sampling
the input values every <code>rate</code> pixels in the <code>height</code> and <code>width</code> dimensions.
This is equivalent to convolving the input with a set of upsampled filters,
produced by inserting <code>rate - 1</code> zeros between two consecutive values of the
filters along the <code>height</code> and <code>width</code> dimensions, hence the name atrous
convolution or convolution with holes (the French word trous means holes in
English).</p>
<p>More specifically:</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q} filters[di, dj, q, k] *
      value[b, i + rate * di, j + rate * dj, q]
</pre></div>


<p>Atrous convolution allows us to explicitly control how densely to compute
feature responses in fully convolutional networks. Used in conjunction with
bilinear interpolation, it offers an alternative to <code>conv2d_transpose</code> in
dense prediction tasks such as semantic image segmentation, optical flow
computation, or depth estimation. It also allows us to effectively enlarge
the field of view of filters without increasing the number of parameters or
the amount of computation.</p>
<p>For a description of atrous convolution and how it can be used for dense
feature extraction, please see: <a href="http://arxiv.org/abs/1412.7062">Semantic Image Segmentation with Deep
Convolutional Nets and Fully Connected CRFs</a>.
The same operation is investigated further in <a href="http://arxiv.org/abs/1511.07122">Multi-Scale Context Aggregation
by Dilated Convolutions</a>. Previous works
that effectively use atrous convolution in different ways are, among others,
<a href="http://arxiv.org/abs/1312.6229">OverFeat: Integrated Recognition, Localization and Detection using
Convolutional Networks</a> and <a href="http://arxiv.org/abs/1302.1700">Fast Image
Scanning with Deep Max-Pooling Convolutional Neural Networks</a>.
Atrous convolution is also closely related to the so-called noble identities
in multi-rate signal processing.</p>
<p>There are many different ways to implement atrous convolution (see the refs
above). The implementation here reduces</p>
<p><code>python
    atrous_conv2d(value, filters, rate, padding=padding)</code></p>
<p>to the following three operations:</p>
<p><code>python
    paddings = ...
    net = space_to_batch(value, paddings, block_size=rate)
    net = conv2d(net, filters, strides=[1, 1, 1, 1], padding="VALID")
    crops = ...
    net = batch_to_space(net, crops, block_size=rate)</code></p>
<p>Advanced usage. Note the following optimization: A sequence of <code>atrous_conv2d</code>
operations with identical <code>rate</code> parameters, 'SAME' <code>padding</code>, and filters
with odd heights/ widths:</p>
<p><code>python
    net = atrous_conv2d(net, filters1, rate, padding="SAME")
    net = atrous_conv2d(net, filters2, rate, padding="SAME")
    ...
    net = atrous_conv2d(net, filtersK, rate, padding="SAME")</code></p>
<p>can be equivalently performed cheaper in terms of computation and memory as:</p>
<p><code>python
    pad = ...  # padding so that the input dims are multiples of rate
    net = space_to_batch(net, paddings=pad, block_size=rate)
    net = conv2d(net, filters1, strides=[1, 1, 1, 1], padding="SAME")
    net = conv2d(net, filters2, strides=[1, 1, 1, 1], padding="SAME")
    ...
    net = conv2d(net, filtersK, strides=[1, 1, 1, 1], padding="SAME")
    net = batch_to_space(net, crops=pad, block_size=rate)</code></p>
<p>because a pair of consecutive <code>space_to_batch</code> and <code>batch_to_space</code> ops with
the same <code>block_size</code> cancel out when their respective <code>paddings</code> and <code>crops</code>
inputs are identical.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code>. It needs to be in the default "NHWC"
    format. Its shape is <code>[batch, in_height, in_width, in_channels]</code>.
  filters: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>. <code>filters</code>'
    <code>in_channels</code> dimension must match that of <code>value</code>. Atrous convolution is
    equivalent to standard convolution with upsampled filters with effective
    height <code>filter_height + (filter_height - 1) * (rate - 1)</code> and effective
    width <code>filter_width + (filter_width - 1) * (rate - 1)</code>, produced by
    inserting <code>rate - 1</code> zeros along consecutive elements across the
    <code>filters</code>' spatial dimensions.
  rate: A positive int32. The stride with which we sample input values across
    the <code>height</code> and <code>width</code> dimensions. Equivalently, the rate by which we
    upsample the filter values by inserting zeros across the <code>height</code> and
    <code>width</code> dimensions. In the literature, the same parameter is sometimes
    called <code>input stride</code> or <code>dilation</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filters</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.atrous_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.audio_summary">
    <p>def <span class="ident">audio_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.audio_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.audio_summary</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.audio_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.audio_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.audio_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with audio. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-30.
Instructions for updating:
Please switch to tf.summary.audio. Note that tf.summary.histogram uses the node name instead of the tag. This means that TensorFlow will automatically de-duplicate summary names based on the scope they are created in.</p>
<p>The summary has up to <code>max_outputs</code> summary values containing audio. The
  audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,
  frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are
  assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of
  <code>sample_rate</code>.</p>
<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
  build the <code>tag</code> of the summary values:</p>
<ul>
<li>If <code>max_outputs</code> is 1, the summary value tag is '<em>tag</em>/audio'.</li>
<li>If <code>max_outputs</code> is greater than 1, the summary value tags are
     generated sequentially as '<em>tag</em>/audio/0', '<em>tag</em>/audio/1', etc.</li>
</ul>
<p>Args:
    tag: A scalar <code>Tensor</code> of type <code>string</code>. Used to build the <code>tag</code>
      of the summary values.
    tensor: A 3-D <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, frames, channels]</code>
      or a 2-D <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, frames]</code>.
    sample_rate: A Scalar <code>float32</code> <code>Tensor</code> indicating the sample rate of the
      signal in hertz.
    max_outputs: Max number of batch elements to generate audio for.
    collections: Optional list of ops.GraphKeys.  The collections to add the
      summary to.  Defaults to [ops.GraphKeys.SUMMARIES]
    name: A name for the operation (optional).</p>
<p>Returns:
    A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
    buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.audio_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.audio_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool">
    <p>def <span class="ident">avg_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnavg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnavg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnavg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the average pooling on the input.
</pre></div>


<p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
window in <code>value</code>.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of shape <code>[batch, height, width, channels]</code> and type
    <code>float32</code>, <code>float64</code>, <code>qint8</code>, <code>quint8</code>, or <code>qint32</code>.
  ksize: A list of ints that has length &gt;= 4.
    The size of the window for each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool2d">
    <p>def <span class="ident">avg_pool2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersavg_pool2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersavg_pool2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersavg_pool2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D average pooling op.
</pre></div>


<p>It is assumed that the pooling is done per image but not in batch or channels.</p>
<p>Args:
  inputs: A 4-D tensor of shape <code>[batch_size, height, width, channels]</code> if
    <code>data_format</code> is <code>NHWC</code>, and <code>[batch_size, channels, height, width]</code> if
    <code>data_format</code> is <code>NCHW</code>.
  kernel_size: A list of length 2: [kernel_height, kernel_width] of the
    pooling kernel over which the op is computed. Can be an int if both
    values are the same.
  stride: A list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: The padding method, either 'VALID' or 'SAME'.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d">
    <p>def <span class="ident">avg_pool3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnavg_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnavg_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnavg_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D average pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer">
    <p>def <span class="ident">avg_pool3d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.avg_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.avg_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.avg_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D average pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_grad">
    <p>def <span class="ident">avg_pool3d_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnavg_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnavg_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnavg_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of average pooling function.
</pre></div>


<p>Args:
  orig_input_shape: A <code>Tensor</code> of type <code>int32</code>.
    The original input dimensions.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>. The backprop for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer">
    <p>def <span class="ident">avg_pool3d_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.avg_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.avg_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.avg_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of average pooling function.
</pre></div>


<p>Args:
  orig_input_shape: A <code>Tensor</code> of type <code>int32</code>.
    The original input dimensions.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>. The backprop for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer">
    <p>def <span class="ident">avg_pool3d_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.avg_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.avg_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.avg_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of average pooling function.
</pre></div>


<p>Args:
  orig_input_shape: A <code>Tensor</code> of type <code>int32</code>.
    The original input dimensions.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>. The backprop for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool3d_layer">
    <p>def <span class="ident">avg_pool3d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.avg_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.avg_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool3d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool3d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.avg_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D average pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool3d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool3d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer">
    <p>def <span class="ident">avg_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the average pooling on the input.
</pre></div>


<p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
window in <code>value</code>.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of shape <code>[batch, height, width, channels]</code> and type
    <code>float32</code>, <code>float64</code>, <code>qint8</code>, <code>quint8</code>, or <code>qint32</code>.
  ksize: A list of ints that has length &gt;= 4.
    The size of the window for each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.avg_pool_layer">
    <p>def <span class="ident">avg_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.avg_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.avg_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the average pooling on the input.
</pre></div>


<p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
window in <code>value</code>.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of shape <code>[batch, height, width, channels]</code> and type
    <code>float32</code>, <code>float64</code>, <code>qint8</code>, <code>quint8</code>, or <code>qint32</code>.
  ksize: A list of ints that has length &gt;= 4.
    The size of the window for each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.  The average pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.avg_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.avg_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_matmul">
    <p>def <span class="ident">batch_matmul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_matmul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.batch_matmul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.batch_matmul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_matmul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.batch_matmul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies slices of two tensors in batches.
</pre></div>


<p>Multiplies all slices of <code>Tensor</code> <code>x</code> and <code>y</code> (each slice can be
viewed as an element of a batch), and arranges the individual results
in a single output tensor of the same batch size. Each of the
individual slices can optionally be adjointed (to adjoint a matrix
means to transpose and conjugate it) before multiplication by setting
the <code>adj_x</code> or <code>adj_y</code> flag to <code>True</code>, which are by default <code>False</code>.</p>
<p>The input tensors <code>x</code> and <code>y</code> are 3-D or higher with shape <code>[..., r_x, c_x]</code>
and <code>[..., r_y, c_y]</code>.</p>
<p>The output tensor is 3-D or higher with shape <code>[..., r_o, c_o]</code>, where:</p>
<div class="codehilite"><pre><span></span>r_o = c_x if adj_x else r_x
c_o = r_y if adj_y else c_y
</pre></div>


<p>It is computed as:</p>
<div class="codehilite"><pre><span></span>output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>complex128</code>.
    3-D or higher with shape <code>[..., r_x, c_x]</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
    3-D or higher with shape <code>[..., r_y, c_y]</code>.
  adj_x: An optional <code>bool</code>. Defaults to <code>False</code>.
    If <code>True</code>, adjoint the slices of <code>x</code>. Defaults to <code>False</code>.
  adj_y: An optional <code>bool</code>. Defaults to <code>False</code>.
    If <code>True</code>, adjoint the slices of <code>y</code>. Defaults to <code>False</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.
  3-D or higher with shape <code>[..., r_o, c_o]</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_matmul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_matmul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization">
    <p>def <span class="ident">batch_norm_with_global_normalization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_norm_with_global_normalization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbatch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbatch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_norm_with_global_normalization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbatch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A 4D input Tensor.
  m: A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  v: A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  beta: A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  gamma: A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  scale_after_normalization: A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for this operation (optional).</p>
<p>Returns:
   A batch-normalized <code>t</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer">
    <p>def <span class="ident">batch_norm_with_global_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_norm_with_global_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.batch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.batch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_norm_with_global_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_norm_with_global_normalization`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.batch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A 4D input Tensor.
  m: A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  v: A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  beta: A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  gamma: A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  scale_after_normalization: A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for this operation (optional).</p>
<p>Returns:
   A batch-normalized <code>t</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer">
    <p>def <span class="ident">batch_norm_with_global_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_norm_with_global_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.batch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.batch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_norm_with_global_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_norm_with_global_normalization`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.batch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A 4D input Tensor.
  m: A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  v: A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  beta: A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  gamma: A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  scale_after_normalization: A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for this operation (optional).</p>
<p>Returns:
   A batch-normalized <code>t</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_norm_with_global_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_normalization">
    <p>def <span class="ident">batch_normalization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_normalization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbatch_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbatch_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_normalization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbatch_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.
Normalizes a tensor by <code>mean</code> and <code>variance</code>, and applies (optionally) a
<code>scale</code> \(\gamma\) to it, as well as an <code>offset</code> \(\beta\):</p>
<p>\(\frac{\gamma(x-\mu)}{\sigma}+\beta\)</p>
<p><code>mean</code>, <code>variance</code>, <code>offset</code> and <code>scale</code> are all expected to be of one of two
shapes:</p>
<ul>
<li>In all generality, they can have the same number of dimensions as the
    input <code>x</code>, with identical sizes as <code>x</code> for the dimensions that are not
    normalized over (the 'depth' dimension(s)), and dimension 1 for the
    others which are being normalized over.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=True)</code> during training, or running averages
    thereof during inference.</li>
<li>In the common case where the 'depth' dimension is the last dimension in
    the input tensor <code>x</code>, they may be one dimensional tensors of the same
    size as the 'depth' dimension.
    This is the case for example for the common <code>[batch, depth]</code> layout of
    fully-connected layers, and <code>[batch, height, width, depth]</code> for
    convolutions.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=False)</code> during training, or running averages
    thereof during inference.</li>
</ul>
<p>Args:
  x: Input <code>Tensor</code> of arbitrary dimensionality.
  mean: A mean <code>Tensor</code>.
  variance: A variance <code>Tensor</code>.
  offset: An offset <code>Tensor</code>, often denoted \(\beta\) in equations, or
    None. If present, will be added to the normalized tensor.
  scale: A scale <code>Tensor</code>, often denoted \(\gamma\) in equations, or
    <code>None</code>. If present, the scale is applied to the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  name: A name for this operation (optional).</p>
<p>Returns:
  the normalized, scaled, offset tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_normalization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_normalization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer">
    <p>def <span class="ident">batch_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.batch_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.batch_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_normalization`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.batch_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.
Normalizes a tensor by <code>mean</code> and <code>variance</code>, and applies (optionally) a
<code>scale</code> \(\gamma\) to it, as well as an <code>offset</code> \(\beta\):</p>
<p>\(\frac{\gamma(x-\mu)}{\sigma}+\beta\)</p>
<p><code>mean</code>, <code>variance</code>, <code>offset</code> and <code>scale</code> are all expected to be of one of two
shapes:</p>
<ul>
<li>In all generality, they can have the same number of dimensions as the
    input <code>x</code>, with identical sizes as <code>x</code> for the dimensions that are not
    normalized over (the 'depth' dimension(s)), and dimension 1 for the
    others which are being normalized over.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=True)</code> during training, or running averages
    thereof during inference.</li>
<li>In the common case where the 'depth' dimension is the last dimension in
    the input tensor <code>x</code>, they may be one dimensional tensors of the same
    size as the 'depth' dimension.
    This is the case for example for the common <code>[batch, depth]</code> layout of
    fully-connected layers, and <code>[batch, height, width, depth]</code> for
    convolutions.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=False)</code> during training, or running averages
    thereof during inference.</li>
</ul>
<p>Args:
  x: Input <code>Tensor</code> of arbitrary dimensionality.
  mean: A mean <code>Tensor</code>.
  variance: A variance <code>Tensor</code>.
  offset: An offset <code>Tensor</code>, often denoted \(\beta\) in equations, or
    None. If present, will be added to the normalized tensor.
  scale: A scale <code>Tensor</code>, often denoted \(\gamma\) in equations, or
    <code>None</code>. If present, the scale is applied to the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  name: A name for this operation (optional).</p>
<p>Returns:
  the normalized, scaled, offset tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_normalization_layer">
    <p>def <span class="ident">batch_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.batch_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.batch_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.batch_normalization`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.batch_normalization</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.
Normalizes a tensor by <code>mean</code> and <code>variance</code>, and applies (optionally) a
<code>scale</code> \(\gamma\) to it, as well as an <code>offset</code> \(\beta\):</p>
<p>\(\frac{\gamma(x-\mu)}{\sigma}+\beta\)</p>
<p><code>mean</code>, <code>variance</code>, <code>offset</code> and <code>scale</code> are all expected to be of one of two
shapes:</p>
<ul>
<li>In all generality, they can have the same number of dimensions as the
    input <code>x</code>, with identical sizes as <code>x</code> for the dimensions that are not
    normalized over (the 'depth' dimension(s)), and dimension 1 for the
    others which are being normalized over.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=True)</code> during training, or running averages
    thereof during inference.</li>
<li>In the common case where the 'depth' dimension is the last dimension in
    the input tensor <code>x</code>, they may be one dimensional tensors of the same
    size as the 'depth' dimension.
    This is the case for example for the common <code>[batch, depth]</code> layout of
    fully-connected layers, and <code>[batch, height, width, depth]</code> for
    convolutions.
    <code>mean</code> and <code>variance</code> in this case would typically be the outputs of
    <code>tf.nn.moments(..., keep_dims=False)</code> during training, or running averages
    thereof during inference.</li>
</ul>
<p>Args:
  x: Input <code>Tensor</code> of arbitrary dimensionality.
  mean: A mean <code>Tensor</code>.
  variance: A variance <code>Tensor</code>.
  offset: An offset <code>Tensor</code>, often denoted \(\beta\) in equations, or
    None. If present, will be added to the normalized tensor.
  scale: A scale <code>Tensor</code>, often denoted \(\gamma\) in equations, or
    <code>None</code>. If present, the scale is applied to the normalized tensor.
  variance_epsilon: A small float number to avoid dividing by 0.
  name: A name for this operation (optional).</p>
<p>Returns:
  the normalized, scaled, offset tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_to_space">
    <p>def <span class="ident">batch_to_space</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_to_space(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.batch_to_space</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.batch_to_space(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_to_space(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.batch_to_space</strong></p>
<div class="codehilite"><pre><span></span>BatchToSpace for 4-D tensors of type T.
</pre></div>


<p>This is a legacy version of the more general BatchToSpaceND.</p>
<p>Rearranges (permutes) data from batch into blocks of spatial data, followed by
cropping. This is the reverse transformation of SpaceToBatch. More specifically,
this op outputs a copy of the input tensor where values from the <code>batch</code>
dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions,
followed by cropping along the <code>height</code> and <code>width</code> dimensions.</p>
<p>Args:
  input: A <code>Tensor</code>. 4-D tensor with shape
    <code>[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
      depth]</code>. Note that the batch size of the input tensor must be divisible by
    <code>block_size * block_size</code>.
  crops: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
    how many elements to crop from the intermediate result across the spatial
    dimensions as follows:</p>
<div class="codehilite"><pre><span></span>    crops = [[crop_top, crop_bottom], [crop_left, crop_right]]
</pre></div>


<p>block_size: An <code>int</code> that is <code>&gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, height, width, depth]</code>, where:</p>
<div class="codehilite"><pre><span></span>    height = height_pad - crop_top - crop_bottom
    width = width_pad - crop_left - crop_right
</pre></div>


<p>The attr <code>block_size</code> must be greater than one. It indicates the block size.</p>
<p>Some examples:</p>
<p>(1) For the following input of shape <code>[4, 1, 1, 1]</code> and block_size of 2:</p>
<p><code>prettyprint
  [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]</code></p>
<p>The output tensor has shape <code>[1, 2, 2, 1]</code> and value:</p>
<p><code>prettyprint
  x = [[[[1], [2]], [[3], [4]]]]</code></p>
<p>(2) For the following input of shape <code>[4, 1, 1, 3]</code> and block_size of 2:</p>
<p><code>prettyprint
  [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]</code></p>
<p>The output tensor has shape <code>[1, 2, 2, 3]</code> and value:</p>
<p><code>prettyprint
  x = [[[[1, 2, 3], [4, 5, 6]],
        [[7, 8, 9], [10, 11, 12]]]]</code></p>
<p>(3) For the following input of shape <code>[4, 2, 2, 1]</code> and block_size of 2:</p>
<p><code>prettyprint
  x = [[[[1], [3]], [[5], [7]]],
       [[[2], [4]], [[10], [12]]],
       [[[5], [7]], [[13], [15]]],
       [[[6], [8]], [[14], [16]]]]</code></p>
<p>The output tensor has shape <code>[1, 4, 4, 1]</code> and value:</p>
<p><code>prettyprint
  x = [[[1],   [2],  [3],  [4]],
       [[5],   [6],  [7],  [8]],
       [[9],  [10], [11],  [12]],
       [[13], [14], [15],  [16]]]</code></p>
<p>(4) For the following input of shape <code>[8, 1, 2, 1]</code> and block_size of 2:</p>
<p><code>prettyprint
  x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
       [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]</code></p>
<p>The output tensor has shape <code>[2, 2, 4, 1]</code> and value:</p>
<p><code>prettyprint
  x = [[[[1], [3]], [[5], [7]]],
       [[[2], [4]], [[10], [12]]],
       [[[5], [7]], [[13], [15]]],
       [[[6], [8]], [[14], [16]]]]</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_to_space', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_to_space" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.batch_to_space_nd">
    <p>def <span class="ident">batch_to_space_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_to_space_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.batch_to_space_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.batch_to_space_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.batch_to_space_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.batch_to_space_nd</strong></p>
<div class="codehilite"><pre><span></span>BatchToSpace for N-D tensors of type T.
</pre></div>


<p>This operation reshapes the "batch" dimension 0 into <code>M + 1</code> dimensions of shape
<code>block_shape + [batch]</code>, interleaves these blocks back into the grid defined by
the spatial dimensions <code>[1, ..., M]</code>, to obtain a result with the same rank as
the input.  The spatial dimensions of this intermediate result are then
optionally cropped according to <code>crops</code> to produce the output.  This is the
reverse of SpaceToBatch.  See below for a precise description.</p>
<p>Args:
  input: A <code>Tensor</code>.
    N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
    where spatial_shape has M dimensions.
  block_shape: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D with shape <code>[M]</code>, all values must be &gt;= 1.
  crops: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.
      <code>crops[i] = [crop_start, crop_end]</code> specifies the amount to crop from input
      dimension <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is
      required that
      <code>crop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1]</code>.</p>
<div class="codehilite"><pre><span></span>This operation is equivalent to the following steps:

1. Reshape `input` to `reshaped` of shape:
     [block_shape[0], ..., block_shape[M-1],
      batch / prod(block_shape),
      input_shape[1], ..., input_shape[N-1]]

2. Permute dimensions of `reshaped` to produce `permuted` of shape
     [batch / prod(block_shape),

      input_shape[1], block_shape[0],
      ...,
      input_shape[M], block_shape[M-1],

      input_shape[M+1], ..., input_shape[N-1]]

3. Reshape `permuted` to produce `reshaped_permuted` of shape
     [batch / prod(block_shape),

      input_shape[1] * block_shape[0],
      ...,
      input_shape[M] * block_shape[M-1],

      input_shape[M+1],
      ...,
      input_shape[N-1]]

4. Crop the start and end of dimensions `[1, ..., M]` of
   `reshaped_permuted` according to `crops` to produce the output of shape:
     [batch / prod(block_shape),

      input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],
      ...,
      input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],

      input_shape[M+1], ..., input_shape[N-1]]

Some examples:

(1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [0, 0]]`:

```prettyprint
[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
```

The output tensor has shape `[1, 2, 2, 1]` and value:

```prettyprint
x = [[[[1], [2]], [[3], [4]]]]
```

(2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [0, 0]]`:

```prettyprint
[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
```

The output tensor has shape `[1, 2, 2, 3]` and value:

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

(3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
```

The output tensor has shape `[1, 4, 4, 1]` and value:

```prettyprint
x = [[[1],   [2],  [3],  [4]],
     [[5],   [6],  [7],  [8]],
     [[9],  [10], [11],  [12]],
     [[13], [14], [15],  [16]]]
```

(4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and
    `crops = [[0, 0], [2, 0]]`:

```prettyprint
x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
     [[[0], [2], [4]]], [[[0], [10], [12]]],
     [[[0], [5], [7]]], [[[0], [13], [15]]],
     [[[0], [6], [8]]], [[[0], [14], [16]]]]
```

The output tensor has shape `[2, 2, 4, 1]` and value:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.batch_to_space_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.batch_to_space_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.betainc">
    <p>def <span class="ident">betainc</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.betainc(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.betainc</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.betainc(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.betainc(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.betainc</strong></p>
<div class="codehilite"><pre><span></span>Compute the regularized incomplete beta integral \\(I_x(a, b)\\).
</pre></div>


<p>The regularized incomplete beta integral is defined as:</p>
<p><code>I_x(a, b) = \frac{B(x; a, b)}{B(a, b)}</code>
where</p>
<p><code>B(x; a, b) = \int_0^x t^{a-1} (1 - t)^{b-1} dt</code></p>
<p>is the incomplete beta function and \(B(a, b)\) is the <em>complete</em>
beta function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  b: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.betainc', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.betainc" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add">
    <p>def <span class="ident">bias_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer">
    <p>def <span class="ident">bias_add_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_grad">
    <p>def <span class="ident">bias_add_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbias_add_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbias_add_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbias_add_grad</strong></p>
<div class="codehilite"><pre><span></span>The backward operation for &quot;BiasAdd&quot; on the &quot;bias&quot; tensor.
</pre></div>


<p>It accumulates all the values from out_backprop into the feature dimension.
For NHWC data format, the feature dimension is the last. For NCHW data format,
the feature dimension is the third-to-last.</p>
<p>Args:
  out_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Any number of dimensions.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the bias tensor will be added to the last dimension
    of the value tensor.
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
    The tensor will be added to "in_channels", the third-to-the-last
        dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>out_backprop</code>.
  1-D with size the feature dimension of <code>out_backprop</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer">
    <p>def <span class="ident">bias_add_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bias_add_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bias_add_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bias_add_grad</strong></p>
<div class="codehilite"><pre><span></span>The backward operation for &quot;BiasAdd&quot; on the &quot;bias&quot; tensor.
</pre></div>


<p>It accumulates all the values from out_backprop into the feature dimension.
For NHWC data format, the feature dimension is the last. For NCHW data format,
the feature dimension is the third-to-last.</p>
<p>Args:
  out_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Any number of dimensions.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the bias tensor will be added to the last dimension
    of the value tensor.
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
    The tensor will be added to "in_channels", the third-to-the-last
        dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>out_backprop</code>.
  1-D with size the feature dimension of <code>out_backprop</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_grad_layer">
    <p>def <span class="ident">bias_add_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bias_add_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bias_add_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bias_add_grad</strong></p>
<div class="codehilite"><pre><span></span>The backward operation for &quot;BiasAdd&quot; on the &quot;bias&quot; tensor.
</pre></div>


<p>It accumulates all the values from out_backprop into the feature dimension.
For NHWC data format, the feature dimension is the last. For NCHW data format,
the feature dimension is the third-to-last.</p>
<p>Args:
  out_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Any number of dimensions.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the bias tensor will be added to the last dimension
    of the value tensor.
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
    The tensor will be added to "in_channels", the third-to-the-last
        dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>out_backprop</code>.
  1-D with size the feature dimension of <code>out_backprop</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_layer">
    <p>def <span class="ident">bias_add_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_v1">
    <p>def <span class="ident">bias_add_v1</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_v1(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbias_add_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbias_add_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_v1(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbias_add_v1</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is a deprecated version of bias_add and will soon to be removed.</p>
<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_v1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_v1" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer">
    <p>def <span class="ident">bias_add_v1_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_v1_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bias_add_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bias_add_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_v1_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_v1`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bias_add_v1</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is a deprecated version of bias_add and will soon to be removed.</p>
<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_v1_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bias_add_v1_layer">
    <p>def <span class="ident">bias_add_v1_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_v1_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bias_add_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bias_add_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bias_add_v1_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bias_add_v1`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bias_add_v1</strong></p>
<div class="codehilite"><pre><span></span>Adds `bias` to `value`.
</pre></div>


<p>This is a deprecated version of bias_add and will soon to be removed.</p>
<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.
Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the
case where both types are quantized.</p>
<p>Args:
  value: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>,
    <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.
  bias: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>.
    Must be the same type as <code>value</code> unless <code>value</code> is a quantized type,
    in which case a different quantized type may be used.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bias_add_v1_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bias_add_v1_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn">
    <p>def <span class="ident">bidirectional_dynamic_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_dynamic_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbidirectional_dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbidirectional_dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_dynamic_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbidirectional_dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a dynamic version of bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs. The input_size of forward and
backward cell must match. The initial state for both directions is zero by
default (but can be set optionally) and no intermediate states are ever
returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not
given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: The RNN inputs.
    If time_major == False (default), this must be a tensor of shape:
      <code>[batch_size, max_time, input_size]</code>.
    If time_major == True, this must be a tensor of shape:
      <code>[max_time, batch_size, input_size]</code>.
    [batch_size, input_size].
  sequence_length: An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial states and expected output.
    Required if initial_states are not provided or RNN states have a
    heterogeneous dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_states) where:
    outputs: A tuple (output_fw, output_bw) containing the forward and
      the backward rnn output <code>Tensor</code>.
      If time_major == False (default),
        output_fw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_bw.output_size]</code>.
      If time_major == True,
        output_fw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_bw.output_size]</code>.
      It returns a tuple instead of a single concatenated <code>Tensor</code>, unlike
      in the <code>bidirectional_rnn</code>. If the concatenated one is preferred,
      the forward and backward outputs can be concatenated as
      <code>tf.concat(2, outputs)</code>.
    output_states: A tuple (output_state_fw, output_state_bw) containing
      the forward and the backward final states of bidirectional rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer">
    <p>def <span class="ident">bidirectional_dynamic_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bidirectional_dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bidirectional_dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_dynamic_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bidirectional_dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a dynamic version of bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs. The input_size of forward and
backward cell must match. The initial state for both directions is zero by
default (but can be set optionally) and no intermediate states are ever
returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not
given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: The RNN inputs.
    If time_major == False (default), this must be a tensor of shape:
      <code>[batch_size, max_time, input_size]</code>.
    If time_major == True, this must be a tensor of shape:
      <code>[max_time, batch_size, input_size]</code>.
    [batch_size, input_size].
  sequence_length: An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial states and expected output.
    Required if initial_states are not provided or RNN states have a
    heterogeneous dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_states) where:
    outputs: A tuple (output_fw, output_bw) containing the forward and
      the backward rnn output <code>Tensor</code>.
      If time_major == False (default),
        output_fw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_bw.output_size]</code>.
      If time_major == True,
        output_fw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_bw.output_size]</code>.
      It returns a tuple instead of a single concatenated <code>Tensor</code>, unlike
      in the <code>bidirectional_rnn</code>. If the concatenated one is preferred,
      the forward and backward outputs can be concatenated as
      <code>tf.concat(2, outputs)</code>.
    output_states: A tuple (output_state_fw, output_state_bw) containing
      the forward and the backward final states of bidirectional rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer">
    <p>def <span class="ident">bidirectional_dynamic_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_dynamic_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bidirectional_dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bidirectional_dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_dynamic_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_dynamic_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bidirectional_dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a dynamic version of bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs. The input_size of forward and
backward cell must match. The initial state for both directions is zero by
default (but can be set optionally) and no intermediate states are ever
returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not
given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: The RNN inputs.
    If time_major == False (default), this must be a tensor of shape:
      <code>[batch_size, max_time, input_size]</code>.
    If time_major == True, this must be a tensor of shape:
      <code>[max_time, batch_size, input_size]</code>.
    [batch_size, input_size].
  sequence_length: An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial states and expected output.
    Required if initial_states are not provided or RNN states have a
    heterogeneous dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_states) where:
    outputs: A tuple (output_fw, output_bw) containing the forward and
      the backward rnn output <code>Tensor</code>.
      If time_major == False (default),
        output_fw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[batch_size, max_time, cell_bw.output_size]</code>.
      If time_major == True,
        output_fw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_fw.output_size]</code>
        and output_bw will be a <code>Tensor</code> shaped:
        <code>[max_time, batch_size, cell_bw.output_size]</code>.
      It returns a tuple instead of a single concatenated <code>Tensor</code>, unlike
      in the <code>bidirectional_rnn</code>. If the concatenated one is preferred,
      the forward and backward outputs can be concatenated as
      <code>tf.concat(2, outputs)</code>.
    output_states: A tuple (output_state_fw, output_state_bw) containing
      the forward and the backward final states of bidirectional rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_dynamic_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_rnn">
    <p>def <span class="ident">bidirectional_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnbidirectional_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnbidirectional_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnbidirectional_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs with the final forward and backward
outputs depth-concatenated, such that the output will have the format
[time][batch][cell_fw.output_size + cell_bw.output_size]. The input_size of
forward and backward cell must match. The initial state for both directions
is zero by default (but can be set optionally) and no intermediate states are
ever returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: A length T list of inputs, each a tensor of shape
    [batch_size, input_size], or a nested tuple of such elements.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  sequence_length: (optional) An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_state_fw, output_state_bw) where:
    outputs is a length <code>T</code> list of outputs (one for each input), which
      are depth-concatenated forward and backward outputs.
    output_state_fw is the final state of the forward rnn.
    output_state_bw is the final state of the backward rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer">
    <p>def <span class="ident">bidirectional_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bidirectional_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bidirectional_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bidirectional_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs with the final forward and backward
outputs depth-concatenated, such that the output will have the format
[time][batch][cell_fw.output_size + cell_bw.output_size]. The input_size of
forward and backward cell must match. The initial state for both directions
is zero by default (but can be set optionally) and no intermediate states are
ever returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: A length T list of inputs, each a tensor of shape
    [batch_size, input_size], or a nested tuple of such elements.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  sequence_length: (optional) An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_state_fw, output_state_bw) where:
    outputs is a length <code>T</code> list of outputs (one for each input), which
      are depth-concatenated forward and backward outputs.
    output_state_fw is the final state of the forward rnn.
    output_state_bw is the final state of the backward rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer">
    <p>def <span class="ident">bidirectional_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.bidirectional_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.bidirectional_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bidirectional_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.bidirectional_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.bidirectional_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a bidirectional recurrent neural network.
</pre></div>


<p>Similar to the unidirectional case above (rnn) but takes input and builds
independent forward and backward RNNs with the final forward and backward
outputs depth-concatenated, such that the output will have the format
[time][batch][cell_fw.output_size + cell_bw.output_size]. The input_size of
forward and backward cell must match. The initial state for both directions
is zero by default (but can be set optionally) and no intermediate states are
ever returned -- the network is fully unrolled for the given (passed in)
length(s) of the sequence(s) or completely unrolled if length(s) is not given.</p>
<p>Args:
  cell_fw: An instance of RNNCell, to be used for forward direction.
  cell_bw: An instance of RNNCell, to be used for backward direction.
  inputs: A length T list of inputs, each a tensor of shape
    [batch_size, input_size], or a nested tuple of such elements.
  initial_state_fw: (optional) An initial state for the forward RNN.
    This must be a tensor of appropriate type and shape
    <code>[batch_size, cell_fw.state_size]</code>.
    If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.
  initial_state_bw: (optional) Same as for <code>initial_state_fw</code>, but using
    the corresponding properties of <code>cell_bw</code>.
  dtype: (optional) The data type for the initial state.  Required if
    either of the initial states are not provided.
  sequence_length: (optional) An int32/int64 vector, size <code>[batch_size]</code>,
    containing the actual lengths for each of the sequences.
  scope: VariableScope for the created subgraph; defaults to "BiRNN"</p>
<p>Returns:
  A tuple (outputs, output_state_fw, output_state_bw) where:
    outputs is a length <code>T</code> list of outputs (one for each input), which
      are depth-concatenated forward and backward outputs.
    output_state_fw is the final state of the forward rnn.
    output_state_bw is the final state of the backward rnn.</p>
<p>Raises:
  TypeError: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bidirectional_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.bitcast">
    <p>def <span class="ident">bitcast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bitcast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.bitcast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.bitcast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.bitcast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.bitcast</strong></p>
<div class="codehilite"><pre><span></span>Bitcasts a tensor from one type to another without copying data.
</pre></div>


<p>Given a tensor <code>input</code>, this operation returns a tensor that has the same buffer
data as <code>input</code> with datatype <code>type</code>.</p>
<p>If the input datatype <code>T</code> is larger than the output datatype <code>type</code> then the
shape changes from [...] to [..., sizeof(<code>T</code>)/sizeof(<code>type</code>)].</p>
<p>If <code>T</code> is smaller than <code>type</code>, the operator requires that the rightmost
dimension be equal to sizeof(<code>type</code>)/sizeof(<code>T</code>). The shape then goes from
[..., sizeof(<code>type</code>)/sizeof(<code>T</code>)] to [...].</p>
<p><em>NOTE</em>: Bitcast is implemented as a low-level cast, so machines with different
endian orderings will give different results.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  type: A <code>tf.DType</code> from: <code>tf.float32, tf.float64, tf.int64, tf.int32, tf.uint8, tf.uint16, tf.int16, tf.int8, tf.complex64, tf.complex128, tf.qint8, tf.quint8, tf.qint32, tf.half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.bitcast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.bitcast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.boolean_mask">
    <p>def <span class="ident">boolean_mask</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.boolean_mask(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.boolean_mask</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.boolean_mask(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.boolean_mask(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.boolean_mask</strong></p>
<div class="codehilite"><pre><span></span>Apply boolean mask to tensor.  Numpy equivalent is `tensor[mask]`.
</pre></div>


<p>```python</p>
<h1>1-D example</h1>
<p>tensor = [0, 1, 2, 3]
mask = [True, False, True, False]
boolean_mask(tensor, mask) ==&gt; [0, 2]
```</p>
<p>In general, <code>0 &lt; dim(mask) = K &lt;= dim(tensor)</code>, and <code>mask</code>'s shape must match
the first K dimensions of <code>tensor</code>'s shape.  We then have:
  <code>boolean_mask(tensor, mask)[i, j1,...,jd] = tensor[i1,...,iK,j1,...,jd]</code>
where <code>(i1,...,iK)</code> is the ith <code>True</code> entry of <code>mask</code> (row-major order).</p>
<p>Args:
  tensor:  N-D tensor.
  mask:  K-D boolean tensor, K &lt;= N and K must be known statically.
  name:  A name for this operation (optional).</p>
<p>Returns:
  Tensor populated by entries in <code>tensor</code> corresponding to <code>True</code> values in
    <code>mask</code>.</p>
<p>Raises:
  ValueError:  If shapes do not conform.</p>
<p>Examples:</p>
<p>```python</p>
<h1>2-D example</h1>
<p>tensor = [[1, 2], [3, 4], [5, 6]]
mask = [True, False, True]
boolean_mask(tensor, mask) ==&gt; [[1, 2], [5, 6]]
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.boolean_mask', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.boolean_mask" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.case">
    <p>def <span class="ident">case</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.case(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.case</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.case(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.case(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.case</strong></p>
<div class="codehilite"><pre><span></span>Create a case operation.
</pre></div>


<p>The <code>pred_fn_pairs</code> parameter is a dict or list of pairs of size N.
Each pair contains a boolean scalar tensor and a python callable that
creates the tensors to be returned if the boolean evaluates to True.
<code>default</code> is a callable generating a list of tensors. All the callables
in <code>pred_fn_pairs</code> as well as <code>default</code> should return the same number
and types of tensors.</p>
<p>If <code>exclusive==True</code>, all predicates are evaluated, and an exception is
thrown if more than one of the predicates evaluates to <code>True</code>.
If <code>exclusive==False</code>, execution stops are the first predicate which
evaluates to True, and the tensors generated by the corresponding function
are returned immediately. If none of the predicates evaluate to True, this
operation returns the tensors generated by <code>default</code>.</p>
<p>Example 1:
  Pseudocode:
  <code>if (x &lt; y) return 17;
    else return 23;</code></p>
<p>Expressions:
  <code>f1 = lambda: tf.constant(17)
    f2 = lambda: tf.constant(23)
    r = case([(tf.less(x, y), f1)], default=f2)</code></p>
<p>Example 2:
  Pseudocode:
  <code>if (x &lt; y &amp;&amp; x &gt; z) raise OpError("Only one predicate may evaluate true");
    if (x &lt; y) return 17;
    else if (x &gt; z) return 23;
    else return -1;</code></p>
<p>Expressions:
  <code>x = tf.constant(0)
    y = tf.constant(1)
    z = tf.constant(2)
    def f1(): return tf.constant(17)
    def f2(): return tf.constant(23)
    def f3(): return tf.constant(-1)
    r = case({tf.less(x, y): f1, tf.greater(x, z): f2},
             default=f3, exclusive=True)</code></p>
<p>Args:
  pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a
                 callable which returns a list of tensors.
  default: A callable that returns a list of tensors.
  exclusive: True iff at most one predicate is allowed to evaluate to <code>True</code>.
  name: A name for this operation (optional).</p>
<p>Returns:
  The tensors returned by the first pair whose predicate evaluated to True, or
  those returned by <code>default</code> if none does.</p>
<p>Raises:
  TypeError: If <code>pred_fn_pairs</code> is not a list/dictionary.
  TypeError: If <code>pred_fn_pairs</code> is a list but does not contain 2-tuples.
  TypeError: If <code>fns[i]</code> is not callable for any i, or <code>default</code> is not
             callable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.case', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.case" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cast">
    <p>def <span class="ident">cast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cast</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to a new type.
</pre></div>


<p>The operation casts <code>x</code> (in case of <code>Tensor</code>) or <code>x.values</code>
(in case of <code>SparseTensor</code>) to <code>dtype</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>tensor <code>a</code> is [1.8, 2.2], dtype=tf.float</h1>
<p>tf.cast(a, tf.int32) ==&gt; [1, 2]  # dtype=tf.int32
```</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  dtype: The destination type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>dtype</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ceil">
    <p>def <span class="ident">ceil</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ceil(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ceil</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ceil(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ceil(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ceil</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise smallest integer in not less than x.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ceil', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ceil" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.check_numerics">
    <p>def <span class="ident">check_numerics</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.check_numerics(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.check_numerics</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.check_numerics(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.check_numerics(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.check_numerics</strong></p>
<div class="codehilite"><pre><span></span>Checks a tensor for NaN and Inf values.
</pre></div>


<p>When run, reports an <code>InvalidArgument</code> error if <code>tensor</code> has any values
that are not a number (NaN) or infinity (Inf). Otherwise, passes <code>tensor</code> as-is.</p>
<p>Args:
  tensor: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  message: A <code>string</code>. Prefix of the error message.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.check_numerics', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.check_numerics" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cholesky">
    <p>def <span class="ident">cholesky</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cholesky(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cholesky</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cholesky(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cholesky(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cholesky</strong></p>
<div class="codehilite"><pre><span></span>Computes the Cholesky decomposition of one or more square matrices.
</pre></div>


<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices, with the same constraints as the single matrix Cholesky
decomposition above. The output is a tensor of the same shape as the input
containing the Cholesky decompositions for all input submatrices <code>[..., :, :]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. Shape is <code>[..., M, M]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cholesky', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cholesky" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cholesky_solve">
    <p>def <span class="ident">cholesky_solve</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cholesky_solve(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cholesky_solve</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cholesky_solve(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cholesky_solve(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cholesky_solve</strong></p>
<div class="codehilite"><pre><span></span>Solves systems of linear eqns `A X = RHS`, given Cholesky factorizations.
</pre></div>


<p>```python</p>
<h1>Solve 10 separate 2x2 linear systems:</h1>
<p>A = ... # shape 10 x 2 x 2
RHS = ... # shape 10 x 2 x 1
chol = tf.cholesky(A)  # shape 10 x 2 x 2
X = tf.cholesky_solve(chol, RHS)  # shape 10 x 2 x 1</p>
<h1>tf.matmul(A, X) ~ RHS</h1>
<p>X[3, :, 0]  # Solution to the linear system A[3, :, :] x = RHS[3, :, 0]</p>
<h1>Solve five linear systems (K = 5) for every member of the length 10 batch.</h1>
<p>A = ... # shape 10 x 2 x 2
RHS = ... # shape 10 x 2 x 5
...
X[3, :, 2]  # Solution to the linear system A[3, :, :] x = RHS[3, :, 2]
```</p>
<p>Args:
  chol:  A <code>Tensor</code>.  Must be <code>float32</code> or <code>float64</code>, shape is <code>[..., M, M]</code>.
    Cholesky factorization of <code>A</code>, e.g. <code>chol = tf.cholesky(A)</code>.
    For that reason, only the lower triangular parts (including the diagonal)
    of the last two dimensions of <code>chol</code> are used.  The strictly upper part is
    assumed to be zero and not accessed.
  rhs:  A <code>Tensor</code>, same type as <code>chol</code>, shape is <code>[..., M, K]</code>.
  name:  A name to give this <code>Op</code>.  Defaults to <code>cholesky_solve</code>.</p>
<p>Returns:
  Solution to <code>A x = rhs</code>, shape <code>[..., M, K]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cholesky_solve', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cholesky_solve" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_average_norm">
    <p>def <span class="ident">clip_by_average_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_average_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_average_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_average_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_average_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_average_norm</strong></p>
<div class="codehilite"><pre><span></span>Clips tensor values to a maximum average L2-norm.
</pre></div>


<p>Given a tensor <code>t</code>, and a maximum clip value <code>clip_norm</code>, this operation
normalizes <code>t</code> so that its average L2-norm is less than or equal to
<code>clip_norm</code>. Specifically, if the average L2-norm is already less than or
equal to <code>clip_norm</code>, then <code>t</code> is not modified. If the average L2-norm is
greater than <code>clip_norm</code>, then this operation returns a tensor of the same
type and shape as <code>t</code> with its values set to:</p>
<p><code>t * clip_norm / l2norm_avg(t)</code></p>
<p>In this case, the average L2-norm of the output tensor is <code>clip_norm</code>.</p>
<p>This operation is typically used to clip gradients before applying them with
an optimizer.</p>
<p>Args:
  t: A <code>Tensor</code>.
  clip_norm: A 0-D (scalar) <code>Tensor</code> &gt; 0. A maximum clipping value.
  name: A name for the operation (optional).</p>
<p>Returns:
  A clipped <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_average_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_average_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_global_norm">
    <p>def <span class="ident">clip_by_global_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_global_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_global_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_global_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_global_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_global_norm</strong></p>
<div class="codehilite"><pre><span></span>Clips values of multiple tensors by the ratio of the sum of their norms.
</pre></div>


<p>Given a tuple or list of tensors <code>t_list</code>, and a clipping ratio <code>clip_norm</code>,
this operation returns a list of clipped tensors <code>list_clipped</code>
and the global norm (<code>global_norm</code>) of all tensors in <code>t_list</code>. Optionally,
if you've already computed the global norm for <code>t_list</code>, you can specify
the global norm with <code>use_norm</code>.</p>
<p>To perform the clipping, the values <code>t_list[i]</code> are set to:</p>
<div class="codehilite"><pre><span></span>t_list[i] * clip_norm / max(global_norm, clip_norm)
</pre></div>


<p>where:</p>
<div class="codehilite"><pre><span></span>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))
</pre></div>


<p>If <code>clip_norm &gt; global_norm</code> then the entries in <code>t_list</code> remain as they are,
otherwise they're all shrunk by the global ratio.</p>
<p>Any of the entries of <code>t_list</code> that are of type <code>None</code> are ignored.</p>
<p>This is the correct way to perform gradient clipping (for example, see
<a href="http://arxiv.org/abs/1211.5063">Pascanu et al., 2012</a>
(<a href="http://arxiv.org/pdf/1211.5063.pdf">pdf</a>)).</p>
<p>However, it is slower than <code>clip_by_norm()</code> because all the parameters must be
ready before the clipping operation can be performed.</p>
<p>Args:
  t_list: A tuple or list of mixed <code>Tensors</code>, <code>IndexedSlices</code>, or None.
  clip_norm: A 0-D (scalar) <code>Tensor</code> &gt; 0. The clipping ratio.
  use_norm: A 0-D (scalar) <code>Tensor</code> of type <code>float</code> (optional). The global
    norm to use. If not provided, <code>global_norm()</code> is used to compute the norm.
  name: A name for the operation (optional).</p>
<p>Returns:
  list_clipped: A list of <code>Tensors</code> of the same type as <code>list_t</code>.
  global_norm: A 0-D (scalar) <code>Tensor</code> representing the global norm.</p>
<p>Raises:
  TypeError: If <code>t_list</code> is not a sequence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_global_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_global_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_norm">
    <p>def <span class="ident">clip_by_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_norm</strong></p>
<div class="codehilite"><pre><span></span>Clips tensor values to a maximum L2-norm.
</pre></div>


<p>Given a tensor <code>t</code>, and a maximum clip value <code>clip_norm</code>, this operation
normalizes <code>t</code> so that its L2-norm is less than or equal to <code>clip_norm</code>,
along the dimensions given in <code>axes</code>. Specifically, in the default case
where all dimensions are used for calculation, if the L2-norm of <code>t</code> is
already less than or equal to <code>clip_norm</code>, then <code>t</code> is not modified. If
the L2-norm is greater than <code>clip_norm</code>, then this operation returns a
tensor of the same type and shape as <code>t</code> with its values set to:</p>
<p><code>t * clip_norm / l2norm(t)</code></p>
<p>In this case, the L2-norm of the output tensor is <code>clip_norm</code>.</p>
<p>As another example, if <code>t</code> is a matrix and <code>axes == [1]</code>, then each row
of the output will have L2-norm equal to <code>clip_norm</code>. If <code>axes == [0]</code>
instead, each column of the output will be clipped.</p>
<p>This operation is typically used to clip gradients before applying them with
an optimizer.</p>
<p>Args:
  t: A <code>Tensor</code>.
  clip_norm: A 0-D (scalar) <code>Tensor</code> &gt; 0. A maximum clipping value.
  axes: A 1-D (vector) <code>Tensor</code> of type int32 containing the dimensions
    to use for computing the L2-norm. If <code>None</code> (the default), uses all
    dimensions.
  name: A name for the operation (optional).</p>
<p>Returns:
  A clipped <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.clip_by_value">
    <p>def <span class="ident">clip_by_value</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_value(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.clip_by_value</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.clip_by_value(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.clip_by_value(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.clip_by_value</strong></p>
<div class="codehilite"><pre><span></span>Clips tensor values to a specified min and max.
</pre></div>


<p>Given a tensor <code>t</code>, this operation returns a tensor of the same type and
shape as <code>t</code> with its values clipped to <code>clip_value_min</code> and <code>clip_value_max</code>.
Any values less than <code>clip_value_min</code> are set to <code>clip_value_min</code>. Any values
greater than <code>clip_value_max</code> are set to <code>clip_value_max</code>.</p>
<p>Args:
  t: A <code>Tensor</code>.
  clip_value_min: A 0-D (scalar) <code>Tensor</code>. The minimum value to clip by.
  clip_value_max: A 0-D (scalar) <code>Tensor</code>. The maximum value to clip by.
  name: A name for the operation (optional).</p>
<p>Returns:
  A clipped <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.clip_by_value', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.clip_by_value" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.complex">
    <p>def <span class="ident">complex</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.complex(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.complex</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.complex(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.complex(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.complex</strong></p>
<div class="codehilite"><pre><span></span>Converts two real numbers to a complex number.
</pre></div>


<p>Given a tensor <code>real</code> representing the real part of a complex number, and a
tensor <code>imag</code> representing the imaginary part of a complex number, this
operation returns complex numbers elementwise of the form (a + bj), where
<em>a</em> represents the <code>real</code> part and <em>b</em> represents the <code>imag</code> part.</p>
<p>The input tensors <code>real</code> and <code>imag</code> must have the same shape.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'real' is [2.25, 3.25]</h1>
<h1>tensor <code>imag</code> is [4.75, 5.75]</h1>
<p>tf.complex(real, imag) ==&gt; [[2.25 + 4.75j], [3.25 + 5.75j]]
```</p>
<p>Args:
  real: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  imag: A <code>Tensor</code>. Must have the same type as <code>real</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code> or <code>complex128</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.complex', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.complex" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.complex_abs">
    <p>def <span class="ident">complex_abs</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.complex_abs(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.complex_abs</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.complex_abs(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.complex_abs(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.complex_abs</strong></p>
<div class="codehilite"><pre><span></span>Computes the complex absolute value of a tensor.
</pre></div>


<p>Given a tensor <code>x</code> of complex numbers, this operation returns a tensor of type
<code>float32</code> or <code>float64</code> that is the absolute value of each element in <code>x</code>. All
elements in <code>x</code> must be complex numbers of the form \(a + bj\). The
absolute value is computed as \( \sqrt{a^2 + b^2}\).</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'x' is [[-2.25 + 4.75j], [-3.25 + 5.75j]]</h1>
<p>tf.complex_abs(x) ==&gt; [5.25594902, 6.60492229]
```</p>
<p>Args:
  x: A <code>Tensor</code> of type <code>complex64</code> or <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.complex_abs', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.complex_abs" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.compute_accidental_hits">
    <p>def <span class="ident">compute_accidental_hits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.compute_accidental_hits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nncompute_accidental_hits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nncompute_accidental_hits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.compute_accidental_hits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nncompute_accidental_hits</strong></p>
<div class="codehilite"><pre><span></span>Compute the position ids in `sampled_candidates` matching `true_classes`.
</pre></div>


<p>In Candidate Sampling, this operation facilitates virtually removing
sampled classes which happen to match target classes.  This is done
in Sampled Softmax and Sampled Logistic.</p>
<p>See our <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">Candidate Sampling Algorithms
Reference</a>.</p>
<p>We presuppose that the <code>sampled_candidates</code> are unique.</p>
<p>We call it an 'accidental hit' when one of the target classes
matches one of the sampled classes.  This operation reports
accidental hits as triples <code>(index, id, weight)</code>, where <code>index</code>
represents the row number in <code>true_classes</code>, <code>id</code> represents the
position in <code>sampled_candidates</code>, and weight is <code>-FLOAT_MAX</code>.</p>
<p>The result of this op should be passed through a <code>sparse_to_dense</code>
operation, then added to the logits of the sampled classes. This
removes the contradictory effect of accidentally sampling the true
target classes as noise classes for the same example.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled_candidates output of CandidateSampler.
  num_true: An <code>int</code>.  The number of target classes per training example.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  indices: A <code>Tensor</code> of type <code>int32</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate rows in <code>true_classes</code>.
  ids: A <code>Tensor</code> of type <code>int64</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate positions in <code>sampled_candidates</code>.
  weights: A <code>Tensor</code> of type <code>float</code> and shape <code>[num_accidental_hits]</code>.
    Each value is <code>-FLOAT_MAX</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer">
    <p>def <span class="ident">compute_accidental_hits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.compute_accidental_hits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.compute_accidental_hits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.compute_accidental_hits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.compute_accidental_hits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.compute_accidental_hits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.compute_accidental_hits</strong></p>
<div class="codehilite"><pre><span></span>Compute the position ids in `sampled_candidates` matching `true_classes`.
</pre></div>


<p>In Candidate Sampling, this operation facilitates virtually removing
sampled classes which happen to match target classes.  This is done
in Sampled Softmax and Sampled Logistic.</p>
<p>See our <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">Candidate Sampling Algorithms
Reference</a>.</p>
<p>We presuppose that the <code>sampled_candidates</code> are unique.</p>
<p>We call it an 'accidental hit' when one of the target classes
matches one of the sampled classes.  This operation reports
accidental hits as triples <code>(index, id, weight)</code>, where <code>index</code>
represents the row number in <code>true_classes</code>, <code>id</code> represents the
position in <code>sampled_candidates</code>, and weight is <code>-FLOAT_MAX</code>.</p>
<p>The result of this op should be passed through a <code>sparse_to_dense</code>
operation, then added to the logits of the sampled classes. This
removes the contradictory effect of accidentally sampling the true
target classes as noise classes for the same example.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled_candidates output of CandidateSampler.
  num_true: An <code>int</code>.  The number of target classes per training example.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  indices: A <code>Tensor</code> of type <code>int32</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate rows in <code>true_classes</code>.
  ids: A <code>Tensor</code> of type <code>int64</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate positions in <code>sampled_candidates</code>.
  weights: A <code>Tensor</code> of type <code>float</code> and shape <code>[num_accidental_hits]</code>.
    Each value is <code>-FLOAT_MAX</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer">
    <p>def <span class="ident">compute_accidental_hits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.compute_accidental_hits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.compute_accidental_hits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.compute_accidental_hits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.compute_accidental_hits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.compute_accidental_hits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.compute_accidental_hits</strong></p>
<div class="codehilite"><pre><span></span>Compute the position ids in `sampled_candidates` matching `true_classes`.
</pre></div>


<p>In Candidate Sampling, this operation facilitates virtually removing
sampled classes which happen to match target classes.  This is done
in Sampled Softmax and Sampled Logistic.</p>
<p>See our <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">Candidate Sampling Algorithms
Reference</a>.</p>
<p>We presuppose that the <code>sampled_candidates</code> are unique.</p>
<p>We call it an 'accidental hit' when one of the target classes
matches one of the sampled classes.  This operation reports
accidental hits as triples <code>(index, id, weight)</code>, where <code>index</code>
represents the row number in <code>true_classes</code>, <code>id</code> represents the
position in <code>sampled_candidates</code>, and weight is <code>-FLOAT_MAX</code>.</p>
<p>The result of this op should be passed through a <code>sparse_to_dense</code>
operation, then added to the logits of the sampled classes. This
removes the contradictory effect of accidentally sampling the true
target classes as noise classes for the same example.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled_candidates output of CandidateSampler.
  num_true: An <code>int</code>.  The number of target classes per training example.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  indices: A <code>Tensor</code> of type <code>int32</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate rows in <code>true_classes</code>.
  ids: A <code>Tensor</code> of type <code>int64</code> and shape <code>[num_accidental_hits]</code>.
    Values indicate positions in <code>sampled_candidates</code>.
  weights: A <code>Tensor</code> of type <code>float</code> and shape <code>[num_accidental_hits]</code>.
    Each value is <code>-FLOAT_MAX</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.compute_accidental_hits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.concat">
    <p>def <span class="ident">concat</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.concat(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.concat</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.concat(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.concat(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.concat</strong></p>
<div class="codehilite"><pre><span></span>Concatenates tensors along one dimension.
</pre></div>


<p>Concatenates the list of tensors <code>values</code> along dimension <code>concat_dim</code>.  If
<code>values[i].shape = [D0, D1, ... Dconcat_dim(i), ...Dn]</code>, the concatenated
result has shape</p>
<div class="codehilite"><pre><span></span>[D0, D1, ... Rconcat_dim, ...Dn]
</pre></div>


<p>where</p>
<div class="codehilite"><pre><span></span>Rconcat_dim = sum(Dconcat_dim(i))
</pre></div>


<p>That is, the data from the input tensors is joined along the <code>concat_dim</code>
dimension.</p>
<p>The number of dimensions of the input tensors must match, and all dimensions
except <code>concat_dim</code> must be equal.</p>
<p>For example:</p>
<p>```python
t1 = [[1, 2, 3], [4, 5, 6]]
t2 = [[7, 8, 9], [10, 11, 12]]
tf.concat(0, [t1, t2]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]
tf.concat(1, [t1, t2]) ==&gt; [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]</p>
<h1>tensor t3 with shape [2, 3]</h1>
<h1>tensor t4 with shape [2, 3]</h1>
<p>tf.shape(tf.concat(0, [t3, t4])) ==&gt; [4, 3]
tf.shape(tf.concat(1, [t3, t4])) ==&gt; [2, 6]
```</p>
<p>Note: If you are concatenating along a new axis consider using pack.
E.g.</p>
<p><code>python
tf.concat(axis, [tf.expand_dims(t, axis) for t in tensors])</code></p>
<p>can be rewritten as</p>
<p><code>python
tf.pack(tensors, axis=axis)</code></p>
<p>Args:
  concat_dim: 0-D <code>int32</code> <code>Tensor</code>.  Dimension along which to concatenate.
  values: A list of <code>Tensor</code> objects or a single <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> resulting from concatenation of the input tensors.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.concat', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.concat" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.concat_v2">
    <p>def <span class="ident">concat_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.concat_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.concat_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.concat_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.concat_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.concat_v2</strong></p>
<div class="codehilite"><pre><span></span>Concatenates tensors along one dimension.
</pre></div>


<p>Concatenates the list of tensors <code>values</code> along dimension <code>axis</code>.  If
<code>values[i].shape = [D0, D1, ... Daxis(i), ...Dn]</code>, the concatenated
result has shape</p>
<div class="codehilite"><pre><span></span>[D0, D1, ... Raxis, ...Dn]
</pre></div>


<p>where</p>
<div class="codehilite"><pre><span></span>Raxis = sum(Daxis(i))
</pre></div>


<p>That is, the data from the input tensors is joined along the <code>axis</code>
dimension.</p>
<p>The number of dimensions of the input tensors must match, and all dimensions
except <code>axis</code> must be equal.</p>
<p>For example:</p>
<p>```python
t1 = [[1, 2, 3], [4, 5, 6]]
t2 = [[7, 8, 9], [10, 11, 12]]
tf.concat_v2([t1, t2], 0) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]
tf.concat_v2([t1, t2], 1) ==&gt; [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]</p>
<h1>tensor t3 with shape [2, 3]</h1>
<h1>tensor t4 with shape [2, 3]</h1>
<p>tf.shape(tf.concat_v2([t3, t4], 0)) ==&gt; [4, 3]
tf.shape(tf.concat_v2([t3, t4], 1)) ==&gt; [2, 6]
```</p>
<p>Note: If you are concatenating along a new axis consider using pack.
E.g.</p>
<p><code>python
tf.concat(axis, [tf.expand_dims(t, axis) for t in tensors])</code></p>
<p>can be rewritten as</p>
<p><code>python
tf.pack(tensors, axis=axis)</code></p>
<p>Args:
  values: A list of <code>Tensor</code> objects or a single <code>Tensor</code>.
  axis: 0-D <code>int32</code> <code>Tensor</code>.  Dimension along which to concatenate.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> resulting from concatenation of the input tensors.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.concat_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.concat_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cond">
    <p>def <span class="ident">cond</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cond(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cond</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cond(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cond(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cond</strong></p>
<div class="codehilite"><pre><span></span>Return either fn1() or fn2() based on the boolean predicate `pred`.
</pre></div>


<p><code>fn1</code> and <code>fn2</code> both return lists of output tensors. <code>fn1</code> and <code>fn2</code> must have
the same non-zero number and type of outputs.</p>
<p>Note that the conditional execution applies only to the operations defined in
fn1 and fn2. Consider the following simple program:</p>
<p><code>python
z = tf.mul(a, b)
result = tf.cond(x &lt; y, lambda: tf.add(x, z), lambda: tf.square(y))</code></p>
<p>If x &lt; y, the <code>tf.add</code> operation will be executed and tf.square
operation will not be executed. Since z is needed for at least one
branch of the cond, the tf.mul operation is always executed, unconditionally.
Although this behavior is consistent with the dataflow model of TensorFlow,
it has occasionally surprised some users who expected a lazier semantics.</p>
<p>Args:
  pred: A scalar determining whether to return the result of <code>fn1</code> or <code>fn2</code>.
  fn1: The callable to be performed if pred is true.
  fn2: The callable to be performed if pref is false.
  name: Optional name prefix for the returned tensors.</p>
<p>Returns:
  Tensors returned by the call to either <code>fn1</code> or <code>fn2</code>. If the callables
  return a singleton list, the element is extracted from the list.</p>
<p>Raises:
  TypeError: if <code>fn1</code> or <code>fn2</code> is not callable.
  ValueError: if <code>fn1</code> and <code>fn2</code> do not return the same number of tensors, or
              return tensors of different types.</p>
<p>Example:</p>
<p><code>python
  x = tf.constant(2)
  y = tf.constant(5)
  def f1(): return tf.mul(x, 17)
  def f2(): return tf.add(y, 23)
  r = cond(tf.less(x, y), f1, f2)
  # r is set to f1().
  # Operations in f2 (e.g., tf.add) are not executed.</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cond', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cond" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conj">
    <p>def <span class="ident">conj</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conj(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.conj</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.conj(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conj(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.conj</strong></p>
<div class="codehilite"><pre><span></span>Returns the complex conjugate of a complex number.
</pre></div>


<p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
complex numbers that are the complex conjugate of each element in <code>input</code>. The
complex numbers in <code>input</code> must be of the form \(a + bj\), where <em>a</em> is the
real part and <em>b</em> is the imaginary part.</p>
<p>The complex conjugate returned by this operation is of the form \(a - bj\).</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span># tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.conj(input) ==&gt; [-2.25 - 4.75j, 3.25 - 5.75j]
</pre></div>


<p>If <code>x</code> is real, it is returned unchanged.</p>
<p>Args:
  x: <code>Tensor</code> to conjugate.  Must have numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> that is the conjugate of <code>x</code> (with the same type).</p>
<p>Raises:
  TypeError: If <code>x</code> is not a numeric tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conj', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conj" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.constant">
    <p>def <span class="ident">constant</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.constant(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.constant</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.constant(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.constant(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.constant</strong></p>
<div class="codehilite"><pre><span></span>Creates a constant tensor.
</pre></div>


<p>The resulting tensor is populated with values of type <code>dtype</code>, as
 specified by arguments <code>value</code> and (optionally) <code>shape</code> (see examples
 below).</p>
<p>The argument <code>value</code> can be a constant value, or a list of values of type
 <code>dtype</code>. If <code>value</code> is a list, then the length of the list must be less
 than or equal to the number of elements implied by the <code>shape</code> argument (if
 specified). In the case where the list length is less than the number of
 elements specified by <code>shape</code>, the last element in the list will be used
 to fill the remaining entries.</p>
<p>The argument <code>shape</code> is optional. If present, it specifies the dimensions of
 the resulting tensor. If not present, the shape of <code>value</code> is used.</p>
<p>If the argument <code>dtype</code> is not specified, then the type is inferred from
 the type of <code>value</code>.</p>
<p>For example:</p>
<p>```python
 # Constant 1-D Tensor populated with value list.
 tensor = tf.constant([1, 2, 3, 4, 5, 6, 7]) =&gt; [1 2 3 4 5 6 7]</p>
<p># Constant 2-D tensor populated with scalar value -1.
 tensor = tf.constant(-1.0, shape=[2, 3]) =&gt; [[-1. -1. -1.]
                                              [-1. -1. -1.]]
 ```</p>
<p>Args:
  value:          A constant value (or list) of output type <code>dtype</code>.</p>
<p>dtype:          The type of the elements of the resulting tensor.</p>
<p>shape:          Optional dimensions of resulting tensor.</p>
<p>name:           Optional name for the tensor.</p>
<p>verify_shape:   Boolean that enables verification of a shape of values.</p>
<p>Returns:
  A Constant Tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.constant', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.constant" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.constant_initializer">
    <p>def <span class="ident">constant_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.constant_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.constant_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.constant_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.constant_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.constant_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors with constant values.
</pre></div>


<p>The resulting tensor is populated with values of type <code>dtype</code>, as
specified by arguments <code>value</code> following the desired <code>shape</code> of the
new tensor (see examples below).</p>
<p>The argument <code>value</code> can be a constant value, or a list of values of type
<code>dtype</code>. If <code>value</code> is a list, then the length of the list must be less
than or equal to the number of elements implied by the desired shape of the
tensor. In the case where the total number of elements in <code>value</code> is less
than the number of elements required by the tensor shape, the last element
in <code>value</code> will be used to fill the remaining entries. If the total number of
elements in <code>value</code> is greater than the number of elements required by the
tensor shape, the initializer will raise a <code>ValueError</code>.</p>
<p>Args:
  value: A Python scalar, list of values, or a N-dimensional numpy array. All
    elements of the initialized variable will be set to the corresponding
    value in the <code>value</code> argument.
  dtype: The data type.</p>
<p>Returns:
  An initializer that generates tensors with constant values.</p>
<p>Examples:
  The following example can be rewritten using a numpy.ndarray instead
  of the <code>value</code> list, even reshaped, as shown in the two commented lines
  below the <code>value</code> list initialization.</p>
<p>```python</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import tensorflow as tf</p>
<p>value = [0, 1, 2, 3, 4, 5, 6, 7]</p>
<h1>value = np.array(value)</h1>
<h1>value = value.reshape([2, 4])</h1>
<p>init = tf.constant_initializer(value)</p>
<p>print('fitting shape:')
tf.reset_default_graph()
with tf.Session():
  x = tf.get_variable('x', shape=[2, 4], initializer=init)
  x.initializer.run()
  print(x.eval())</p>
</blockquote>
</blockquote>
</blockquote>
<p>fitting shape:
  [[ 0.  1.  2.  3.]
   [ 4.  5.  6.  7.]]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print('larger shape:')
tf.reset_default_graph()
with tf.Session():
  x = tf.get_variable('x', shape=[3, 4], initializer=init)
  x.initializer.run()
  print(x.eval())</p>
</blockquote>
</blockquote>
</blockquote>
<p>larger shape:
  [[ 0.  1.  2.  3.]
   [ 4.  5.  6.  7.]
   [ 7.  7.  7.  7.]]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print('smaller shape:')
tf.reset_default_graph()
with tf.Session():
  x = tf.get_variable('x', shape=[2, 3], initializer=init)</p>
</blockquote>
</blockquote>
</blockquote>
<p>ValueError: Too many elements provided. Needed at most 6, but received 8
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.constant_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.constant_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.container">
    <p>def <span class="ident">container</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.container(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.container</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.container(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.container(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.container</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.container()` using the default graph.
</pre></div>


<p>Args:
  container_name: The container string to use in the context.</p>
<p>Returns:
  A context manager that specifies the default container to use for newly
  created stateful ops.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.container', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.container" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.control_dependencies">
    <p>def <span class="ident">control_dependencies</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.control_dependencies(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.control_dependencies</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.control_dependencies(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.control_dependencies(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.control_dependencies</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.control_dependencies()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.control_dependencies"><code>Graph.control_dependencies()</code></a>
for more details.</p>
<p>Args:
  control_inputs: A list of <code>Operation</code> or <code>Tensor</code> objects which
    must be executed or computed before running the operations
    defined in the context.  Can also be <code>None</code> to clear the control
    dependencies.</p>
<p>Returns:
 A context manager that specifies control dependencies for all
 operations constructed within the context.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.control_dependencies', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.control_dependencies" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv1d">
    <p>def <span class="ident">conv1d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv1d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv1d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv1d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv1d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv1d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 1-D convolution given 3-D input and filter tensors.
</pre></div>


<p>Given an input tensor of shape
  [batch, in_width, in_channels]
if data_format is "NHWC", or
  [batch, in_channels, in_width]
if data_format is "NCHW",
and a filter / kernel tensor of shape
[filter_width, in_channels, out_channels], this op reshapes
the arguments to pass them to conv2d to perform the equivalent
convolution operation.</p>
<p>Internally, this op reshapes the input tensors and invokes <code>tf.nn.conv2d</code>.
For example, if <code>data_format</code> does not start with "NC", a tensor of shape
  [batch, in_width, in_channels]
is reshaped to
  [batch, 1, in_width, in_channels],
and the filter is reshaped to
  [1, filter_width, in_channels, out_channels].
The result is then reshaped back to
  [batch, out_width, out_channels]
(where out_width is a function of the stride and padding as in conv2d) and
returned to the caller.</p>
<p>Args:
  value: A 3D <code>Tensor</code>.  Must be of type <code>float32</code> or <code>float64</code>.
  filters: A 3D <code>Tensor</code>.  Must have the same type as <code>input</code>.
  stride: An <code>integer</code>.  The number of entries by which
    the filter is moved right at each step.
  padding: 'SAME' or 'VALID'
  use_cudnn_on_gpu: An optional <code>bool</code>.  Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from <code>"NHWC", "NCHW"</code>.  Defaults
    to <code>"NHWC"</code>, the data is stored in the order of
    [batch, in_width, in_channels].  The <code>"NCHW"</code> format stores
    data as [batch, in_channels, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>.  Has the same type as input.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv1d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv1d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer">
    <p>def <span class="ident">conv1d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv1d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv1d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv1d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv1d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv1d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv1d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 1-D convolution given 3-D input and filter tensors.
</pre></div>


<p>Given an input tensor of shape
  [batch, in_width, in_channels]
if data_format is "NHWC", or
  [batch, in_channels, in_width]
if data_format is "NCHW",
and a filter / kernel tensor of shape
[filter_width, in_channels, out_channels], this op reshapes
the arguments to pass them to conv2d to perform the equivalent
convolution operation.</p>
<p>Internally, this op reshapes the input tensors and invokes <code>tf.nn.conv2d</code>.
For example, if <code>data_format</code> does not start with "NC", a tensor of shape
  [batch, in_width, in_channels]
is reshaped to
  [batch, 1, in_width, in_channels],
and the filter is reshaped to
  [1, filter_width, in_channels, out_channels].
The result is then reshaped back to
  [batch, out_width, out_channels]
(where out_width is a function of the stride and padding as in conv2d) and
returned to the caller.</p>
<p>Args:
  value: A 3D <code>Tensor</code>.  Must be of type <code>float32</code> or <code>float64</code>.
  filters: A 3D <code>Tensor</code>.  Must have the same type as <code>input</code>.
  stride: An <code>integer</code>.  The number of entries by which
    the filter is moved right at each step.
  padding: 'SAME' or 'VALID'
  use_cudnn_on_gpu: An optional <code>bool</code>.  Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from <code>"NHWC", "NCHW"</code>.  Defaults
    to <code>"NHWC"</code>, the data is stored in the order of
    [batch, in_width, in_channels].  The <code>"NCHW"</code> format stores
    data as [batch, in_channels, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>.  Has the same type as input.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv1d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv1d_layer">
    <p>def <span class="ident">conv1d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv1d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv1d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv1d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv1d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv1d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv1d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 1-D convolution given 3-D input and filter tensors.
</pre></div>


<p>Given an input tensor of shape
  [batch, in_width, in_channels]
if data_format is "NHWC", or
  [batch, in_channels, in_width]
if data_format is "NCHW",
and a filter / kernel tensor of shape
[filter_width, in_channels, out_channels], this op reshapes
the arguments to pass them to conv2d to perform the equivalent
convolution operation.</p>
<p>Internally, this op reshapes the input tensors and invokes <code>tf.nn.conv2d</code>.
For example, if <code>data_format</code> does not start with "NC", a tensor of shape
  [batch, in_width, in_channels]
is reshaped to
  [batch, 1, in_width, in_channels],
and the filter is reshaped to
  [1, filter_width, in_channels, out_channels].
The result is then reshaped back to
  [batch, out_width, out_channels]
(where out_width is a function of the stride and padding as in conv2d) and
returned to the caller.</p>
<p>Args:
  value: A 3D <code>Tensor</code>.  Must be of type <code>float32</code> or <code>float64</code>.
  filters: A 3D <code>Tensor</code>.  Must have the same type as <code>input</code>.
  stride: An <code>integer</code>.  The number of entries by which
    the filter is moved right at each step.
  padding: 'SAME' or 'VALID'
  use_cudnn_on_gpu: An optional <code>bool</code>.  Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from <code>"NHWC", "NCHW"</code>.  Defaults
    to <code>"NHWC"</code>, the data is stored in the order of
    [batch, in_width, in_channels].  The <code>"NCHW"</code> format stores
    data as [batch, in_channels, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>.  Has the same type as input.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv1d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv1d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d">
    <p>def <span class="ident">conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>, this op
performs the following:</p>
<ol>
<li>Flattens the filter to a 2-D matrix with shape
   <code>[filter_height * filter_width * in_channels, output_channels]</code>.</li>
<li>Extracts image patches from the input tensor to form a <em>virtual</em>
   tensor of shape <code>[batch, out_height, out_width,
   filter_height * filter_width * in_channels]</code>.</li>
<li>For each patch, right-multiplies the filter matrix and the image patch
   vector.</li>
</ol>
<p>In detail, with the default NHWC format,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter">
    <p>def <span class="ident">conv2d_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer">
    <p>def <span class="ident">conv2d_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer">
    <p>def <span class="ident">conv2d_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_input">
    <p>def <span class="ident">conv2d_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer">
    <p>def <span class="ident">conv2d_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer">
    <p>def <span class="ident">conv2d_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution. Must be in the same order as the dimension specified with
    format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer">
    <p>def <span class="ident">conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>, this op
performs the following:</p>
<ol>
<li>Flattens the filter to a 2-D matrix with shape
   <code>[filter_height * filter_width * in_channels, output_channels]</code>.</li>
<li>Extracts image patches from the input tensor to form a <em>virtual</em>
   tensor of shape <code>[batch, out_height, out_width,
   filter_height * filter_width * in_channels]</code>.</li>
<li>For each patch, right-multiplies the filter matrix and the image patch
   vector.</li>
</ol>
<p>In detail, with the default NHWC format,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_layer">
    <p>def <span class="ident">conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>, this op
performs the following:</p>
<ol>
<li>Flattens the filter to a 2-D matrix with shape
   <code>[filter_height * filter_width * in_channels, output_channels]</code>.</li>
<li>Extracts image patches from the input tensor to form a <em>virtual</em>
   tensor of shape <code>[batch, out_height, out_width,
   filter_height * filter_width * in_channels]</code>.</li>
<li>For each patch, right-multiplies the filter matrix and the image patch
   vector.</li>
</ol>
<p>In detail, with the default NHWC format,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  use_cudnn_on_gpu: An optional <code>bool</code>. Defaults to <code>True</code>.
  data_format: An optional <code>string</code> from: <code>"NHWC", "NCHW"</code>. Defaults to <code>"NHWC"</code>.
    Specify the data format of the input and output data. With the
    default format "NHWC", the data is stored in the order of:
        [batch, in_height, in_width, in_channels].
    Alternatively, the format could be "NCHW", the data storage order of:
        [batch, in_channels, in_height, in_width].
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_transpose">
    <p>def <span class="ident">conv2d_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv2d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv2d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv2d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv2d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv2d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, height, width, in_channels]</code> for <code>NHWC</code> data format or
    <code>[batch, in_channels, height, width]</code> for <code>NCHW</code> data format.
  filter: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer">
    <p>def <span class="ident">conv2d_transpose_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_transpose_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_transpose_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_transpose`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv2d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv2d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, height, width, in_channels]</code> for <code>NHWC</code> data format or
    <code>[batch, in_channels, height, width]</code> for <code>NCHW</code> data format.
  filter: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer">
    <p>def <span class="ident">conv2d_transpose_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_transpose_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv2d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv2d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv2d_transpose_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv2d_transpose`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv2d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv2d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv2d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 4-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, height, width, in_channels]</code> for <code>NHWC</code> data format or
    <code>[batch, in_channels, height, width]</code> for <code>NCHW</code> data format.
  filter: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv2d_transpose_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d">
    <p>def <span class="ident">conv3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv3d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 3-D convolution given 5-D `input` and `filter` tensors.
</pre></div>


<p>In signal processing, cross-correlation is a measure of similarity of
two waveforms as a function of a time-lag applied to one of them. This
is also known as a sliding dot product or sliding inner-product.</p>
<p>Our Conv3D implements a form of cross-correlation.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[filter_depth, filter_height, filter_width, in_channels,
    out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter">
    <p>def <span class="ident">conv3d_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv3d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv3d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv3d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer">
    <p>def <span class="ident">conv3d_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2">
    <p>def <span class="ident">conv3d_backprop_filter_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv3d_backprop_filter_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv3d_backprop_filter_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv3d_backprop_filter_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 5-D
    <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
    tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_filter_v2_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_filter_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_filter_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter_v2`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_filter_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 5-D
    <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
    tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer">
    <p>def <span class="ident">conv3d_backprop_filter_v2_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_v2_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_filter_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_filter_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_filter_v2_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_filter_v2`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_filter_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 5-D
    <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
    tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_filter_v2_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input">
    <p>def <span class="ident">conv3d_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv3d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv3d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv3d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer">
    <p>def <span class="ident">conv3d_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2">
    <p>def <span class="ident">conv3d_backprop_input_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv3d_backprop_input_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv3d_backprop_input_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv3d_backprop_input_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>input</code>,
    where <code>input</code> is a 5-D
    <code>[batch, depth, rows, cols, in_channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer">
    <p>def <span class="ident">conv3d_backprop_input_v2_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_v2_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_input_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_input_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_v2_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input_v2`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_input_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>input</code>,
    where <code>input</code> is a 5-D
    <code>[batch, depth, rows, cols, in_channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer">
    <p>def <span class="ident">conv3d_backprop_input_v2_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_v2_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_backprop_input_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_backprop_input_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_backprop_input_v2_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_backprop_input_v2`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_backprop_input_v2</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of 3-D convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>input</code>,
    where <code>input</code> is a 5-D
    <code>[batch, depth, rows, cols, in_channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
    <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
    out_channels]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_backprop_input_v2_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer">
    <p>def <span class="ident">conv3d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 3-D convolution given 5-D `input` and `filter` tensors.
</pre></div>


<p>In signal processing, cross-correlation is a measure of similarity of
two waveforms as a function of a time-lag applied to one of them. This
is also known as a sliding dot product or sliding inner-product.</p>
<p>Our Conv3D implements a form of cross-correlation.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[filter_depth, filter_height, filter_width, in_channels,
    out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_layer">
    <p>def <span class="ident">conv3d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 3-D convolution given 5-D `input` and `filter` tensors.
</pre></div>


<p>In signal processing, cross-correlation is a measure of similarity of
two waveforms as a function of a time-lag applied to one of them. This
is also known as a sliding dot product or sliding inner-product.</p>
<p>Our Conv3D implements a form of cross-correlation.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Shape <code>[filter_depth, filter_height, filter_width, in_channels,
    out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_transpose">
    <p>def <span class="ident">conv3d_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconv3d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconv3d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconv3d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv3d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv3d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 5-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, depth, height, width, in_channels]</code>.
  filter: A 5-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[depth, height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer">
    <p>def <span class="ident">conv3d_transpose_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_transpose_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_transpose_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_transpose`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv3d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv3d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 5-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, depth, height, width, in_channels]</code>.
  filter: A 5-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[depth, height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer">
    <p>def <span class="ident">conv3d_transpose_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_transpose_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.conv3d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.conv3d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.conv3d_transpose_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.conv3d_transpose`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.conv3d_transpose</strong></p>
<div class="codehilite"><pre><span></span>The transpose of `conv3d`.
</pre></div>


<p>This operation is sometimes called "deconvolution" after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional
Networks</a>, but is
actually the transpose (gradient) of <code>conv3d</code> rather than an actual
deconvolution.</p>
<p>Args:
  value: A 5-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, depth, height, width, in_channels]</code>.
  filter: A 5-D <code>Tensor</code> with the same type as <code>value</code> and shape
    <code>[depth, height, width, output_channels, in_channels]</code>.  <code>filter</code>'s
    <code>in_channels</code> dimension must match that of <code>value</code>.
  output_shape: A 1-D <code>Tensor</code> representing the output shape of the
    deconvolution op.
  strides: A list of ints. The stride of the sliding window for each
    dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  name: Optional name for the returned tensor.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>value</code>.</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code>'s shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.conv3d_transpose_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convert_to_tensor">
    <p>def <span class="ident">convert_to_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convert_to_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.convert_to_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.convert_to_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convert_to_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.convert_to_tensor</strong></p>
<div class="codehilite"><pre><span></span>Converts the given `value` to a `Tensor`.
</pre></div>


<p>This function converts Python objects of various types to <code>Tensor</code>
objects. It accepts <code>Tensor</code> objects, numpy arrays, Python lists,
and Python scalars. For example:</p>
<p>```python
import numpy as np</p>
<p>def my_func(arg):
  arg = tf.convert_to_tensor(arg, dtype=tf.float32)
  return tf.matmul(arg, arg) + arg</p>
<h1>The following calls are equivalent.</h1>
<p>value_1 = my_func(tf.constant([[1.0, 2.0], [3.0, 4.0]]))
value_2 = my_func([[1.0, 2.0], [3.0, 4.0]])
value_3 = my_func(np.array([[1.0, 2.0], [3.0, 4.0]], dtype=np.float32))
```</p>
<p>This function can be useful when composing a new operation in Python
(such as <code>my_func</code> in the example above). All standard Python op
constructors apply this function to each of their Tensor-valued
inputs, which allows those ops to accept numpy arrays, Python lists,
and scalars in addition to <code>Tensor</code> objects.</p>
<p>Args:
  value: An object whose type has a registered <code>Tensor</code> conversion function.
  dtype: Optional element type for the returned tensor. If missing, the
    type is inferred from the type of <code>value</code>.
  name: Optional name to use if a new <code>Tensor</code> is created.
  as_ref: True if we want the result as a ref tensor. Only used if a new
    <code>Tensor</code> is created.
  preferred_dtype: Optional element type for the returned tensor,
    used when dtype is None. In some cases, a caller may not have a
    dtype in mind when converting to a tensor, so preferred_dtype
    can be used as a soft preference.  If the conversion to
    <code>preferred_dtype</code> is not possible, this argument has no effect.</p>
<p>Returns:
  A <code>Tensor</code> based on <code>value</code>.</p>
<p>Raises:
  TypeError: If no conversion function is registered for <code>value</code>.
  RuntimeError: If a registered conversion function returns an invalid value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convert_to_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convert_to_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices">
    <p>def <span class="ident">convert_to_tensor_or_indexed_slices</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convert_to_tensor_or_indexed_slices(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.convert_to_tensor_or_indexed_slices</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.convert_to_tensor_or_indexed_slices(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convert_to_tensor_or_indexed_slices(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.convert_to_tensor_or_indexed_slices</strong></p>
<div class="codehilite"><pre><span></span>Converts the given object to a `Tensor` or an `IndexedSlices`.
</pre></div>


<p>If <code>value</code> is an <code>IndexedSlices</code> or <code>SparseTensor</code> it is returned
unmodified. Otherwise, it is converted to a <code>Tensor</code> using
<code>convert_to_tensor()</code>.</p>
<p>Args:
  value: An <code>IndexedSlices</code>, <code>SparseTensor</code>, or an object that can be consumed
    by <code>convert_to_tensor()</code>.
  dtype: (Optional.) The required <code>DType</code> of the returned <code>Tensor</code> or
    <code>IndexedSlices</code>.
  name: (Optional.) A name to use if a new <code>Tensor</code> is created.
  as_ref: True if the caller wants the results as ref tensors.</p>
<p>Returns:
  An <code>Tensor</code>, <code>IndexedSlices</code>, or <code>SparseTensor</code> based on <code>value</code>.</p>
<p>Raises:
  ValueError: If <code>dtype</code> does not match the element type of <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convert_to_tensor_or_indexed_slices" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convolution">
    <p>def <span class="ident">convolution</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnconvolution</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnconvolution(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnconvolution</strong></p>
<div class="codehilite"><pre><span></span>Computes sums of N-D convolutions (actually cross-correlation).
</pre></div>


<p>This also supports either output striding via the optional <code>strides</code> parameter
or atrous convolution (also known as convolution with holes or dilated
convolution, based on the French word "trous" meaning holes in English) via
the optional <code>dilation_rate</code> parameter.  Currently, however, output striding
is not supported for atrous convolutions.</p>
<p>Specifically, in the case that <code>data_format</code> does not start with "NC", given
a rank (N+2) <code>input</code> Tensor of shape</p>
<p>[num_batches,
   input_spatial_shape[0],
   ...,
   input_spatial_shape[N-1],
   num_input_channels],</p>
<p>a rank (N+2) <code>filter</code> Tensor of shape</p>
<p>[spatial_filter_shape[0],
   ...,
   spatial_filter_shape[N-1],
   num_input_channels,
   num_output_channels],</p>
<p>an optional <code>dilation_rate</code> tensor of shape [N] (defaulting to [1]<em>N)
specifying the filter upsampling/input downsampling rate, and an optional list
of N <code>strides</code> (defaulting [1]</em>N), this computes for each N-D spatial output
position (x[0], ..., x[N-1]):</p>
<p>output[b, x[0], ..., x[N-1], k] =</p>
<div class="codehilite"><pre><span></span>  sum_{z[0], ..., z[N-1], q}

      filter[z[0], ..., z[N-1], q, k] *
      padded_input[b,
                   x[0]*strides[0] + dilation_rate[0]*z[0],
                   ...,
                   x[N-1]*strides[N-1] + dilation_rate[N-1]*z[N-1],
                   q]
</pre></div>


<p>where <code>padded_input</code> is obtained by zero padding the input using an effective
spatial filter shape of <code>(spatial_filter_shape-1) * dilation_rate + 1</code> and
output striding <code>strides</code> as described in the
<a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.</p>
<p>In the case that <code>data_format</code> does start with <code>"NC"</code>, the <code>input</code> and output
(but not the <code>filter</code>) are simply transposed as follows:</p>
<p>convolution(input, data_format, <strong>kwargs) =
    tf.transpose(convolution(tf.transpose(input, [0] + range(2,N+2) + [1]),
                             </strong>kwargs),
                 [0, N+1] + range(1, N+1))</p>
<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p>Args:
  input: An N-D <code>Tensor</code> of type <code>T</code>, of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  filter: An N-D <code>Tensor</code> with the same type as <code>input</code> and shape
    <code>spatial_filter_shape + [in_channels, out_channels]</code>.
  padding: A string, either <code>"VALID"</code> or <code>"SAME"</code>. The padding algorithm.
  strides: Optional.  Sequence of N ints &gt;= 1.  Specifies the output stride.
    Defaults to [1]*N.  If any value of strides is &gt; 1, then all values of
    dilation_rate must be 1.
  dilation_rate: Optional.  Sequence of N ints &gt;= 1.  Specifies the filter
    upsampling/input downsampling rate.  In the literature, the same parameter
    is sometimes called <code>input stride</code> or <code>dilation</code>.  The effective filter
    size used for the convolution will be <code>spatial_filter_shape +
    (spatial_filter_shape - 1) * (rate - 1)</code>, obtained by inserting
    (dilation_rate[i]-1) zeros between consecutive elements of the original
    filter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,
    then all values of strides must be 1.
  name: Optional name for the returned tensor.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, the valid value is "NDHWC".</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>input</code> of shape</p>
<div class="codehilite"><pre><span></span>  `[batch_size] + output_spatial_shape + [out_channels]`
</pre></div>


<p>if data_format is None or does not start with "NC", or</p>
<div class="codehilite"><pre><span></span>  `[batch_size, out_channels] + output_spatial_shape`
</pre></div>


<p>if data_format starts with "NC",
  where <code>output_spatial_shape</code> depends on the value of <code>padding</code>.</p>
<p>If padding == "SAME":
    output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</p>
<p>If padding == "VALID":
    output_spatial_shape[i] =
      ceil((input_spatial_shape[i] -
            (spatial_filter_shape[i]-1) * dilation_rate[i])
           / strides[i]).</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code> shape, if padding
    is other than <code>"VALID"</code> or <code>"SAME"</code>, or if data_format is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convolution', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convolution" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convolution2d">
    <p>def <span class="ident">convolution2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconvolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconvolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconvolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds an N-D convolution followed by an optional batch_norm layer.
</pre></div>


<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p><code>convolution</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved (actually cross-correlated) with the
<code>inputs</code> to produce a <code>Tensor</code> of activations. If a <code>normalizer_fn</code> is
provided (such as <code>batch_norm</code>), it is then applied. Otherwise, if
<code>normalizer_fn</code> is None and a <code>biases_initializer</code> is provided then a <code>biases</code>
variable would be created and added the activations. Finally, if
<code>activation_fn</code> is not <code>None</code>, it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride/dilation rate equal to <code>rate</code>
if a value &gt; 1 for any dimension of <code>rate</code> is specified.  In this case
<code>stride</code> values != 1 are not supported.</p>
<p>Args:
  inputs: a Tensor of rank N+2 of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  num_outputs: integer, the number of output filters.
  kernel_size: a sequence of N positive integers specifying the spatial
    dimensions of of the filters.  Can be a single integer to specify the same
    value for all spatial dimensions.
  stride: a sequence of N positive integers specifying the stride at which to
    compute output.  Can be a single integer to specify the same value for all
    spatial dimensions.  Specifying any <code>stride</code> value != 1 is incompatible
    with specifying any <code>rate</code> value != 1.
  padding: one of <code>"VALID"</code> or <code>"SAME"</code>.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, currently the only valid value is "NDHWC".
  rate: a sequence of N positive integers specifying the dilation rate to use
    for a'trous convolution.  Can be a single integer to specify the same
    value for all spatial dimensions.  Specifying any <code>rate</code> value != 1 is
    incompatible with specifying any <code>stride</code> value != 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.
  ValueError: both 'rate' and <code>stride</code> are not uniformly 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convolution2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convolution2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convolution_conv2d_layer">
    <p>def <span class="ident">convolution_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.convolution</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.convolution(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.convolution`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.convolution</strong></p>
<div class="codehilite"><pre><span></span>Computes sums of N-D convolutions (actually cross-correlation).
</pre></div>


<p>This also supports either output striding via the optional <code>strides</code> parameter
or atrous convolution (also known as convolution with holes or dilated
convolution, based on the French word "trous" meaning holes in English) via
the optional <code>dilation_rate</code> parameter.  Currently, however, output striding
is not supported for atrous convolutions.</p>
<p>Specifically, in the case that <code>data_format</code> does not start with "NC", given
a rank (N+2) <code>input</code> Tensor of shape</p>
<p>[num_batches,
   input_spatial_shape[0],
   ...,
   input_spatial_shape[N-1],
   num_input_channels],</p>
<p>a rank (N+2) <code>filter</code> Tensor of shape</p>
<p>[spatial_filter_shape[0],
   ...,
   spatial_filter_shape[N-1],
   num_input_channels,
   num_output_channels],</p>
<p>an optional <code>dilation_rate</code> tensor of shape [N] (defaulting to [1]<em>N)
specifying the filter upsampling/input downsampling rate, and an optional list
of N <code>strides</code> (defaulting [1]</em>N), this computes for each N-D spatial output
position (x[0], ..., x[N-1]):</p>
<p>output[b, x[0], ..., x[N-1], k] =</p>
<div class="codehilite"><pre><span></span>  sum_{z[0], ..., z[N-1], q}

      filter[z[0], ..., z[N-1], q, k] *
      padded_input[b,
                   x[0]*strides[0] + dilation_rate[0]*z[0],
                   ...,
                   x[N-1]*strides[N-1] + dilation_rate[N-1]*z[N-1],
                   q]
</pre></div>


<p>where <code>padded_input</code> is obtained by zero padding the input using an effective
spatial filter shape of <code>(spatial_filter_shape-1) * dilation_rate + 1</code> and
output striding <code>strides</code> as described in the
<a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.</p>
<p>In the case that <code>data_format</code> does start with <code>"NC"</code>, the <code>input</code> and output
(but not the <code>filter</code>) are simply transposed as follows:</p>
<p>convolution(input, data_format, <strong>kwargs) =
    tf.transpose(convolution(tf.transpose(input, [0] + range(2,N+2) + [1]),
                             </strong>kwargs),
                 [0, N+1] + range(1, N+1))</p>
<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p>Args:
  input: An N-D <code>Tensor</code> of type <code>T</code>, of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  filter: An N-D <code>Tensor</code> with the same type as <code>input</code> and shape
    <code>spatial_filter_shape + [in_channels, out_channels]</code>.
  padding: A string, either <code>"VALID"</code> or <code>"SAME"</code>. The padding algorithm.
  strides: Optional.  Sequence of N ints &gt;= 1.  Specifies the output stride.
    Defaults to [1]*N.  If any value of strides is &gt; 1, then all values of
    dilation_rate must be 1.
  dilation_rate: Optional.  Sequence of N ints &gt;= 1.  Specifies the filter
    upsampling/input downsampling rate.  In the literature, the same parameter
    is sometimes called <code>input stride</code> or <code>dilation</code>.  The effective filter
    size used for the convolution will be <code>spatial_filter_shape +
    (spatial_filter_shape - 1) * (rate - 1)</code>, obtained by inserting
    (dilation_rate[i]-1) zeros between consecutive elements of the original
    filter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,
    then all values of strides must be 1.
  name: Optional name for the returned tensor.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, the valid value is "NDHWC".</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>input</code> of shape</p>
<div class="codehilite"><pre><span></span>  `[batch_size] + output_spatial_shape + [out_channels]`
</pre></div>


<p>if data_format is None or does not start with "NC", or</p>
<div class="codehilite"><pre><span></span>  `[batch_size, out_channels] + output_spatial_shape`
</pre></div>


<p>if data_format starts with "NC",
  where <code>output_spatial_shape</code> depends on the value of <code>padding</code>.</p>
<p>If padding == "SAME":
    output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</p>
<p>If padding == "VALID":
    output_spatial_shape[i] =
      ceil((input_spatial_shape[i] -
            (spatial_filter_shape[i]-1) * dilation_rate[i])
           / strides[i]).</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code> shape, if padding
    is other than <code>"VALID"</code> or <code>"SAME"</code>, or if data_format is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convolution_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convolution_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.convolution_layer">
    <p>def <span class="ident">convolution_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.convolution</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.convolution(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.convolution_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.convolution`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.convolution</strong></p>
<div class="codehilite"><pre><span></span>Computes sums of N-D convolutions (actually cross-correlation).
</pre></div>


<p>This also supports either output striding via the optional <code>strides</code> parameter
or atrous convolution (also known as convolution with holes or dilated
convolution, based on the French word "trous" meaning holes in English) via
the optional <code>dilation_rate</code> parameter.  Currently, however, output striding
is not supported for atrous convolutions.</p>
<p>Specifically, in the case that <code>data_format</code> does not start with "NC", given
a rank (N+2) <code>input</code> Tensor of shape</p>
<p>[num_batches,
   input_spatial_shape[0],
   ...,
   input_spatial_shape[N-1],
   num_input_channels],</p>
<p>a rank (N+2) <code>filter</code> Tensor of shape</p>
<p>[spatial_filter_shape[0],
   ...,
   spatial_filter_shape[N-1],
   num_input_channels,
   num_output_channels],</p>
<p>an optional <code>dilation_rate</code> tensor of shape [N] (defaulting to [1]<em>N)
specifying the filter upsampling/input downsampling rate, and an optional list
of N <code>strides</code> (defaulting [1]</em>N), this computes for each N-D spatial output
position (x[0], ..., x[N-1]):</p>
<p>output[b, x[0], ..., x[N-1], k] =</p>
<div class="codehilite"><pre><span></span>  sum_{z[0], ..., z[N-1], q}

      filter[z[0], ..., z[N-1], q, k] *
      padded_input[b,
                   x[0]*strides[0] + dilation_rate[0]*z[0],
                   ...,
                   x[N-1]*strides[N-1] + dilation_rate[N-1]*z[N-1],
                   q]
</pre></div>


<p>where <code>padded_input</code> is obtained by zero padding the input using an effective
spatial filter shape of <code>(spatial_filter_shape-1) * dilation_rate + 1</code> and
output striding <code>strides</code> as described in the
<a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.</p>
<p>In the case that <code>data_format</code> does start with <code>"NC"</code>, the <code>input</code> and output
(but not the <code>filter</code>) are simply transposed as follows:</p>
<p>convolution(input, data_format, <strong>kwargs) =
    tf.transpose(convolution(tf.transpose(input, [0] + range(2,N+2) + [1]),
                             </strong>kwargs),
                 [0, N+1] + range(1, N+1))</p>
<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p>Args:
  input: An N-D <code>Tensor</code> of type <code>T</code>, of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  filter: An N-D <code>Tensor</code> with the same type as <code>input</code> and shape
    <code>spatial_filter_shape + [in_channels, out_channels]</code>.
  padding: A string, either <code>"VALID"</code> or <code>"SAME"</code>. The padding algorithm.
  strides: Optional.  Sequence of N ints &gt;= 1.  Specifies the output stride.
    Defaults to [1]*N.  If any value of strides is &gt; 1, then all values of
    dilation_rate must be 1.
  dilation_rate: Optional.  Sequence of N ints &gt;= 1.  Specifies the filter
    upsampling/input downsampling rate.  In the literature, the same parameter
    is sometimes called <code>input stride</code> or <code>dilation</code>.  The effective filter
    size used for the convolution will be <code>spatial_filter_shape +
    (spatial_filter_shape - 1) * (rate - 1)</code>, obtained by inserting
    (dilation_rate[i]-1) zeros between consecutive elements of the original
    filter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,
    then all values of strides must be 1.
  name: Optional name for the returned tensor.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, the valid value is "NDHWC".</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>input</code> of shape</p>
<div class="codehilite"><pre><span></span>  `[batch_size] + output_spatial_shape + [out_channels]`
</pre></div>


<p>if data_format is None or does not start with "NC", or</p>
<div class="codehilite"><pre><span></span>  `[batch_size, out_channels] + output_spatial_shape`
</pre></div>


<p>if data_format starts with "NC",
  where <code>output_spatial_shape</code> depends on the value of <code>padding</code>.</p>
<p>If padding == "SAME":
    output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</p>
<p>If padding == "VALID":
    output_spatial_shape[i] =
      ceil((input_spatial_shape[i] -
            (spatial_filter_shape[i]-1) * dilation_rate[i])
           / strides[i]).</p>
<p>Raises:
  ValueError: If input/output depth does not match <code>filter</code> shape, if padding
    is other than <code>"VALID"</code> or <code>"SAME"</code>, or if data_format is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.convolution_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.convolution_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cos">
    <p>def <span class="ident">cos</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cos(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cos</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cos(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cos(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cos</strong></p>
<div class="codehilite"><pre><span></span>Computes cos of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cos', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cos" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.count_nonzero">
    <p>def <span class="ident">count_nonzero</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.count_nonzero(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.count_nonzero</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.count_nonzero(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.count_nonzero(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.count_nonzero</strong></p>
<div class="codehilite"><pre><span></span>Computes number of nonzero elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p><strong>NOTE</strong> Floating point comparison to zero is done by exact floating point
equality check.  Small values are <strong>not</strong> rounded to zero for purposes of
the nonzero check.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[0, 1, 0]</h1>
<h1>[1, 1, 0]]</h1>
<p>tf.count_nonzero(x) ==&gt; 3
tf.count_nonzero(x, 0) ==&gt; [1, 2, 0]
tf.count_nonzero(x, 1) ==&gt; [1, 2]
tf.count_nonzero(x, 1, keep_dims=True) ==&gt; [[1], [2]]
tf.count_nonzero(x, [0, 1]) ==&gt; 3
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should be of numeric type, or <code>bool</code>.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  dtype: The output dtype; defaults to <code>tf.int64</code>.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor (number of nonzero values).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.count_nonzero', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.count_nonzero" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.count_up_to">
    <p>def <span class="ident">count_up_to</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.count_up_to(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.count_up_to</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.count_up_to(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.count_up_to(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.count_up_to</strong></p>
<div class="codehilite"><pre><span></span>Increments &#39;ref&#39; until it reaches &#39;limit&#39;.
</pre></div>


<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Should be from a scalar <code>Variable</code> node.
  limit: An <code>int</code>.
    If incrementing ref would bring it above limit, instead generates an
    'OutOfRange' error.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>ref</code>.
  A copy of the input before increment. If nothing else modifies the
  input, the values produced will all be distinct.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.count_up_to', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.count_up_to" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.create_partitioned_variables">
    <p>def <span class="ident">create_partitioned_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.create_partitioned_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.create_partitioned_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.create_partitioned_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.create_partitioned_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.create_partitioned_variables</strong></p>
<div class="codehilite"><pre><span></span>Create a list of partitioned variables according to the given `slicing`.
</pre></div>


<p>Currently only one dimension of the full variable can be sliced, and the
full variable can be reconstructed by the concatenation of the returned
list along that dimension.</p>
<p>Args:
  shape: List of integers.  The shape of the full variable.
  slicing: List of integers.  How to partition the variable.
    Must be of the same length as <code>shape</code>.  Each value
    indicate how many slices to create in the corresponding
    dimension.  Presently only one of the values can be more than 1;
    that is, the variable can only be sliced along one dimension.</p>
<div class="codehilite"><pre><span></span>For convenience, The requested number of partitions does not have to
divide the corresponding dimension evenly.  If it does not, the
shapes of the partitions are incremented by 1 starting from partition
0 until all slack is absorbed.  The adjustment rules may change in the
future, but as you can save/restore these variables with different
slicing specifications this should not be a problem.
</pre></div>


<p>initializer: A <code>Tensor</code> of shape <code>shape</code> or a variable initializer
    function.  If a function, it will be called once for each slice,
    passing the shape and data type of the slice as parameters.  The
    function must return a tensor with the same shape as the slice.
  dtype: Type of the variables. Ignored if <code>initializer</code> is a <code>Tensor</code>.
  trainable: If True also add all the variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code>.
  collections: List of graph collections keys to add the variables to.
    Defaults to <code>[GraphKeys.GLOBAL_VARIABLES]</code>.
  name: Optional name for the full variable.  Defaults to
    <code>"PartitionedVariable"</code> and gets uniquified automatically.
  reuse: Boolean or <code>None</code>; if <code>True</code> and name is set, it would reuse
    previously created variables. if <code>False</code> it will create new variables.
    if <code>None</code>, it would inherit the parent scope reuse.</p>
<p>Returns:
  A list of Variables corresponding to the slicing.</p>
<p>Raises:
  ValueError: If any of the arguments is malformed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.create_partitioned_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.create_partitioned_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.crelu">
    <p>def <span class="ident">crelu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.crelu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nncrelu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nncrelu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.crelu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nncrelu</strong></p>
<div class="codehilite"><pre><span></span>Computes Concatenated ReLU.
</pre></div>


<p>Concatenates a ReLU which selects only the positive part of the activation
with a ReLU which selects only the <em>negative</em> part of the activation.
Note that as a result this non-linearity doubles the depth of the activations.
Source: https://arxiv.org/abs/1603.05201</p>
<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.crelu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.crelu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer">
    <p>def <span class="ident">crelu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.crelu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.crelu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.crelu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.crelu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.crelu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.crelu</strong></p>
<div class="codehilite"><pre><span></span>Computes Concatenated ReLU.
</pre></div>


<p>Concatenates a ReLU which selects only the positive part of the activation
with a ReLU which selects only the <em>negative</em> part of the activation.
Note that as a result this non-linearity doubles the depth of the activations.
Source: https://arxiv.org/abs/1603.05201</p>
<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.crelu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.crelu_layer">
    <p>def <span class="ident">crelu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.crelu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.crelu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.crelu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.crelu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.crelu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.crelu</strong></p>
<div class="codehilite"><pre><span></span>Computes Concatenated ReLU.
</pre></div>


<p>Concatenates a ReLU which selects only the positive part of the activation
with a ReLU which selects only the <em>negative</em> part of the activation.
Note that as a result this non-linearity doubles the depth of the activations.
Source: https://arxiv.org/abs/1603.05201</p>
<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.crelu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.crelu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cross">
    <p>def <span class="ident">cross</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cross(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cross</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cross(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cross(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cross</strong></p>
<div class="codehilite"><pre><span></span>Compute the pairwise cross product.
</pre></div>


<p><code>a</code> and <code>b</code> must be the same shape; they can either be simple 3-element vectors,
or any shape where the innermost dimension is 3. In the latter case, each pair
of corresponding 3-element vectors is cross-multiplied independently.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    A tensor containing 3-element vectors.
  b: A <code>Tensor</code>. Must have the same type as <code>a</code>.
    Another tensor, of same type and shape as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.
  Pairwise cross product of the vectors in <code>a</code> and <code>b</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cross', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cross" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder">
    <p>def <span class="ident">ctc_beam_search_decoder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_beam_search_decoder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnctc_beam_search_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnctc_beam_search_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_beam_search_decoder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnctc_beam_search_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs beam search decoding on the logits given in input.
</pre></div>


<p><strong>Note</strong> The <code>ctc_greedy_decoder</code> is a special case of the
<code>ctc_beam_search_decoder</code> with <code>top_paths=1</code> (but that decoder is faster
for this special case).</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in the output beams.
This means that if consecutive entries in a beam are the same,
only the first of these is emitted.  That is, when the top path
is <code>A B B B B</code>, the return value is:</p>
<ul>
<li><code>A B</code> if <code>merge_repeated = True</code>.</li>
<li><code>A B B B B</code> if <code>merge_repeated = False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>, size
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  beam_width: An int scalar &gt;= 0 (beam search beam width).
  top_paths: An int scalar &gt;= 0, &lt;= beam_width (controls output size).
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A list of length top_paths, where <code>decoded[j]</code>
    is a <code>SparseTensor</code> containing the decoded outputs:
    <code>decoded[j].indices</code>: Indices matrix <code>(total_decoded_outputs[j] x 2)</code>
      The rows store: [batch, time].
    <code>decoded[j].values</code>: Values vector, size <code>(total_decoded_outputs[j])</code>.
      The vector stores the decoded classes for beam j.
    <code>decoded[j].shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length[j]]</code>.
  log_probability: A <code>float</code> matrix <code>(batch_size x top_paths)</code> containing
      sequence log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer">
    <p>def <span class="ident">ctc_beam_search_decoder_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_beam_search_decoder_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.ctc_beam_search_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.ctc_beam_search_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_beam_search_decoder_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_beam_search_decoder`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.ctc_beam_search_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs beam search decoding on the logits given in input.
</pre></div>


<p><strong>Note</strong> The <code>ctc_greedy_decoder</code> is a special case of the
<code>ctc_beam_search_decoder</code> with <code>top_paths=1</code> (but that decoder is faster
for this special case).</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in the output beams.
This means that if consecutive entries in a beam are the same,
only the first of these is emitted.  That is, when the top path
is <code>A B B B B</code>, the return value is:</p>
<ul>
<li><code>A B</code> if <code>merge_repeated = True</code>.</li>
<li><code>A B B B B</code> if <code>merge_repeated = False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>, size
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  beam_width: An int scalar &gt;= 0 (beam search beam width).
  top_paths: An int scalar &gt;= 0, &lt;= beam_width (controls output size).
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A list of length top_paths, where <code>decoded[j]</code>
    is a <code>SparseTensor</code> containing the decoded outputs:
    <code>decoded[j].indices</code>: Indices matrix <code>(total_decoded_outputs[j] x 2)</code>
      The rows store: [batch, time].
    <code>decoded[j].values</code>: Values vector, size <code>(total_decoded_outputs[j])</code>.
      The vector stores the decoded classes for beam j.
    <code>decoded[j].shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length[j]]</code>.
  log_probability: A <code>float</code> matrix <code>(batch_size x top_paths)</code> containing
      sequence log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer">
    <p>def <span class="ident">ctc_beam_search_decoder_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_beam_search_decoder_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.ctc_beam_search_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.ctc_beam_search_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_beam_search_decoder_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_beam_search_decoder`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.ctc_beam_search_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs beam search decoding on the logits given in input.
</pre></div>


<p><strong>Note</strong> The <code>ctc_greedy_decoder</code> is a special case of the
<code>ctc_beam_search_decoder</code> with <code>top_paths=1</code> (but that decoder is faster
for this special case).</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in the output beams.
This means that if consecutive entries in a beam are the same,
only the first of these is emitted.  That is, when the top path
is <code>A B B B B</code>, the return value is:</p>
<ul>
<li><code>A B</code> if <code>merge_repeated = True</code>.</li>
<li><code>A B B B B</code> if <code>merge_repeated = False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>, size
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  beam_width: An int scalar &gt;= 0 (beam search beam width).
  top_paths: An int scalar &gt;= 0, &lt;= beam_width (controls output size).
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A list of length top_paths, where <code>decoded[j]</code>
    is a <code>SparseTensor</code> containing the decoded outputs:
    <code>decoded[j].indices</code>: Indices matrix <code>(total_decoded_outputs[j] x 2)</code>
      The rows store: [batch, time].
    <code>decoded[j].values</code>: Values vector, size <code>(total_decoded_outputs[j])</code>.
      The vector stores the decoded classes for beam j.
    <code>decoded[j].shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length[j]]</code>.
  log_probability: A <code>float</code> matrix <code>(batch_size x top_paths)</code> containing
      sequence log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_beam_search_decoder_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder">
    <p>def <span class="ident">ctc_greedy_decoder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_greedy_decoder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnctc_greedy_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnctc_greedy_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_greedy_decoder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnctc_greedy_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs greedy decoding on the logits given in input (best path).
</pre></div>


<p>Note: Regardless of the value of merge_repeated, if the maximum index of a
given time and batch corresponds to the blank index <code>(num_classes - 1)</code>, no
new element is emitted.</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in output.
This means that if consecutive logits' maximum indices are the same,
only the first of these is emitted.  The sequence <code>A B B * B * B</code> (where '*'
is the blank label) becomes</p>
<ul>
<li><code>A B</code> if <code>merge_repeated=True</code>.</li>
<li><code>A B B B B B</code> if <code>merge_repeated=False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code> sized
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A single-element list. <code>decoded[0]</code>
    is an <code>SparseTensor</code> containing the decoded outputs s.t.:
    <code>decoded.indices</code>: Indices matrix <code>(total_decoded_outputs x 2)</code>.
      The rows store: <code>[batch, time]</code>.
    <code>decoded.values</code>: Values vector, size <code>(total_decoded_outputs)</code>.
      The vector stores the decoded classes.
    <code>decoded.shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length]</code>
  log_probability: A <code>float</code> matrix <code>(batch_size x 1)</code> containing sequence
      log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer">
    <p>def <span class="ident">ctc_greedy_decoder_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_greedy_decoder_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.ctc_greedy_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.ctc_greedy_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_greedy_decoder_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_greedy_decoder`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.ctc_greedy_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs greedy decoding on the logits given in input (best path).
</pre></div>


<p>Note: Regardless of the value of merge_repeated, if the maximum index of a
given time and batch corresponds to the blank index <code>(num_classes - 1)</code>, no
new element is emitted.</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in output.
This means that if consecutive logits' maximum indices are the same,
only the first of these is emitted.  The sequence <code>A B B * B * B</code> (where '*'
is the blank label) becomes</p>
<ul>
<li><code>A B</code> if <code>merge_repeated=True</code>.</li>
<li><code>A B B B B B</code> if <code>merge_repeated=False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code> sized
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A single-element list. <code>decoded[0]</code>
    is an <code>SparseTensor</code> containing the decoded outputs s.t.:
    <code>decoded.indices</code>: Indices matrix <code>(total_decoded_outputs x 2)</code>.
      The rows store: <code>[batch, time]</code>.
    <code>decoded.values</code>: Values vector, size <code>(total_decoded_outputs)</code>.
      The vector stores the decoded classes.
    <code>decoded.shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length]</code>
  log_probability: A <code>float</code> matrix <code>(batch_size x 1)</code> containing sequence
      log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer">
    <p>def <span class="ident">ctc_greedy_decoder_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_greedy_decoder_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.ctc_greedy_decoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.ctc_greedy_decoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_greedy_decoder_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_greedy_decoder`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.ctc_greedy_decoder</strong></p>
<div class="codehilite"><pre><span></span>Performs greedy decoding on the logits given in input (best path).
</pre></div>


<p>Note: Regardless of the value of merge_repeated, if the maximum index of a
given time and batch corresponds to the blank index <code>(num_classes - 1)</code>, no
new element is emitted.</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in output.
This means that if consecutive logits' maximum indices are the same,
only the first of these is emitted.  The sequence <code>A B B * B * B</code> (where '*'
is the blank label) becomes</p>
<ul>
<li><code>A B</code> if <code>merge_repeated=True</code>.</li>
<li><code>A B B B B B</code> if <code>merge_repeated=False</code>.</li>
</ul>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code> sized
    <code>[max_time x batch_size x num_classes]</code>.  The logits.
  sequence_length: 1-D <code>int32</code> vector containing sequence lengths,
    having size <code>[batch_size]</code>.
  merge_repeated: Boolean.  Default: True.</p>
<p>Returns:
  A tuple <code>(decoded, log_probabilities)</code> where
  decoded: A single-element list. <code>decoded[0]</code>
    is an <code>SparseTensor</code> containing the decoded outputs s.t.:
    <code>decoded.indices</code>: Indices matrix <code>(total_decoded_outputs x 2)</code>.
      The rows store: <code>[batch, time]</code>.
    <code>decoded.values</code>: Values vector, size <code>(total_decoded_outputs)</code>.
      The vector stores the decoded classes.
    <code>decoded.shape</code>: Shape vector, size <code>(2)</code>.
      The shape values are: <code>[batch_size, max_decoded_length]</code>
  log_probability: A <code>float</code> matrix <code>(batch_size x 1)</code> containing sequence
      log-probabilities.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_greedy_decoder_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_loss">
    <p>def <span class="ident">ctc_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnctc_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnctc_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnctc_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes the CTC (Connectionist Temporal Classification) Loss.
</pre></div>


<p>This op implements the CTC loss as presented in the article:</p>
<p>A. Graves, S. Fernandez, F. Gomez, J. Schmidhuber.
Connectionist Temporal Classification: Labelling Unsegmented Sequence Data
with Recurrent Neural Networks. ICML 2006, Pittsburgh, USA, pp. 369-376.</p>
<p>http://www.cs.toronto.edu/~graves/icml_2006.pdf</p>
<p>Input requirements:</p>
<p>```
sequence_length(b) &lt;= time for all b</p>
<p>max(labels.indices(labels.indices[:, 1] == b, 2))
  &lt;= sequence_length(b) for all b.
```</p>
<p>Notes:</p>
<p>This class performs the softmax operation for you, so inputs should
be e.g. linear projections of outputs by an LSTM.</p>
<p>The <code>inputs</code> Tensor's innermost dimension size, <code>num_classes</code>, represents
<code>num_labels + 1</code> classes, where num_labels is the number of true labels, and
the largest value <code>(num_classes - 1)</code> is reserved for the blank label.</p>
<p>For example, for a vocabulary containing 3 labels <code>[a, b, c]</code>,
<code>num_classes = 4</code> and the labels indexing is <code>{a: 0, b: 1, c: 2, blank: 3}</code>.</p>
<p>Regarding the arguments <code>preprocess_collapse_repeated</code> and
<code>ctc_merge_repeated</code>:</p>
<p>If <code>preprocess_collapse_repeated</code> is True, then a preprocessing step runs
before loss calculation, wherein repeated labels passed to the loss
are merged into single labels.  This is useful if the training labels come
from, e.g., forced alignments and therefore have unnecessary repetitions.</p>
<p>If <code>ctc_merge_repeated</code> is set False, then deep within the CTC calculation,
repeated non-blank labels will not be merged and are interpreted
as individual labels.  This is a simplified (non-standard) version of CTC.</p>
<p>Here is a table of the (roughly) expected first order behavior:</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Classical CTC behavior: Outputs true repeated classes with blanks in
  between, and can also output repeated classes with no blanks in
  between that need to be collapsed by the decoder.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Never learns to output repeated classes, as they are collapsed
  in the input labels before training.</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Outputs repeated classes with blanks in between, but generally does not
  require the decoder to collapse/merge repeated classes.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Untested.  Very likely will not learn to output repeated classes.</p>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>.
    If time_major == False, this will be a <code>Tensor</code> shaped:
      <code>[batch_size x max_time x num_classes]</code>.
    If time_major == True (default), this will be a <code>Tensor</code> shaped:
      <code>[max_time x batch_size x num_classes]</code>.
    The logits.
  labels: An <code>int32</code> <code>SparseTensor</code>.
    <code>labels.indices[i, :] == [b, t]</code> means <code>labels.values[i]</code> stores
    the id for (batch b, time t).
    <code>labels.values[i]</code> must take on values in <code>[0, num_labels)</code>.
    See <code>core/ops/ctc_ops.cc</code> for more details.
  sequence_length: 1-D <code>int32</code> vector, size <code>[batch_size]</code>.
    The sequence lengths.
  preprocess_collapse_repeated: Boolean.  Default: False.
    If True, repeated labels are collapsed prior to the CTC calculation.
  ctc_merge_repeated: Boolean.  Default: True.
  time_major: The shape format of the <code>inputs</code> Tensors.
    If True, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, num_classes]</code>.
    If False, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, num_classes]</code>.
    Using <code>time_major = True</code> (default) is a bit more efficient because it avoids
    transposes at the beginning of the ctc_loss calculation.  However, most
    TensorFlow data is batch-major, so by this function also accepts inputs
    in batch-major form.</p>
<p>Returns:
  A 1-D <code>float</code> <code>Tensor</code>, size <code>[batch]</code>, containing the negative log probabilities.</p>
<p>Raises:
  TypeError: if labels is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer">
    <p>def <span class="ident">ctc_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.ctc_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.ctc_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.ctc_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes the CTC (Connectionist Temporal Classification) Loss.
</pre></div>


<p>This op implements the CTC loss as presented in the article:</p>
<p>A. Graves, S. Fernandez, F. Gomez, J. Schmidhuber.
Connectionist Temporal Classification: Labelling Unsegmented Sequence Data
with Recurrent Neural Networks. ICML 2006, Pittsburgh, USA, pp. 369-376.</p>
<p>http://www.cs.toronto.edu/~graves/icml_2006.pdf</p>
<p>Input requirements:</p>
<p>```
sequence_length(b) &lt;= time for all b</p>
<p>max(labels.indices(labels.indices[:, 1] == b, 2))
  &lt;= sequence_length(b) for all b.
```</p>
<p>Notes:</p>
<p>This class performs the softmax operation for you, so inputs should
be e.g. linear projections of outputs by an LSTM.</p>
<p>The <code>inputs</code> Tensor's innermost dimension size, <code>num_classes</code>, represents
<code>num_labels + 1</code> classes, where num_labels is the number of true labels, and
the largest value <code>(num_classes - 1)</code> is reserved for the blank label.</p>
<p>For example, for a vocabulary containing 3 labels <code>[a, b, c]</code>,
<code>num_classes = 4</code> and the labels indexing is <code>{a: 0, b: 1, c: 2, blank: 3}</code>.</p>
<p>Regarding the arguments <code>preprocess_collapse_repeated</code> and
<code>ctc_merge_repeated</code>:</p>
<p>If <code>preprocess_collapse_repeated</code> is True, then a preprocessing step runs
before loss calculation, wherein repeated labels passed to the loss
are merged into single labels.  This is useful if the training labels come
from, e.g., forced alignments and therefore have unnecessary repetitions.</p>
<p>If <code>ctc_merge_repeated</code> is set False, then deep within the CTC calculation,
repeated non-blank labels will not be merged and are interpreted
as individual labels.  This is a simplified (non-standard) version of CTC.</p>
<p>Here is a table of the (roughly) expected first order behavior:</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Classical CTC behavior: Outputs true repeated classes with blanks in
  between, and can also output repeated classes with no blanks in
  between that need to be collapsed by the decoder.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Never learns to output repeated classes, as they are collapsed
  in the input labels before training.</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Outputs repeated classes with blanks in between, but generally does not
  require the decoder to collapse/merge repeated classes.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Untested.  Very likely will not learn to output repeated classes.</p>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>.
    If time_major == False, this will be a <code>Tensor</code> shaped:
      <code>[batch_size x max_time x num_classes]</code>.
    If time_major == True (default), this will be a <code>Tensor</code> shaped:
      <code>[max_time x batch_size x num_classes]</code>.
    The logits.
  labels: An <code>int32</code> <code>SparseTensor</code>.
    <code>labels.indices[i, :] == [b, t]</code> means <code>labels.values[i]</code> stores
    the id for (batch b, time t).
    <code>labels.values[i]</code> must take on values in <code>[0, num_labels)</code>.
    See <code>core/ops/ctc_ops.cc</code> for more details.
  sequence_length: 1-D <code>int32</code> vector, size <code>[batch_size]</code>.
    The sequence lengths.
  preprocess_collapse_repeated: Boolean.  Default: False.
    If True, repeated labels are collapsed prior to the CTC calculation.
  ctc_merge_repeated: Boolean.  Default: True.
  time_major: The shape format of the <code>inputs</code> Tensors.
    If True, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, num_classes]</code>.
    If False, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, num_classes]</code>.
    Using <code>time_major = True</code> (default) is a bit more efficient because it avoids
    transposes at the beginning of the ctc_loss calculation.  However, most
    TensorFlow data is batch-major, so by this function also accepts inputs
    in batch-major form.</p>
<p>Returns:
  A 1-D <code>float</code> <code>Tensor</code>, size <code>[batch]</code>, containing the negative log probabilities.</p>
<p>Raises:
  TypeError: if labels is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ctc_loss_layer">
    <p>def <span class="ident">ctc_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.ctc_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.ctc_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ctc_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.ctc_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.ctc_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes the CTC (Connectionist Temporal Classification) Loss.
</pre></div>


<p>This op implements the CTC loss as presented in the article:</p>
<p>A. Graves, S. Fernandez, F. Gomez, J. Schmidhuber.
Connectionist Temporal Classification: Labelling Unsegmented Sequence Data
with Recurrent Neural Networks. ICML 2006, Pittsburgh, USA, pp. 369-376.</p>
<p>http://www.cs.toronto.edu/~graves/icml_2006.pdf</p>
<p>Input requirements:</p>
<p>```
sequence_length(b) &lt;= time for all b</p>
<p>max(labels.indices(labels.indices[:, 1] == b, 2))
  &lt;= sequence_length(b) for all b.
```</p>
<p>Notes:</p>
<p>This class performs the softmax operation for you, so inputs should
be e.g. linear projections of outputs by an LSTM.</p>
<p>The <code>inputs</code> Tensor's innermost dimension size, <code>num_classes</code>, represents
<code>num_labels + 1</code> classes, where num_labels is the number of true labels, and
the largest value <code>(num_classes - 1)</code> is reserved for the blank label.</p>
<p>For example, for a vocabulary containing 3 labels <code>[a, b, c]</code>,
<code>num_classes = 4</code> and the labels indexing is <code>{a: 0, b: 1, c: 2, blank: 3}</code>.</p>
<p>Regarding the arguments <code>preprocess_collapse_repeated</code> and
<code>ctc_merge_repeated</code>:</p>
<p>If <code>preprocess_collapse_repeated</code> is True, then a preprocessing step runs
before loss calculation, wherein repeated labels passed to the loss
are merged into single labels.  This is useful if the training labels come
from, e.g., forced alignments and therefore have unnecessary repetitions.</p>
<p>If <code>ctc_merge_repeated</code> is set False, then deep within the CTC calculation,
repeated non-blank labels will not be merged and are interpreted
as individual labels.  This is a simplified (non-standard) version of CTC.</p>
<p>Here is a table of the (roughly) expected first order behavior:</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Classical CTC behavior: Outputs true repeated classes with blanks in
  between, and can also output repeated classes with no blanks in
  between that need to be collapsed by the decoder.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Never learns to output repeated classes, as they are collapsed
  in the input labels before training.</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Outputs repeated classes with blanks in between, but generally does not
  require the decoder to collapse/merge repeated classes.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Untested.  Very likely will not learn to output repeated classes.</p>
<p>Args:
  inputs: 3-D <code>float</code> <code>Tensor</code>.
    If time_major == False, this will be a <code>Tensor</code> shaped:
      <code>[batch_size x max_time x num_classes]</code>.
    If time_major == True (default), this will be a <code>Tensor</code> shaped:
      <code>[max_time x batch_size x num_classes]</code>.
    The logits.
  labels: An <code>int32</code> <code>SparseTensor</code>.
    <code>labels.indices[i, :] == [b, t]</code> means <code>labels.values[i]</code> stores
    the id for (batch b, time t).
    <code>labels.values[i]</code> must take on values in <code>[0, num_labels)</code>.
    See <code>core/ops/ctc_ops.cc</code> for more details.
  sequence_length: 1-D <code>int32</code> vector, size <code>[batch_size]</code>.
    The sequence lengths.
  preprocess_collapse_repeated: Boolean.  Default: False.
    If True, repeated labels are collapsed prior to the CTC calculation.
  ctc_merge_repeated: Boolean.  Default: True.
  time_major: The shape format of the <code>inputs</code> Tensors.
    If True, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, num_classes]</code>.
    If False, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, num_classes]</code>.
    Using <code>time_major = True</code> (default) is a bit more efficient because it avoids
    transposes at the beginning of the ctc_loss calculation.  However, most
    TensorFlow data is batch-major, so by this function also accepts inputs
    in batch-major form.</p>
<p>Returns:
  A 1-D <code>float</code> <code>Tensor</code>, size <code>[batch]</code>, containing the negative log probabilities.</p>
<p>Raises:
  TypeError: if labels is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ctc_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ctc_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cumprod">
    <p>def <span class="ident">cumprod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cumprod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cumprod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cumprod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cumprod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cumprod</strong></p>
<div class="codehilite"><pre><span></span>Compute the cumulative product of the tensor `x` along `axis`.
</pre></div>


<p>By default, this op performs an inclusive cumprod, which means that the
first
element of the input is identical to the first element of the output:
<code>prettyprint
tf.cumprod([a, b, c]) ==&gt; [a, a * b, a * b * c]</code></p>
<p>By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumprod is
performed
instead:
<code>prettyprint
tf.cumprod([a, b, c], exclusive=True) ==&gt; [1, a, a * b]</code></p>
<p>By setting the <code>reverse</code> kwarg to <code>True</code>, the cumprod is performed in the
opposite direction:
<code>prettyprint
tf.cumprod([a, b, c], reverse=True) ==&gt; [a * b * c, b * c, c]</code>
This is more efficient than using separate <code>tf.reverse</code> ops.</p>
<p>The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:
<code>prettyprint
tf.cumprod([a, b, c], exclusive=True, reverse=True) ==&gt; [b * c, c, 1]</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
     <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
     <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  axis: A <code>Tensor</code> of type <code>int32</code> (default: 0).
  reverse: A <code>bool</code> (default: False).
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cumprod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cumprod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.cumsum">
    <p>def <span class="ident">cumsum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cumsum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.cumsum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.cumsum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.cumsum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.cumsum</strong></p>
<div class="codehilite"><pre><span></span>Compute the cumulative sum of the tensor `x` along `axis`.
</pre></div>


<p>By default, this op performs an inclusive cumsum, which means that the first
element of the input is identical to the first element of the output:
<code>prettyprint
tf.cumsum([a, b, c]) ==&gt; [a, a + b, a + b + c]</code></p>
<p>By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumsum is performed
instead:
<code>prettyprint
tf.cumsum([a, b, c], exclusive=True) ==&gt; [0, a, a + b]</code></p>
<p>By setting the <code>reverse</code> kwarg to <code>True</code>, the cumsum is performed in the
opposite direction:
<code>prettyprint
tf.cumsum([a, b, c], reverse=True) ==&gt; [a + b + c, b + c, c]</code>
This is more efficient than using separate <code>tf.reverse</code> ops.</p>
<p>The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:
<code>prettyprint
tf.cumsum([a, b, c], exclusive=True, reverse=True) ==&gt; [b + c, c, 0]</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
     <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
     <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
     axis: A <code>Tensor</code> of type <code>int32</code> (default: 0).
     reverse: A <code>bool</code> (default: False).
     name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.cumsum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.cumsum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.data">
    <p>def <span class="ident">data</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.data', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_base64">
    <p>def <span class="ident">decode_base64</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_base64(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_base64</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_base64(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_base64(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_base64</strong></p>
<div class="codehilite"><pre><span></span>Decode web-safe base64-encoded strings.
</pre></div>


<p>Input may or may not have padding at the end. See EncodeBase64 for padding.
Web-safe means that input must use - and _ instead of + and /.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. Base64 strings to decode.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. Decoded strings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_base64', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_base64" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_csv">
    <p>def <span class="ident">decode_csv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_csv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_csv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_csv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_csv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_csv</strong></p>
<div class="codehilite"><pre><span></span>Convert CSV records to tensors. Each column maps to one tensor.
</pre></div>


<p>RFC 4180 format is expected for the CSV records.
(https://tools.ietf.org/html/rfc4180)
Note that we allow leading and trailing spaces with int or float field.</p>
<p>Args:
  records: A <code>Tensor</code> of type <code>string</code>.
    Each string is a record/row in the csv and all records should have
    the same format.
  record_defaults: A list of <code>Tensor</code> objects with types from: <code>float32</code>, <code>int32</code>, <code>int64</code>, <code>string</code>.
    One tensor per column of the input record, with either a
    scalar default value for that column or empty if the column is required.
  field_delim: An optional <code>string</code>. Defaults to <code>","</code>.
    delimiter to separate fields in a record.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list of <code>Tensor</code> objects. Has the same type as <code>record_defaults</code>.
  Each tensor will have the same shape as records.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_csv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_csv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_json_example">
    <p>def <span class="ident">decode_json_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_json_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_json_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_json_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_json_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_json_example</strong></p>
<div class="codehilite"><pre><span></span>Convert JSON-encoded Example records to binary protocol buffer strings.
</pre></div>


<p>This op translates a tensor containing Example records, encoded using
the <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">standard JSON
mapping</a>,
into a tensor containing the same records encoded as binary protocol
buffers. The resulting tensor can then be fed to any of the other
Example-parsing ops.</p>
<p>Args:
  json_examples: A <code>Tensor</code> of type <code>string</code>.
    Each string is a JSON object serialized according to the JSON
    mapping of the Example proto.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.
  Each string is a binary Example protocol buffer corresponding
  to the respective element of <code>json_examples</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_json_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_json_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.decode_raw">
    <p>def <span class="ident">decode_raw</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_raw(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.decode_raw</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.decode_raw(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.decode_raw(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.decode_raw</strong></p>
<div class="codehilite"><pre><span></span>Reinterpret the bytes of a string as a vector of numbers.
</pre></div>


<p>Args:
  bytes: A <code>Tensor</code> of type <code>string</code>.
    All the elements must have the same length.
  out_type: A <code>tf.DType</code> from: <code>tf.half, tf.float32, tf.float64, tf.int32, tf.uint8, tf.int16, tf.int8, tf.int64</code>.
  little_endian: An optional <code>bool</code>. Defaults to <code>True</code>.
    Whether the input <code>bytes</code> are in little-endian order.
    Ignored for <code>out_type</code> values that are stored in a single byte like
    <code>uint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>.
  A Tensor with one more dimension than the input <code>bytes</code>.  The
  added dimension will have size equal to the length of the elements
  of <code>bytes</code> divided by the number of bytes to represent <code>out_type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.decode_raw', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.decode_raw" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.delete_session_tensor">
    <p>def <span class="ident">delete_session_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.delete_session_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.delete_session_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.delete_session_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.delete_session_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.delete_session_tensor</strong></p>
<div class="codehilite"><pre><span></span>Delete the tensor for the given tensor handle.
</pre></div>


<p>This is EXPERIMENTAL and subject to change.</p>
<p>Delete the tensor of a given tensor handle. The tensor is produced
in a previous run() and stored in the state of the session.</p>
<p>Args:
  handle: The string representation of a persistent tensor handle.
  name: Optional name prefix for the return tensor.</p>
<p>Returns:
  A pair of graph elements. The first is a placeholder for feeding a
  tensor handle and the second is a deletion operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.delete_session_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.delete_session_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depth_to_space">
    <p>def <span class="ident">depth_to_space</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depth_to_space(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.depth_to_space</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.depth_to_space(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depth_to_space(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.depth_to_space</strong></p>
<div class="codehilite"><pre><span></span>DepthToSpace for tensors of type T.
</pre></div>


<p>Rearranges data from depth into blocks of spatial data.
This is the reverse transformation of SpaceToDepth. More specifically,
this op outputs a copy of the input tensor where values from the <code>depth</code>
dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions.
The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>
<ul>
<li>Chunks of data of size <code>block_size * block_size</code> from depth are rearranged
    into non-overlapping blocks of size <code>block_size x block_size</code></li>
<li>The width the output tensor is <code>input_depth * block_size</code>, whereas the
    height is <code>input_height * block_size</code>.</li>
<li>The depth of the input tensor must be divisible by
    <code>block_size * block_size</code>.</li>
</ul>
<p>That is, assuming the input is in the shape:
<code>[batch, height, width, depth]</code>,
the shape of the output will be:
<code>[batch, height*block_size, width*block_size, depth/(block_size*block_size)]</code></p>
<p>This operation requires that the input tensor be of rank 4, and that
<code>block_size</code> be &gt;=1 and that <code>block_size * block_size</code> be a divisor of the
input depth.</p>
<p>This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</p>
<p>For example, given this input of shape <code>[1, 1, 1, 4]</code>, and a block size of 2:</p>
<p>```prettyprint
x = [[[[1, 2, 3, 4]]]]</p>
<p>```</p>
<p>This operation will output a tensor of shape <code>[1, 2, 2, 1]</code>:</p>
<p><code>prettyprint
   [[[[1], [2]],
     [[3], [4]]]]</code></p>
<p>Here, the input has a batch of 1 and each batch element has shape <code>[1, 1, 4]</code>,
the corresponding output will have 2x2 elements and will have a depth of
1 channel (1 = <code>4 / (block_size * block_size)</code>).
The output element shape is <code>[2, 2, 1]</code>.</p>
<p>For an input tensor with larger depth, here of shape <code>[1, 1, 1, 12]</code>, e.g.</p>
<p><code>prettyprint
x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]</code></p>
<p>This operation, for block size of 2, will return the following tensor of shape
<code>[1, 2, 2, 3]</code></p>
<p>```prettyprint
   [[[[1, 2, 3], [4, 5, 6]],
     [[7, 8, 9], [10, 11, 12]]]]</p>
<p>```</p>
<p>Similarly, for the following input of shape <code>[1 2 2 4]</code>, and a block size of 2:</p>
<p><code>prettyprint
x =  [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]</code></p>
<p>the operator will return the following tensor of shape <code>[1 4 4 1]</code>:</p>
<p>```prettyprint
x = [[ [1],   [2],  [5],  [6]],
     [ [3],   [4],  [7],  [8]],
     [ [9],  [10], [13],  [14]],
     [ [11], [12], [15],  [16]]]</p>
<p>```</p>
<p>Args:
  input: A <code>Tensor</code>.
  block_size: An <code>int</code> that is <code>&gt;= 2</code>.
    The size of the spatial block, same as in Space2Depth.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depth_to_space', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depth_to_space" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d">
    <p>def <span class="ident">depthwise_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndepthwise_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndepthwise_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndepthwise_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Depthwise 2-D convolution.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>
containing <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code>
applies a different filter to each input channel (expanding from 1 channel
to <code>channel_multiplier</code> channels for each), then concatenates the results
together.  The output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k * channel_multiplier + q] =
    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                 filter[di, dj, k, q]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the
same horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter: 4-D with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
  strides: 1-D of size 4.  The stride of the sliding window for each
    dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape
  <code>[batch, out_height, out_width, in_channels * channel_multiplier].</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Depthwise 2-D convolution.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>
containing <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code>
applies a different filter to each input channel (expanding from 1 channel
to <code>channel_multiplier</code> channels for each), then concatenates the results
together.  The output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k * channel_multiplier + q] =
    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                 filter[di, dj, k, q]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the
same horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter: 4-D with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
  strides: 1-D of size 4.  The stride of the sliding window for each
    dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape
  <code>[batch, out_height, out_width, in_channels * channel_multiplier].</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Depthwise 2-D convolution.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>
containing <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code>
applies a different filter to each input channel (expanding from 1 channel
to <code>channel_multiplier</code> channels for each), then concatenates the results
together.  The output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k * channel_multiplier + q] =
    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                 filter[di, dj, k, q]
</pre></div>


<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the
same horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter: 4-D with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
  strides: 1-D of size 4.  The stride of the sliding window for each
    dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape
  <code>[batch, out_height, out_width, in_channels * channel_multiplier].</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native">
    <p>def <span class="ident">depthwise_conv2d_native</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndepthwise_conv2d_native</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndepthwise_conv2d_native(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndepthwise_conv2d_native</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing
<code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies
a different filter to each input channel (expanding from 1 channel to
<code>channel_multiplier</code> channels for each), then concatenates the results
together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>for k in 0..in_channels-1
  for q in 0..channel_multiplier-1
    output[b, i, j, k * channel_multiplier + q] =
      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]</p>
<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndepthwise_conv2d_native_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndepthwise_conv2d_native_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndepthwise_conv2d_native_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  filter_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the tensor shape of <code>filter</code>,
    where <code>filter</code> is a 4-D
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape
  <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
  the <code>filter</code> input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndepthwise_conv2d_native_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndepthwise_conv2d_native_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndepthwise_conv2d_native_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer">
    <p>def <span class="ident">depthwise_conv2d_native_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d_native_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradients of depthwise convolution with respect to the input.
</pre></div>


<p>Args:
  input_sizes: A <code>Tensor</code> of type <code>int32</code>.
    An integer vector representing the shape of <code>input</code>,
    where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    4-D with shape
    <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>filter</code>.
    4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
    Gradients w.r.t. the output of the convolution.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    of the convolution.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>filter</code>.
  4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
  w.r.t. the input of the convolution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer">
    <p>def <span class="ident">depthwise_conv2d_native_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d_native</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d_native(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d_native</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing
<code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies
a different filter to each input channel (expanding from 1 channel to
<code>channel_multiplier</code> channels for each), then concatenates the results
together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>for k in 0..in_channels-1
  for q in 0..channel_multiplier-1
    output[b, i, j, k * channel_multiplier + q] =
      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]</p>
<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer">
    <p>def <span class="ident">depthwise_conv2d_native_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.depthwise_conv2d_native</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.depthwise_conv2d_native(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.depthwise_conv2d_native_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.depthwise_conv2d_native`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.depthwise_conv2d_native</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
</pre></div>


<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing
<code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies
a different filter to each input channel (expanding from 1 channel to
<code>channel_multiplier</code> channels for each), then concatenates the results
together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>for k in 0..in_channels-1
  for q in 0..channel_multiplier-1
    output[b, i, j, k * channel_multiplier + q] =
      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]</p>
<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.depthwise_conv2d_native_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dequantize">
    <p>def <span class="ident">dequantize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dequantize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.dequantize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.dequantize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dequantize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.dequantize</strong></p>
<div class="codehilite"><pre><span></span>Dequantize the &#39;input&#39; tensor into a float Tensor.
</pre></div>


<p>[min_range, max_range] are scalar floats that specify the range for
the 'input' data. The 'mode' attribute controls exactly which calculations are
used to convert the float values to their quantized equivalents.</p>
<p>In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:</p>
<p><code>if T == qint8, in[i] += (range(T) + 1)/ 2.0
out[i] = min_range + (in[i]* (max_range - min_range) / range(T))</code>
here <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code></p>
<p><em>MIN_COMBINED Mode Example</em></p>
<p>If the input comes from a QuantizedRelu6, the output type is
quint8 (range of 0-255) but the possible range of QuantizedRelu6 is
0-6.  The min_range and max_range values are therefore 0.0 and 6.0.
Dequantize on quint8 will take each value, cast to float, and multiply
by 6 / 255.
Note that if quantizedtype is qint8, the operation will additionally add
each value by 128 prior to casting.</p>
<p>If the mode is 'MIN_FIRST', then this approach is used:</p>
<p><code>number_of_steps = 1 &lt;&lt; (# of bits in T)
range_adjust = number_of_steps / (number_of_steps - 1)
range = (range_max - range_min) * range_adjust
range_scale = range / number_of_steps
const double offset_input = static_cast&lt;double&gt;(input) - lowest_quantized;
result = range_min + ((input - numeric_limits&lt;T&gt;::min()) * range_scale)</code></p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_range: A <code>Tensor</code> of type <code>float32</code>.
    The minimum scalar value possibly produced for the input.
  max_range: A <code>Tensor</code> of type <code>float32</code>.
    The maximum scalar value possibly produced for the input.
  mode: An optional <code>string</code> from: <code>"MIN_COMBINED", "MIN_FIRST"</code>. Defaults to <code>"MIN_COMBINED"</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dequantize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dequantize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.deserialize_many_sparse">
    <p>def <span class="ident">deserialize_many_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.deserialize_many_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.deserialize_many_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.deserialize_many_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.deserialize_many_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.deserialize_many_sparse</strong></p>
<div class="codehilite"><pre><span></span>Deserialize and concatenate `SparseTensors` from a serialized minibatch.
</pre></div>


<p>The input <code>serialized_sparse</code> must be a string matrix of shape <code>[N x 3]</code> where
<code>N</code> is the minibatch size and the rows correspond to packed outputs of
<code>serialize_sparse</code>.  The ranks of the original <code>SparseTensor</code> objects
must all match.  When the final <code>SparseTensor</code> is created, it has rank one
higher than the ranks of the incoming <code>SparseTensor</code> objects (they have been
concatenated along a new row dimension).</p>
<p>The output <code>SparseTensor</code> object's shape values for all dimensions but the
first are the max across the input <code>SparseTensor</code> objects' shape values
for the corresponding dimensions.  Its first shape value is <code>N</code>, the minibatch
size.</p>
<p>The input <code>SparseTensor</code> objects' indices are assumed ordered in
standard lexicographic order.  If this is not the case, after this
step run <code>sparse_reorder</code> to restore index ordering.</p>
<p>For example, if the serialized input is a <code>[2, 3]</code> matrix representing two
original <code>SparseTensor</code> objects:</p>
<div class="codehilite"><pre><span></span>index = [ 0]
        [10]
        [20]
values = [1, 2, 3]
shape = [50]
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>index = [ 2]
        [10]
values = [4, 5]
shape = [30]
</pre></div>


<p>then the final deserialized <code>SparseTensor</code> will be:</p>
<div class="codehilite"><pre><span></span>index = [0  0]
        [0 10]
        [0 20]
        [1  2]
        [1 10]
values = [1, 2, 3, 4, 5]
shape = [2 50]
</pre></div>


<p>Args:
  serialized_sparse: 2-D <code>Tensor</code> of type <code>string</code> of shape <code>[N, 3]</code>.
    The serialized and packed <code>SparseTensor</code> objects.
  dtype: The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.
  rank: (optional) Python int, the rank of the <code>SparseTensor</code> objects.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A <code>SparseTensor</code> representing the deserialized <code>SparseTensor</code>s,
  concatenated along the <code>SparseTensor</code>s' first dimension.</p>
<p>All of the serialized <code>SparseTensor</code>s must have had the same rank and type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.deserialize_many_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.deserialize_many_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.device">
    <p>def <span class="ident">device</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.device(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.device</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.device(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.device(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.device</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.device()` using the default graph.
</pre></div>


<p>See
<a href="../../api_docs/python/framework.md#Graph.device"><code>Graph.device()</code></a>
for more details.</p>
<p>Args:
  device_name_or_function: The device name or function to use in
    the context.</p>
<p>Returns:
  A context manager that specifies the default device to use for newly
  created ops.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.device', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.device" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.diag">
    <p>def <span class="ident">diag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.diag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.diag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.diag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.diag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.diag</strong></p>
<div class="codehilite"><pre><span></span>Returns a diagonal tensor with a given diagonal values.
</pre></div>


<p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
everything else padded with zeros. The diagonal is computed as follows:</p>
<p>Assume <code>diagonal</code> has dimensions [D1,..., Dk], then the output is a tensor of
rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:</p>
<p><code>output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]</code> and 0 everywhere else.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'diagonal' is [1, 2, 3, 4]</h1>
<p>tf.diag(diagonal) ==&gt; [[1, 0, 0, 0]
                       [0, 2, 0, 0]
                       [0, 0, 3, 0]
                       [0, 0, 0, 4]]
```</p>
<p>Args:
  diagonal: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
    Rank k tensor where k is at most 3.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>diagonal</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.diag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.diag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.diag_part">
    <p>def <span class="ident">diag_part</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.diag_part(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.diag_part</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.diag_part(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.diag_part(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.diag_part</strong></p>
<div class="codehilite"><pre><span></span>Returns the diagonal part of the tensor.
</pre></div>


<p>This operation returns a tensor with the <code>diagonal</code> part
of the <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>
<p>Assume <code>input</code> has dimensions <code>[D1,..., Dk, D1,..., Dk]</code>, then the output is a
tensor of rank <code>k</code> with dimensions <code>[D1,..., Dk]</code> where:</p>
<p><code>diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'input' is [[1, 0, 0, 0]</h1>
<div class="codehilite"><pre><span></span>          [0, 2, 0, 0]
          [0, 0, 3, 0]
          [0, 0, 0, 4]]
</pre></div>


<p>tf.diag_part(input) ==&gt; [1, 2, 3, 4]
```</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
    Rank k tensor where k is 2, 4, or 6.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. The extracted diagonal.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.diag_part', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.diag_part" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.digamma">
    <p>def <span class="ident">digamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.digamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.digamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.digamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.digamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.digamma</strong></p>
<div class="codehilite"><pre><span></span>Computes Psi, the derivative of Lgamma (the log of the absolute value of
</pre></div>


<p><code>Gamma(x)</code>), element-wise.</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.digamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.digamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d">
    <p>def <span class="ident">dilation2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndilation2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndilation2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndilation2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.
</pre></div>


<p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each
input channel is processed independently of the others with its own structuring
function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output
tensor depend on the <code>padding</code> algorithm. We currently only support the default
"NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D dilation is the max-sum correlation
(for consistency with <code>conv2d</code>, we use unmirrored filters):</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   max_{dy, dx} input[b,
                      strides[1] * y + rates[1] * dy,
                      strides[2] * x + rates[2] * dx,
                      c] +
                filter[dy, dx, c]
</pre></div>


<p>Max-pooling is a special case when the filter has size equal to the pooling
kernel size and contains all zeros.</p>
<p>Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the
negation of the erosion of <code>-input</code> by the reflected <code>filter</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the input
    tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The input stride for atrous morphological dilation. Must be:
    <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter">
    <p>def <span class="ident">dilation2d_backprop_filter</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_filter(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndilation2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndilation2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_filter(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndilation2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  3-D with shape <code>[filter_height, filter_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer">
    <p>def <span class="ident">dilation2d_backprop_filter_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_filter_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dilation2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dilation2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_filter_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dilation2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  3-D with shape <code>[filter_height, filter_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer">
    <p>def <span class="ident">dilation2d_backprop_filter_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_filter_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dilation2d_backprop_filter</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dilation2d_backprop_filter(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_filter_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_filter`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dilation2d_backprop_filter</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the filter.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  3-D with shape <code>[filter_height, filter_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_filter_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input">
    <p>def <span class="ident">dilation2d_backprop_input</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_input(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndilation2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndilation2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_input(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndilation2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer">
    <p>def <span class="ident">dilation2d_backprop_input_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_input_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dilation2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dilation2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_input_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dilation2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer">
    <p>def <span class="ident">dilation2d_backprop_input_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_input_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dilation2d_backprop_input</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dilation2d_backprop_input(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_backprop_input_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d_backprop_input`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dilation2d_backprop_input</strong></p>
<div class="codehilite"><pre><span></span>Computes the gradient of morphological 2-D dilation with respect to the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  out_backprop: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    4-D with shape <code>[batch, out_height, out_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_backprop_input_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer">
    <p>def <span class="ident">dilation2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dilation2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dilation2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dilation2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.
</pre></div>


<p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each
input channel is processed independently of the others with its own structuring
function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output
tensor depend on the <code>padding</code> algorithm. We currently only support the default
"NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D dilation is the max-sum correlation
(for consistency with <code>conv2d</code>, we use unmirrored filters):</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   max_{dy, dx} input[b,
                      strides[1] * y + rates[1] * dy,
                      strides[2] * x + rates[2] * dx,
                      c] +
                filter[dy, dx, c]
</pre></div>


<p>Max-pooling is a special case when the filter has size equal to the pooling
kernel size and contains all zeros.</p>
<p>Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the
negation of the erosion of <code>-input</code> by the reflected <code>filter</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the input
    tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The input stride for atrous morphological dilation. Must be:
    <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dilation2d_layer">
    <p>def <span class="ident">dilation2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dilation2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dilation2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dilation2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dilation2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dilation2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.
</pre></div>


<p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each
input channel is processed independently of the others with its own structuring
function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output
tensor depend on the <code>padding</code> algorithm. We currently only support the default
"NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D dilation is the max-sum correlation
(for consistency with <code>conv2d</code>, we use unmirrored filters):</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   max_{dy, dx} input[b,
                      strides[1] * y + rates[1] * dy,
                      strides[2] * x + rates[2] * dx,
                      c] +
                filter[dy, dx, c]
</pre></div>


<p>Max-pooling is a special case when the filter has size equal to the pooling
kernel size and contains all zeros.</p>
<p>Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the
negation of the erosion of <code>-input</code> by the reflected <code>filter</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    3-D with shape <code>[filter_height, filter_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the input
    tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The input stride for atrous morphological dilation. Must be:
    <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dilation2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dilation2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.div">
    <p>def <span class="ident">div</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.div(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.div</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.div(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.div(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.div</strong></p>
<div class="codehilite"><pre><span></span>Returns x / y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Div</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.div', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.div" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.divide">
    <p>def <span class="ident">divide</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.divide(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.divide</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.divide(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.divide(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.divide</strong></p>
<div class="codehilite"><pre><span></span>Computes Python style division of `x` by `y`.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.divide', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.divide" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.drop_layer">
    <p>def <span class="ident">drop_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.drop_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderdrop_layer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuilderdrop_layer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.drop_layer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorbuilderdrop_layer</strong></p>
<div class="codehilite"><pre><span></span>Computes dropout.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>Args:
  x: A tensor.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).
Returns:
  A Tensor of the same shape of <code>x</code>.
Raises:
  ValueError: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.drop_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.drop_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dropout">
    <p>def <span class="ident">dropout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dropout(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dropout(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndropout</strong></p>
<div class="codehilite"><pre><span></span>Computes dropout.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>By default, each element is kept or dropped independently.  If <code>noise_shape</code>
is specified, it must be
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcastable</a>
to the shape of <code>x</code>, and only dimensions with <code>noise_shape[i] == shape(x)[i]</code>
will make independent decisions.  For example, if <code>shape(x) = [k, l, m, n]</code>
and <code>noise_shape = [k, 1, 1, n]</code>, each batch and channel component will be
kept independently and each row and column will be kept or not kept together.</p>
<p>Args:
  x: A tensor.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).</p>
<p>Returns:
  A Tensor of the same shape of <code>x</code>.</p>
<p>Raises:
  ValueError: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dropout', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dropout" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer">
    <p>def <span class="ident">dropout_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dropout_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dropout_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dropout`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dropout</strong></p>
<div class="codehilite"><pre><span></span>Computes dropout.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>By default, each element is kept or dropped independently.  If <code>noise_shape</code>
is specified, it must be
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcastable</a>
to the shape of <code>x</code>, and only dimensions with <code>noise_shape[i] == shape(x)[i]</code>
will make independent decisions.  For example, if <code>shape(x) = [k, l, m, n]</code>
and <code>noise_shape = [k, 1, 1, n]</code>, each batch and channel component will be
kept independently and each row and column will be kept or not kept together.</p>
<p>Args:
  x: A tensor.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).</p>
<p>Returns:
  A Tensor of the same shape of <code>x</code>.</p>
<p>Raises:
  ValueError: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dropout_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dropout_layer">
    <p>def <span class="ident">dropout_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dropout_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dropout_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dropout`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dropout</strong></p>
<div class="codehilite"><pre><span></span>Computes dropout.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>By default, each element is kept or dropped independently.  If <code>noise_shape</code>
is specified, it must be
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcastable</a>
to the shape of <code>x</code>, and only dimensions with <code>noise_shape[i] == shape(x)[i]</code>
will make independent decisions.  For example, if <code>shape(x) = [k, l, m, n]</code>
and <code>noise_shape = [k, 1, 1, n]</code>, each batch and channel component will be
kept independently and each row and column will be kept or not kept together.</p>
<p>Args:
  x: A tensor.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).</p>
<p>Returns:
  A Tensor of the same shape of <code>x</code>.</p>
<p>Raises:
  ValueError: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dropout_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dropout_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_partition">
    <p>def <span class="ident">dynamic_partition</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_partition(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.dynamic_partition</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.dynamic_partition(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_partition(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.dynamic_partition</strong></p>
<div class="codehilite"><pre><span></span>Partitions `data` into `num_partitions` tensors using indices from `partitions`.
</pre></div>


<p>For each index tuple <code>js</code> of size <code>partitions.ndim</code>, the slice <code>data[js, ...]</code>
becomes part of <code>outputs[partitions[js]]</code>.  The slices with <code>partitions[js] = i</code>
are placed in <code>outputs[i]</code> in lexicographic order of <code>js</code>, and the first
dimension of <code>outputs[i]</code> is the number of entries in <code>partitions</code> equal to <code>i</code>.
In detail,</p>
<p>```python
    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]</p>
<div class="codehilite"><pre><span></span>outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
</pre></div>


<p>```</p>
<p><code>data.shape</code> must start with <code>partitions.shape</code>.</p>
<p>For example:</p>
<p>```python
    # Scalar partitions.
    partitions = 1
    num_partitions = 2
    data = [10, 20]
    outputs[0] = []  # Empty with shape [0, 2]
    outputs[1] = [[10, 20]]</p>
<div class="codehilite"><pre><span></span># Vector partitions.
partitions = [0, 0, 1, 1, 0]
num_partitions = 2
data = [10, 20, 30, 40, 50]
outputs[0] = [10, 20, 50]
outputs[1] = [30, 40]
</pre></div>


<p>```</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicPartition.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>.
  partitions: A <code>Tensor</code> of type <code>int32</code>.
    Any shape.  Indices in the range <code>[0, num_partitions)</code>.
  num_partitions: An <code>int</code> that is <code>&gt;= 1</code>.
    The number of partitions to output.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list of <code>num_partitions</code> <code>Tensor</code> objects of the same type as data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_partition', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_partition" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_rnn">
    <p>def <span class="ident">dynamic_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nndynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nndynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nndynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>This function is functionally identical to the function <code>rnn</code> above, but
performs fully dynamic unrolling of <code>inputs</code>.</p>
<p>Unlike <code>rnn</code>, the input <code>inputs</code> is not a Python list of <code>Tensors</code>, one for
each frame.  Instead, <code>inputs</code> may be a single <code>Tensor</code> where
the maximum time is either the first or second dimension (see the parameter
<code>time_major</code>).  Alternatively, it may be a (possibly nested) tuple of
Tensors, each of them having matching batch and time dimensions.
The corresponding output is either a single <code>Tensor</code> having the same number
of time steps and batch size, or a (possibly nested) tuple of such tensors,
matching the nested structure of <code>cell.output_size</code>.</p>
<p>The parameter <code>sequence_length</code> is optional and is used to copy-through state
and zero-out outputs when past a batch element's sequence length. So it's more
for correctness than performance, unlike in rnn().</p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: The RNN inputs.</p>
<div class="codehilite"><pre><span></span>If `time_major == False` (default), this must be a `Tensor` of shape:
  `[batch_size, max_time, ...]`, or a nested tuple of such
  elements.

If `time_major == True`, this must be a `Tensor` of shape:
  `[max_time, batch_size, ...]`, or a nested tuple of such
  elements.

This may also be a (possibly nested) tuple of Tensors satisfying
this property.  The first two dimensions must match across all the inputs,
but otherwise the ranks and other shape components may differ.
In this case, input to `cell` at each time-step will replicate the
structure of these tuples, except for the time dimension (from which the
time is taken).

The input to `cell` at each time step will be a `Tensor` or (possibly
nested) tuple of Tensors each with dimensions `[batch_size, ...]`.
</pre></div>


<p>sequence_length: (optional) An int32/int64 vector sized <code>[batch_size]</code>.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<div class="codehilite"><pre><span></span>outputs: The RNN output `Tensor`.

  If time_major == False (default), this will be a `Tensor` shaped:
    `[batch_size, max_time, cell.output_size]`.

  If time_major == True, this will be a `Tensor` shaped:
    `[max_time, batch_size, cell.output_size]`.

  Note, if `cell.output_size` is a (possibly nested) tuple of integers
  or `TensorShape` objects, then `outputs` will be a tuple having the
  same structure as `cell.output_size`, containing Tensors having shapes
  corresponding to the shape data in `cell.output_size`.

state: The final state.  If `cell.state_size` is an int, this
  will be shaped `[batch_size, cell.state_size]`.  If it is a
  `TensorShape`, this will be shaped `[batch_size] + cell.state_size`.
  If it is a (possibly nested) tuple of ints or `TensorShape`, this will
  be a tuple having the corresponding shapes.
</pre></div>


<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer">
    <p>def <span class="ident">dynamic_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dynamic_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>This function is functionally identical to the function <code>rnn</code> above, but
performs fully dynamic unrolling of <code>inputs</code>.</p>
<p>Unlike <code>rnn</code>, the input <code>inputs</code> is not a Python list of <code>Tensors</code>, one for
each frame.  Instead, <code>inputs</code> may be a single <code>Tensor</code> where
the maximum time is either the first or second dimension (see the parameter
<code>time_major</code>).  Alternatively, it may be a (possibly nested) tuple of
Tensors, each of them having matching batch and time dimensions.
The corresponding output is either a single <code>Tensor</code> having the same number
of time steps and batch size, or a (possibly nested) tuple of such tensors,
matching the nested structure of <code>cell.output_size</code>.</p>
<p>The parameter <code>sequence_length</code> is optional and is used to copy-through state
and zero-out outputs when past a batch element's sequence length. So it's more
for correctness than performance, unlike in rnn().</p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: The RNN inputs.</p>
<div class="codehilite"><pre><span></span>If `time_major == False` (default), this must be a `Tensor` of shape:
  `[batch_size, max_time, ...]`, or a nested tuple of such
  elements.

If `time_major == True`, this must be a `Tensor` of shape:
  `[max_time, batch_size, ...]`, or a nested tuple of such
  elements.

This may also be a (possibly nested) tuple of Tensors satisfying
this property.  The first two dimensions must match across all the inputs,
but otherwise the ranks and other shape components may differ.
In this case, input to `cell` at each time-step will replicate the
structure of these tuples, except for the time dimension (from which the
time is taken).

The input to `cell` at each time step will be a `Tensor` or (possibly
nested) tuple of Tensors each with dimensions `[batch_size, ...]`.
</pre></div>


<p>sequence_length: (optional) An int32/int64 vector sized <code>[batch_size]</code>.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<div class="codehilite"><pre><span></span>outputs: The RNN output `Tensor`.

  If time_major == False (default), this will be a `Tensor` shaped:
    `[batch_size, max_time, cell.output_size]`.

  If time_major == True, this will be a `Tensor` shaped:
    `[max_time, batch_size, cell.output_size]`.

  Note, if `cell.output_size` is a (possibly nested) tuple of integers
  or `TensorShape` objects, then `outputs` will be a tuple having the
  same structure as `cell.output_size`, containing Tensors having shapes
  corresponding to the shape data in `cell.output_size`.

state: The final state.  If `cell.state_size` is an int, this
  will be shaped `[batch_size, cell.state_size]`.  If it is a
  `TensorShape`, this will be shaped `[batch_size] + cell.state_size`.
  If it is a (possibly nested) tuple of ints or `TensorShape`, this will
  be a tuple having the corresponding shapes.
</pre></div>


<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer">
    <p>def <span class="ident">dynamic_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.dynamic_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.dynamic_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.dynamic_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.dynamic_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>This function is functionally identical to the function <code>rnn</code> above, but
performs fully dynamic unrolling of <code>inputs</code>.</p>
<p>Unlike <code>rnn</code>, the input <code>inputs</code> is not a Python list of <code>Tensors</code>, one for
each frame.  Instead, <code>inputs</code> may be a single <code>Tensor</code> where
the maximum time is either the first or second dimension (see the parameter
<code>time_major</code>).  Alternatively, it may be a (possibly nested) tuple of
Tensors, each of them having matching batch and time dimensions.
The corresponding output is either a single <code>Tensor</code> having the same number
of time steps and batch size, or a (possibly nested) tuple of such tensors,
matching the nested structure of <code>cell.output_size</code>.</p>
<p>The parameter <code>sequence_length</code> is optional and is used to copy-through state
and zero-out outputs when past a batch element's sequence length. So it's more
for correctness than performance, unlike in rnn().</p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: The RNN inputs.</p>
<div class="codehilite"><pre><span></span>If `time_major == False` (default), this must be a `Tensor` of shape:
  `[batch_size, max_time, ...]`, or a nested tuple of such
  elements.

If `time_major == True`, this must be a `Tensor` of shape:
  `[max_time, batch_size, ...]`, or a nested tuple of such
  elements.

This may also be a (possibly nested) tuple of Tensors satisfying
this property.  The first two dimensions must match across all the inputs,
but otherwise the ranks and other shape components may differ.
In this case, input to `cell` at each time-step will replicate the
structure of these tuples, except for the time dimension (from which the
time is taken).

The input to `cell` at each time step will be a `Tensor` or (possibly
nested) tuple of Tensors each with dimensions `[batch_size, ...]`.
</pre></div>


<p>sequence_length: (optional) An int32/int64 vector sized <code>[batch_size]</code>.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  time_major: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors.
    If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>.
    If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>.
    Using <code>time_major = True</code> is a bit more efficient because it avoids
    transposes at the beginning and end of the RNN calculation.  However,
    most TensorFlow data is batch-major, so by default this function
    accepts input and emits output in batch-major form.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<div class="codehilite"><pre><span></span>outputs: The RNN output `Tensor`.

  If time_major == False (default), this will be a `Tensor` shaped:
    `[batch_size, max_time, cell.output_size]`.

  If time_major == True, this will be a `Tensor` shaped:
    `[max_time, batch_size, cell.output_size]`.

  Note, if `cell.output_size` is a (possibly nested) tuple of integers
  or `TensorShape` objects, then `outputs` will be a tuple having the
  same structure as `cell.output_size`, containing Tensors having shapes
  corresponding to the shape data in `cell.output_size`.

state: The final state.  If `cell.state_size` is an int, this
  will be shaped `[batch_size, cell.state_size]`.  If it is a
  `TensorShape`, this will be shaped `[batch_size] + cell.state_size`.
  If it is a (possibly nested) tuple of ints or `TensorShape`, this will
  be a tuple having the corresponding shapes.
</pre></div>


<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If inputs is None or an empty list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.dynamic_stitch">
    <p>def <span class="ident">dynamic_stitch</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_stitch(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.dynamic_stitch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.dynamic_stitch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.dynamic_stitch(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.dynamic_stitch</strong></p>
<div class="codehilite"><pre><span></span>Interleave the values from the `data` tensors into a single tensor.
</pre></div>


<p>Builds a merged tensor such that</p>
<p><code>python
    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]</code></p>
<p>For example, if each <code>indices[m]</code> is scalar or vector, we have</p>
<p>```python
    # Scalar indices:
    merged[indices[m], ...] = data[m][...]</p>
<div class="codehilite"><pre><span></span># Vector indices:
merged[indices[m][i], ...] = data[m][i, ...]
</pre></div>


<p>```</p>
<p>Each <code>data[i].shape</code> must start with the corresponding <code>indices[i].shape</code>,
and the rest of <code>data[i].shape</code> must be constant w.r.t. <code>i</code>.  That is, we
must have <code>data[i].shape = indices[i].shape + constant</code>.  In terms of this
<code>constant</code>, the output shape is</p>
<div class="codehilite"><pre><span></span>merged.shape = [max(indices)] + constant
</pre></div>


<p>Values are merged in order, so if an index appears in both <code>indices[m][i]</code> and
<code>indices[n][j]</code> for <code>(m,i) &lt; (n,j)</code> the slice <code>data[n][j]</code> will appear in the
merged result.</p>
<p>For example:</p>
<p><code>python
    indices[0] = 6
    indices[1] = [4, 1]
    indices[2] = [[5, 2], [0, 3]]
    data[0] = [61, 62]
    data[1] = [[41, 42], [11, 12]]
    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
              [51, 52], [61, 62]]</code></p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicStitch.png" alt>
</div>

<p>Args:
  indices: A list of at least 1 <code>Tensor</code> objects of type <code>int32</code>.
  data: A list with the same number of <code>Tensor</code> objects as <code>indices</code> of <code>Tensor</code> objects of the same type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.dynamic_stitch', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.dynamic_stitch" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.edit_distance">
    <p>def <span class="ident">edit_distance</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.edit_distance(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.edit_distance</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.edit_distance(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.edit_distance(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.edit_distance</strong></p>
<div class="codehilite"><pre><span></span>Computes the Levenshtein distance between sequences.
</pre></div>


<p>This operation takes variable-length sequences (<code>hypothesis</code> and <code>truth</code>),
each provided as a <code>SparseTensor</code>, and computes the Levenshtein distance.
You can normalize the edit distance by length of <code>truth</code> by setting
<code>normalize</code> to true.</p>
<p>For example, given the following input:</p>
<p>```python</p>
<h1>'hypothesis' is a tensor of shape <code>[2, 1]</code> with variable-length values:</h1>
<h1>(0,0) = ["a"]</h1>
<h1>(1,0) = ["b"]</h1>
<p>hypothesis = tf.SparseTensor(
    [[0, 0, 0],
     [1, 0, 0]],
    ["a", "b"]
    (2, 1, 1))</p>
<h1>'truth' is a tensor of shape <code>[2, 2]</code> with variable-length values:</h1>
<h1>(0,0) = []</h1>
<h1>(0,1) = ["a"]</h1>
<h1>(1,0) = ["b", "c"]</h1>
<h1>(1,1) = ["a"]</h1>
<p>truth = tf.SparseTensor(
    [[0, 1, 0],
     [1, 0, 0],
     [1, 0, 1],
     [1, 1, 0]]
    ["a", "b", "c", "a"],
    (2, 2, 2))</p>
<p>normalize = True
```</p>
<p>This operation would return the following:</p>
<p>```python</p>
<h1>'output' is a tensor of shape <code>[2, 2]</code> with edit distances normalized</h1>
<h1>by 'truth' lengths.</h1>
<p>output ==&gt; [[inf, 1.0],  # (0,0): no truth, (0,1): no hypothesis
           [0.5, 1.0]]  # (1,0): addition, (1,1): no hypothesis
```</p>
<p>Args:
  hypothesis: A <code>SparseTensor</code> containing hypothesis sequences.
  truth: A <code>SparseTensor</code> containing truth sequences.
  normalize: A <code>bool</code>. If <code>True</code>, normalizes the Levenshtein distance by
    length of <code>truth.</code>
  name: A name for the operation (optional).</p>
<p>Returns:
  A dense <code>Tensor</code> with rank <code>R - 1</code>, where R is the rank of the
  <code>SparseTensor</code> inputs <code>hypothesis</code> and <code>truth</code>.</p>
<p>Raises:
  TypeError: If either <code>hypothesis</code> or <code>truth</code> are not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.edit_distance', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.edit_distance" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.einsum">
    <p>def <span class="ident">einsum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.einsum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.einsum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.einsum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.einsum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.einsum</strong></p>
<div class="codehilite"><pre><span></span>A generalized contraction between tensors of arbitrary dimension.
</pre></div>


<p>This function returns a tensor whose elements are defined by <code>equation</code>,
which is written in a shorthand form inspired by the Einstein summation
convention.  As an example, consider multiplying two matrices
A and B to form a matrix C.  The elements of C are given by:</p>
<p><code>C[i,k] = sum_j A[i,j] * B[j,k]</code></p>
<p>The corresponding <code>equation</code> is:</p>
<p><code>ij,jk-&gt;ik</code></p>
<p>In general, the <code>equation</code> is obtained from the more familiar element-wise
equation by
  1. removing variable names, brackets, and commas,
  2. replacing "*" with ",",
  3. dropping summation signs, and
  4. moving the output to the right, and replacing "=" with "-&gt;".</p>
<p>Many common operations can be expressed in this way.  For example:</p>
<h1>Matrix multiplication</h1>
<blockquote>
<blockquote>
<blockquote>
<p>einsum('ij,jk-&gt;ik', m0, m1)  # output[i,k] = sum_j m0[i,j] * m1[j, k]</p>
</blockquote>
</blockquote>
</blockquote>
<h1>Dot product</h1>
<blockquote>
<blockquote>
<blockquote>
<p>einsum('i,i-&gt;', u, v)  # output = sum_i u[i]*v[i]</p>
</blockquote>
</blockquote>
</blockquote>
<h1>Outer product</h1>
<blockquote>
<blockquote>
<blockquote>
<p>einsum('i,j-&gt;ij', u, v)  # output[i,j] = u[i]*v[j]</p>
</blockquote>
</blockquote>
</blockquote>
<h1>Transpose</h1>
<blockquote>
<blockquote>
<blockquote>
<p>einsum('ij-&gt;ji', m)  # output[j,i] = m[i,j]</p>
</blockquote>
</blockquote>
</blockquote>
<h1>Batch matrix multiplication</h1>
<blockquote>
<blockquote>
<blockquote>
<p>einsum('aij,ajk-&gt;aik', s, t)  # out[a,i,k] = sum_j s[a,i,j] * t[a, j, k]</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function behaves like <code>numpy.einsum</code>, but does not support:
<em> Ellipses (subscripts like <code>ij...,jk...-&gt;ik...</code>)
</em> Subscripts where an axis appears more than once for a single input
  (e.g. <code>ijj,k-&gt;ik</code>).
* Subscripts that are summed across multiple inputs (e.g., <code>ij,ij,jk-&gt;ik</code>).</p>
<p>Args:
  equation: a <code>str</code> describing the contraction, in the same format as
    <code>numpy.einsum</code>.
  inputs: the inputs to contract (each one a <code>Tensor</code>), whose shapes should
    be consistent with <code>equation</code>.</p>
<p>Returns:
  The contracted <code>Tensor</code>, with shape determined by <code>equation</code>.</p>
<p>Raises:
  ValueError: If
    - the format of <code>equation</code> is incorrect,
    - the number of inputs implied by <code>equation</code> does not match <code>len(inputs)</code>,
    - an axis appears in the output subscripts but not in any of the inputs,
    - the number of dimensions of an input differs from the number of
      indices in its subscript, or
    - the input shapes are inconsistent along a particular axis.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.einsum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.einsum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.elu">
    <p>def <span class="ident">elu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.elu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnelu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnelu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.elu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnelu</strong></p>
<div class="codehilite"><pre><span></span>Computes exponential linear: `exp(features) - 1` if &lt; 0, `features` otherwise.
</pre></div>


<p>See <a href="http://arxiv.org/abs/1511.07289">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
</a></p>
<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.elu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.elu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.elu_conv2d_layer">
    <p>def <span class="ident">elu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.elu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.elu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.elu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.elu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.elu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.elu</strong></p>
<div class="codehilite"><pre><span></span>Computes exponential linear: `exp(features) - 1` if &lt; 0, `features` otherwise.
</pre></div>


<p>See <a href="http://arxiv.org/abs/1511.07289">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
</a></p>
<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.elu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.elu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.elu_layer">
    <p>def <span class="ident">elu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.elu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.elu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.elu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.elu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.elu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.elu</strong></p>
<div class="codehilite"><pre><span></span>Computes exponential linear: `exp(features) - 1` if &lt; 0, `features` otherwise.
</pre></div>


<p>See <a href="http://arxiv.org/abs/1511.07289">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
</a></p>
<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.elu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.elu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup">
    <p>def <span class="ident">embedding_lookup</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnembedding_lookup</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnembedding_lookup(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnembedding_lookup</strong></p>
<div class="codehilite"><pre><span></span>Looks up `ids` in a list of embedding tensors.
</pre></div>


<p>This function is used to perform parallel lookups on the list of
tensors in <code>params</code>.  It is a generalization of
<a href="../../api_docs/python/array_ops.md#gather"><code>tf.gather()</code></a>, where <code>params</code> is
interpreted as a partitioning of a large embedding tensor.  <code>params</code> may be
a <code>PartitionedVariable</code> as returned by using <code>tf.get_variable()</code> with a
partitioner.</p>
<p>If <code>len(params) &gt; 1</code>, each element <code>id</code> of <code>ids</code> is partitioned between
the elements of <code>params</code> according to the <code>partition_strategy</code>.
In all strategies, if the id space does not evenly divide the number of
partitions, each of the first <code>(max_id + 1) % len(params)</code> partitions will
be assigned one more id.</p>
<p>If <code>partition_strategy</code> is <code>"mod"</code>, we assign each id to partition
<code>p = id % len(params)</code>. For instance,
13 ids are split across 5 partitions as:
<code>[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]</code></p>
<p>If <code>partition_strategy</code> is <code>"div"</code>, we assign ids to partitions in a
contiguous manner. In this case, 13 ids are split across 5 partitions as:
<code>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]</code></p>
<p>The results of the lookup are concatenated into a dense
tensor. The returned tensor has shape <code>shape(ids) + shape(params)[1:]</code>.</p>
<p>Args:
  params: A list of tensors with the same type and which can be concatenated
    along dimension 0. Alternatively, a <code>PartitionedVariable</code>, created by
    partitioning along dimension 0.  Each element must be appropriately sized
    for the given <code>partition_strategy</code>.
  ids: A <code>Tensor</code> with type <code>int32</code> or <code>int64</code> containing the ids to be looked
    up in <code>params</code>.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>.
  name: A name for the operation (optional).
  validate_indices: Whether or not to validate gather indices.
  max_norm: If not None, embedding values are l2-normalized to the value of
   max_norm.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as the tensors in <code>params</code>.</p>
<p>Raises:
  ValueError: If <code>params</code> is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer">
    <p>def <span class="ident">embedding_lookup_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.embedding_lookup</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.embedding_lookup(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.embedding_lookup</strong></p>
<div class="codehilite"><pre><span></span>Looks up `ids` in a list of embedding tensors.
</pre></div>


<p>This function is used to perform parallel lookups on the list of
tensors in <code>params</code>.  It is a generalization of
<a href="../../api_docs/python/array_ops.md#gather"><code>tf.gather()</code></a>, where <code>params</code> is
interpreted as a partitioning of a large embedding tensor.  <code>params</code> may be
a <code>PartitionedVariable</code> as returned by using <code>tf.get_variable()</code> with a
partitioner.</p>
<p>If <code>len(params) &gt; 1</code>, each element <code>id</code> of <code>ids</code> is partitioned between
the elements of <code>params</code> according to the <code>partition_strategy</code>.
In all strategies, if the id space does not evenly divide the number of
partitions, each of the first <code>(max_id + 1) % len(params)</code> partitions will
be assigned one more id.</p>
<p>If <code>partition_strategy</code> is <code>"mod"</code>, we assign each id to partition
<code>p = id % len(params)</code>. For instance,
13 ids are split across 5 partitions as:
<code>[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]</code></p>
<p>If <code>partition_strategy</code> is <code>"div"</code>, we assign ids to partitions in a
contiguous manner. In this case, 13 ids are split across 5 partitions as:
<code>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]</code></p>
<p>The results of the lookup are concatenated into a dense
tensor. The returned tensor has shape <code>shape(ids) + shape(params)[1:]</code>.</p>
<p>Args:
  params: A list of tensors with the same type and which can be concatenated
    along dimension 0. Alternatively, a <code>PartitionedVariable</code>, created by
    partitioning along dimension 0.  Each element must be appropriately sized
    for the given <code>partition_strategy</code>.
  ids: A <code>Tensor</code> with type <code>int32</code> or <code>int64</code> containing the ids to be looked
    up in <code>params</code>.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>.
  name: A name for the operation (optional).
  validate_indices: Whether or not to validate gather indices.
  max_norm: If not None, embedding values are l2-normalized to the value of
   max_norm.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as the tensors in <code>params</code>.</p>
<p>Raises:
  ValueError: If <code>params</code> is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_layer">
    <p>def <span class="ident">embedding_lookup_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.embedding_lookup</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.embedding_lookup(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.embedding_lookup</strong></p>
<div class="codehilite"><pre><span></span>Looks up `ids` in a list of embedding tensors.
</pre></div>


<p>This function is used to perform parallel lookups on the list of
tensors in <code>params</code>.  It is a generalization of
<a href="../../api_docs/python/array_ops.md#gather"><code>tf.gather()</code></a>, where <code>params</code> is
interpreted as a partitioning of a large embedding tensor.  <code>params</code> may be
a <code>PartitionedVariable</code> as returned by using <code>tf.get_variable()</code> with a
partitioner.</p>
<p>If <code>len(params) &gt; 1</code>, each element <code>id</code> of <code>ids</code> is partitioned between
the elements of <code>params</code> according to the <code>partition_strategy</code>.
In all strategies, if the id space does not evenly divide the number of
partitions, each of the first <code>(max_id + 1) % len(params)</code> partitions will
be assigned one more id.</p>
<p>If <code>partition_strategy</code> is <code>"mod"</code>, we assign each id to partition
<code>p = id % len(params)</code>. For instance,
13 ids are split across 5 partitions as:
<code>[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]</code></p>
<p>If <code>partition_strategy</code> is <code>"div"</code>, we assign ids to partitions in a
contiguous manner. In this case, 13 ids are split across 5 partitions as:
<code>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]</code></p>
<p>The results of the lookup are concatenated into a dense
tensor. The returned tensor has shape <code>shape(ids) + shape(params)[1:]</code>.</p>
<p>Args:
  params: A list of tensors with the same type and which can be concatenated
    along dimension 0. Alternatively, a <code>PartitionedVariable</code>, created by
    partitioning along dimension 0.  Each element must be appropriately sized
    for the given <code>partition_strategy</code>.
  ids: A <code>Tensor</code> with type <code>int32</code> or <code>int64</code> containing the ids to be looked
    up in <code>params</code>.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>.
  name: A name for the operation (optional).
  validate_indices: Whether or not to validate gather indices.
  max_norm: If not None, embedding values are l2-normalized to the value of
   max_norm.</p>
<p>Returns:
  A <code>Tensor</code> with the same type as the tensors in <code>params</code>.</p>
<p>Raises:
  ValueError: If <code>params</code> is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse">
    <p>def <span class="ident">embedding_lookup_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnembedding_lookup_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnembedding_lookup_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnembedding_lookup_sparse</strong></p>
<div class="codehilite"><pre><span></span>Computes embeddings for the given ids and weights.
</pre></div>


<p>This op assumes that there is at least one id for each row in the dense tensor
represented by sp_ids (i.e. there are no rows with empty features), and that
all the indices of sp_ids are in canonical row-major order.</p>
<p>It also assumes that all id values lie in the range [0, p0), where p0
is the sum of the size of params along dimension 0.</p>
<p>Args:
  params: A single tensor representing the complete embedding tensor,
    or a list of P tensors all of same shape except for the first dimension,
    representing sharded embedding tensors.  Alternatively, a
    <code>PartitionedVariable</code>, created by partitioning along dimension 0.
  sp_ids: N x M SparseTensor of int64 ids (typically from FeatureValueToId),
    where N is typically batch size and M is arbitrary.
  sp_weights: either a SparseTensor of float / double weights, or None to
    indicate all weights should be taken to be 1. If specified, sp_weights
    must have exactly the same shape and indices as sp_ids.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: Optional name for the op.
  combiner: A string specifying the reduction op. Currently "mean", "sqrtn"
    and "sum" are supported.
    "sum" computes the weighted sum of the embedding results for each row.
    "mean" is the weighted sum divided by the total weight.
    "sqrtn" is the weighted sum divided by the square root of the sum of the
    squares of the weights.
  max_norm: If not None, each embedding is normalized to have l2 norm equal
    to max_norm before combining.</p>
<p>Returns:
  A dense tensor representing the combined embeddings for the
  sparse ids. For each row in the dense tensor represented by sp_ids, the op
  looks up the embeddings for all ids in that row, multiplies them by the
  corresponding weight, and combines these embeddings as specified.</p>
<p>In other words, if</p>
<div class="codehilite"><pre><span></span>shape(combined params) = [p0, p1, ..., pm]
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>shape(sp_ids) = shape(sp_weights) = [d0, d1, ..., dn]
</pre></div>


<p>then</p>
<div class="codehilite"><pre><span></span>shape(output) = [d0, d1, ..., dn-1, p1, ..., pm].
</pre></div>


<p>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</p>
<div class="codehilite"><pre><span></span>[0, 0]: id 1, weight 2.0
[0, 1]: id 3, weight 0.5
[1, 0]: id 0, weight 1.0
[2, 3]: id 1, weight 3.0
</pre></div>


<p>with <code>combiner</code>="mean", then the output will be a 3x20 matrix where</p>
<div class="codehilite"><pre><span></span>output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)
output[1, :] = params[0, :] * 1.0
output[2, :] = params[1, :] * 3.0
</pre></div>


<p>Raises:
  TypeError: If sp_ids is not a SparseTensor, or if sp_weights is neither
    None nor SparseTensor.
  ValueError: If combiner is not one of {"mean", "sqrtn", "sum"}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer">
    <p>def <span class="ident">embedding_lookup_sparse_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_sparse_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.embedding_lookup_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.embedding_lookup_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_sparse_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup_sparse`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.embedding_lookup_sparse</strong></p>
<div class="codehilite"><pre><span></span>Computes embeddings for the given ids and weights.
</pre></div>


<p>This op assumes that there is at least one id for each row in the dense tensor
represented by sp_ids (i.e. there are no rows with empty features), and that
all the indices of sp_ids are in canonical row-major order.</p>
<p>It also assumes that all id values lie in the range [0, p0), where p0
is the sum of the size of params along dimension 0.</p>
<p>Args:
  params: A single tensor representing the complete embedding tensor,
    or a list of P tensors all of same shape except for the first dimension,
    representing sharded embedding tensors.  Alternatively, a
    <code>PartitionedVariable</code>, created by partitioning along dimension 0.
  sp_ids: N x M SparseTensor of int64 ids (typically from FeatureValueToId),
    where N is typically batch size and M is arbitrary.
  sp_weights: either a SparseTensor of float / double weights, or None to
    indicate all weights should be taken to be 1. If specified, sp_weights
    must have exactly the same shape and indices as sp_ids.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: Optional name for the op.
  combiner: A string specifying the reduction op. Currently "mean", "sqrtn"
    and "sum" are supported.
    "sum" computes the weighted sum of the embedding results for each row.
    "mean" is the weighted sum divided by the total weight.
    "sqrtn" is the weighted sum divided by the square root of the sum of the
    squares of the weights.
  max_norm: If not None, each embedding is normalized to have l2 norm equal
    to max_norm before combining.</p>
<p>Returns:
  A dense tensor representing the combined embeddings for the
  sparse ids. For each row in the dense tensor represented by sp_ids, the op
  looks up the embeddings for all ids in that row, multiplies them by the
  corresponding weight, and combines these embeddings as specified.</p>
<p>In other words, if</p>
<div class="codehilite"><pre><span></span>shape(combined params) = [p0, p1, ..., pm]
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>shape(sp_ids) = shape(sp_weights) = [d0, d1, ..., dn]
</pre></div>


<p>then</p>
<div class="codehilite"><pre><span></span>shape(output) = [d0, d1, ..., dn-1, p1, ..., pm].
</pre></div>


<p>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</p>
<div class="codehilite"><pre><span></span>[0, 0]: id 1, weight 2.0
[0, 1]: id 3, weight 0.5
[1, 0]: id 0, weight 1.0
[2, 3]: id 1, weight 3.0
</pre></div>


<p>with <code>combiner</code>="mean", then the output will be a 3x20 matrix where</p>
<div class="codehilite"><pre><span></span>output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)
output[1, :] = params[0, :] * 1.0
output[2, :] = params[1, :] * 3.0
</pre></div>


<p>Raises:
  TypeError: If sp_ids is not a SparseTensor, or if sp_weights is neither
    None nor SparseTensor.
  ValueError: If combiner is not one of {"mean", "sqrtn", "sum"}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer">
    <p>def <span class="ident">embedding_lookup_sparse_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_sparse_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.embedding_lookup_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.embedding_lookup_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.embedding_lookup_sparse_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.embedding_lookup_sparse`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.embedding_lookup_sparse</strong></p>
<div class="codehilite"><pre><span></span>Computes embeddings for the given ids and weights.
</pre></div>


<p>This op assumes that there is at least one id for each row in the dense tensor
represented by sp_ids (i.e. there are no rows with empty features), and that
all the indices of sp_ids are in canonical row-major order.</p>
<p>It also assumes that all id values lie in the range [0, p0), where p0
is the sum of the size of params along dimension 0.</p>
<p>Args:
  params: A single tensor representing the complete embedding tensor,
    or a list of P tensors all of same shape except for the first dimension,
    representing sharded embedding tensors.  Alternatively, a
    <code>PartitionedVariable</code>, created by partitioning along dimension 0.
  sp_ids: N x M SparseTensor of int64 ids (typically from FeatureValueToId),
    where N is typically batch size and M is arbitrary.
  sp_weights: either a SparseTensor of float / double weights, or None to
    indicate all weights should be taken to be 1. If specified, sp_weights
    must have exactly the same shape and indices as sp_ids.
  partition_strategy: A string specifying the partitioning strategy, relevant
    if <code>len(params) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported. Default
    is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: Optional name for the op.
  combiner: A string specifying the reduction op. Currently "mean", "sqrtn"
    and "sum" are supported.
    "sum" computes the weighted sum of the embedding results for each row.
    "mean" is the weighted sum divided by the total weight.
    "sqrtn" is the weighted sum divided by the square root of the sum of the
    squares of the weights.
  max_norm: If not None, each embedding is normalized to have l2 norm equal
    to max_norm before combining.</p>
<p>Returns:
  A dense tensor representing the combined embeddings for the
  sparse ids. For each row in the dense tensor represented by sp_ids, the op
  looks up the embeddings for all ids in that row, multiplies them by the
  corresponding weight, and combines these embeddings as specified.</p>
<p>In other words, if</p>
<div class="codehilite"><pre><span></span>shape(combined params) = [p0, p1, ..., pm]
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>shape(sp_ids) = shape(sp_weights) = [d0, d1, ..., dn]
</pre></div>


<p>then</p>
<div class="codehilite"><pre><span></span>shape(output) = [d0, d1, ..., dn-1, p1, ..., pm].
</pre></div>


<p>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</p>
<div class="codehilite"><pre><span></span>[0, 0]: id 1, weight 2.0
[0, 1]: id 3, weight 0.5
[1, 0]: id 0, weight 1.0
[2, 3]: id 1, weight 3.0
</pre></div>


<p>with <code>combiner</code>="mean", then the output will be a 3x20 matrix where</p>
<div class="codehilite"><pre><span></span>output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)
output[1, :] = params[0, :] * 1.0
output[2, :] = params[1, :] * 3.0
</pre></div>


<p>Raises:
  TypeError: If sp_ids is not a SparseTensor, or if sp_weights is neither
    None nor SparseTensor.
  ValueError: If combiner is not one of {"mean", "sqrtn", "sum"}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.embedding_lookup_sparse_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.encode_base64">
    <p>def <span class="ident">encode_base64</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.encode_base64(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.encode_base64</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.encode_base64(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.encode_base64(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.encode_base64</strong></p>
<div class="codehilite"><pre><span></span>Encode strings into web-safe base64 format.
</pre></div>


<p>Refer to the following article for more information on base64 format:
en.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the
end so that the encoded has length multiple of 4. See Padding section of the
link above.</p>
<p>Web-safe means that the encoder uses - and _ instead of + and /.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. Strings to be encoded.
  pad: An optional <code>bool</code>. Defaults to <code>False</code>.
    Bool whether padding is applied at the ends.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. Input strings encoded in base64.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.encode_base64', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.encode_base64" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ensamble_dropout">
    <p>def <span class="ident">ensamble_dropout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ensamble_dropout(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderensamble_dropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuilderensamble_dropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ensamble_dropout(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorbuilderensamble_dropout</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ensamble_dropout', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ensamble_dropout" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.equal">
    <p>def <span class="ident">equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x == y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Equal</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>quint8</code>, <code>qint8</code>, <code>qint32</code>, <code>string</code>, <code>bool</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erf">
    <p>def <span class="ident">erf</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erf(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.erf</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.erf(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erf(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.erf</strong></p>
<div class="codehilite"><pre><span></span>Computes the Gauss error function of `x` element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> of <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erf', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erf" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erfc">
    <p>def <span class="ident">erfc</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erfc(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.erfc</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.erfc(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erfc(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.erfc</strong></p>
<div class="codehilite"><pre><span></span>Computes the complementary error function of `x` element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erfc', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erfc" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erosion2d">
    <p>def <span class="ident">erosion2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erosion2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnerosion2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnerosion2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erosion2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnerosion2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale erosion of 4-D `value` and 3-D `kernel` tensors.
</pre></div>


<p>The <code>value</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>kernel</code> tensor has shape <code>[kernel_height, kernel_width, depth]</code>, i.e.,
each input channel is processed independently of the others with its own
structuring function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the
output tensor depend on the <code>padding</code> algorithm. We currently only support the
default "NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D erosion is given by:</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   min_{dy, dx} value[b,
                      strides[1] * y - rates[1] * dy,
                      strides[2] * x - rates[2] * dx,
                      c] -
                kernel[dy, dx, c]
</pre></div>


<p>Duality: The erosion of <code>value</code> by the <code>kernel</code> is equal to the negation of
the dilation of <code>-value</code> by the reflected <code>kernel</code>.</p>
<p>Args:
  value: A <code>Tensor</code>. 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  kernel: A <code>Tensor</code>. Must have the same type as <code>value</code>.
    3-D with shape <code>[kernel_height, kernel_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional). If not specified "erosion2d"
    is used.</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>value</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
<p>Raises:
  ValueError: If the <code>value</code> depth does not match <code>kernel</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erosion2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erosion2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer">
    <p>def <span class="ident">erosion2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erosion2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.erosion2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.erosion2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erosion2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.erosion2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.erosion2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale erosion of 4-D `value` and 3-D `kernel` tensors.
</pre></div>


<p>The <code>value</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>kernel</code> tensor has shape <code>[kernel_height, kernel_width, depth]</code>, i.e.,
each input channel is processed independently of the others with its own
structuring function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the
output tensor depend on the <code>padding</code> algorithm. We currently only support the
default "NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D erosion is given by:</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   min_{dy, dx} value[b,
                      strides[1] * y - rates[1] * dy,
                      strides[2] * x - rates[2] * dx,
                      c] -
                kernel[dy, dx, c]
</pre></div>


<p>Duality: The erosion of <code>value</code> by the <code>kernel</code> is equal to the negation of
the dilation of <code>-value</code> by the reflected <code>kernel</code>.</p>
<p>Args:
  value: A <code>Tensor</code>. 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  kernel: A <code>Tensor</code>. Must have the same type as <code>value</code>.
    3-D with shape <code>[kernel_height, kernel_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional). If not specified "erosion2d"
    is used.</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>value</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
<p>Raises:
  ValueError: If the <code>value</code> depth does not match <code>kernel</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erosion2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.erosion2d_layer">
    <p>def <span class="ident">erosion2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erosion2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.erosion2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.erosion2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.erosion2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.erosion2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.erosion2d</strong></p>
<div class="codehilite"><pre><span></span>Computes the grayscale erosion of 4-D `value` and 3-D `kernel` tensors.
</pre></div>


<p>The <code>value</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>kernel</code> tensor has shape <code>[kernel_height, kernel_width, depth]</code>, i.e.,
each input channel is processed independently of the others with its own
structuring function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the
output tensor depend on the <code>padding</code> algorithm. We currently only support the
default "NHWC" <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D erosion is given by:</p>
<div class="codehilite"><pre><span></span>output[b, y, x, c] =
   min_{dy, dx} value[b,
                      strides[1] * y - rates[1] * dy,
                      strides[2] * x - rates[2] * dx,
                      c] -
                kernel[dy, dx, c]
</pre></div>


<p>Duality: The erosion of <code>value</code> by the <code>kernel</code> is equal to the negation of
the dilation of <code>-value</code> by the reflected <code>kernel</code>.</p>
<p>Args:
  value: A <code>Tensor</code>. 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
  kernel: A <code>Tensor</code>. Must have the same type as <code>value</code>.
    3-D with shape <code>[kernel_height, kernel_width, depth]</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The stride of the sliding window for each dimension of
    the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. The input stride for atrous morphological dilation.
    Must be: <code>[1, rate_height, rate_width, 1]</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional). If not specified "erosion2d"
    is used.</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>value</code>.
  4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
<p>Raises:
  ValueError: If the <code>value</code> depth does not match <code>kernel</code>' shape, or if
    padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.erosion2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.erosion2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.exp">
    <p>def <span class="ident">exp</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.exp(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.exp</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.exp(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.exp(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.exp</strong></p>
<div class="codehilite"><pre><span></span>Computes exponential of x element-wise.  \\(y = e^x\\).
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.exp', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.exp" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.expand_dims">
    <p>def <span class="ident">expand_dims</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.expand_dims(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.expand_dims</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.expand_dims(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.expand_dims(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.expand_dims</strong></p>
<div class="codehilite"><pre><span></span>Inserts a axisension of 1 into a tensor&#39;s shape.
</pre></div>


<p>Given a tensor <code>input</code>, this operation inserts a axisension of 1 at the
axisension index <code>axis</code> of <code>input</code>'s shape. The axisension index <code>axis</code> starts at
zero; if you specify a negative number for <code>axis</code> it is counted backward from
the end.</p>
<p>This operation is useful if you want to add a batch axisension to a single
element. For example, if you have a single image of shape <code>[height, width,
channels]</code>, you can make it a batch of 1 image with <code>expand_axiss(image, 0)</code>,
which will make the shape <code>[1, height, width, channels]</code>.</p>
<p>Other examples:</p>
<p>```prettyprint</p>
<h1>'t' is a tensor of shape [2]</h1>
<p>shape(expand_axiss(t, 0)) ==&gt; [1, 2]
shape(expand_axiss(t, 1)) ==&gt; [2, 1]
shape(expand_axiss(t, -1)) ==&gt; [2, 1]</p>
<h1>'t2' is a tensor of shape [2, 3, 5]</h1>
<p>shape(expand_axiss(t2, 0)) ==&gt; [1, 2, 3, 5]
shape(expand_axiss(t2, 2)) ==&gt; [2, 3, 1, 5]
shape(expand_axiss(t2, 3)) ==&gt; [2, 3, 5, 1]
```</p>
<p>This operation requires that:</p>
<p><code>-1-input.axiss() &lt;= axis &lt;= input.axiss()</code></p>
<p>This operation is related to <code>squeeze()</code>, which removes axisensions of
size 1.</p>
<p>Args:
  input: A <code>Tensor</code>.
  axis: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    0-D (scalar). Specifies the axisension index at which to
    expand the shape of <code>input</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Contains the same data as <code>input</code>, but its shape has an additional
  axisension of size 1 added.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.expand_dims', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.expand_dims" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.extract_image_patches">
    <p>def <span class="ident">extract_image_patches</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.extract_image_patches(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.extract_image_patches</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.extract_image_patches(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.extract_image_patches(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.extract_image_patches</strong></p>
<div class="codehilite"><pre><span></span>Extract `patches` from `images` and put them in the &quot;depth&quot; output dimension.
</pre></div>


<p>Args:
  images: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
    4-D Tensor with shape <code>[batch, in_rows, in_cols, depth]</code>.
  ksizes: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The size of the sliding window for each dimension of <code>images</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. How far the centers of two consecutive patches are in
    the images. Must be: <code>[1, stride_rows, stride_cols, 1]</code>.
  rates: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    1-D of length 4. Must be: <code>[1, rate_rows, rate_cols, 1]</code>. This is the
    input stride, specifying how far two consecutive patch samples are in the
    input. Equivalent to extracting patches with
    <code>patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)</code>, followed by
    subsampling them spatially by a factor of <code>rates</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.</p>
<div class="codehilite"><pre><span></span>We specify the size-related attributes as:

```python
      ksizes = [1, ksize_rows, ksize_cols, 1]
      strides = [1, strides_rows, strides_cols, 1]
      rates = [1, rates_rows, rates_cols, 1]
```
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>images</code>.
  4-D Tensor with shape <code>[batch, out_rows, out_cols, ksize_rows *
  ksize_cols * depth]</code> containing image patches with size
  <code>ksize_rows x ksize_cols x depth</code> vectorized in the "depth" dimension.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.extract_image_patches', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.extract_image_patches" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.eye">
    <p>def <span class="ident">eye</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.eye(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.eye</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.eye(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.eye(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.eye</strong></p>
<div class="codehilite"><pre><span></span>Construct an identity matrix, or a batch of matrices.
</pre></div>


<p>```python</p>
<h1>Construct one identity matrix.</h1>
<p>tf.eye(2)
==&gt; [[1., 0.],
     [0., 1.]]</p>
<h1>Construct a batch of 3 identity matricies, each 2 x 2.</h1>
<h1>batch_identity[i, :, :] is a 2 x 2 identity matrix, i = 0, 1, 2.</h1>
<p>batch_identity = tf.eye(2, batch_shape=[3])</p>
<h1>Construct one 2 x 3 "identity" matrix</h1>
<p>tf.eye(2, num_columns=3)
==&gt; [[ 1.,  0.,  0.],
     [ 0.,  1.,  0.]]
```</p>
<p>Args:
  num_rows: Non-negative <code>int32</code> scalar <code>Tensor</code> giving the number of rows
    in each batch matrix.
  num_columns: Optional non-negative <code>int32</code> scalar <code>Tensor</code> giving the number
    of columns in each batch matrix.  Defaults to <code>num_rows</code>.
  batch_shape:  <code>int32</code> <code>Tensor</code>.  If provided, returned <code>Tensor</code> will have
    leading batch dimensions of this shape.
  dtype:  The type of an element in the resulting <code>Tensor</code>
  name:  A name for this <code>Op</code>.  Defaults to "eye".</p>
<p>Returns:
  A <code>Tensor</code> of shape <code>batch_shape + [num_rows, num_columns]</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.eye', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.eye" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args">
    <p>def <span class="ident">fake_quant_with_min_max_args</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_args(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fake_quant_with_min_max_args</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fake_quant_with_min_max_args(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_args(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fake_quant_with_min_max_args</strong></p>
<div class="codehilite"><pre><span></span>Fake-quantize the &#39;inputs&#39; tensor, type float to &#39;outputs&#39; tensor of same type.
</pre></div>


<p>Attributes [min; max] define the clamping range for the 'inputs' data.  Op
divides this range into 255 steps (total of 256 values), then replaces each
'inputs' value with the closest of the quantized step values.</p>
<p>Quantization is called fake since the output is still in floating point.</p>
<p>Args:
  inputs: A <code>Tensor</code> of type <code>float32</code>.
  min: An optional <code>float</code>. Defaults to <code>-6</code>.
  max: An optional <code>float</code>. Defaults to <code>6</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args_gradient">
    <p>def <span class="ident">fake_quant_with_min_max_args_gradient</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_args_gradient(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fake_quant_with_min_max_args_gradient</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fake_quant_with_min_max_args_gradient(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_args_gradient(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fake_quant_with_min_max_args_gradient</strong></p>
<div class="codehilite"><pre><span></span>Compute gradients for a FakeQuantWithMinMaxArgs operation.
</pre></div>


<p>Args:
  gradients: A <code>Tensor</code> of type <code>float32</code>.
    Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.
  inputs: A <code>Tensor</code> of type <code>float32</code>.
    Values passed as inputs to the FakeQuantWithMinMaxArgs operation.
  min: An optional <code>float</code>. Defaults to <code>-6</code>.
  max: An optional <code>float</code>. Defaults to <code>6</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code>.
  Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:
  <code>gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args_gradient', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_args_gradient" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars">
    <p>def <span class="ident">fake_quant_with_min_max_vars</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fake_quant_with_min_max_vars</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fake_quant_with_min_max_vars(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fake_quant_with_min_max_vars</strong></p>
<div class="codehilite"><pre><span></span>Fake-quantize the &#39;inputs&#39; tensor of type float and shape `[b, h, w, d]` via
</pre></div>


<p>global float scalars <code>min</code> and <code>max</code> to 'outputs' tensor of same shape as
<code>inputs</code>.</p>
<p>[min; max] is the clamping range for the 'inputs' data.  Op divides this range
into 255 steps (total of 256 values), then replaces each 'inputs' value with the
closest of the quantized step values.</p>
<p>This operation has a gradient and thus allows for training <code>min</code> and <code>max</code> values.</p>
<p>Args:
  inputs: A <code>Tensor</code> of type <code>float32</code>.
  min: A <code>Tensor</code> of type <code>float32</code>.
  max: A <code>Tensor</code> of type <code>float32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_gradient">
    <p>def <span class="ident">fake_quant_with_min_max_vars_gradient</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars_gradient(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fake_quant_with_min_max_vars_gradient</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fake_quant_with_min_max_vars_gradient(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars_gradient(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fake_quant_with_min_max_vars_gradient</strong></p>
<div class="codehilite"><pre><span></span>Compute gradients for a FakeQuantWithMinMaxVars operation.
</pre></div>


<p>Args:
  gradients: A <code>Tensor</code> of type <code>float32</code>.
    Backpropagated gradients above the FakeQuantWithMinMaxVars operation.
  inputs: A <code>Tensor</code> of type <code>float32</code>.
    Values passed as inputs to the FakeQuantWithMinMaxVars operation.
    min, max: Quantization interval, scalar floats.
  min: A <code>Tensor</code> of type <code>float32</code>.
  max: A <code>Tensor</code> of type <code>float32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (backprops_wrt_input, backprop_wrt_min, backprop_wrt_max).
  backprops_wrt_input: A <code>Tensor</code> of type <code>float32</code>. Backpropagated gradients w.r.t. inputs:
    <code>gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)</code>.
  backprop_wrt_min: A <code>Tensor</code> of type <code>float32</code>. Backpropagated gradients w.r.t. min parameter:
    <code>sum(gradients * (inputs &lt; min))</code>.
  backprop_wrt_max: A <code>Tensor</code> of type <code>float32</code>. Backpropagated gradients w.r.t. max parameter:
    <code>sum(gradients * (inputs &gt; max))</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_gradient', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_gradient" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel">
    <p>def <span class="ident">fake_quant_with_min_max_vars_per_channel</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars_per_channel(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fake_quant_with_min_max_vars_per_channel</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fake_quant_with_min_max_vars_per_channel(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars_per_channel(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fake_quant_with_min_max_vars_per_channel</strong></p>
<div class="codehilite"><pre><span></span>Fake-quantize the &#39;inputs&#39; tensor of type float and one of the shapes: `[d]`,
</pre></div>


<p><code>[b, d]</code> <code>[b, h, w, d]</code> via per-channel floats <code>min</code> and <code>max</code> of shape <code>[d]</code>
to 'outputs' tensor of same shape as <code>inputs</code>.</p>
<p>[min; max] is the clamping range for the 'inputs' data in the corresponding
depth channel.  Op divides this range into 255 steps (total of 256 values), then
replaces each 'inputs' value with the closest of the quantized step values.</p>
<p>This operation has a gradient and thus allows for training <code>min</code> and <code>max</code> values.</p>
<p>Args:
  inputs: A <code>Tensor</code> of type <code>float32</code>.
  min: A <code>Tensor</code> of type <code>float32</code>.
  max: A <code>Tensor</code> of type <code>float32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel_gradient">
    <p>def <span class="ident">fake_quant_with_min_max_vars_per_channel_gradient</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars_per_channel_gradient(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fake_quant_with_min_max_vars_per_channel_gradient</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fake_quant_with_min_max_vars_per_channel_gradient(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fake_quant_with_min_max_vars_per_channel_gradient(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fake_quant_with_min_max_vars_per_channel_gradient</strong></p>
<div class="codehilite"><pre><span></span>Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.
</pre></div>


<p>Args:
  gradients: A <code>Tensor</code> of type <code>float32</code>.
    Backpropagated gradients above the FakeQuantWithMinMaxVars operation,
    shape one of: <code>[d]</code>, <code>[b, d]</code>,  <code>[b, h, w, d]</code>.
  inputs: A <code>Tensor</code> of type <code>float32</code>.
    Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape
      same as <code>gradients</code>.
    min, max: Quantization interval, floats of shape <code>[d]</code>.
  min: A <code>Tensor</code> of type <code>float32</code>.
  max: A <code>Tensor</code> of type <code>float32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (backprops_wrt_input, backprop_wrt_min, backprop_wrt_max).
  backprops_wrt_input: A <code>Tensor</code> of type <code>float32</code>. Backpropagated gradients w.r.t. inputs, shape same as
    <code>inputs</code>:
      <code>gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)</code>.
  backprop_wrt_min: A <code>Tensor</code> of type <code>float32</code>. Backpropagated gradients w.r.t. min parameter, shape <code>[d]</code>:
    <code>sum_per_d(gradients * (inputs &lt; min))</code>.
  backprop_wrt_max: A <code>Tensor</code> of type <code>float32</code>. Backpropagated gradients w.r.t. max parameter, shape <code>[d]</code>:
    <code>sum_per_d(gradients * (inputs &gt; max))</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel_gradient', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fake_quant_with_min_max_vars_per_channel_gradient" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fft">
    <p>def <span class="ident">fft</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fft(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fft</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fft(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fft(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fft</strong></p>
<div class="codehilite"><pre><span></span>Compute the 1-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>dimension of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most
  dimension of <code>input</code> is replaced with its 1D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fft', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fft" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fft2d">
    <p>def <span class="ident">fft2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fft2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fft2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fft2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fft2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fft2d</strong></p>
<div class="codehilite"><pre><span></span>Compute the 2-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>2 dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 2
    dimensions of <code>input</code> are replaced with their 2D Fourier Transform.</p>
<p>@compatibility(numpy)
  Equivalent to np.fft2
  @end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fft2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fft2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fft3d">
    <p>def <span class="ident">fft3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fft3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fft3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fft3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fft3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fft3d</strong></p>
<div class="codehilite"><pre><span></span>Compute the 3-dimensional discrete Fourier Transform over the inner-most 3
</pre></div>


<p>dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
    dimensions of <code>input</code> are replaced with their 3D Fourier Transform.</p>
<p>@compatibility(numpy)
  Equivalent to np.fft3
  @end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fft3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fft3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fill">
    <p>def <span class="ident">fill</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fill(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fill</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fill(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fill(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fill</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor filled with a scalar value.
</pre></div>


<p>This operation creates a tensor of shape <code>dims</code> and fills it with <code>value</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>Output tensor has shape [2, 3].</h1>
<p>fill([2, 3], 9) ==&gt; [[9, 9, 9]
                     [9, 9, 9]]
```</p>
<p>Args:
  dims: A <code>Tensor</code> of type <code>int32</code>.
    1-D. Represents the shape of the output tensor.
  value: A <code>Tensor</code>. 0-D (scalar). Value to fill the returned tensor.</p>
<div class="codehilite"><pre><span></span><span class="p">@</span><span class="n">compatibility</span><span class="p">(</span><span class="n">numpy</span><span class="p">)</span>
<span class="n">Equivalent</span> <span class="n">to</span> <span class="n">np</span><span class="p">.</span><span class="n">full</span>
<span class="p">@</span><span class="n">end_compatibility</span>
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fill', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fill" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_size_partitioner">
    <p>def <span class="ident">fixed_size_partitioner</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_size_partitioner(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.fixed_size_partitioner</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.fixed_size_partitioner(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_size_partitioner(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.fixed_size_partitioner</strong></p>
<div class="codehilite"><pre><span></span>Partitioner to specify a fixed number of shards along given axis.
</pre></div>


<p>Args:
  num_shards: <code>int</code>, number of shards to partition variable.
  axis: <code>int</code>, axis to partition on.</p>
<p>Returns:
  A partition function usable as the <code>partitioner</code> argument to
  <code>variable_scope</code>, <code>get_variable</code>, and <code>get_partitioned_variable_list</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_size_partitioner', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_size_partitioner" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler">
    <p>def <span class="ident">fixed_unigram_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_unigram_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfixed_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfixed_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_unigram_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfixed_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using the provided (fixed) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution is read from a file or passed in as an
in-memory array. There is also an option to skew the distribution by
applying a distortion power to the weights.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  vocab_file: Each valid line in this file (which should have a CSV-like
    format) corresponds to a valid word ID. IDs are in sequential order,
    starting from num_reserved_ids. The last entry in each line is expected
    to be a value corresponding to the count or relative probability. Exactly
    one of <code>vocab_file</code> and <code>unigrams</code> needs to be passed to this operation.
  distortion: The distortion is used to skew the unigram probability
    distribution.  Each weight is first raised to the distortion's power
    before adding to the internal unigram distribution. As a result,
    <code>distortion = 1.0</code> gives regular unigram sampling (as defined by the vocab
    file), and <code>distortion = 0.0</code> gives a uniform distribution.
  num_reserved_ids: Optionally some reserved IDs can be added in the range
    <code>[0, num_reserved_ids]</code> by the users. One use case is that a special
    unknown word token is used as ID 0. These IDs will have a sampling
    probability of 0.
  num_shards: A sampler can be used to sample from a subset of the original
    range in order to speed up the whole computation through parallelism. This
    parameter (together with <code>shard</code>) indicates the number of partitions that
    are being used in the overall computation.
  shard: A sampler can be used to sample from a subset of the original range
    in order to speed up the whole computation through parallelism. This
    parameter (together with <code>num_shards</code>) indicates the particular partition
    number of the operation, when partitioning is being used.
  unigrams: A list of unigram counts or probabilities, one per ID in
    sequential order. Exactly one of <code>vocab_file</code> and <code>unigrams</code> should be
    passed to this operation.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">fixed_unigram_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fixed_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fixed_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fixed_unigram_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fixed_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using the provided (fixed) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution is read from a file or passed in as an
in-memory array. There is also an option to skew the distribution by
applying a distortion power to the weights.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  vocab_file: Each valid line in this file (which should have a CSV-like
    format) corresponds to a valid word ID. IDs are in sequential order,
    starting from num_reserved_ids. The last entry in each line is expected
    to be a value corresponding to the count or relative probability. Exactly
    one of <code>vocab_file</code> and <code>unigrams</code> needs to be passed to this operation.
  distortion: The distortion is used to skew the unigram probability
    distribution.  Each weight is first raised to the distortion's power
    before adding to the internal unigram distribution. As a result,
    <code>distortion = 1.0</code> gives regular unigram sampling (as defined by the vocab
    file), and <code>distortion = 0.0</code> gives a uniform distribution.
  num_reserved_ids: Optionally some reserved IDs can be added in the range
    <code>[0, num_reserved_ids]</code> by the users. One use case is that a special
    unknown word token is used as ID 0. These IDs will have a sampling
    probability of 0.
  num_shards: A sampler can be used to sample from a subset of the original
    range in order to speed up the whole computation through parallelism. This
    parameter (together with <code>shard</code>) indicates the number of partitions that
    are being used in the overall computation.
  shard: A sampler can be used to sample from a subset of the original range
    in order to speed up the whole computation through parallelism. This
    parameter (together with <code>num_shards</code>) indicates the particular partition
    number of the operation, when partitioning is being used.
  unigrams: A list of unigram counts or probabilities, one per ID in
    sequential order. Exactly one of <code>vocab_file</code> and <code>unigrams</code> should be
    passed to this operation.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer">
    <p>def <span class="ident">fixed_unigram_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_unigram_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fixed_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fixed_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fixed_unigram_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fixed_unigram_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fixed_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using the provided (fixed) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution is read from a file or passed in as an
in-memory array. There is also an option to skew the distribution by
applying a distortion power to the weights.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  vocab_file: Each valid line in this file (which should have a CSV-like
    format) corresponds to a valid word ID. IDs are in sequential order,
    starting from num_reserved_ids. The last entry in each line is expected
    to be a value corresponding to the count or relative probability. Exactly
    one of <code>vocab_file</code> and <code>unigrams</code> needs to be passed to this operation.
  distortion: The distortion is used to skew the unigram probability
    distribution.  Each weight is first raised to the distortion's power
    before adding to the internal unigram distribution. As a result,
    <code>distortion = 1.0</code> gives regular unigram sampling (as defined by the vocab
    file), and <code>distortion = 0.0</code> gives a uniform distribution.
  num_reserved_ids: Optionally some reserved IDs can be added in the range
    <code>[0, num_reserved_ids]</code> by the users. One use case is that a special
    unknown word token is used as ID 0. These IDs will have a sampling
    probability of 0.
  num_shards: A sampler can be used to sample from a subset of the original
    range in order to speed up the whole computation through parallelism. This
    parameter (together with <code>shard</code>) indicates the number of partitions that
    are being used in the overall computation.
  shard: A sampler can be used to sample from a subset of the original range
    in order to speed up the whole computation through parallelism. This
    parameter (together with <code>num_shards</code>) indicates the particular partition
    number of the operation, when partitioning is being used.
  unigrams: A list of unigram counts or probabilities, one per ID in
    sequential order. Exactly one of <code>vocab_file</code> and <code>unigrams</code> should be
    passed to this operation.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fixed_unigram_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.flatten">
    <p>def <span class="ident">flatten</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.flatten(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersflatten</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersflatten(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.flatten(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersflatten</strong></p>
<div class="codehilite"><pre><span></span>Flattens the input while maintaining the batch_size.
</pre></div>


<p>Assumes that the first dimension represents the batch.</p>
<p>Args:
  inputs: a tensor of size [batch_size, ...].
  outputs_collections: collection to add the outputs.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  a flattened tensor with shape [batch_size, k].
Raises:
  ValueError: if inputs.shape is wrong.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.flatten', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.flatten" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.floor">
    <p>def <span class="ident">floor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.floor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.floor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.floor</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise largest integer not greater than x.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.floor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.floor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.floor_div">
    <p>def <span class="ident">floor_div</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floor_div(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.floor_div</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.floor_div(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floor_div(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.floor_div</strong></p>
<div class="codehilite"><pre><span></span>Returns x // y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>FloorDiv</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.floor_div', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.floor_div" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.floordiv">
    <p>def <span class="ident">floordiv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floordiv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.floordiv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.floordiv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floordiv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.floordiv</strong></p>
<div class="codehilite"><pre><span></span>Divides `x / y` elementwise, rounding toward the most negative integer.
</pre></div>


<p>The same as <code>tf.div(x,y)</code> for integers, but uses <code>tf.floor(tf.div(x,y))</code> for
floating point arguments so that the result is always an integer (though
possibly an integer represented as floating point).  This op is generated by
<code>x // y</code> floor division in Python 3 and in Python 2.7 with
<code>from __future__ import division</code>.</p>
<p>Note that for efficiency, <code>floordiv</code> uses C semantics for negative numbers
(unlike Python and Numpy).</p>
<p><code>x</code> and <code>y</code> must have the same type, and the result will have the same type
as well.</p>
<p>Args:
  x: <code>Tensor</code> numerator of real numeric type.
  y: <code>Tensor</code> denominator of real numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>x / y</code> rounded down (except possibly towards zero for negative integers).</p>
<p>Raises:
  TypeError: If the inputs are complex.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.floordiv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.floordiv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.floormod">
    <p>def <span class="ident">floormod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floormod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.floormod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.floormod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.floormod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.floormod</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise remainder of division. When `x &lt; 0` xor `y &lt; 0` is
</pre></div>


<p>true, this follows Python semantics in that the result here is consistent
with a flooring divide. E.g. <code>floor(x / y) * y + mod(x, y) = x</code>.</p>
<p><em>NOTE</em>: <code>FloorMod</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>, <code>float32</code>, <code>float64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.floormod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.floormod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.foldl">
    <p>def <span class="ident">foldl</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.foldl(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.foldl</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.foldl(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.foldl(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.foldl</strong></p>
<div class="codehilite"><pre><span></span>foldl on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>This foldl operator repeatedly applies the callable <code>fn</code> to a sequence
of elements from first to last. The elements are made of the tensors
unpacked from <code>elems</code> on dimension 0. The callable fn takes two tensors as
arguments. The first argument is the accumulated value computed from the
preceding invocation of fn. If <code>initializer</code> is None, <code>elems</code> must contain
at least one element, and its first element is used as the initializer.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is fn(initializer, values[0]).shape`.</p>
<p>Args:
  fn: The callable to be performed.
  elems: A tensor to be unpacked on dimension 0.
  initializer: (optional) The initial value for the accumulator.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor resulting from applying <code>fn</code> consecutively to the list of tensors
  unpacked from <code>elems</code>, from first to last.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable.</p>
<p>Example:
  <code>python
  elems = [1, 2, 3, 4, 5, 6]
  sum = foldl(lambda a, x: a + x, elems)
  # sum == 21</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.foldl', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.foldl" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.foldr">
    <p>def <span class="ident">foldr</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.foldr(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.foldr</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.foldr(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.foldr(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.foldr</strong></p>
<div class="codehilite"><pre><span></span>foldr on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>This foldr operator repeatedly applies the callable <code>fn</code> to a sequence
of elements from last to first. The elements are made of the tensors
unpacked from <code>elems</code>. The callable fn takes two tensors as arguments.
The first argument is the accumulated value computed from the preceding
invocation of fn. If <code>initializer</code> is None, <code>elems</code> must contain at least
one element, and its first element is used as the initializer.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is <code>fn(initializer, values[0]).shape</code>.</p>
<p>Args:
  fn: The callable to be performed.
  elems: A tensor that is unpacked into a sequence of tensors to apply <code>fn</code>.
  initializer: (optional) The initial value for the accumulator.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor resulting from applying <code>fn</code> consecutively to the list of tensors
  unpacked from <code>elems</code>, from last to first.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable.</p>
<p>Example:
  <code>python
  elems = [1, 2, 3, 4, 5, 6]
  sum = foldr(lambda a, x: a + x, elems)
  # sum == 21</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.foldr', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.foldr" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_avg_pool">
    <p>def <span class="ident">fractional_avg_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_avg_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfractional_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfractional_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_avg_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfractional_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional average pooling on the input.
</pre></div>


<p>Fractional average pooling is similar to Fractional max pooling in the pooling
region generation step. The only difference is that after pooling regions are
generated, a mean operation is performed instead of a max operation in each
pooling region.</p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
    Graham, Fractional Max-Pooling</a> for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [41/3, 26/3] for fractional avg pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalAvgPool node in the computation graph. Mainly used
    in unit test to make FractionalAvgPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional avg pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer">
    <p>def <span class="ident">fractional_avg_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_avg_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fractional_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fractional_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_avg_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_avg_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fractional_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional average pooling on the input.
</pre></div>


<p>Fractional average pooling is similar to Fractional max pooling in the pooling
region generation step. The only difference is that after pooling regions are
generated, a mean operation is performed instead of a max operation in each
pooling region.</p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
    Graham, Fractional Max-Pooling</a> for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [41/3, 26/3] for fractional avg pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalAvgPool node in the computation graph. Mainly used
    in unit test to make FractionalAvgPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional avg pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer">
    <p>def <span class="ident">fractional_avg_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_avg_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fractional_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fractional_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_avg_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_avg_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fractional_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional average pooling on the input.
</pre></div>


<p>Fractional average pooling is similar to Fractional max pooling in the pooling
region generation step. The only difference is that after pooling regions are
generated, a mean operation is performed instead of a max operation in each
pooling region.</p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
    Graham, Fractional Max-Pooling</a> for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [41/3, 26/3] for fractional avg pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalAvgPool node in the computation graph. Mainly used
    in unit test to make FractionalAvgPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional avg pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_avg_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_max_pool">
    <p>def <span class="ident">fractional_max_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_max_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfractional_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfractional_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_max_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfractional_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional max pooling on the input.
</pre></div>


<p>Fractional max pooling is slightly different than regular max pooling.  In
regular max pooling, you downsize an input set by taking the maximum value of
smaller N x N subsections of the set (often 2x2), and try to reduce the set by
a factor of N, where N is an integer.  Fractional max pooling, as you might
expect from the word "fractional", means that the overall reduction ratio N
does not have to be an integer.</p>
<p>The sizes of the pooling regions are generated randomly but are fairly uniform.
For example, let's look at the height dimension, and the constraints on the
list of rows that will be pool boundaries.</p>
<p>First we define the following:</p>
<ol>
<li>input_row_length : the number of rows from the input set</li>
<li>output_row_length : which will be smaller than the input</li>
<li>alpha = input_row_length / output_row_length : our reduction ratio</li>
<li>K = floor(alpha)</li>
<li>row_pooling_sequence : this is the result list of pool boundary rows</li>
</ol>
<p>Then, row_pooling_sequence should satisfy:</p>
<ol>
<li>a[0] = 0 : the first value of the sequence is 0</li>
<li>a[end] = input_row_length : the last value of the sequence is the size</li>
<li>K &lt;= (a[i+1] - a[i]) &lt;= K+1 : all intervals are K or K+1 size</li>
<li>length(row_pooling_sequence) = output_row_length+1</li>
</ol>
<p>For more details on fractional max pooling, see this paper:
<a href="http://arxiv.org/abs/1412.6071">Benjamin Graham, Fractional Max-Pooling</a></p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
    Graham, Fractional Max-Pooling</a> for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [20, 16] for fractional max pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalMaxPool node in the computation graph. Mainly used
    in unit test to make FractionalMaxPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional max pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_max_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_max_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer">
    <p>def <span class="ident">fractional_max_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_max_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fractional_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fractional_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_max_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_max_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fractional_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional max pooling on the input.
</pre></div>


<p>Fractional max pooling is slightly different than regular max pooling.  In
regular max pooling, you downsize an input set by taking the maximum value of
smaller N x N subsections of the set (often 2x2), and try to reduce the set by
a factor of N, where N is an integer.  Fractional max pooling, as you might
expect from the word "fractional", means that the overall reduction ratio N
does not have to be an integer.</p>
<p>The sizes of the pooling regions are generated randomly but are fairly uniform.
For example, let's look at the height dimension, and the constraints on the
list of rows that will be pool boundaries.</p>
<p>First we define the following:</p>
<ol>
<li>input_row_length : the number of rows from the input set</li>
<li>output_row_length : which will be smaller than the input</li>
<li>alpha = input_row_length / output_row_length : our reduction ratio</li>
<li>K = floor(alpha)</li>
<li>row_pooling_sequence : this is the result list of pool boundary rows</li>
</ol>
<p>Then, row_pooling_sequence should satisfy:</p>
<ol>
<li>a[0] = 0 : the first value of the sequence is 0</li>
<li>a[end] = input_row_length : the last value of the sequence is the size</li>
<li>K &lt;= (a[i+1] - a[i]) &lt;= K+1 : all intervals are K or K+1 size</li>
<li>length(row_pooling_sequence) = output_row_length+1</li>
</ol>
<p>For more details on fractional max pooling, see this paper:
<a href="http://arxiv.org/abs/1412.6071">Benjamin Graham, Fractional Max-Pooling</a></p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
    Graham, Fractional Max-Pooling</a> for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [20, 16] for fractional max pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalMaxPool node in the computation graph. Mainly used
    in unit test to make FractionalMaxPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional max pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer">
    <p>def <span class="ident">fractional_max_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_max_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fractional_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fractional_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fractional_max_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fractional_max_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fractional_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs fractional max pooling on the input.
</pre></div>


<p>Fractional max pooling is slightly different than regular max pooling.  In
regular max pooling, you downsize an input set by taking the maximum value of
smaller N x N subsections of the set (often 2x2), and try to reduce the set by
a factor of N, where N is an integer.  Fractional max pooling, as you might
expect from the word "fractional", means that the overall reduction ratio N
does not have to be an integer.</p>
<p>The sizes of the pooling regions are generated randomly but are fairly uniform.
For example, let's look at the height dimension, and the constraints on the
list of rows that will be pool boundaries.</p>
<p>First we define the following:</p>
<ol>
<li>input_row_length : the number of rows from the input set</li>
<li>output_row_length : which will be smaller than the input</li>
<li>alpha = input_row_length / output_row_length : our reduction ratio</li>
<li>K = floor(alpha)</li>
<li>row_pooling_sequence : this is the result list of pool boundary rows</li>
</ol>
<p>Then, row_pooling_sequence should satisfy:</p>
<ol>
<li>a[0] = 0 : the first value of the sequence is 0</li>
<li>a[end] = input_row_length : the last value of the sequence is the size</li>
<li>K &lt;= (a[i+1] - a[i]) &lt;= K+1 : all intervals are K or K+1 size</li>
<li>length(row_pooling_sequence) = output_row_length+1</li>
</ol>
<p>For more details on fractional max pooling, see this paper:
<a href="http://arxiv.org/abs/1412.6071">Benjamin Graham, Fractional Max-Pooling</a></p>
<p>Args:
  value: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  pooling_ratio: A list of <code>floats</code> that has length <code>&gt;= 4</code>.
    Pooling ratio for each dimension of <code>value</code>, currently only
    supports row and col dimension and should be &gt;= 1.0. For example, a valid
    pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
    must be 1.0 because we don't allow pooling on batch and channels
    dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
    respectively.
  pseudo_random: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, generates the pooling sequence in a
    pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
    Graham, Fractional Max-Pooling</a> for
    difference between pseudorandom and random.
  overlapping: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, it means when pooling, the values at the boundary
    of adjacent pooling cells are used by both cells. For example:</p>
<div class="codehilite"><pre><span></span>`index  0  1  2  3  4`

`value  20 5  16 3  7`

If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
The result would be [20, 16] for fractional max pooling.
</pre></div>


<p>deterministic: An optional <code>bool</code>. Defaults to <code>False</code>.
    When set to True, a fixed pooling region will be used when
    iterating over a FractionalMaxPool node in the computation graph. Mainly used
    in unit test to make FractionalMaxPool deterministic.
  seed: An optional <code>int</code>. Defaults to <code>0</code>.
    If either seed or seed2 are set to be non-zero, the random number
    generator is seeded by the given seed.  Otherwise, it is seeded by a
    random seed.
  seed2: An optional <code>int</code>. Defaults to <code>0</code>.
    An second seed to avoid seed collision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).
  output: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional max pooling.
  row_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.
  col_pooling_sequence: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fractional_max_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_batch_norm">
    <p>def <span class="ident">fused_batch_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfused_batch_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfused_batch_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfused_batch_norm</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.</p>
<p>Args:
  x: Input <code>Tensor</code> of 4 dimensions.
  scale: A <code>Tensor</code> of 1 dimension for scaling.
  offset: A <code>Tensor</code> of 1 dimension for bias.
  mean: A <code>Tensor</code> of 1 dimension for population mean used for inference.
  variance: A <code>Tensor</code> of 1 dimension for population variance
            used for inference.
  epsilon: A small float number added to the variance of x.
  data_format: The data format for x. Either "NHWC" (default) or "NCHW".
  is_training: A bool value to specify if the operation is used for
               training or inference.
  name: A name for this operation (optional).</p>
<p>Returns:
  y: A 4D Tensor for the normalized, scaled, offsetted x.
  batch_mean: A 1D Tensor for the mean of x.
  batch_var: A 1D Tensor for the variance of x.</p>
<p>Raises:
  ValueError: If mean or variance is not None when is_training is True.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_batch_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_batch_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_batch_norm_conv2d_layer">
    <p>def <span class="ident">fused_batch_norm_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_batch_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_batch_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_batch_norm`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_batch_norm</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.</p>
<p>Args:
  x: Input <code>Tensor</code> of 4 dimensions.
  scale: A <code>Tensor</code> of 1 dimension for scaling.
  offset: A <code>Tensor</code> of 1 dimension for bias.
  mean: A <code>Tensor</code> of 1 dimension for population mean used for inference.
  variance: A <code>Tensor</code> of 1 dimension for population variance
            used for inference.
  epsilon: A small float number added to the variance of x.
  data_format: The data format for x. Either "NHWC" (default) or "NCHW".
  is_training: A bool value to specify if the operation is used for
               training or inference.
  name: A name for this operation (optional).</p>
<p>Returns:
  y: A 4D Tensor for the normalized, scaled, offsetted x.
  batch_mean: A 1D Tensor for the mean of x.
  batch_var: A 1D Tensor for the variance of x.</p>
<p>Raises:
  ValueError: If mean or variance is not None when is_training is True.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad">
    <p>def <span class="ident">fused_batch_norm_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfused_batch_norm_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfused_batch_norm_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfused_batch_norm_grad</strong></p>
<div class="codehilite"><pre><span></span>Gradient for batch normalization.
</pre></div>


<p>Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
<p>Args:
  y_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    A 4D Tensor for the gradient with respect to y.
  x: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 4D Tensor for input data.
  scale: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for scaling factor, to scale the normalized x.
  reserve_space_1: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for the computed batch mean, to be reused
    in the gradient computation.
  reserve_space_2: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for the computed batch variance (inverted variance
    in the cuDNN case), to be used in the gradient computation.
  epsilon: An optional <code>float</code>. Defaults to <code>0.0001</code>.
    A small float number added to the variance of x.
  data_format: An optional <code>string</code>. Defaults to <code>"NHWC"</code>.
    The data format for y_backprop, x, x_backprop.
    Either "NHWC" (default) or "NCHW".
  is_training: An optional <code>bool</code>. Defaults to <code>True</code>.
    A bool value to indicate the operation is for training (default)
    or inference.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4).
  x_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 4D Tensor for the gradient with respect to x.
  scale_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 1D Tensor for the gradient with respect to scale.
  offset_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 1D Tensor for the gradient with respect to offset.
  reserve_space_3: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. Unused placeholder to match the mean input in FusedBatchNorm.
  reserve_space_4: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. Unused placeholder to match the variance input
    in FusedBatchNorm.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_conv2d_layer">
    <p>def <span class="ident">fused_batch_norm_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_batch_norm_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_batch_norm_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_batch_norm_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_batch_norm_grad</strong></p>
<div class="codehilite"><pre><span></span>Gradient for batch normalization.
</pre></div>


<p>Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
<p>Args:
  y_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    A 4D Tensor for the gradient with respect to y.
  x: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 4D Tensor for input data.
  scale: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for scaling factor, to scale the normalized x.
  reserve_space_1: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for the computed batch mean, to be reused
    in the gradient computation.
  reserve_space_2: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for the computed batch variance (inverted variance
    in the cuDNN case), to be used in the gradient computation.
  epsilon: An optional <code>float</code>. Defaults to <code>0.0001</code>.
    A small float number added to the variance of x.
  data_format: An optional <code>string</code>. Defaults to <code>"NHWC"</code>.
    The data format for y_backprop, x, x_backprop.
    Either "NHWC" (default) or "NCHW".
  is_training: An optional <code>bool</code>. Defaults to <code>True</code>.
    A bool value to indicate the operation is for training (default)
    or inference.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4).
  x_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 4D Tensor for the gradient with respect to x.
  scale_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 1D Tensor for the gradient with respect to scale.
  offset_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 1D Tensor for the gradient with respect to offset.
  reserve_space_3: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. Unused placeholder to match the mean input in FusedBatchNorm.
  reserve_space_4: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. Unused placeholder to match the variance input
    in FusedBatchNorm.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_layer">
    <p>def <span class="ident">fused_batch_norm_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_batch_norm_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_batch_norm_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_batch_norm_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_batch_norm_grad</strong></p>
<div class="codehilite"><pre><span></span>Gradient for batch normalization.
</pre></div>


<p>Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
<p>Args:
  y_backprop: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    A 4D Tensor for the gradient with respect to y.
  x: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 4D Tensor for input data.
  scale: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for scaling factor, to scale the normalized x.
  reserve_space_1: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for the computed batch mean, to be reused
    in the gradient computation.
  reserve_space_2: A <code>Tensor</code>. Must have the same type as <code>y_backprop</code>.
    A 1D Tensor for the computed batch variance (inverted variance
    in the cuDNN case), to be used in the gradient computation.
  epsilon: An optional <code>float</code>. Defaults to <code>0.0001</code>.
    A small float number added to the variance of x.
  data_format: An optional <code>string</code>. Defaults to <code>"NHWC"</code>.
    The data format for y_backprop, x, x_backprop.
    Either "NHWC" (default) or "NCHW".
  is_training: An optional <code>bool</code>. Defaults to <code>True</code>.
    A bool value to indicate the operation is for training (default)
    or inference.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (x_backprop, scale_backprop, offset_backprop, reserve_space_3, reserve_space_4).
  x_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 4D Tensor for the gradient with respect to x.
  scale_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 1D Tensor for the gradient with respect to scale.
  offset_backprop: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. A 1D Tensor for the gradient with respect to offset.
  reserve_space_3: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. Unused placeholder to match the mean input in FusedBatchNorm.
  reserve_space_4: A <code>Tensor</code>. Has the same type as <code>y_backprop</code>. Unused placeholder to match the variance input
    in FusedBatchNorm.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_batch_norm_layer">
    <p>def <span class="ident">fused_batch_norm_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_batch_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_batch_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_batch_norm_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_batch_norm`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_batch_norm</strong></p>
<div class="codehilite"><pre><span></span>Batch normalization.
</pre></div>


<p>As described in http://arxiv.org/abs/1502.03167.</p>
<p>Args:
  x: Input <code>Tensor</code> of 4 dimensions.
  scale: A <code>Tensor</code> of 1 dimension for scaling.
  offset: A <code>Tensor</code> of 1 dimension for bias.
  mean: A <code>Tensor</code> of 1 dimension for population mean used for inference.
  variance: A <code>Tensor</code> of 1 dimension for population variance
            used for inference.
  epsilon: A small float number added to the variance of x.
  data_format: The data format for x. Either "NHWC" (default) or "NCHW".
  is_training: A bool value to specify if the operation is used for
               training or inference.
  name: A name for this operation (optional).</p>
<p>Returns:
  y: A 4D Tensor for the normalized, scaled, offsetted x.
  batch_mean: A 1D Tensor for the mean of x.
  batch_var: A 1D Tensor for the variance of x.</p>
<p>Raises:
  ValueError: If mean or variance is not None when is_training is True.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_batch_norm_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_pad_conv2d">
    <p>def <span class="ident">fused_pad_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_pad_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfused_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfused_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_pad_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfused_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a padding as a preprocess during a convolution.
</pre></div>


<p>Similar to FusedResizeAndPadConv2d, this op allows for an optimized
implementation where the spatial padding transformation stage is fused with the
im2col lookup, but in this case without the bilinear filtering required for
resizing. Fusing the padding prevents the need to write out the intermediate
results as whole tensors, reducing memory pressure, and we can get some latency
gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
order is used instead.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_pad_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_pad_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_conv2d_layer">
    <p>def <span class="ident">fused_pad_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_pad_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_pad_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_pad_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a padding as a preprocess during a convolution.
</pre></div>


<p>Similar to FusedResizeAndPadConv2d, this op allows for an optimized
implementation where the spatial padding transformation stage is fused with the
im2col lookup, but in this case without the bilinear filtering required for
resizing. Fusing the padding prevents the need to write out the intermediate
results as whole tensors, reducing memory pressure, and we can get some latency
gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
order is used instead.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_layer">
    <p>def <span class="ident">fused_pad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_pad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_pad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_pad_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a padding as a preprocess during a convolution.
</pre></div>


<p>Similar to FusedResizeAndPadConv2d, this op allows for an optimized
implementation where the spatial padding transformation stage is fused with the
im2col lookup, but in this case without the bilinear filtering required for
resizing. Fusing the padding prevents the need to write out the intermediate
results as whole tensors, reducing memory pressure, and we can get some latency
gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
order is used instead.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_pad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d">
    <p>def <span class="ident">fused_resize_and_pad_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_resize_and_pad_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnfused_resize_and_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnfused_resize_and_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_resize_and_pad_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnfused_resize_and_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a resize and padding as a preprocess during a convolution.
</pre></div>


<p>It's often possible to do spatial transformations more efficiently as part of
the packing stage of a convolution, so this op allows for an optimized
implementation where these stages are fused together. This prevents the need to
write out the intermediate results as whole tensors, reducing memory pressure,
and we can get some latency gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and defaults to
'NHWC' order.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  size: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
    new size for the images.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  resize_align_corners: An optional <code>bool</code>. Defaults to <code>False</code>.
    If true, rescale input by (new_height - 1) / (height - 1),
    which exactly aligns the 4 corners of images and resized images. If false, rescale
    by new_height / height. Treat similarly the width dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer">
    <p>def <span class="ident">fused_resize_and_pad_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_resize_and_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_resize_and_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_resize_and_pad_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_resize_and_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a resize and padding as a preprocess during a convolution.
</pre></div>


<p>It's often possible to do spatial transformations more efficiently as part of
the packing stage of a convolution, so this op allows for an optimized
implementation where these stages are fused together. This prevents the need to
write out the intermediate results as whole tensors, reducing memory pressure,
and we can get some latency gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and defaults to
'NHWC' order.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  size: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
    new size for the images.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  resize_align_corners: An optional <code>bool</code>. Defaults to <code>False</code>.
    If true, rescale input by (new_height - 1) / (height - 1),
    which exactly aligns the 4 corners of images and resized images. If false, rescale
    by new_height / height. Treat similarly the width dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer">
    <p>def <span class="ident">fused_resize_and_pad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_resize_and_pad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.fused_resize_and_pad_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.fused_resize_and_pad_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.fused_resize_and_pad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.fused_resize_and_pad_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.fused_resize_and_pad_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Performs a resize and padding as a preprocess during a convolution.
</pre></div>


<p>It's often possible to do spatial transformations more efficiently as part of
the packing stage of a convolution, so this op allows for an optimized
implementation where these stages are fused together. This prevents the need to
write out the intermediate results as whole tensors, reducing memory pressure,
and we can get some latency gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and defaults to
'NHWC' order.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
    4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
  size: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
    new size for the images.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
    A two-column matrix specifying the padding sizes. The number of
    rows must be the same as the rank of <code>input</code>.
  filter: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape
    <code>[filter_height, filter_width, in_channels, out_channels]</code>.
  mode: A <code>string</code> from: <code>"REFLECT", "SYMMETRIC"</code>.
  strides: A list of <code>ints</code>.
    1-D of length 4.  The stride of the sliding window for each dimension
    of <code>input</code>. Must be in the same order as the dimension specified with format.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  resize_align_corners: An optional <code>bool</code>. Defaults to <code>False</code>.
    If true, rescale input by (new_height - 1) / (height - 1),
    which exactly aligns the 4 corners of images and resized images. If false, rescale
    by new_height / height. Treat similarly the width dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.fused_resize_and_pad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.gather">
    <p>def <span class="ident">gather</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.gather(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.gather</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.gather(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.gather(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.gather</strong></p>
<div class="codehilite"><pre><span></span>Gather slices from `params` according to `indices`.
</pre></div>


<p><code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:</p>
<p>```python
    # Scalar indices
    output[:, ..., :] = params[indices, :, ... :]</p>
<div class="codehilite"><pre><span></span># Vector indices
output[i, :, ..., :] = params[indices[i], :, ... :]

# Higher rank indices
output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
</pre></div>


<p>```</p>
<p>If <code>indices</code> is a permutation and <code>len(indices) == params.shape[0]</code> then
this operation will permute <code>params</code> accordingly.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/Gather.png" alt>
</div>

<p>Args:
  params: A <code>Tensor</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
  validate_indices: An optional <code>bool</code>. Defaults to <code>True</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>params</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.gather', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.gather" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.gather_nd">
    <p>def <span class="ident">gather_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.gather_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.gather_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.gather_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.gather_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.gather_nd</strong></p>
<div class="codehilite"><pre><span></span>Gather values or slices from `params` according to `indices`.
</pre></div>


<p><code>params</code> is a Tensor of rank <code>P</code> and <code>indices</code> is a Tensor of rank <code>Q</code>.</p>
<p><code>indices</code> must be integer tensor, containing indices into <code>params</code>.
It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.</p>
<p>The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to
indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th
dimension of <code>params</code>.</p>
<p>Produces an output tensor with shape</p>
<p><code>[d_0, ..., d_{Q-2}, params.shape[K], ..., params.shape[P-1]].</code></p>
<p>Some examples below.</p>
<p>Simple indexing into a matrix:</p>
<p><code>python
    indices = [[0, 0], [1, 1]]
    params = [['a', 'b'], ['c', 'd']]
    output = ['a', 'd']</code></p>
<p>Slice indexing into a matrix:</p>
<p><code>python
    indices = [[1], [0]]
    params = [['a', 'b'], ['c', 'd']]
    output = [['c', 'd'], ['a', 'b']]</code></p>
<p>Indexing into a 3-tensor:</p>
<p>```python
    indices = [[1]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [[['a1', 'b1'], ['c1', 'd1']]]</p>
<div class="codehilite"><pre><span></span>indices = [[0, 1], [1, 0]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]]


indices = [[0, 0, 1], [1, 0, 1]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [&#39;b0&#39;, &#39;b1&#39;]
</pre></div>


<p>```</p>
<p>Batched indexing into a matrix:</p>
<p><code>python
    indices = [[[0, 0]], [[0, 1]]]
    params = [['a', 'b'], ['c', 'd']]
    output = [['a'], ['b']]</code></p>
<p>Batched slice indexing into a matrix:</p>
<p><code>python
    indices = [[[1]], [[0]]]
    params = [['a', 'b'], ['c', 'd']]
    output = [[['c', 'd']], [['a', 'b']]]</code></p>
<p>Batched indexing into a 3-tensor:</p>
<p>```python
    indices = [[[1]], [[0]]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [[[['a1', 'b1'], ['c1', 'd1']]],
              [[['a0', 'b0'], ['c0', 'd0']]]]</p>
<div class="codehilite"><pre><span></span>indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]],
          [[&#39;a0&#39;, &#39;b0&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[&#39;b0&#39;, &#39;b1&#39;], [&#39;d0&#39;, &#39;c1&#39;]]
</pre></div>


<p>```</p>
<p>Args:
  params: A <code>Tensor</code>. <code>P-D</code>.  The tensor from which to gather values.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    <code>Q-D</code>.  Index tensor having shape <code>[d_0, ..., d_{Q-2}, K]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>params</code>.
  <code>(P+Q-K-1)-D</code>.  Values from <code>params</code> gathered from indices given by
  <code>indices</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.gather_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.gather_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_collection">
    <p>def <span class="ident">get_collection</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_collection(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_collection</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_collection(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_collection(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_collection</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.get_collection()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.get_collection"><code>Graph.get_collection()</code></a>
for more details.</p>
<p>Args:
  key: The key for the collection. For example, the <code>GraphKeys</code> class
    contains many standard names for collections.
  scope: (Optional.) If supplied, the resulting list is filtered to include
    only items whose <code>name</code> attribute matches using <code>re.match</code>. Items
    without a <code>name</code> attribute are never returned if a scope is supplied and
    the choice or <code>re.match</code> means that a <code>scope</code> without special tokens
    filters by prefix.</p>
<p>Returns:
  The list of values in the collection with the given <code>name</code>, or
  an empty list if no value has been added to that collection. The
  list contains the values in the order under which they were
  collected.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_collection', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_collection" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_collection_ref">
    <p>def <span class="ident">get_collection_ref</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_collection_ref(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_collection_ref</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_collection_ref(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_collection_ref(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_collection_ref</strong></p>
<div class="codehilite"><pre><span></span>Wrapper for `Graph.get_collection_ref()` using the default graph.
</pre></div>


<p>See <a href="../../api_docs/python/framework.md#Graph.get_collection_ref"><code>Graph.get_collection_ref()</code></a>
for more details.</p>
<p>Args:
  key: The key for the collection. For example, the <code>GraphKeys</code> class
    contains many standard names for collections.</p>
<p>Returns:
  The list of values in the collection with the given <code>name</code>, or an empty
  list if no value has been added to that collection.  Note that this returns
  the collection list itself, which can be modified in place to change the
  collection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_collection_ref', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_collection_ref" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_default_graph">
    <p>def <span class="ident">get_default_graph</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_default_graph(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_default_graph</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_default_graph(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_default_graph(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_default_graph</strong></p>
<div class="codehilite"><pre><span></span>Returns the default graph for the current thread.
</pre></div>


<p>The returned graph will be the innermost graph on which a
<code>Graph.as_default()</code> context has been entered, or a global default
graph if none has been explicitly created.</p>
<p>NOTE: The default graph is a property of the current thread. If you
create a new thread, and wish to use the default graph in that
thread, you must explicitly add a <code>with g.as_default():</code> in that
thread's function.</p>
<p>Returns:
  The default <code>Graph</code> being used in the current thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_default_graph', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_default_graph" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_default_session">
    <p>def <span class="ident">get_default_session</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_default_session(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_default_session</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_default_session(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_default_session(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_default_session</strong></p>
<div class="codehilite"><pre><span></span>Returns the default session for the current thread.
</pre></div>


<p>The returned <code>Session</code> will be the innermost session on which a
<code>Session</code> or <code>Session.as_default()</code> context has been entered.</p>
<p>NOTE: The default session is a property of the current thread. If you
create a new thread, and wish to use the default session in that
thread, you must explicitly add a <code>with sess.as_default():</code> in that
thread's function.</p>
<p>Returns:
  The default <code>Session</code> being used in the current thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_default_session', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_default_session" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_seed">
    <p>def <span class="ident">get_seed</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_seed(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_seed</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_seed(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_seed(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_seed</strong></p>
<div class="codehilite"><pre><span></span>Returns the local seeds an operation should use given an op-specific seed.
</pre></div>


<p>Given operation-specific seed, <code>op_seed</code>, this helper function returns two
seeds derived from graph-level and op-level seeds. Many random operations
internally use the two seeds to allow user to change the seed globally for a
graph, or for only specific operations.</p>
<p>For details on how the graph-level seed interacts with op seeds, see
<a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>.</p>
<p>Args:
  op_seed: integer.</p>
<p>Returns:
  A tuple of two integers that should be used for the local seed of this
  operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_seed', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_seed" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_session_handle">
    <p>def <span class="ident">get_session_handle</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_session_handle(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_session_handle</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_session_handle(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_session_handle(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_session_handle</strong></p>
<div class="codehilite"><pre><span></span>Return the handle of `data`.
</pre></div>


<p>This is EXPERIMENTAL and subject to change.</p>
<p>Keep <code>data</code> "in-place" in the runtime and create a handle that can be
used to retrieve <code>data</code> in a subsequent run().</p>
<p>Combined with <code>get_session_tensor</code>, we can keep a tensor produced in
one run call in place, and use it as the input in a future run call.</p>
<p>Args:
  data: A tensor to be stored in the session.
  name: Optional name prefix for the return tensor.</p>
<p>Returns:
  A scalar string tensor representing a unique handle for <code>data</code>.</p>
<p>Raises:
  TypeError: if <code>data</code> is not a Tensor.</p>
<p>Example:</p>
<p>```python
c = tf.mul(a, b)
h = tf.get_session_handle(c)
h = sess.run(h)</p>
<p>p, a = tf.get_session_tensor(h.handle, tf.float32)
b = tf.mul(a, 10)
c = sess.run(b, feed_dict={p: h.handle})
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_session_handle', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_session_handle" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_session_tensor">
    <p>def <span class="ident">get_session_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_session_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_session_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_session_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_session_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_session_tensor</strong></p>
<div class="codehilite"><pre><span></span>Get the tensor of type `dtype` by feeding a tensor handle.
</pre></div>


<p>This is EXPERIMENTAL and subject to change.</p>
<p>Get the value of the tensor from a tensor handle. The tensor
is produced in a previous run() and stored in the state of the
session.</p>
<p>Args:
  handle: The string representation of a persistent tensor handle.
  dtype: The type of the output tensor.
  name: Optional name prefix for the return tensor.</p>
<p>Returns:
  A pair of tensors. The first is a placeholder for feeding a
  tensor handle and the second is the tensor in the session state
  keyed by the tensor handle.</p>
<p>Example:</p>
<p>```python
c = tf.mul(a, b)
h = tf.get_session_handle(c)
h = sess.run(h)</p>
<p>p, a = tf.get_session_tensor(h.handle, tf.float32)
b = tf.mul(a, 10)
c = sess.run(b, feed_dict={p: h.handle})
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_session_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_session_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_variable">
    <p>def <span class="ident">get_variable</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_variable(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_variable</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_variable(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_variable(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.get_variable</strong></p>
<div class="codehilite"><pre><span></span>Gets an existing variable with these parameters or create a new one.
</pre></div>


<p>This function prefixes the name with the current variable scope
and performs reuse checks. See the
<a href="../../how_tos/variable_scope/index.md">Variable Scope How To</a>
for an extensive description of how reusing works. Here is a basic example:</p>
<p><code>python
with tf.variable_scope("foo"):
    v = tf.get_variable("v", [1])  # v.name == "foo/v:0"
    w = tf.get_variable("w", [1])  # w.name == "foo/w:0"
with tf.variable_scope("foo", reuse=True)
    v1 = tf.get_variable("v")  # The same as v above.</code></p>
<p>If initializer is <code>None</code> (the default), the default initializer passed in
the variable scope will be used. If that one is <code>None</code> too, a
<code>uniform_unit_scaling_initializer</code> will be used. The initializer can also be
a Tensor, in which case the variable is initialized to this value and shape.</p>
<p>Similarly, if the regularizer is <code>None</code> (the default), the default regularizer
passed in the variable scope will be used (if that is <code>None</code> too,
then by default no regularization is performed).</p>
<p>If a partitioner is provided, a <code>PartitionedVariable</code> is returned.
Accessing this object as a <code>Tensor</code> returns the shards concatenated along
the partition axis.</p>
<p>Some useful partitioners are available.  See, e.g.,
<code>variable_axis_size_partitioner</code> and <code>min_max_variable_partitioner</code>.</p>
<p>Args:
  name: The name of the new or existing variable.
  shape: Shape of the new or existing variable.
  dtype: Type of the new or existing variable (defaults to <code>DT_FLOAT</code>).
  initializer: Initializer for the variable if one is created.
  regularizer: A (Tensor -&gt; Tensor or None) function; the result of
    applying it on a newly created variable will be added to the collection
    GraphKeys.REGULARIZATION_LOSSES and can be used for regularization.
  trainable: If <code>True</code> also add the variable to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see <code>tf.Variable</code>).
  collections: List of graph collections keys to add the Variable to.
    Defaults to <code>[GraphKeys.GLOBAL_VARIABLES]</code> (see <code>tf.Variable</code>).
  caching_device: Optional device string or function describing where the
    Variable should be cached for reading.  Defaults to the Variable's
    device.  If not <code>None</code>, caches on another device.  Typical use is to
    cache on the device where the Ops using the Variable reside, to
    deduplicate copying through <code>Switch</code> and other conditional statements.
  partitioner: Optional callable that accepts a fully defined <code>TensorShape</code>
    and <code>dtype</code> of the Variable to be created, and returns a list of
    partitions for each axis (currently only one axis can be partitioned).
  validate_shape: If False, allows the variable to be initialized with a
      value of unknown shape. If True, the default, the shape of initial_value
      must be known.
  custom_getter: Callable that takes as a first argument the true getter, and
    allows overwriting the internal get_variable method.
    The signature of <code>custom_getter</code> should match that of this method,
    but the most future-proof version will allow for changes:
    <code>def custom_getter(getter, *args, **kwargs)</code>.  Direct access to
    all <code>get_variable</code> parameters is also allowed:
    <code>def custom_getter(getter, name, *args, **kwargs)</code>.  A simple identity
    custom getter that simply creates variables with modified names is:
    <code>python
    def custom_getter(getter, name, *args, **kwargs):
      return getter(name + '_suffix', *args, **kwargs)</code></p>
<p>Returns:
  The created or existing <code>Variable</code> (or <code>PartitionedVariable</code>, if a
  partitioner was used).</p>
<p>Raises:
  ValueError: when creating a new variable and shape is not declared,
    when violating reuse during variable creation, or when <code>initializer</code> dtype
    and <code>dtype</code> don't match. Reuse is set inside <code>variable_scope</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_variable', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_variable" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.get_variable_scope">
    <p>def <span class="ident">get_variable_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_variable_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.get_variable_scope</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.get_variable_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.get_variable_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.get_variable_scope</strong></p>
<div class="codehilite"><pre><span></span>Returns the current variable scope.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.get_variable_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.get_variable_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.global_norm">
    <p>def <span class="ident">global_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.global_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.global_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.global_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.global_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.global_norm</strong></p>
<div class="codehilite"><pre><span></span>Computes the global norm of multiple tensors.
</pre></div>


<p>Given a tuple or list of tensors <code>t_list</code>, this operation returns the
global norm of the elements in all tensors in <code>t_list</code>. The global norm is
computed as:</p>
<p><code>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</code></p>
<p>Any entries in <code>t_list</code> that are of type None are ignored.</p>
<p>Args:
  t_list: A tuple or list of mixed <code>Tensors</code>, <code>IndexedSlices</code>, or None.
  name: A name for the operation (optional).</p>
<p>Returns:
  A 0-D (scalar) <code>Tensor</code> of type <code>float</code>.</p>
<p>Raises:
  TypeError: If <code>t_list</code> is not a sequence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.global_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.global_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.global_variables">
    <p>def <span class="ident">global_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.global_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.global_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.global_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.global_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.global_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns global variables.
</pre></div>


<p>Global variables are variables that are shared across machines in a
distributed environment. The <code>Variable()</code> constructor or <code>get_variable()</code>
automatically adds new variables to the graph collection
<code>GraphKeys.GLOBAL_VARIABLES</code>.
This convenience function returns the contents of that collection.</p>
<p>An alternative to global variables are local variables. See
<a href="../../api_docs/python/state_ops.md#local_variables"><code>tf.local_variables()</code></a></p>
<p>Returns:
  A list of <code>Variable</code> objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.global_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.global_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.global_variables_initializer">
    <p>def <span class="ident">global_variables_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.global_variables_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.global_variables_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.global_variables_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.global_variables_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.global_variables_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes global variables.
</pre></div>


<p>This is just a shortcut for <code>variable_initializers(global_variables())</code></p>
<p>Returns:
  An Op that initializes global variables in the graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.global_variables_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.global_variables_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.gradients">
    <p>def <span class="ident">gradients</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.gradients(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.gradients</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.gradients(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.gradients(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.gradients</strong></p>
<div class="codehilite"><pre><span></span>Constructs symbolic partial derivatives of sum of `ys` w.r.t. x in `xs`.
</pre></div>


<p><code>ys</code> and <code>xs</code> are each a <code>Tensor</code> or a list of tensors.  <code>grad_ys</code>
is a list of <code>Tensor</code>, holding the gradients received by the
<code>ys</code>. The list must be the same length as <code>ys</code>.</p>
<p><code>gradients()</code> adds ops to the graph to output the partial
derivatives of <code>ys</code> with respect to <code>xs</code>.  It returns a list of
<code>Tensor</code> of length <code>len(xs)</code> where each tensor is the <code>sum(dy/dx)</code>
for y in <code>ys</code>.</p>
<p><code>grad_ys</code> is a list of tensors of the same length as <code>ys</code> that holds
the initial gradients for each y in <code>ys</code>.  When <code>grad_ys</code> is None,
we fill in a tensor of '1's of the shape of y for each y in <code>ys</code>.  A
user can provide their own initial <code>grad_ys</code> to compute the
derivatives using a different initial gradient for each y (e.g., if
one wanted to weight the gradient differently for each value in
each y).</p>
<p>Args:
  ys: A <code>Tensor</code> or list of tensors to be differentiated.
  xs: A <code>Tensor</code> or list of tensors to be used for differentiation.
  grad_ys: Optional. A <code>Tensor</code> or list of tensors the same size as
    <code>ys</code> and holding the gradients computed for each y in <code>ys</code>.
  name: Optional name to use for grouping all the gradient ops together.
    defaults to 'gradients'.
  colocate_gradients_with_ops: If True, try colocating gradients with
    the corresponding op.
  gate_gradients: If True, add a tuple around the gradients returned
    for an operations.  This avoids some race conditions.
  aggregation_method: Specifies the method used to combine gradient terms.
    Accepted values are constants defined in the class <code>AggregationMethod</code>.</p>
<p>Returns:
  A list of <code>sum(dy/dx)</code> for each x in <code>xs</code>.</p>
<p>Raises:
  LookupError: if one of the operations between <code>x</code> and <code>y</code> does not
    have a registered gradient function.
  ValueError: if the arguments are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.gradients', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.gradients" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.greater">
    <p>def <span class="ident">greater</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.greater(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.greater</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.greater(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.greater(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.greater</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &gt; y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Greater</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.greater', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.greater" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.greater_equal">
    <p>def <span class="ident">greater_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.greater_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.greater_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.greater_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.greater_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.greater_equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &gt;= y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>GreaterEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.greater_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.greater_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.group">
    <p>def <span class="ident">group</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.group(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.group</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.group(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.group(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.group</strong></p>
<div class="codehilite"><pre><span></span>Create an op that groups multiple operations.
</pre></div>


<p>When this op finishes, all ops in <code>input</code> have finished. This op has no
output.</p>
<p>See also <code>tuple</code> and <code>with_dependencies</code>.</p>
<p>Args:
  <em>inputs: Zero or more tensors to group.
  </em>*kwargs: Optional parameters to pass when constructing the NodeDef.
  name: A name for this operation (optional).</p>
<p>Returns:
  An Operation that executes all its inputs.</p>
<p>Raises:
  ValueError: If an unknown keyword argument is provided.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.group', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.group" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.hessians">
    <p>def <span class="ident">hessians</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.hessians(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.hessians</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.hessians(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.hessians(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.hessians</strong></p>
<div class="codehilite"><pre><span></span>Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.
</pre></div>


<p><code>hessians()</code> adds ops to the graph to output the Hessian matrix of <code>ys</code>
with respect to <code>xs</code>.  It returns a list of <code>Tensor</code> of length <code>len(xs)</code>
where each tensor is the Hessian of <code>sum(ys)</code>. This function currently
only supports evaluating the Hessian with respect to (a list of) one-
dimensional tensors.</p>
<p>The Hessian is a matrix of second-order partial derivatives of a scalar
tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).</p>
<p>Args:
  ys: A <code>Tensor</code> or list of tensors to be differentiated.
  xs: A <code>Tensor</code> or list of tensors to be used for differentiation.
  name: Optional name to use for grouping all the gradient ops together.
    defaults to 'hessians'.
  colocate_gradients_with_ops: See <code>gradients()</code> documentation for details.
  gate_gradients: See <code>gradients()</code> documentation for details.
  aggregation_method: See <code>gradients()</code> documentation for details.</p>
<p>Returns:
  A list of Hessian matrices of <code>sum(y)</code> for each <code>x</code> in <code>xs</code>.</p>
<p>Raises:
  LookupError: if one of the operations between <code>xs</code> and <code>ys</code> does not
    have a registered gradient function.
  ValueError: if the arguments are invalid or not supported. Currently,
    this function only supports one-dimensional <code>x</code> in <code>xs</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.hessians', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.hessians" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.histogram_fixed_width">
    <p>def <span class="ident">histogram_fixed_width</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.histogram_fixed_width(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.histogram_fixed_width</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.histogram_fixed_width(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.histogram_fixed_width(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.histogram_fixed_width</strong></p>
<div class="codehilite"><pre><span></span>Return histogram of values.
</pre></div>


<p>Given the tensor <code>values</code>, this operation returns a rank 1 histogram counting
the number of entries in <code>values</code> that fell into every bin.  The bins are
equal width and determined by the arguments <code>value_range</code> and <code>nbins</code>.</p>
<p>Args:
  values:  Numeric <code>Tensor</code>.
  value_range:  Shape [2] <code>Tensor</code>.  new_values &lt;= value_range[0] will be
    mapped to hist[0], values &gt;= value_range[1] will be mapped to hist[-1].
    Must be same dtype as new_values.
  nbins:  Scalar <code>int32 Tensor</code>.  Number of histogram bins.
  dtype:  dtype for returned histogram.
  name:  A name for this operation (defaults to 'histogram_fixed_width').</p>
<p>Returns:
  A 1-D <code>Tensor</code> holding histogram of values.</p>
<p>Examples:</p>
<p>```python</p>
<h1>Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)</h1>
<p>nbins = 5
value_range = [0.0, 5.0]
new_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]</p>
<p>with tf.default_session() as sess:
  hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)
  variables.global_variables_initializer().run()
  sess.run(hist) =&gt; [2, 1, 1, 0, 2]
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.histogram_fixed_width', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.histogram_fixed_width" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.histogram_summary">
    <p>def <span class="ident">histogram_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.histogram_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.histogram_summary</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.histogram_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.histogram_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.histogram_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with a histogram. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-30.
Instructions for updating:
Please switch to tf.summary.histogram. Note that tf.summary.histogram uses the node name instead of the tag. This means that TensorFlow will automatically de-duplicate summary names based on their scope.</p>
<p>The generated
  <a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
  has one summary value containing a histogram for <code>values</code>.</p>
<p>This op reports an <code>InvalidArgument</code> error if any value is not finite.</p>
<p>Args:
    tag: A <code>string</code> <code>Tensor</code>. 0-D.  Tag to use for the summary value.
    values: A real numeric <code>Tensor</code>. Any shape. Values to use to
      build the histogram.
    collections: Optional list of graph collections keys. The new summary op is
      added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
    name: A name for the operation (optional).</p>
<p>Returns:
    A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
    buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.histogram_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.histogram_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.identity">
    <p>def <span class="ident">identity</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.identity(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.identity</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.identity(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.identity(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.identity</strong></p>
<div class="codehilite"><pre><span></span>Return a tensor with the same shape and contents as the input tensor or value.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.identity', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.identity" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ifft">
    <p>def <span class="ident">ifft</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ifft(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ifft</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ifft(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ifft(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ifft</strong></p>
<div class="codehilite"><pre><span></span>Compute the inverse 1-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>dimension of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most
  dimension of <code>input</code> is replaced with its inverse 1D Fourier Transform.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ifft', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ifft" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ifft2d">
    <p>def <span class="ident">ifft2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ifft2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ifft2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ifft2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ifft2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ifft2d</strong></p>
<div class="codehilite"><pre><span></span>Compute the inverse 2-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>2 dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 2
    dimensions of <code>input</code> are replaced with their inverse 2D Fourier Transform.</p>
<p>@compatibility(numpy)
  Equivalent to np.ifft2
  @end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ifft2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ifft2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ifft3d">
    <p>def <span class="ident">ifft3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ifft3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ifft3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ifft3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ifft3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ifft3d</strong></p>
<div class="codehilite"><pre><span></span>Compute the inverse 3-dimensional discrete Fourier Transform over the inner-most
</pre></div>


<p>3 dimensions of <code>input</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>complex64</code>. A complex64 tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>complex64</code>.
  A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
    dimensions of <code>input</code> are replaced with their inverse 3D Fourier Transform.</p>
<p>@compatibility(numpy)
  Equivalent to np.fft3
  @end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ifft3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ifft3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.igamma">
    <p>def <span class="ident">igamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.igamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.igamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.igamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.igamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.igamma</strong></p>
<div class="codehilite"><pre><span></span>Compute the lower regularized incomplete Gamma function `Q(a, x)`.
</pre></div>


<p>The lower regularized incomplete Gamma function is defined as:</p>
<p><code>P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)</code>
where
<code>gamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt</code>
is the lower incomplete Gamma function.</p>
<p>Note, above <code>Q(a, x)</code> (<code>Igammac</code>) is the upper regularized complete
Gamma function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.igamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.igamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.igammac">
    <p>def <span class="ident">igammac</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.igammac(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.igammac</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.igammac(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.igammac(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.igammac</strong></p>
<div class="codehilite"><pre><span></span>Compute the upper regularized incomplete Gamma function `Q(a, x)`.
</pre></div>


<p>The upper regularized incomplete Gamma function is defined as:</p>
<p><code>Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)</code>
where
<code>Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt</code>
is the upper incomplete Gama function.</p>
<p>Note, above <code>P(a, x)</code> (<code>Igamma</code>) is the lower regularized complete
Gamma function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.igammac', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.igammac" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.imag">
    <p>def <span class="ident">imag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.imag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.imag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.imag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.imag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.imag</strong></p>
<div class="codehilite"><pre><span></span>Returns the imaginary part of a complex number.
</pre></div>


<p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
type <code>float32</code> or <code>float64</code> that is the imaginary part of each element in
<code>input</code>. All elements in <code>input</code> must be complex numbers of the form (a +
bj), where <em>a</em> is the real part and <em>b</em> is the imaginary part returned by
this operation.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]</h1>
<p>tf.imag(input) ==&gt; [4.75, 5.75]
```</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>complex64</code>,
    <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.imag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.imag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.image_summary">
    <p>def <span class="ident">image_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.image_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.image_summary</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.image_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.image_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.image_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with images. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-30.
Instructions for updating:
Please switch to tf.summary.image. Note that tf.summary.histogram uses the node name instead of the tag. This means that TensorFlow will automatically de-duplicate summary names based on the scope they are created in. Also, the max_images argument was renamed to max_outputs.</p>
<p>The summary has up to <code>max_images</code> summary values containing images. The
  images are built from <code>tensor</code> which must be 4-D with shape <code>[batch_size,
  height, width, channels]</code> and where <code>channels</code> can be:</p>
<ul>
<li>1: <code>tensor</code> is interpreted as Grayscale.</li>
<li>3: <code>tensor</code> is interpreted as RGB.</li>
<li>4: <code>tensor</code> is interpreted as RGBA.</li>
</ul>
<p>The images have the same number of channels as the input tensor. For float
  input, the values are normalized one image at a time to fit in the range
  <code>[0, 255]</code>.  <code>uint8</code> values are unchanged.  The op uses two different
  normalization algorithms:</p>
<ul>
<li>
<p>If the input values are all positive, they are rescaled so the largest one
     is 255.</p>
</li>
<li>
<p>If any input value is negative, the values are shifted so input value 0.0
     is at 127.  They are then rescaled so that either the smallest value is 0,
     or the largest one is 255.</p>
</li>
</ul>
<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
  build the <code>tag</code> of the summary values:</p>
<ul>
<li>If <code>max_images</code> is 1, the summary value tag is '<em>tag</em>/image'.</li>
<li>If <code>max_images</code> is greater than 1, the summary value tags are
     generated sequentially as '<em>tag</em>/image/0', '<em>tag</em>/image/1', etc.</li>
</ul>
<p>Args:
    tag: A scalar <code>Tensor</code> of type <code>string</code>. Used to build the <code>tag</code>
      of the summary values.
    tensor: A 4-D <code>uint8</code> or <code>float32</code> <code>Tensor</code> of shape <code>[batch_size, height,
      width, channels]</code> where <code>channels</code> is 1, 3, or 4.
    max_images: Max number of batch elements to generate images for.
    collections: Optional list of ops.GraphKeys.  The collections to add the
      summary to.  Defaults to [ops.GraphKeys.SUMMARIES]
    name: A name for the operation (optional).</p>
<p>Returns:
    A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
    buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.image_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.image_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.import_graph_def">
    <p>def <span class="ident">import_graph_def</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.import_graph_def(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.import_graph_def</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.import_graph_def(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.import_graph_def(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.import_graph_def</strong></p>
<div class="codehilite"><pre><span></span>Imports the TensorFlow graph in `graph_def` into the Python `Graph`.
</pre></div>


<p>This function provides a way to import a serialized TensorFlow
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto"><code>GraphDef</code></a>
protocol buffer, and extract individual objects in the <code>GraphDef</code> as
<a href="#Tensor"><code>Tensor</code></a> and <a href="#Operation"><code>Operation</code></a> objects. See
<a href="#Graph.as_graph_def"><code>Graph.as_graph_def()</code></a> for a way to create a
<code>GraphDef</code> proto.</p>
<p>Args:
  graph_def: A <code>GraphDef</code> proto containing operations to be imported into
    the default graph.
  input_map: A dictionary mapping input names (as strings) in <code>graph_def</code>
    to <code>Tensor</code> objects. The values of the named input tensors in the
    imported graph will be re-mapped to the respective <code>Tensor</code> values.
  return_elements: A list of strings containing operation names in
    <code>graph_def</code> that will be returned as <code>Operation</code> objects; and/or
    tensor names in <code>graph_def</code> that will be returned as <code>Tensor</code> objects.
  name: (Optional.) A prefix that will be prepended to the names in
    <code>graph_def</code>. Defaults to <code>"import"</code>.
  op_dict: (Optional.) A dictionary mapping op type names to <code>OpDef</code> protos.
    Must contain an <code>OpDef</code> proto for each op type named in <code>graph_def</code>.
    If omitted, uses the <code>OpDef</code> protos registered in the global registry.
  producer_op_list: (Optional.) An <code>OpList</code> proto with the (possibly stripped)
    list of <code>OpDef</code>s used by the producer of the graph. If provided, attrs
    for ops in <code>graph_def</code> that are not in <code>op_dict</code> that have their default
    value according to <code>producer_op_list</code> will be removed. This will allow
    some more <code>GraphDef</code>s produced by later binaries to be accepted by
    earlier binaries.</p>
<p>Returns:
  A list of <code>Operation</code> and/or <code>Tensor</code> objects from the imported graph,
  corresponding to the names in <code>return_elements</code>.</p>
<p>Raises:
  TypeError: If <code>graph_def</code> is not a <code>GraphDef</code> proto,
    <code>input_map</code> is not a dictionary mapping strings to <code>Tensor</code> objects,
    or <code>return_elements</code> is not a list of strings.
  ValueError: If <code>input_map</code>, or <code>return_elements</code> contains names that
    do not appear in <code>graph_def</code>, or <code>graph_def</code> is not well-formed (e.g.
    it refers to an unknown tensor).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.import_graph_def', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.import_graph_def" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.in_top_k">
    <p>def <span class="ident">in_top_k</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.in_top_k(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnin_top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnin_top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.in_top_k(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnin_top_k</strong></p>
<div class="codehilite"><pre><span></span>Says whether the targets are in the top `K` predictions.
</pre></div>


<p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
prediction for the target class is among the top <code>k</code> predictions among
all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
from the <code>TopK</code> op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-<code>k</code> boundary, all of those
classes are considered to be in the top <code>k</code>.</p>
<p>More formally, let</p>
<p>\(predictions_i\) be the predictions for all classes for example <code>i</code>,
  \(targets_i\) be the target class for example <code>i</code>,
  \(out_i\) be the output for example <code>i</code>,</p>
<p>$$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$</p>
<p>Args:
  predictions: A <code>Tensor</code> of type <code>float32</code>.
    A <code>batch_size</code> x <code>classes</code> tensor.
  targets: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A <code>batch_size</code> vector of class ids.
  k: An <code>int</code>. Number of top elements to look at for computing precision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>. Computed Precision at <code>k</code> as a <code>bool Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.in_top_k', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.in_top_k" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer">
    <p>def <span class="ident">in_top_k_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.in_top_k_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.in_top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.in_top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.in_top_k_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.in_top_k`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.in_top_k</strong></p>
<div class="codehilite"><pre><span></span>Says whether the targets are in the top `K` predictions.
</pre></div>


<p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
prediction for the target class is among the top <code>k</code> predictions among
all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
from the <code>TopK</code> op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-<code>k</code> boundary, all of those
classes are considered to be in the top <code>k</code>.</p>
<p>More formally, let</p>
<p>\(predictions_i\) be the predictions for all classes for example <code>i</code>,
  \(targets_i\) be the target class for example <code>i</code>,
  \(out_i\) be the output for example <code>i</code>,</p>
<p>$$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$</p>
<p>Args:
  predictions: A <code>Tensor</code> of type <code>float32</code>.
    A <code>batch_size</code> x <code>classes</code> tensor.
  targets: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A <code>batch_size</code> vector of class ids.
  k: An <code>int</code>. Number of top elements to look at for computing precision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>. Computed Precision at <code>k</code> as a <code>bool Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.in_top_k_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.in_top_k_layer">
    <p>def <span class="ident">in_top_k_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.in_top_k_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.in_top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.in_top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.in_top_k_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.in_top_k`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.in_top_k</strong></p>
<div class="codehilite"><pre><span></span>Says whether the targets are in the top `K` predictions.
</pre></div>


<p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
prediction for the target class is among the top <code>k</code> predictions among
all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
from the <code>TopK</code> op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-<code>k</code> boundary, all of those
classes are considered to be in the top <code>k</code>.</p>
<p>More formally, let</p>
<p>\(predictions_i\) be the predictions for all classes for example <code>i</code>,
  \(targets_i\) be the target class for example <code>i</code>,
  \(out_i\) be the output for example <code>i</code>,</p>
<p>$$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$</p>
<p>Args:
  predictions: A <code>Tensor</code> of type <code>float32</code>.
    A <code>batch_size</code> x <code>classes</code> tensor.
  targets: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A <code>batch_size</code> vector of class ids.
  k: An <code>int</code>. Number of top elements to look at for computing precision.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>. Computed Precision at <code>k</code> as a <code>bool Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.in_top_k_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.in_top_k_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.inception_layer">
    <p>def <span class="ident">inception_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.inception_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderinception_layer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuilderinception_layer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.inception_layer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorbuilderinception_layer</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.inception_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.inception_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_all_tables">
    <p>def <span class="ident">initialize_all_tables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_all_tables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_all_tables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_all_tables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_all_tables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_all_tables</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes all tables of the default graph.
</pre></div>


<p>Args:
  name: Optional name for the initialization op.</p>
<p>Returns:
  An Op that initializes all tables.  Note that if there are
  not tables the returned Op is a NoOp.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_all_tables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_all_tables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_all_variables">
    <p>def <span class="ident">initialize_all_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_all_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_all_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_all_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_all_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_all_variables</strong></p>
<div class="codehilite"><pre><span></span>See `tf.global_variables_initializer`. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2017-03-02.
Instructions for updating:
Use <code>tf.global_variables_initializer</code> instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_all_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_all_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_local_variables">
    <p>def <span class="ident">initialize_local_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_local_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_local_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_local_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_local_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_local_variables</strong></p>
<div class="codehilite"><pre><span></span>See `tf.local_variables_initializer`. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2017-03-02.
Instructions for updating:
Use <code>tf.local_variables_initializer</code> instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_local_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_local_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.initialize_variables">
    <p>def <span class="ident">initialize_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.initialize_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.initialize_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.initialize_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.initialize_variables</strong></p>
<div class="codehilite"><pre><span></span>See `tf.variables_initializer`. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2017-03-02.
Instructions for updating:
Use <code>tf.variables_initializer</code> instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.initialize_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.initialize_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.invert_permutation">
    <p>def <span class="ident">invert_permutation</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.invert_permutation(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.invert_permutation</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.invert_permutation(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.invert_permutation(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.invert_permutation</strong></p>
<div class="codehilite"><pre><span></span>Computes the inverse permutation of a tensor.
</pre></div>


<p>This operation computes the inverse of an index permutation. It takes a 1-D
integer tensor <code>x</code>, which represents the indices of a zero-based array, and
swaps each value with its index position. In other words, for an output tensor
<code>y</code> and an input tensor <code>x</code>, this operation computes the following:</p>
<p><code>y[x[i]] = i for i in [0, 1, ..., len(x) - 1]</code></p>
<p>The values must include 0. There can be no duplicate values or negative values.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor <code>x</code> is [3, 4, 0, 2, 1]</h1>
<p>invert_permutation(x) ==&gt; [2, 4, 3, 0, 1]
```</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>. 1-D.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.invert_permutation', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.invert_permutation" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_finite">
    <p>def <span class="ident">is_finite</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_finite(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_finite</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_finite(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_finite(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_finite</strong></p>
<div class="codehilite"><pre><span></span>Returns which elements of x are finite.
</pre></div>


<p>@compatibility(numpy)
Equivalent to np.isfinite
@end_compatibility</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_finite', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_finite" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_inf">
    <p>def <span class="ident">is_inf</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_inf(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_inf</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_inf(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_inf(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_inf</strong></p>
<div class="codehilite"><pre><span></span>Returns which elements of x are Inf.
</pre></div>


<p>@compatibility(numpy)
Equivalent to np.isinf
@end_compatibility</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_inf', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_inf" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_nan">
    <p>def <span class="ident">is_nan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_nan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_nan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_nan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_nan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_nan</strong></p>
<div class="codehilite"><pre><span></span>Returns which elements of x are NaN.
</pre></div>


<p>@compatibility(numpy)
Equivalent to np.isnan
@end_compatibility</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_nan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_nan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_non_decreasing">
    <p>def <span class="ident">is_non_decreasing</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_non_decreasing(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_non_decreasing</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_non_decreasing(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_non_decreasing(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_non_decreasing</strong></p>
<div class="codehilite"><pre><span></span>Returns `True` if `x` is non-decreasing.
</pre></div>


<p>Elements of <code>x</code> are compared in row-major order.  The tensor <code>[x[0],...]</code>
is non-decreasing if for every adjacent pair we have <code>x[i] &lt;= x[i+1]</code>.
If <code>x</code> has less than two elements, it is trivially non-decreasing.</p>
<p>See also:  <code>is_strictly_increasing</code></p>
<p>Args:
  x: Numeric <code>Tensor</code>.
  name: A name for this operation (optional).  Defaults to "is_non_decreasing"</p>
<p>Returns:
  Boolean <code>Tensor</code>, equal to <code>True</code> iff <code>x</code> is non-decreasing.</p>
<p>Raises:
  TypeError: if <code>x</code> is not a numeric tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_non_decreasing', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_non_decreasing" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_numeric_tensor">
    <p>def <span class="ident">is_numeric_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_numeric_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_numeric_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_numeric_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_numeric_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_numeric_tensor</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_numeric_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_numeric_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_strictly_increasing">
    <p>def <span class="ident">is_strictly_increasing</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_strictly_increasing(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_strictly_increasing</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_strictly_increasing(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_strictly_increasing(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_strictly_increasing</strong></p>
<div class="codehilite"><pre><span></span>Returns `True` if `x` is strictly increasing.
</pre></div>


<p>Elements of <code>x</code> are compared in row-major order.  The tensor <code>[x[0],...]</code>
is strictly increasing if for every adjacent pair we have <code>x[i] &lt; x[i+1]</code>.
If <code>x</code> has less than two elements, it is trivially strictly increasing.</p>
<p>See also:  <code>is_non_decreasing</code></p>
<p>Args:
  x: Numeric <code>Tensor</code>.
  name: A name for this operation (optional).
    Defaults to "is_strictly_increasing"</p>
<p>Returns:
  Boolean <code>Tensor</code>, equal to <code>True</code> iff <code>x</code> is strictly increasing.</p>
<p>Raises:
  TypeError: if <code>x</code> is not a numeric tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_strictly_increasing', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_strictly_increasing" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.is_variable_initialized">
    <p>def <span class="ident">is_variable_initialized</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_variable_initialized(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.is_variable_initialized</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.is_variable_initialized(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.is_variable_initialized(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.is_variable_initialized</strong></p>
<div class="codehilite"><pre><span></span>Tests if a variable has been initialized.
</pre></div>


<p>Args:
  variable: A <code>Variable</code>.</p>
<p>Returns:
  Returns a scalar boolean Tensor, <code>True</code> if the variable has been
  initialized, <code>False</code> otherwise.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.is_variable_initialized', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.is_variable_initialized" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_loss">
    <p>def <span class="ident">l2_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnl2_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnl2_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnl2_loss</strong></p>
<div class="codehilite"><pre><span></span>L2 Loss.
</pre></div>


<p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>
<div class="codehilite"><pre><span></span>output = sum(t ** 2) / 2
</pre></div>


<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Typically 2-D, but may have any dimensions.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>t</code>. 0-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer">
    <p>def <span class="ident">l2_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.l2_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.l2_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.l2_loss</strong></p>
<div class="codehilite"><pre><span></span>L2 Loss.
</pre></div>


<p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>
<div class="codehilite"><pre><span></span>output = sum(t ** 2) / 2
</pre></div>


<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Typically 2-D, but may have any dimensions.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>t</code>. 0-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_loss_layer">
    <p>def <span class="ident">l2_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.l2_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.l2_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.l2_loss</strong></p>
<div class="codehilite"><pre><span></span>L2 Loss.
</pre></div>


<p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>
<div class="codehilite"><pre><span></span>output = sum(t ** 2) / 2
</pre></div>


<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Typically 2-D, but may have any dimensions.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>t</code>. 0-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_normalize">
    <p>def <span class="ident">l2_normalize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_normalize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnl2_normalize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnl2_normalize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_normalize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnl2_normalize</strong></p>
<div class="codehilite"><pre><span></span>Normalizes along dimension `dim` using an L2 norm.
</pre></div>


<p>For a 1-D tensor with <code>dim = 0</code>, computes</p>
<div class="codehilite"><pre><span></span>output = x / sqrt(max(sum(x**2), epsilon))
</pre></div>


<p>For <code>x</code> with more dimensions, independently normalizes each 1-D slice along
dimension <code>dim</code>.</p>
<p>Args:
  x: A <code>Tensor</code>.
  dim: Dimension along which to normalize.  A scalar or a vector of
    integers.
  epsilon: A lower bound value for the norm. Will use <code>sqrt(epsilon)</code> as the
    divisor if <code>norm &lt; sqrt(epsilon)</code>.
  name: A name for this operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same shape as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_normalize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_normalize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer">
    <p>def <span class="ident">l2_normalize_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_normalize_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.l2_normalize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.l2_normalize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_normalize_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_normalize`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.l2_normalize</strong></p>
<div class="codehilite"><pre><span></span>Normalizes along dimension `dim` using an L2 norm.
</pre></div>


<p>For a 1-D tensor with <code>dim = 0</code>, computes</p>
<div class="codehilite"><pre><span></span>output = x / sqrt(max(sum(x**2), epsilon))
</pre></div>


<p>For <code>x</code> with more dimensions, independently normalizes each 1-D slice along
dimension <code>dim</code>.</p>
<p>Args:
  x: A <code>Tensor</code>.
  dim: Dimension along which to normalize.  A scalar or a vector of
    integers.
  epsilon: A lower bound value for the norm. Will use <code>sqrt(epsilon)</code> as the
    divisor if <code>norm &lt; sqrt(epsilon)</code>.
  name: A name for this operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same shape as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_normalize_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.l2_normalize_layer">
    <p>def <span class="ident">l2_normalize_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_normalize_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.l2_normalize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.l2_normalize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.l2_normalize_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.l2_normalize`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.l2_normalize</strong></p>
<div class="codehilite"><pre><span></span>Normalizes along dimension `dim` using an L2 norm.
</pre></div>


<p>For a 1-D tensor with <code>dim = 0</code>, computes</p>
<div class="codehilite"><pre><span></span>output = x / sqrt(max(sum(x**2), epsilon))
</pre></div>


<p>For <code>x</code> with more dimensions, independently normalizes each 1-D slice along
dimension <code>dim</code>.</p>
<p>Args:
  x: A <code>Tensor</code>.
  dim: Dimension along which to normalize.  A scalar or a vector of
    integers.
  epsilon: A lower bound value for the norm. Will use <code>sqrt(epsilon)</code> as the
    divisor if <code>norm &lt; sqrt(epsilon)</code>.
  name: A name for this operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same shape as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.l2_normalize_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.l2_normalize_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lbeta">
    <p>def <span class="ident">lbeta</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lbeta(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.lbeta</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.lbeta(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lbeta(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.lbeta</strong></p>
<div class="codehilite"><pre><span></span>Computes `ln(|Beta(x)|)`, reducing along the last dimension.
</pre></div>


<p>Given one-dimensional <code>z = [z_0,...,z_{K-1}]</code>, we define</p>
<p><code>Beta(z) = \prod_j Gamma(z_j) / Gamma(\sum_j z_j)</code></p>
<p>And for <code>n + 1</code> dimensional <code>x</code> with shape <code>[N1, ..., Nn, K]</code>, we define
<code>lbeta(x)[i1, ..., in] = Log(|Beta(x[i1, ..., in, :])|)</code>.  In other words,
the last dimension is treated as the <code>z</code> vector.</p>
<p>Note that if <code>z = [u, v]</code>, then
<code>Beta(z) = int_0^1 t^{u-1} (1 - t)^{v-1} dt</code>, which defines the traditional
bivariate beta function.</p>
<p>Args:
  x: A rank <code>n + 1</code> <code>Tensor</code> with type <code>float</code>, or <code>double</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  The logarithm of <code>|Beta(x)|</code> reducing along the last dimension.</p>
<p>Raises:
  ValueError:  If <code>x</code> is empty with rank one or less.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lbeta', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lbeta" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler">
    <p>def <span class="ident">learned_unigram_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.learned_unigram_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnlearned_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnlearned_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.learned_unigram_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnlearned_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes from a distribution learned during training.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is constructed on the fly
during training.  It is a unigram distribution over the target
classes seen so far during training.  Every integer in <code>[0, range_max)</code>
begins with a weight of 1, and is incremented by 1 each time it is
seen as a target class.  The base distribution is not saved to checkpoints,
so it is reset when the model is reloaded.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">learned_unigram_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.learned_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.learned_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.learned_unigram_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.learned_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes from a distribution learned during training.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is constructed on the fly
during training.  It is a unigram distribution over the target
classes seen so far during training.  Every integer in <code>[0, range_max)</code>
begins with a weight of 1, and is incremented by 1 each time it is
seen as a target class.  The base distribution is not saved to checkpoints,
so it is reset when the model is reloaded.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer">
    <p>def <span class="ident">learned_unigram_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.learned_unigram_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.learned_unigram_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.learned_unigram_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.learned_unigram_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.learned_unigram_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.learned_unigram_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes from a distribution learned during training.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is constructed on the fly
during training.  It is a unigram distribution over the target
classes seen so far during training.  Every integer in <code>[0, range_max)</code>
begins with a weight of 1, and is incremented by 1 each time it is
seen as a target class.  The base distribution is not saved to checkpoints,
so it is reset when the model is reloaded.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.learned_unigram_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.less">
    <p>def <span class="ident">less</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.less(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.less</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.less(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.less(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.less</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &lt; y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Less</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.less', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.less" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.less_equal">
    <p>def <span class="ident">less_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.less_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.less_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.less_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.less_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.less_equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x &lt;= y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>LessEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.less_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.less_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lgamma">
    <p>def <span class="ident">lgamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lgamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.lgamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.lgamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lgamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.lgamma</strong></p>
<div class="codehilite"><pre><span></span>Computes the log of the absolute value of `Gamma(x)` element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lgamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lgamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lin_space">
    <p>def <span class="ident">lin_space</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lin_space(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.lin_space</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.lin_space(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lin_space(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.lin_space</strong></p>
<div class="codehilite"><pre><span></span>Generates values in an interval.
</pre></div>


<p>A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>.
If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>,
so that the last one is exactly <code>stop</code>.</p>
<p>For example:</p>
<p><code>tf.linspace(10.0, 12.0, 3, name="linspace") =&gt; [ 10.0  11.0  12.0]</code></p>
<p>Args:
  start: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    First entry in the range.
  stop: A <code>Tensor</code>. Must have the same type as <code>start</code>.
    Last entry in the range.
  num: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Number of values to generate.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>start</code>. 1-D. The generated values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lin_space', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lin_space" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.linear_conv2d_layer">
    <p>def <span class="ident">linear_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.linear_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconvolution</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconvolution(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.linear_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `None`.
</pre></div>


<p><strong>tf.contrib.layersconvolution</strong></p>
<div class="codehilite"><pre><span></span>Adds an N-D convolution followed by an optional batch_norm layer.
</pre></div>


<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p><code>convolution</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved (actually cross-correlated) with the
<code>inputs</code> to produce a <code>Tensor</code> of activations. If a <code>normalizer_fn</code> is
provided (such as <code>batch_norm</code>), it is then applied. Otherwise, if
<code>normalizer_fn</code> is None and a <code>biases_initializer</code> is provided then a <code>biases</code>
variable would be created and added the activations. Finally, if
<code>activation_fn</code> is not <code>None</code>, it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride/dilation rate equal to <code>rate</code>
if a value &gt; 1 for any dimension of <code>rate</code> is specified.  In this case
<code>stride</code> values != 1 are not supported.</p>
<p>Args:
  inputs: a Tensor of rank N+2 of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  num_outputs: integer, the number of output filters.
  kernel_size: a sequence of N positive integers specifying the spatial
    dimensions of of the filters.  Can be a single integer to specify the same
    value for all spatial dimensions.
  stride: a sequence of N positive integers specifying the stride at which to
    compute output.  Can be a single integer to specify the same value for all
    spatial dimensions.  Specifying any <code>stride</code> value != 1 is incompatible
    with specifying any <code>rate</code> value != 1.
  padding: one of <code>"VALID"</code> or <code>"SAME"</code>.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, currently the only valid value is "NDHWC".
  rate: a sequence of N positive integers specifying the dilation rate to use
    for a'trous convolution.  Can be a single integer to specify the same
    value for all spatial dimensions.  Specifying any <code>rate</code> value != 1 is
    incompatible with specifying any <code>stride</code> value != 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.
  ValueError: both 'rate' and <code>stride</code> are not uniformly 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.linear_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.linear_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.linear_layer">
    <p>def <span class="ident">linear_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.linear_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersfully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersfully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.linear_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `None`.
</pre></div>


<p><strong>tf.contrib.layersfully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.linear_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.linear_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.linspace">
    <p>def <span class="ident">linspace</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.linspace(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.linspace</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.linspace(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.linspace(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.linspace</strong></p>
<div class="codehilite"><pre><span></span>Generates values in an interval.
</pre></div>


<p>A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>.
If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>,
so that the last one is exactly <code>stop</code>.</p>
<p>For example:</p>
<p><code>tf.linspace(10.0, 12.0, 3, name="linspace") =&gt; [ 10.0  11.0  12.0]</code></p>
<p>Args:
  start: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    First entry in the range.
  stop: A <code>Tensor</code>. Must have the same type as <code>start</code>.
    Last entry in the range.
  num: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Number of values to generate.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>start</code>. 1-D. The generated values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.linspace', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.linspace" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.load_file_system_library">
    <p>def <span class="ident">load_file_system_library</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.load_file_system_library(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.load_file_system_library</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.load_file_system_library(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.load_file_system_library(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.load_file_system_library</strong></p>
<div class="codehilite"><pre><span></span>Loads a TensorFlow plugin, containing file system implementation.
</pre></div>


<p>Pass <code>library_filename</code> to a platform-specific mechanism for dynamically
loading a library. The rules for determining the exact location of the
library are platform-specific and are not documented here.</p>
<p>Args:
  library_filename: Path to the plugin.
    Relative or absolute filesystem path to a dynamic library file.</p>
<p>Returns:
  None.</p>
<p>Raises:
  RuntimeError: when unable to load the library.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.load_file_system_library', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.load_file_system_library" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.load_op_library">
    <p>def <span class="ident">load_op_library</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.load_op_library(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.load_op_library</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.load_op_library(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.load_op_library(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.load_op_library</strong></p>
<div class="codehilite"><pre><span></span>Loads a TensorFlow plugin, containing custom ops and kernels.
</pre></div>


<p>Pass "library_filename" to a platform-specific mechanism for dynamically
loading a library. The rules for determining the exact location of the
library are platform-specific and are not documented here. When the
library is loaded, ops and kernels registered in the library via the
<code>REGISTER_*</code> macros are made available in the TensorFlow process. Note
that ops with the same name as an existing op are rejected and not
registered with the process.</p>
<p>Args:
  library_filename: Path to the plugin.
    Relative or absolute filesystem path to a dynamic library file.</p>
<p>Returns:
  A python module containing the Python wrappers for Ops defined in
  the plugin.</p>
<p>Raises:
  RuntimeError: when unable to load the library or get the python wrappers.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.load_op_library', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.load_op_library" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_response_normalization">
    <p>def <span class="ident">local_response_normalization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_response_normalization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnlocal_response_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnlocal_response_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_response_normalization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnlocal_response_normalization</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_response_normalization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_response_normalization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer">
    <p>def <span class="ident">local_response_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_response_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.lrn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.lrn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_response_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.lrn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.lrn</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_response_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_response_normalization_layer">
    <p>def <span class="ident">local_response_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_response_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.lrn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.lrn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_response_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.lrn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.lrn</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_response_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_response_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_variables">
    <p>def <span class="ident">local_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.local_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.local_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.local_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns local variables.
</pre></div>


<p>Local variables - per process variables, usually not saved/restored to
checkpoint and used for temporary or intermediate values.
For example, they can be used as counters for metrics computation or
number of epochs this machine has read data.
The <code>local_variable()</code> automatically adds new variable to
<code>GraphKeys.LOCAL_VARIABLES</code>.
This convenience function returns the contents of that collection.</p>
<p>An alternative to local variables are global variables. See
<a href="../../api_docs/python/state_ops.md#global_variables"><code>tf.global_variables()</code></a></p>
<p>Returns:
  A list of local <code>Variable</code> objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.local_variables_initializer">
    <p>def <span class="ident">local_variables_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_variables_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.local_variables_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.local_variables_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.local_variables_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.local_variables_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes all local variables.
</pre></div>


<p>This is just a shortcut for <code>variable_initializers(local_variables())</code></p>
<p>Returns:
  An Op that initializes all local variables in the graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.local_variables_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.local_variables_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log">
    <p>def <span class="ident">log</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.log</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.log(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.log</strong></p>
<div class="codehilite"><pre><span></span>Computes natural logarithm of x element-wise.
</pre></div>


<p>I.e., \(y = \log_e x\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log1p">
    <p>def <span class="ident">log1p</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log1p(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.log1p</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.log1p(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log1p(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.log1p</strong></p>
<div class="codehilite"><pre><span></span>Computes natural logarithm of (1 + x) element-wise.
</pre></div>


<p>I.e., \(y = \log_e (1 + x)\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log1p', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log1p" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_poisson_loss">
    <p>def <span class="ident">log_poisson_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_poisson_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnlog_poisson_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnlog_poisson_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_poisson_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnlog_poisson_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes log Poisson loss given `log_input`.
</pre></div>


<p>Gives the log-likelihood loss between the prediction and the target under the
assumption that the target has a Poisson distribution.
Caveat: By default, this is not the exact loss, but the loss minus a
  constant term [log(z!)]. That has no effect for optimization, but
  does not play well with relative loss comparisons. To compute an
  approximation of the log factorial term, specify
  compute_full_loss=True to enable Stirling's Approximation.</p>
<p>For brevity, let <code>c = log(x) = log_input</code>, <code>z = targets</code>.  The log Poisson
loss is</p>
<div class="codehilite"><pre><span></span>  -log(exp(-x) * (x^z) / z!)
= -log(exp(-x) * (x^z)) + log(z!)
~ -log(exp(-x)) - log(x^z) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
    [ Note the second term is the Stirling&#39;s Approximation for log(z!).
      It is invariant to x and does not affect optimization, though
      important for correct relative loss comparisons. It is only
      computed when compute_full_loss == True. ]
= x - z * log(x) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
= exp(c) - z * c [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
</pre></div>


<p>Args:
  log_input: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>log_input</code>.
  compute_full_loss: whether to compute the full loss. If false, a constant
    term is dropped in favor of more efficient optimization.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>log_input</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>log_input</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_poisson_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_poisson_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer">
    <p>def <span class="ident">log_poisson_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_poisson_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.log_poisson_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.log_poisson_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_poisson_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_poisson_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.log_poisson_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes log Poisson loss given `log_input`.
</pre></div>


<p>Gives the log-likelihood loss between the prediction and the target under the
assumption that the target has a Poisson distribution.
Caveat: By default, this is not the exact loss, but the loss minus a
  constant term [log(z!)]. That has no effect for optimization, but
  does not play well with relative loss comparisons. To compute an
  approximation of the log factorial term, specify
  compute_full_loss=True to enable Stirling's Approximation.</p>
<p>For brevity, let <code>c = log(x) = log_input</code>, <code>z = targets</code>.  The log Poisson
loss is</p>
<div class="codehilite"><pre><span></span>  -log(exp(-x) * (x^z) / z!)
= -log(exp(-x) * (x^z)) + log(z!)
~ -log(exp(-x)) - log(x^z) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
    [ Note the second term is the Stirling&#39;s Approximation for log(z!).
      It is invariant to x and does not affect optimization, though
      important for correct relative loss comparisons. It is only
      computed when compute_full_loss == True. ]
= x - z * log(x) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
= exp(c) - z * c [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
</pre></div>


<p>Args:
  log_input: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>log_input</code>.
  compute_full_loss: whether to compute the full loss. If false, a constant
    term is dropped in favor of more efficient optimization.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>log_input</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>log_input</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer">
    <p>def <span class="ident">log_poisson_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_poisson_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.log_poisson_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.log_poisson_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_poisson_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_poisson_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.log_poisson_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes log Poisson loss given `log_input`.
</pre></div>


<p>Gives the log-likelihood loss between the prediction and the target under the
assumption that the target has a Poisson distribution.
Caveat: By default, this is not the exact loss, but the loss minus a
  constant term [log(z!)]. That has no effect for optimization, but
  does not play well with relative loss comparisons. To compute an
  approximation of the log factorial term, specify
  compute_full_loss=True to enable Stirling's Approximation.</p>
<p>For brevity, let <code>c = log(x) = log_input</code>, <code>z = targets</code>.  The log Poisson
loss is</p>
<div class="codehilite"><pre><span></span>  -log(exp(-x) * (x^z) / z!)
= -log(exp(-x) * (x^z)) + log(z!)
~ -log(exp(-x)) - log(x^z) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
    [ Note the second term is the Stirling&#39;s Approximation for log(z!).
      It is invariant to x and does not affect optimization, though
      important for correct relative loss comparisons. It is only
      computed when compute_full_loss == True. ]
= x - z * log(x) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
= exp(c) - z * c [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
</pre></div>


<p>Args:
  log_input: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>log_input</code>.
  compute_full_loss: whether to compute the full loss. If false, a constant
    term is dropped in favor of more efficient optimization.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>log_input</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>log_input</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_poisson_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_softmax">
    <p>def <span class="ident">log_softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnlog_softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnlog_softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnlog_softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes log softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>logsoftmax = logits - log(reduce_sum(exp(logits), dim))
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.</p>
<p>Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer">
    <p>def <span class="ident">log_softmax_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_softmax_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.log_softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.log_softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_softmax_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_softmax`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.log_softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes log softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>logsoftmax = logits - log(reduce_sum(exp(logits), dim))
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.</p>
<p>Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_softmax_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_softmax_layer">
    <p>def <span class="ident">log_softmax_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_softmax_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.log_softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.log_softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_softmax_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_softmax`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.log_softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes log softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>logsoftmax = logits - log(reduce_sum(exp(logits), dim))
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.</p>
<p>Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_softmax_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_softmax_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler">
    <p>def <span class="ident">log_uniform_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_uniform_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnlog_uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnlog_uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_uniform_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnlog_uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a log-uniform (Zipfian) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is an approximately log-uniform
or Zipfian distribution:</p>
<p><code>P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)</code></p>
<p>This sampler is useful when the target classes approximately follow such
a distribution - for example, if the classes represent words in a lexicon
sorted in decreasing order of frequency. If your classes are not ordered by
decreasing frequency, do not use this op.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">log_uniform_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_uniform_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.log_uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.log_uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_uniform_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_uniform_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.log_uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a log-uniform (Zipfian) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is an approximately log-uniform
or Zipfian distribution:</p>
<p><code>P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)</code></p>
<p>This sampler is useful when the target classes approximately follow such
a distribution - for example, if the classes represent words in a lexicon
sorted in decreasing order of frequency. If your classes are not ordered by
decreasing frequency, do not use this op.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer">
    <p>def <span class="ident">log_uniform_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_uniform_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.log_uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.log_uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.log_uniform_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.log_uniform_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.log_uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a log-uniform (Zipfian) base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is an approximately log-uniform
or Zipfian distribution:</p>
<p><code>P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)</code></p>
<p>This sampler is useful when the target classes approximately follow such
a distribution - for example, if the classes represent words in a lexicon
sorted in decreasing order of frequency. If your classes are not ordered by
decreasing frequency, do not use this op.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.log_uniform_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_and">
    <p>def <span class="ident">logical_and</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_and(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_and</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_and(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_and(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_and</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of x AND y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>LogicalAnd</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code> of type <code>bool</code>.
  y: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_and', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_and" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_not">
    <p>def <span class="ident">logical_not</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_not(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_not</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_not(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_not(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_not</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of NOT x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_not', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_not" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_or">
    <p>def <span class="ident">logical_or</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_or(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_or</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_or(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_or(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_or</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of x OR y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>LogicalOr</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code> of type <code>bool</code>.
  y: A <code>Tensor</code> of type <code>bool</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_or', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_or" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.logical_xor">
    <p>def <span class="ident">logical_xor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_xor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.logical_xor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.logical_xor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.logical_xor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.logical_xor</strong></p>
<div class="codehilite"><pre><span></span>x ^ y = (x | y) &amp; ~(x &amp; y).
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.logical_xor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.logical_xor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lrn">
    <p>def <span class="ident">lrn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lrn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnlrn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnlrn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lrn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnlrn</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lrn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lrn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer">
    <p>def <span class="ident">lrn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lrn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.lrn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.lrn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lrn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.lrn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.lrn</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lrn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.lrn_layer">
    <p>def <span class="ident">lrn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lrn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.lrn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.lrn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.lrn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.lrn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.lrn</strong></p>
<div class="codehilite"><pre><span></span>Local Response Normalization.
</pre></div>


<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>
<div class="codehilite"><pre><span></span>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</pre></div>


<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D.
  depth_radius: An optional <code>int</code>. Defaults to <code>5</code>.
    0-D.  Half-width of the 1-D normalization window.
  bias: An optional <code>float</code>. Defaults to <code>1</code>.
    An offset (usually positive to avoid dividing by 0).
  alpha: An optional <code>float</code>. Defaults to <code>1</code>.
    A scale factor, usually positive.
  beta: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.lrn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.lrn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_all">
    <p>def <span class="ident">make_all</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_all(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnmake_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnmake_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_all(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnmake_all</strong></p>
<div class="codehilite"><pre><span></span>Generates `__all__` from the docstring of one or more modules.
</pre></div>


<p>Usage: <code>make_all(__name__)</code> or
<code>make_all(__name__, [sys.modules(__name__), other_module])</code>. The doc string
modules must each a docstring, and <code>__all__</code> will contain all symbols with
<code>@@</code> references, where that symbol currently exists in the module named
<code>module_name</code>.</p>
<p>Args:
  module_name: The name of the module (usually <code>__name__</code>).
  doc_string_modules: a list of modules from which to take docstring.
  If None, then a list containing only the module named <code>module_name</code> is used.</p>
<p>Returns:
  A list suitable for use as <code>__all__</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_all', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_all" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer">
    <p>def <span class="ident">make_all_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_all_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.make_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.make_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_all_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.make_all`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.make_all</strong></p>
<div class="codehilite"><pre><span></span>Generates `__all__` from the docstring of one or more modules.
</pre></div>


<p>Usage: <code>make_all(__name__)</code> or
<code>make_all(__name__, [sys.modules(__name__), other_module])</code>. The doc string
modules must each a docstring, and <code>__all__</code> will contain all symbols with
<code>@@</code> references, where that symbol currently exists in the module named
<code>module_name</code>.</p>
<p>Args:
  module_name: The name of the module (usually <code>__name__</code>).
  doc_string_modules: a list of modules from which to take docstring.
  If None, then a list containing only the module named <code>module_name</code> is used.</p>
<p>Returns:
  A list suitable for use as <code>__all__</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_all_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_all_layer">
    <p>def <span class="ident">make_all_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_all_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.make_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.make_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_all_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.make_all`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.make_all</strong></p>
<div class="codehilite"><pre><span></span>Generates `__all__` from the docstring of one or more modules.
</pre></div>


<p>Usage: <code>make_all(__name__)</code> or
<code>make_all(__name__, [sys.modules(__name__), other_module])</code>. The doc string
modules must each a docstring, and <code>__all__</code> will contain all symbols with
<code>@@</code> references, where that symbol currently exists in the module named
<code>module_name</code>.</p>
<p>Args:
  module_name: The name of the module (usually <code>__name__</code>).
  doc_string_modules: a list of modules from which to take docstring.
  If None, then a list containing only the module named <code>module_name</code> is used.</p>
<p>Returns:
  A list suitable for use as <code>__all__</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_all_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_all_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.make_template">
    <p>def <span class="ident">make_template</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_template(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.make_template</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.make_template(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.make_template(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.make_template</strong></p>
<div class="codehilite"><pre><span></span>Given an arbitrary function, wrap it so that it does variable sharing.
</pre></div>


<p>This wraps <code>func_</code> in a Template and partially evaluates it. Templates are
functions that create variables the first time they are called and reuse them
thereafter. In order for <code>func_</code> to be compatible with a <code>Template</code> it must
have the following properties:</p>
<ul>
<li>The function should create all trainable variables and any variables that
   should be reused by calling <code>tf.get_variable</code>. If a trainable variable is
   created using <code>tf.Variable</code>, then a ValueError will be thrown. Variables
   that are intended to be locals can be created by specifying
   <code>tf.Variable(..., trainable=false)</code>.</li>
<li>The function may use variable scopes and other templates internally to
    create and reuse variables, but it shouldn't use <code>tf.all_variables</code> to
    capture variables that are defined outside of the scope of the function.</li>
<li>Internal scopes and variable names should not depend on any arguments that
    are not supplied to <code>make_template</code>. In general you will get a ValueError
    telling you that you are trying to reuse a variable that doesn't exist
    if you make a mistake.</li>
</ul>
<p>In the following example, both <code>z</code> and <code>w</code> will be scaled by the same <code>y</code>. It
is important to note that if we didn't assign <code>scalar_name</code> and used a
different name for z and w that a <code>ValueError</code> would be thrown because it
couldn't reuse the variable.</p>
<p>```python
def my_op(x, scalar_name):
  var1 = tf.get_variable(scalar_name,
                         shape=[],
                         initializer=tf.constant_initializer(1))
  return x * var1</p>
<p>scale_by_y = tf.make_template('scale_by_y', my_op, scalar_name='y')</p>
<p>z = scale_by_y(input1)
w = scale_by_y(input2)
```</p>
<p>As a safe-guard, the returned function will raise a <code>ValueError</code> after the
first call if trainable variables are created by calling <code>tf.Variable</code>.</p>
<p>If all of these are true, then 2 properties are enforced by the template:</p>
<ol>
<li>Calling the same template multiple times will share all non-local
    variables.</li>
<li>Two different templates are guaranteed to be unique, unless you reenter the
    same variable scope as the initial definition of a template and redefine
    it. An examples of this exception:</li>
</ol>
<p>```python
def my_op(x, scalar_name):
  var1 = tf.get_variable(scalar_name,
                         shape=[],
                         initializer=tf.constant_initializer(1))
  return x * var1</p>
<p>with tf.variable_scope('scope') as vs:
  scale_by_y = tf.make_template('scale_by_y', my_op, scalar_name='y')
  z = scale_by_y(input1)
  w = scale_by_y(input2)</p>
<h1>Creates a template that reuses the variables above.</h1>
<p>with tf.variable_scope(vs, reuse=True):
  scale_by_y2 = tf.make_template('scale_by_y', my_op, scalar_name='y')
  z2 = scale_by_y2(input1)
  w2 = scale_by_y2(input2)
```</p>
<p>Depending on the value of <code>create_scope_now_</code>, the full variable scope may be
captured either at the time of first call or at the time of construction. If
this option is set to True, then all Tensors created by repeated calls to the
template will have an extra trailing _N+1 to their name, as the first time the
scope is entered in the Template constructor no Tensors are created.</p>
<p>Note: <code>name_</code>, <code>func_</code> and <code>create_scope_now_</code> have a trailing underscore to
reduce the likelihood of collisions with kwargs.</p>
<p>Args:
  name_: A name for the scope created by this template. If necessary, the name
    will be made unique by appending <code>_N</code> to the name.
  func_: The function to wrap.
  create_scope_now_: Boolean controlling whether the scope should be created
    when the template is constructed or when the template is called. Default
    is False, meaning the scope is created when the template is called.
  unique_name_: When used, it overrides name_ and is not made unique. If a
    template of the same scope/unique_name already exists and reuse is false,
    an error is raised. Defaults to None.
  **kwargs: Keyword arguments to apply to <code>func_</code>.</p>
<p>Returns:
  A function to encapsulate a set of variables which should be created once
  and reused. An enclosing scope will created, either where <code>make_template</code>
  is called, or wherever the result is called, depending on the value of
  <code>create_scope_now_</code>. Regardless of the value, the first time the template
  is called it will enter the scope with no reuse, and call <code>func_</code> to create
  variables, which are guaranteed to be unique. All subsequent calls will
  re-enter the scope and reuse those variables.</p>
<p>Raises:
  ValueError: if the name is None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.make_template', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.make_template" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.map_fn">
    <p>def <span class="ident">map_fn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.map_fn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.map_fn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.map_fn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.map_fn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.map_fn</strong></p>
<div class="codehilite"><pre><span></span>map on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>The simplest version of <code>map</code> repeatedly applies the callable <code>fn</code> to a
sequence of elements from first to last. The elements are made of the
tensors unpacked from <code>elems</code>. <code>dtype</code> is the data type of the return
value of <code>fn</code>. Users must provide <code>dtype</code> if it is different from
the data type of <code>elems</code>.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is <code>[values.shape[0]] + fn(values[0]).shape</code>.</p>
<p>This method also allows multi-arity <code>elems</code> and output of <code>fn</code>.  If <code>elems</code>
is a (possibly nested) list or tuple of tensors, then each of these tensors
must have a matching first (unpack) dimension.  The signature of <code>fn</code> may
match the structure of <code>elems</code>.  That is, if <code>elems</code> is
<code>(t1, [t2, t3, [t4, t5]])</code>, then an appropriate signature for <code>fn</code> is:
<code>fn = lambda (t1, [t2, t3, [t4, t5]]):</code>.</p>
<p>Furthermore, <code>fn</code> may emit a different structure than its input.  For example,
<code>fn</code> may look like: <code>fn = lambda t1: return (t1 + 1, t1 - 1)</code>.  In this case,
the <code>dtype</code> parameter is not optional: <code>dtype</code> must be a type or (possibly
nested) tuple of types matching the output of <code>fn</code>.</p>
<p>To apply a functional operation to the nonzero elements of a SparseTensor
one of the following methods is recommended. First, if the function is
expressible as TensorFlow ops, use</p>
<p><code>python
  result = SparseTensor(input.indices, fn(input.values), input.shape)</code></p>
<p>If, however, the function is not expressible as a TensorFlow op, then use</p>
<p><code>python
result = SparseTensor(input.indices, map_fn(fn, input.values), input.shape)</code></p>
<p>instead.</p>
<p>Args:
  fn: The callable to be performed.  It accepts one argument, which will
    have the same (possibly nested) structure as <code>elems</code>.  Its output
    must have the same structure as <code>dtype</code> if one is provided, otherwise
    it must have the same structure as <code>elems</code>.
  elems: A tensor or (possibly nested) sequence of tensors, each of which
    will be unpacked along their first dimension.  The nested sequence
    of the resulting slices will be applied to <code>fn</code>.
  dtype: (optional) The output type(s) of <code>fn</code>.  If <code>fn</code> returns a structure
    of Tensors differing from the structure of <code>elems</code>, then <code>dtype</code> is not
    optional and must have the same structure as the output of <code>fn</code>.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  infer_shape: (optional) False disables tests for consistent output shapes.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor or (possibly nested) sequence of tensors.  Each tensor packs the
  results of applying <code>fn</code> to tensors unpacked from <code>elems</code> along the first
  dimension, from first to last.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable or the structure of the output of
    <code>fn</code> and <code>dtype</code> do not match, or if elems is a SparseTensor.
  ValueError: if the lengths of the output of <code>fn</code> and <code>dtype</code> do not match.</p>
<p>Examples:
  <code>python
  elems = np.array([1, 2, 3, 4, 5, 6])
  squares = map_fn(lambda x: x * x, elems)
  # squares == [1, 4, 9, 16, 25, 36]</code></p>
<p><code>python
  elems = (np.array([1, 2, 3]), np.array([-1, 1, -1]))
  alternate = map_fn(lambda x: x[0] * x[1], elems, dtype=tf.int64)
  # alternate == [-1, 2, -3]</code></p>
<p><code>python
  elems = np.array([1, 2, 3])
  alternates = map_fn(lambda x: (x, -x), elems, dtype=(tf.int64, tf.int64))
  # alternates[0] == [1, 2, 3]
  # alternates[1] == [-1, -2, -3]</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.map_fn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.map_fn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matching_files">
    <p>def <span class="ident">matching_files</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matching_files(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matching_files</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matching_files(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matching_files(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matching_files</strong></p>
<div class="codehilite"><pre><span></span>Returns the set of files matching a pattern.
</pre></div>


<p>Note that this routine only supports wildcard characters in the
basename portion of the pattern, not in the directory portion.</p>
<p>Args:
  pattern: A <code>Tensor</code> of type <code>string</code>. A (scalar) shell wildcard pattern.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. A vector of matching filenames.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matching_files', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matching_files" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matmul">
    <p>def <span class="ident">matmul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matmul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matmul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matmul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matmul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matmul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies matrix `a` by matrix `b`, producing `a` * `b`.
</pre></div>


<p>The inputs must be matrices (or tensors of rank &gt; 2, representing batches of
matrices), with matching inner dimensions, possibly after transposition.</p>
<p>Both matrices must be of the same type. The supported types are:
<code>float16</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>complex128</code>.</p>
<p>Either matrix can be transposed or adjointed (conjugated and transposed) on
the fly by setting one of the corresponding flag to <code>True</code>. These are <code>False</code>
by default.</p>
<p>If one or both of the matrices contain a lot of zeros, a more efficient
multiplication algorithm can be used by setting the corresponding
<code>a_is_sparse</code> or <code>b_is_sparse</code> flag to <code>True</code>. These are <code>False</code> by default.
This optimization is only available for plain matrices (rank-2 tensors) with
datatypes <code>bfloat16</code> or <code>float32</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>2-D tensor <code>a</code></h1>
<p>a = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3]) =&gt; [[1. 2. 3.]
                                                      [4. 5. 6.]]</p>
<h1>2-D tensor <code>b</code></h1>
<p>b = tf.constant([7, 8, 9, 10, 11, 12], shape=[3, 2]) =&gt; [[7. 8.]
                                                         [9. 10.]
                                                         [11. 12.]]
c = tf.matmul(a, b) =&gt; [[58 64]
                        [139 154]]</p>
<h1>3-D tensor <code>a</code></h1>
<p>a = tf.constant(np.arange(1,13), shape=[2, 2, 3]) =&gt; [[[ 1.  2.  3.]
                                                       [ 4.  5.  6.]],
                                                      [[ 7.  8.  9.]
                                                       [10. 11. 12.]]]</p>
<h1>3-D tensor <code>b</code></h1>
<p>b = tf.constant(np.arange(13,25), shape=[2, 3, 2]) =&gt; [[[13. 14.]
                                                        [15. 16.]
                                                        [17. 18.]],
                                                       [[19. 20.]
                                                        [21. 22.]
                                                        [23. 24.]]]
c = tf.matmul(a, b) =&gt; [[[ 94 100]
                         [229 244]],
                        [[508 532]
                         [697 730]]]
```</p>
<p>Args:
  a: <code>Tensor</code> of type <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>,
    <code>complex128</code> and rank &gt; 1.
  b: <code>Tensor</code> with same type and rank as <code>a</code>.
  transpose_a: If <code>True</code>, <code>a</code> is transposed before multiplication.
  transpose_b: If <code>True</code>, <code>b</code> is transposed before multiplication.
  adjoint_a: If <code>True</code>, <code>a</code> is conjugated and transposed before
    multiplication.
  adjoint_b: If <code>True</code>, <code>b</code> is conjugated and transposed before
    multiplication.
  a_is_sparse: If <code>True</code>, <code>a</code> is treated as a sparse matrix.
  b_is_sparse: If <code>True</code>, <code>b</code> is treated as a sparse matrix.
  name: Name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same type as <code>a</code> and <code>b</code> where each inner-most matrix is
  the product of the corresponding matrices in <code>a</code> and <code>b, e.g. if all
  transpose or adjoint attributes are</code>False`:</p>
<p>output[..., :, :] = a[..., :, :] * b[..., :, :] ,</p>
<p>Raises:
  ValueError: If transpose_a and adjoint_a, or transpose_b and adjoint_b
    are both set to True.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matmul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matmul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_band_part">
    <p>def <span class="ident">matrix_band_part</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_band_part(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_band_part</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_band_part(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_band_part(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_band_part</strong></p>
<div class="codehilite"><pre><span></span>Copy a tensor setting everything outside a central band in each innermost matrix
</pre></div>


<p>to zero.</p>
<p>The <code>band</code> part is computed as follows:
Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., M, N]</code>, then the output is a
tensor with the same shape where</p>
<p><code>band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]</code>.</p>
<p>The indicator function</p>
<p><code>in_band(m, n) = (num_lower &lt; 0 || (m-n) &lt;= num_lower)) &amp;&amp;
                 (num_upper &lt; 0 || (n-m) &lt;= num_upper)</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>if 'input' is [[ 0,  1,  2, 3]</h1>
<div class="codehilite"><pre><span></span>             [-1,  0,  1, 2]
             [-2, -1,  0, 1]
             [-3, -2, -1, 0]],
</pre></div>


<p>tf.matrix_band_part(input, 1, -1) ==&gt; [[ 0,  1,  2, 3]
                                       [-1,  0,  1, 2]
                                       [ 0, -1,  0, 1]
                                       [ 0,  0, -1, 0]],</p>
<p>tf.matrix_band_part(input, 2, 1) ==&gt; [[ 0,  1,  0, 0]
                                      [-1,  0,  1, 0]
                                      [-2, -1,  0, 1]
                                      [ 0, -2, -1, 0]]
```</p>
<p>Useful special cases:</p>
<p><code>prettyprint
 tf.matrix_band_part(input, 0, -1) ==&gt; Upper triangular part.
 tf.matrix_band_part(input, -1, 0) ==&gt; Lower triangular part.
 tf.matrix_band_part(input, 0, 0) ==&gt; Diagonal.</code></p>
<p>Args:
  input: A <code>Tensor</code>. Rank <code>k</code> tensor.
  num_lower: A <code>Tensor</code> of type <code>int64</code>.
    0-D tensor. Number of subdiagonals to keep. If negative, keep entire
    lower triangle.
  num_upper: A <code>Tensor</code> of type <code>int64</code>.
    0-D tensor. Number of superdiagonals to keep. If negative, keep
    entire upper triangle.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Rank <code>k</code> tensor of the same shape as input. The extracted banded tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_band_part', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_band_part" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_determinant">
    <p>def <span class="ident">matrix_determinant</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_determinant(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_determinant</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_determinant(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_determinant(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_determinant</strong></p>
<div class="codehilite"><pre><span></span>Computes the determinant of one ore more square matrices.
</pre></div>


<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. The output is a tensor containing the determinants
for all input submatrices <code>[..., :, :]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
    Shape is <code>[..., M, M]</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. Shape is <code>[...]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_determinant', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_determinant" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_diag">
    <p>def <span class="ident">matrix_diag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_diag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_diag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_diag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_diag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_diag</strong></p>
<div class="codehilite"><pre><span></span>Returns a batched diagonal tensor with a given batched diagonal values.
</pre></div>


<p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
everything else padded with zeros. The diagonal is computed as follows:</p>
<p>Assume <code>diagonal</code> has <code>k</code> dimensions <code>[I, J, K, ..., N]</code>, then the output is a
tensor of rank <code>k+1</code> with dimensions [I, J, K, ..., N, N]` where:</p>
<p><code>output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]</h1>
<p>and diagonal.shape = (2, 4)</p>
<p>tf.matrix_diag(diagonal) ==&gt; [[[1, 0, 0, 0]
                                     [0, 2, 0, 0]
                                     [0, 0, 3, 0]
                                     [0, 0, 0, 4]],
                                    [[5, 0, 0, 0]
                                     [0, 6, 0, 0]
                                     [0, 0, 7, 0]
                                     [0, 0, 0, 8]]]</p>
<p>which has shape (2, 4, 4)
```</p>
<p>Args:
  diagonal: A <code>Tensor</code>. Rank <code>k</code>, where <code>k &gt;= 1</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>diagonal</code>.
  Rank <code>k+1</code>, with <code>output.shape = diagonal.shape + [diagonal.shape[-1]]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_diag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_diag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_diag_part">
    <p>def <span class="ident">matrix_diag_part</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_diag_part(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_diag_part</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_diag_part(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_diag_part(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_diag_part</strong></p>
<div class="codehilite"><pre><span></span>Returns the batched diagonal part of a batched tensor.
</pre></div>


<p>This operation returns a tensor with the <code>diagonal</code> part
of the batched <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>
<p>Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., M, N]</code>, then the output is a
tensor of rank <code>k - 1</code> with dimensions <code>[I, J, K, ..., min(M, N)]</code> where:</p>
<p><code>diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]</code>.</p>
<p>The input must be at least a matrix.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'input' is [[[1, 0, 0, 0]</h1>
<div class="codehilite"><pre><span></span>           [0, 2, 0, 0]
           [0, 0, 3, 0]
           [0, 0, 0, 4]],
          [[5, 0, 0, 0]
           [0, 6, 0, 0]
           [0, 0, 7, 0]
           [0, 0, 0, 8]]]
</pre></div>


<p>and input.shape = (2, 4, 4)</p>
<p>tf.matrix_diag_part(input) ==&gt; [[1, 2, 3, 4], [5, 6, 7, 8]]</p>
<p>which has shape (2, 4)
```</p>
<p>Args:
  input: A <code>Tensor</code>. Rank <code>k</code> tensor where <code>k &gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The extracted diagonal(s) having shape
  <code>diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_diag_part', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_diag_part" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_inverse">
    <p>def <span class="ident">matrix_inverse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_inverse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_inverse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_inverse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_inverse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_inverse</strong></p>
<div class="codehilite"><pre><span></span>Computes the inverse of one or more square invertible matrices or their
</pre></div>


<p>adjoints (conjugate transposes).</p>
<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. The output is a tensor of the same shape as the input
containing the inverse for all input submatrices <code>[..., :, :]</code>.</p>
<p>The op uses LU decomposition with partial pivoting to compute the inverses.</p>
<p>If a matrix is not invertible there is no guarantee what the op does. It
may detect the condition and raise an exception or it may simply return a
garbage result.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  adjoint: An optional <code>bool</code>. Defaults to <code>False</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. Shape is <code>[..., M, M]</code>.</p>
<p>@compatibility(numpy)
  Equivalent to np.linalg.inv
  @end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_inverse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_inverse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_set_diag">
    <p>def <span class="ident">matrix_set_diag</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_set_diag(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_set_diag</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_set_diag(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_set_diag(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_set_diag</strong></p>
<div class="codehilite"><pre><span></span>Returns a batched matrix tensor with new batched diagonal values.
</pre></div>


<p>Given <code>input</code> and <code>diagonal</code>, this operation returns a tensor with the
same shape and values as <code>input</code>, except for the main diagonal of the
innermost matrices.  These will be overwritten by the values in <code>diagonal</code>.</p>
<p>The output is computed as follows:</p>
<p>Assume <code>input</code> has <code>k+1</code> dimensions <code>[I, J, K, ..., M, N]</code> and <code>diagonal</code> has
<code>k</code> dimensions <code>[I, J, K, ..., min(M, N)]</code>.  Then the output is a
tensor of rank <code>k+1</code> with dimensions <code>[I, J, K, ..., M, N]</code> where:</p>
<ul>
<li><code>output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]</code> for <code>m == n</code>.</li>
<li><code>output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]</code> for <code>m != n</code>.</li>
</ul>
<p>Args:
  input: A <code>Tensor</code>. Rank <code>k+1</code>, where <code>k &gt;= 1</code>.
  diagonal: A <code>Tensor</code>. Must have the same type as <code>input</code>.
    Rank <code>k</code>, where <code>k &gt;= 1</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Rank <code>k+1</code>, with <code>output.shape = input.shape</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_set_diag', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_set_diag" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_solve">
    <p>def <span class="ident">matrix_solve</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_solve(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_solve</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_solve(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_solve(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_solve</strong></p>
<div class="codehilite"><pre><span></span>Solves systems of linear equations.
</pre></div>


<p><code>Matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. <code>Rhs</code> is a tensor of shape <code>[..., M, K]</code>. The <code>output</code> is
a tensor shape <code>[..., M, K]</code>.  If <code>adjoint</code> is <code>False</code> then each output matrix
satisfies <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code>.
If <code>adjoint</code> is <code>True</code> then each output matrix satisfies
<code>adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]</code>.</p>
<p>Args:
  matrix: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>, <code>complex64</code>, <code>complex128</code>.
    Shape is <code>[..., M, M]</code>.
  rhs: A <code>Tensor</code>. Must have the same type as <code>matrix</code>.
    Shape is <code>[..., M, K]</code>.
  adjoint: An optional <code>bool</code>. Defaults to <code>False</code>.
    Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
    adjoint.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>matrix</code>. Shape is <code>[..., M, K]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_solve', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_solve" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_solve_ls">
    <p>def <span class="ident">matrix_solve_ls</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_solve_ls(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_solve_ls</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_solve_ls(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_solve_ls(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_solve_ls</strong></p>
<div class="codehilite"><pre><span></span>Solves one or more linear least-squares problems.
</pre></div>


<p><code>matrix</code> is a tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
form <code>M</code>-by-<code>N</code> matrices. Rhs is a tensor of shape <code>[..., M, K]</code> whose
inner-most 2 dimensions form <code>M</code>-by-<code>K</code> matrices.   The computed output is a
<code>Tensor</code> of shape <code>[..., N, K]</code> whose inner-most 2 dimensions form <code>M</code>-by-<code>K</code>
matrices that solve the equations
<code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code> in the least squares
sense.</p>
<p>Below we will use the following notation for each pair of matrix and
right-hand sides in the batch:</p>
<p><code>matrix</code>=\(A \in \Re^{m \times n}\),
<code>rhs</code>=\(B  \in \Re^{m \times k}\),
<code>output</code>=\(X  \in \Re^{n \times k}\),
<code>l2_regularizer</code>=\(\lambda\).</p>
<p>If <code>fast</code> is <code>True</code>, then the solution is computed by solving the normal
equations using Cholesky decomposition. Specifically, if \(m \ge n\) then
\(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares
problem \(X = \mathrm{argmin}<em>{Z \in \Re^{n \times k}} ||A Z - B||_F^2 +
\lambda ||Z||_F^2\). If \(m \lt n\) then <code>output</code> is computed as
\(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is
the minimum-norm solution to the under-determined linear system, i.e.
\(X = \mathrm{argmin}</em>{Z \in \Re^{n \times k}} ||Z||<em>F^2 \), subject to
\(A Z = B\). Notice that the fast path is only numerically stable when
\(A\) is numerically full rank and has a condition number
\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon</em>{mach}}}\) or\(\lambda\)
is sufficiently large.</p>
<p>If <code>fast</code> is <code>False</code> an algorithm based on the numerically robust complete
orthogonal decomposition is used. This computes the minimum-norm
least-squares solution, even when \(A\) is rank deficient. This path is
typically 6-7 times slower than the fast path. If <code>fast</code> is <code>False</code> then
<code>l2_regularizer</code> is ignored.</p>
<p>Args:
  matrix: <code>Tensor</code> of shape <code>[..., M, N]</code>.
  rhs: <code>Tensor</code> of shape <code>[..., M, K]</code>.
  l2_regularizer: 0-D <code>double</code> <code>Tensor</code>. Ignored if <code>fast=False</code>.
  fast: bool. Defaults to <code>True</code>.
  name: string, optional name of the operation.</p>
<p>Returns:
  output: <code>Tensor</code> of shape <code>[..., N, K]</code> whose inner-most 2 dimensions form
    <code>M</code>-by-<code>K</code> matrices that solve the equations
    <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code> in the least
    squares sense.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_solve_ls', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_solve_ls" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_transpose">
    <p>def <span class="ident">matrix_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_transpose</strong></p>
<div class="codehilite"><pre><span></span>Transposes last two dimensions of tensor `a`.
</pre></div>


<p>For example:</p>
<p>```python</p>
<h1>Matrix with no batch dimension.</h1>
<h1>'x' is [[1 2 3]</h1>
<h1>[4 5 6]]</h1>
<p>tf.matrix_transpose(x) ==&gt; [[1 4]
                                 [2 5]
                                 [3 6]]</p>
<h1>Matrix with two batch dimensions.</h1>
<h1>x.shape is [1, 2, 3, 4]</h1>
<h1>tf.matrix_transpose(x) is shape [1, 2, 4, 3]</h1>
<p>```</p>
<p>Args:
  a: A <code>Tensor</code> with <code>rank &gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A transposed batch matrix <code>Tensor</code>.</p>
<p>Raises:
  ValueError:  If <code>a</code> is determined statically to have <code>rank &lt; 2</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.matrix_triangular_solve">
    <p>def <span class="ident">matrix_triangular_solve</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_triangular_solve(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.matrix_triangular_solve</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.matrix_triangular_solve(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.matrix_triangular_solve(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.matrix_triangular_solve</strong></p>
<div class="codehilite"><pre><span></span>Solves systems of linear equations with upper or lower triangular matrices by
</pre></div>


<p>backsubstitution.</p>
<p><code>matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions form
square matrices. If <code>lower</code> is <code>True</code> then the strictly upper triangular part
of each inner-most matrix is assumed to be zero and not accessed.
If <code>lower</code> is False then the strictly lower triangular part of each inner-most
matrix is assumed to be zero and not accessed.
<code>rhs</code> is a tensor of shape <code>[..., M, K]</code>.</p>
<p>The output is a tensor of shape <code>[..., M, K]</code>. If <code>adjoint</code> is
<code>True</code> then the innermost matrices in output<code>satisfy matrix equations</code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]<code>.
If</code>adjoint<code>is</code>False<code>then the strictly then the  innermost matrices in</code>output<code>satisfy matrix equations</code>adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.</p>
<p>Args:
  matrix: A <code>Tensor</code>. Must be one of the following types: <code>float64</code>, <code>float32</code>.
    Shape is <code>[..., M, M]</code>.
  rhs: A <code>Tensor</code>. Must have the same type as <code>matrix</code>.
    Shape is <code>[..., M, K]</code>.
  lower: An optional <code>bool</code>. Defaults to <code>True</code>.
    Boolean indicating whether the innermost matrices in <code>matrix</code> are
    lower or upper triangular.
  adjoint: An optional <code>bool</code>. Defaults to <code>False</code>.
    Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
             adjoint.</p>
<div class="codehilite"><pre><span></span><span class="p">@</span><span class="n">compatibility</span><span class="p">(</span><span class="n">numpy</span><span class="p">)</span>
<span class="n">Equivalent</span> <span class="n">to</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">triangular_solve</span>
<span class="p">@</span><span class="n">end_compatibility</span>
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>matrix</code>. Shape is <code>[..., M, K]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.matrix_triangular_solve', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.matrix_triangular_solve" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool">
    <p>def <span class="ident">max_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnmax_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnmax_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnmax_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the max pooling on the input.
</pre></div>


<p>Args:
  value: A 4-D <code>Tensor</code> with shape <code>[batch, height, width, channels]</code> and
    type <code>tf.float32</code>.
  ksize: A list of ints that has length &gt;= 4.  The size of the window for
    each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.  The stride of the sliding
    window for each dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with type <code>tf.float32</code>.  The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool2d">
    <p>def <span class="ident">max_pool2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersmax_pool2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersmax_pool2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersmax_pool2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D Max Pooling op.
</pre></div>


<p>It is assumed that the pooling is done per image but not in batch or channels.</p>
<p>Args:
  inputs: A 4-D tensor of shape <code>[batch_size, height, width, channels]</code> if
    <code>data_format</code> is <code>NHWC</code>, and <code>[batch_size, channels, height, width]</code> if
    <code>data_format</code> is <code>NCHW</code>.
  kernel_size: A list of length 2: [kernel_height, kernel_width] of the
    pooling kernel over which the op is computed. Can be an int if both
    values are the same.
  stride: A list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: The padding method, either 'VALID' or 'SAME'.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.
  ValueError: If 'kernel_size' is not a 2-D list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d">
    <p>def <span class="ident">max_pool3d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnmax_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnmax_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnmax_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D max pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer">
    <p>def <span class="ident">max_pool3d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D max pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_grad">
    <p>def <span class="ident">max_pool3d_grad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_grad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnmax_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnmax_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_grad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnmax_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of max pooling function.
</pre></div>


<p>Args:
  orig_input: A <code>Tensor</code> of type <code>float32</code>. The original input tensor.
  orig_output: A <code>Tensor</code> of type <code>float32</code>. The original output tensor.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer">
    <p>def <span class="ident">max_pool3d_grad_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_grad_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_grad_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of max pooling function.
</pre></div>


<p>Args:
  orig_input: A <code>Tensor</code> of type <code>float32</code>. The original input tensor.
  orig_output: A <code>Tensor</code> of type <code>float32</code>. The original output tensor.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer">
    <p>def <span class="ident">max_pool3d_grad_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_grad_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool3d_grad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool3d_grad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_grad_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d_grad`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool3d_grad</strong></p>
<div class="codehilite"><pre><span></span>Computes gradients of max pooling function.
</pre></div>


<p>Args:
  orig_input: A <code>Tensor</code> of type <code>float32</code>. The original input tensor.
  orig_output: A <code>Tensor</code> of type <code>float32</code>. The original output tensor.
  grad: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>grad</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_grad_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool3d_layer">
    <p>def <span class="ident">max_pool3d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool3d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool3d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool3d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool3d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool3d</strong></p>
<div class="codehilite"><pre><span></span>Performs 3D max pooling on the input.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The size of the window for each dimension of
    the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
  strides: A list of <code>ints</code> that has length <code>&gt;= 5</code>.
    1-D tensor of length 5. The stride of the sliding window for each
    dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool3d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool3d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer">
    <p>def <span class="ident">max_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the max pooling on the input.
</pre></div>


<p>Args:
  value: A 4-D <code>Tensor</code> with shape <code>[batch, height, width, channels]</code> and
    type <code>tf.float32</code>.
  ksize: A list of ints that has length &gt;= 4.  The size of the window for
    each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.  The stride of the sliding
    window for each dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with type <code>tf.float32</code>.  The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_layer">
    <p>def <span class="ident">max_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool</strong></p>
<div class="codehilite"><pre><span></span>Performs the max pooling on the input.
</pre></div>


<p>Args:
  value: A 4-D <code>Tensor</code> with shape <code>[batch, height, width, channels]</code> and
    type <code>tf.float32</code>.
  ksize: A list of ints that has length &gt;= 4.  The size of the window for
    each dimension of the input tensor.
  strides: A list of ints that has length &gt;= 4.  The stride of the sliding
    window for each dimension of the input tensor.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  name: Optional name for the operation.</p>
<p>Returns:
  A <code>Tensor</code> with type <code>tf.float32</code>.  The max pooled output tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_with_argmax">
    <p>def <span class="ident">max_pool_with_argmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_with_argmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnmax_pool_with_argmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnmax_pool_with_argmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_with_argmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnmax_pool_with_argmax</strong></p>
<div class="codehilite"><pre><span></span>Performs max pooling on the input and outputs both max values and indices.
</pre></div>


<p>The indices in <code>argmax</code> are flattened, so that a maximum value at position
<code>[b, y, x, c]</code> becomes flattened index
<code>((b * height + y) * width + x) * channels + c</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The size of the window for each dimension of the input tensor.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  Targmax: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, argmax).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.
  argmax: A <code>Tensor</code> of type <code>Targmax</code>. 4-D.  The flattened indices of the max values chosen for each output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer">
    <p>def <span class="ident">max_pool_with_argmax_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_with_argmax_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool_with_argmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool_with_argmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_with_argmax_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool_with_argmax`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool_with_argmax</strong></p>
<div class="codehilite"><pre><span></span>Performs max pooling on the input and outputs both max values and indices.
</pre></div>


<p>The indices in <code>argmax</code> are flattened, so that a maximum value at position
<code>[b, y, x, c]</code> becomes flattened index
<code>((b * height + y) * width + x) * channels + c</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The size of the window for each dimension of the input tensor.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  Targmax: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, argmax).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.
  argmax: A <code>Tensor</code> of type <code>Targmax</code>. 4-D.  The flattened indices of the max values chosen for each output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer">
    <p>def <span class="ident">max_pool_with_argmax_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_with_argmax_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.max_pool_with_argmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.max_pool_with_argmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.max_pool_with_argmax_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.max_pool_with_argmax`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.max_pool_with_argmax</strong></p>
<div class="codehilite"><pre><span></span>Performs max pooling on the input and outputs both max values and indices.
</pre></div>


<p>The indices in <code>argmax</code> are flattened, so that a maximum value at position
<code>[b, y, x, c]</code> becomes flattened index
<code>((b * height + y) * width + x) * channels + c</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.
  ksize: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The size of the window for each dimension of the input tensor.
  strides: A list of <code>ints</code> that has length <code>&gt;= 4</code>.
    The stride of the sliding window for each dimension of the
    input tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  Targmax: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, argmax).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.
  argmax: A <code>Tensor</code> of type <code>Targmax</code>. 4-D.  The flattened indices of the max values chosen for each output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.max_pool_with_argmax_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.maximize">
    <p>def <span class="ident">maximize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.maximize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuildermaximize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuildermaximize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.maximize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorbuildermaximize</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.maximize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.maximize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.maximum">
    <p>def <span class="ident">maximum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.maximum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.maximum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.maximum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.maximum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.maximum</strong></p>
<div class="codehilite"><pre><span></span>Returns the max of x and y (i.e. x &gt; y ? x : y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Maximum</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.maximum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.maximum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.merge_all_summaries">
    <p>def <span class="ident">merge_all_summaries</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.merge_all_summaries(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.merge_all_summaries</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.merge_all_summaries(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.merge_all_summaries(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.merge_all_summaries</strong></p>
<div class="codehilite"><pre><span></span>Merges all summaries collected in the default graph. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-30.
Instructions for updating:
Please switch to tf.summary.merge_all.</p>
<p>Args:
    key: <code>GraphKey</code> used to collect the summaries.  Defaults to
      <code>GraphKeys.SUMMARIES</code>.</p>
<p>Returns:
    If no summaries were collected, returns None.  Otherwise returns a scalar
    <code>Tensor</code> of type <code>string</code> containing the serialized <code>Summary</code> protocol
    buffer resulting from the merging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.merge_all_summaries', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.merge_all_summaries" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.merge_summary">
    <p>def <span class="ident">merge_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.merge_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.merge_summary</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.merge_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.merge_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.merge_summary</strong></p>
<div class="codehilite"><pre><span></span>Merges summaries. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-30.
Instructions for updating:
Please switch to tf.summary.merge.</p>
<p>This op creates a
  <a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
  protocol buffer that contains the union of all the values in the input
  summaries.</p>
<p>When the Op is run, it reports an <code>InvalidArgument</code> error if multiple values
  in the summaries to merge use the same tag.</p>
<p>Args:
    inputs: A list of <code>string</code> <code>Tensor</code> objects containing serialized <code>Summary</code>
      protocol buffers.
    collections: Optional list of graph collections keys. The new summary op is
      added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
    name: A name for the operation (optional).</p>
<p>Returns:
    A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
    buffer resulting from the merging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.merge_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.merge_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.meshgrid">
    <p>def <span class="ident">meshgrid</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.meshgrid(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.meshgrid</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.meshgrid(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.meshgrid(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.meshgrid</strong></p>
<div class="codehilite"><pre><span></span>Broadcasts parameters for evaluation on an N-D grid.
</pre></div>


<p>Given N one-dimensional coordinate arrays <code>*args</code>, returns a list <code>outputs</code>
of N-D coordinate arrays for evaluating expressions on an N-D grid.</p>
<p>Notes:</p>
<p><code>meshgrid</code> supports cartesian ('xy') and matrix ('ij') indexing conventions.
When the <code>indexing</code> argument is set to 'xy' (the default), the broadcasting
instructions for the first two dimensions are swapped.</p>
<p>Examples:</p>
<p>Calling <code>X, Y = meshgrid(x, y)</code> with the tensors</p>
<p><code>prettyprint
  x = [1, 2, 3]
  y = [4, 5, 6]</code></p>
<p>results in</p>
<p><code>prettyprint
  X = [[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]]
  Y = [[4, 5, 6],
       [4, 5, 6],
       [4, 5, 6]]</code></p>
<p>Args:
  *args: <code>Tensor</code>s with rank 1
  indexing: Either 'xy' or 'ij' (optional, default: 'xy')
  name: A name for the operation (optional).</p>
<p>Returns:
  outputs: A list of N <code>Tensor</code>s with rank N</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.meshgrid', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.meshgrid" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner">
    <p>def <span class="ident">min_max_variable_partitioner</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.min_max_variable_partitioner(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.min_max_variable_partitioner</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.min_max_variable_partitioner(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.min_max_variable_partitioner(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.min_max_variable_partitioner</strong></p>
<div class="codehilite"><pre><span></span>Partitioner to allocate minimum size per slice.
</pre></div>


<p>Returns a partitioner that partitions the variable of given shape and dtype
such that each partition has a minimum of <code>min_slice_size</code> slice of the
variable. The maximum number of such partitions (upper bound) is given by
<code>max_partitions</code>.</p>
<p>Args:
  max_partitions: Upper bound on the number of partitions. Defaults to 1.
  axis: Axis along which to partition the variable. Defaults to 0.
  min_slice_size: Minimum size of the variable slice per partition. Defaults
    to 256K.
  bytes_per_string_element: If the <code>Variable</code> is of type string, this provides
    an estimate of how large each scalar in the <code>Variable</code> is.</p>
<p>Returns:
  A partition function usable as the <code>partitioner</code> argument to
  <code>variable_scope</code>, <code>get_variable</code>, and <code>get_partitioned_variable_list</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.min_max_variable_partitioner" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.minimize">
    <p>def <span class="ident">minimize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.minimize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderminimize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuilderminimize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.minimize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorbuilderminimize</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.minimize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.minimize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.minimum">
    <p>def <span class="ident">minimum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.minimum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.minimum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.minimum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.minimum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.minimum</strong></p>
<div class="codehilite"><pre><span></span>Returns the min of x and y (i.e. x &lt; y ? x : y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Minimum</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.minimum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.minimum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.mod">
    <p>def <span class="ident">mod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.mod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.mod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.mod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.mod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.mod</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise remainder of division.
</pre></div>


<p><em>NOTE</em>: <code>Mod</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>, <code>float32</code>, <code>float64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.mod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.mod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.model_variables">
    <p>def <span class="ident">model_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.model_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.model_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.model_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.model_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.model_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables in the MODEL_VARIABLES collection.
</pre></div>


<p>Returns:
  A list of local Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.model_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.model_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moments">
    <p>def <span class="ident">moments</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moments(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnmoments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnmoments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moments(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnmoments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of `x`.
</pre></div>


<p>The mean and variance are calculated by aggregating the contents of <code>x</code>
across <code>axes</code>.  If <code>x</code> is 1-D and <code>axes = [0]</code> this is just the mean
and variance of a vector.</p>
<p>When using these moments for batch normalization (see
<code>tf.nn.batch_normalization</code>):</p>
<ul>
<li>for so-called "global normalization", used with convolutional filters with
   shape <code>[batch, height, width, depth]</code>, pass <code>axes=[0, 1, 2]</code>.</li>
<li>for simple batch normalization pass <code>axes=[0]</code> (batch only).</li>
</ul>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints.  Axes along which to compute mean and
    variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  name: Name used to scope the operations that compute the moments.
  keep_dims: produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moments', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moments" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moments_conv2d_layer">
    <p>def <span class="ident">moments_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moments_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moments_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.moments`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of `x`.
</pre></div>


<p>The mean and variance are calculated by aggregating the contents of <code>x</code>
across <code>axes</code>.  If <code>x</code> is 1-D and <code>axes = [0]</code> this is just the mean
and variance of a vector.</p>
<p>When using these moments for batch normalization (see
<code>tf.nn.batch_normalization</code>):</p>
<ul>
<li>for so-called "global normalization", used with convolutional filters with
   shape <code>[batch, height, width, depth]</code>, pass <code>axes=[0, 1, 2]</code>.</li>
<li>for simple batch normalization pass <code>axes=[0]</code> (batch only).</li>
</ul>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints.  Axes along which to compute mean and
    variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  name: Name used to scope the operations that compute the moments.
  keep_dims: produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moments_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moments_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moments_layer">
    <p>def <span class="ident">moments_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moments_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moments_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.moments`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of `x`.
</pre></div>


<p>The mean and variance are calculated by aggregating the contents of <code>x</code>
across <code>axes</code>.  If <code>x</code> is 1-D and <code>axes = [0]</code> this is just the mean
and variance of a vector.</p>
<p>When using these moments for batch normalization (see
<code>tf.nn.batch_normalization</code>):</p>
<ul>
<li>for so-called "global normalization", used with convolutional filters with
   shape <code>[batch, height, width, depth]</code>, pass <code>axes=[0, 1, 2]</code>.</li>
<li>for simple batch normalization pass <code>axes=[0]</code> (batch only).</li>
</ul>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints.  Axes along which to compute mean and
    variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  name: Name used to scope the operations that compute the moments.
  keep_dims: produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moments_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moments_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.moving_average_variables">
    <p>def <span class="ident">moving_average_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moving_average_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.moving_average_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.moving_average_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.moving_average_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.moving_average_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables that maintain their moving averages.
</pre></div>


<p>If an <code>ExponentialMovingAverage</code> object is created and the <code>apply()</code>
method is called on a list of variables, these variables will
be added to the <code>GraphKeys.MOVING_AVERAGE_VARIABLES</code> collection.
This convenience function returns the contents of that collection.</p>
<p>Returns:
  A list of Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.moving_average_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.moving_average_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.mul">
    <p>def <span class="ident">mul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.mul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.mul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.mul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.mul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.mul</strong></p>
<div class="codehilite"><pre><span></span>Returns x * y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Mul</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.mul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.mul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.multinomial">
    <p>def <span class="ident">multinomial</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.multinomial(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.multinomial</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.multinomial(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.multinomial(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.multinomial</strong></p>
<div class="codehilite"><pre><span></span>Draws samples from a multinomial distribution.
</pre></div>


<p>Example:</p>
<p>```python</p>
<h1>samples has shape [1, 5], where each value is either 0 or 1 with equal</h1>
<h1>probability.</h1>
<p>samples = tf.multinomial(tf.log([[10., 10.]]), 5)
```</p>
<p>Args:
  logits: 2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice
    <code>[i, :]</code> represents the unnormalized log probabilities for all classes.
  num_samples: 0-D.  Number of independent samples to draw for each row slice.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: Optional name for the operation.</p>
<p>Returns:
  The drawn samples of shape <code>[batch_size, num_samples]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.multinomial', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.multinomial" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.multiply">
    <p>def <span class="ident">multiply</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.multiply(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.multiply</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.multiply(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.multiply(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.multiply</strong></p>
<div class="codehilite"><pre><span></span>Returns x * y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Mul</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.multiply', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.multiply" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.name_scope">
    <p>def <span class="ident">name_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.name_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.name_scope</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.name_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.name_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.name_scope</strong></p>
<div class="codehilite"><pre><span></span>Returns a context manager for use when defining a Python op.
</pre></div>


<p>This context manager validates that the given <code>values</code> are from the
same graph, makes that graph the default graph, and pushes a
name scope in that graph (see
<a href="../../api_docs/python/framework.md#Graph.name_scope"><code>Graph.name_scope()</code></a>
for more details on that).</p>
<p>For example, to define a new Python op called <code>my_op</code>:</p>
<p><code>python
def my_op(a, b, c, name=None):
  with tf.name_scope(name, "MyOp", [a, b, c]) as scope:
    a = tf.convert_to_tensor(a, name="a")
    b = tf.convert_to_tensor(b, name="b")
    c = tf.convert_to_tensor(c, name="c")
    # Define some computation that uses `a`, `b`, and `c`.
    return foo_op(..., name=scope)</code></p>
<p>Args:
  name: The name argument that is passed to the op function.
  default_name: The default name to use if the <code>name</code> argument is <code>None</code>.
  values: The list of <code>Tensor</code> arguments that are passed to the op function.</p>
<p>Returns:
  A context manager for use in defining Python ops. Yields the name scope.</p>
<p>Raises:
  ValueError: if neither <code>name</code> nor <code>default_name</code> is provided
    but <code>values</code> are.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.name_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.name_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.nce_loss">
    <p>def <span class="ident">nce_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.nce_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnnce_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnnce_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.nce_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnnce_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the noise-contrastive estimation training loss.
</pre></div>


<p>See <a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf">Noise-contrastive estimation: A new estimation principle for
unnormalized statistical models</a>.
Also see our <a href="../../extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a></p>
<p>Note: By default this uses a log-uniform (Zipfian) distribution for sampling,
so your labels must be sorted in order of decreasing frequency to achieve
good results.  For more details, see
<a href="#log_uniform_candidate_sampler">log_uniform_candidate_sampler</a>.</p>
<p>Note: In the case where <code>num_true</code> &gt; 1, we assign to each target class
the target probability 1 / <code>num_true</code> so that the target probabilities
sum to 1 per-example.</p>
<p>Note: It would be useful to allow a variable number of target classes per
example.  We hope to provide this functionality in a future release.
For now, if you have a variable number of target classes, you can pad them
out to a constant number by either repeating them or by padding
with an otherwise unused class.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-partitioned) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  Whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  If set to
      <code>True</code>, this is a "Sampled Logistic" loss instead of NCE, and we are
      learning to generate log-odds instead of log probabilities.  See
      our [Candidate Sampling Algorithms Reference]
      (../../extras/candidate_sampling.pdf).
      Default is False.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example NCE losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.nce_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.nce_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer">
    <p>def <span class="ident">nce_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.nce_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.nce_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.nce_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.nce_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.nce_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.nce_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the noise-contrastive estimation training loss.
</pre></div>


<p>See <a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf">Noise-contrastive estimation: A new estimation principle for
unnormalized statistical models</a>.
Also see our <a href="../../extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a></p>
<p>Note: By default this uses a log-uniform (Zipfian) distribution for sampling,
so your labels must be sorted in order of decreasing frequency to achieve
good results.  For more details, see
<a href="#log_uniform_candidate_sampler">log_uniform_candidate_sampler</a>.</p>
<p>Note: In the case where <code>num_true</code> &gt; 1, we assign to each target class
the target probability 1 / <code>num_true</code> so that the target probabilities
sum to 1 per-example.</p>
<p>Note: It would be useful to allow a variable number of target classes per
example.  We hope to provide this functionality in a future release.
For now, if you have a variable number of target classes, you can pad them
out to a constant number by either repeating them or by padding
with an otherwise unused class.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-partitioned) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  Whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  If set to
      <code>True</code>, this is a "Sampled Logistic" loss instead of NCE, and we are
      learning to generate log-odds instead of log probabilities.  See
      our [Candidate Sampling Algorithms Reference]
      (../../extras/candidate_sampling.pdf).
      Default is False.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example NCE losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.nce_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.nce_loss_layer">
    <p>def <span class="ident">nce_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.nce_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.nce_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.nce_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.nce_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.nce_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.nce_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the noise-contrastive estimation training loss.
</pre></div>


<p>See <a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf">Noise-contrastive estimation: A new estimation principle for
unnormalized statistical models</a>.
Also see our <a href="../../extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a></p>
<p>Note: By default this uses a log-uniform (Zipfian) distribution for sampling,
so your labels must be sorted in order of decreasing frequency to achieve
good results.  For more details, see
<a href="#log_uniform_candidate_sampler">log_uniform_candidate_sampler</a>.</p>
<p>Note: In the case where <code>num_true</code> &gt; 1, we assign to each target class
the target probability 1 / <code>num_true</code> so that the target probabilities
sum to 1 per-example.</p>
<p>Note: It would be useful to allow a variable number of target classes per
example.  We hope to provide this functionality in a future release.
For now, if you have a variable number of target classes, you can pad them
out to a constant number by either repeating them or by padding
with an otherwise unused class.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-partitioned) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  Whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  If set to
      <code>True</code>, this is a "Sampled Logistic" loss instead of NCE, and we are
      learning to generate log-odds instead of log probabilities.  See
      our [Candidate Sampling Algorithms Reference]
      (../../extras/candidate_sampling.pdf).
      Default is False.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example NCE losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.nce_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.nce_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.neg">
    <p>def <span class="ident">neg</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.neg(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.neg</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.neg(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.neg(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.neg</strong></p>
<div class="codehilite"><pre><span></span>Computes numerical negative value element-wise.
</pre></div>


<p>I.e., (y = -x).</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.neg', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.neg" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.negative">
    <p>def <span class="ident">negative</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.negative(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.negative</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.negative(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.negative(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.negative</strong></p>
<div class="codehilite"><pre><span></span>Computes numerical negative value element-wise.
</pre></div>


<p>I.e., \(y = -x\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.negative', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.negative" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.no_op">
    <p>def <span class="ident">no_op</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.no_op(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.no_op</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.no_op(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.no_op(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.no_op</strong></p>
<div class="codehilite"><pre><span></span>Does nothing. Only useful as a placeholder for control edges.
</pre></div>


<p>Args:
  name: A name for the operation (optional).</p>
<p>Returns:
  The created Operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.no_op', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.no_op" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.no_regularizer">
    <p>def <span class="ident">no_regularizer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.no_regularizer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.no_regularizer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.no_regularizer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.no_regularizer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.no_regularizer</strong></p>
<div class="codehilite"><pre><span></span>Use this function to prevent regularization of variables.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.no_regularizer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.no_regularizer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.normalize_moments">
    <p>def <span class="ident">normalize_moments</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.normalize_moments(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnnormalize_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnnormalize_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.normalize_moments(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnnormalize_moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of based on the sufficient statistics.
</pre></div>


<p>Args:
  counts: A <code>Tensor</code> containing a the total count of the data (one value).
  mean_ss: A <code>Tensor</code> containing the mean sufficient statistics: the (possibly
    shifted) sum of the elements to average over.
  variance_ss: A <code>Tensor</code> containing the variance sufficient statistics: the
    (possibly shifted) squared sum of the data to compute the variance over.
  shift: A <code>Tensor</code> containing the value by which the data is shifted for
    numerical stability, or <code>None</code> if no shift was performed.
  name: Name used to scope the operations that compute the moments.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.normalize_moments', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.normalize_moments" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer">
    <p>def <span class="ident">normalize_moments_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.normalize_moments_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.normalize_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.normalize_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.normalize_moments_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.normalize_moments`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.normalize_moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of based on the sufficient statistics.
</pre></div>


<p>Args:
  counts: A <code>Tensor</code> containing a the total count of the data (one value).
  mean_ss: A <code>Tensor</code> containing the mean sufficient statistics: the (possibly
    shifted) sum of the elements to average over.
  variance_ss: A <code>Tensor</code> containing the variance sufficient statistics: the
    (possibly shifted) squared sum of the data to compute the variance over.
  shift: A <code>Tensor</code> containing the value by which the data is shifted for
    numerical stability, or <code>None</code> if no shift was performed.
  name: Name used to scope the operations that compute the moments.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.normalize_moments_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.normalize_moments_layer">
    <p>def <span class="ident">normalize_moments_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.normalize_moments_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.normalize_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.normalize_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.normalize_moments_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.normalize_moments`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.normalize_moments</strong></p>
<div class="codehilite"><pre><span></span>Calculate the mean and variance of based on the sufficient statistics.
</pre></div>


<p>Args:
  counts: A <code>Tensor</code> containing a the total count of the data (one value).
  mean_ss: A <code>Tensor</code> containing the mean sufficient statistics: the (possibly
    shifted) sum of the elements to average over.
  variance_ss: A <code>Tensor</code> containing the variance sufficient statistics: the
    (possibly shifted) squared sum of the data to compute the variance over.
  shift: A <code>Tensor</code> containing the value by which the data is shifted for
    numerical stability, or <code>None</code> if no shift was performed.
  name: Name used to scope the operations that compute the moments.</p>
<p>Returns:
  Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.normalize_moments_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.normalize_moments_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.not_equal">
    <p>def <span class="ident">not_equal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.not_equal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.not_equal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.not_equal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.not_equal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.not_equal</strong></p>
<div class="codehilite"><pre><span></span>Returns the truth value of (x != y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>NotEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>quint8</code>, <code>qint8</code>, <code>qint32</code>, <code>string</code>, <code>bool</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>bool</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.not_equal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.not_equal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.one_hot">
    <p>def <span class="ident">one_hot</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.one_hot(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.one_hot</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.one_hot(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.one_hot(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.one_hot</strong></p>
<div class="codehilite"><pre><span></span>Returns a one-hot tensor.
</pre></div>


<p>The locations represented by indices in <code>indices</code> take value <code>on_value</code>,
while all other locations take value <code>off_value</code>.</p>
<p><code>on_value</code> and <code>off_value</code> must have matching data types. If <code>dtype</code> is also
provided, they must be the same data type as specified by <code>dtype</code>.</p>
<p>If <code>on_value</code> is not provided, it will default to the value <code>1</code> with type
<code>dtype</code></p>
<p>If <code>off_value</code> is not provided, it will default to the value <code>0</code> with type
<code>dtype</code></p>
<p>If the input <code>indices</code> is rank <code>N</code>, the output will have rank <code>N+1</code>. The
new axis is created at dimension <code>axis</code> (default: the new axis is appended
at the end).</p>
<p>If <code>indices</code> is a scalar the output shape will be a vector of length <code>depth</code></p>
<p>If <code>indices</code> is a vector of length <code>features</code>, the output shape will be:</p>
<p><code>features x depth if axis == -1
  depth x features if axis == 0</code></p>
<p>If <code>indices</code> is a matrix (batch) with shape <code>[batch, features]</code>, the output
shape will be:</p>
<p><code>batch x features x depth if axis == -1
  batch x depth x features if axis == 1
  depth x batch x features if axis == 0</code></p>
<p>If <code>dtype</code> is not provided, it will attempt to assume the data type of
<code>on_value</code> or <code>off_value</code>, if one or both are passed in. If none of
<code>on_value</code>, <code>off_value</code>, or <code>dtype</code> are provided, <code>dtype</code> will default to the
value <code>tf.float32</code>.</p>
<p>Note: If a non-numeric data type output is desired (<code>tf.string</code>, <code>tf.bool</code>,
etc.), both <code>on_value</code> and <code>off_value</code> <em>must</em> be provided to <code>one_hot</code>.</p>
<h1>Examples</h1>
<p>Suppose that</p>
<p><code>python
  indices = [0, 2, -1, 1]
  depth = 3
  on_value = 5.0
  off_value = 0.0
  axis = -1</code></p>
<p>Then output is <code>[4 x 3]</code>:</p>
<p><code>python
  output =
  [5.0 0.0 0.0]  // one_hot(0)
  [0.0 0.0 5.0]  // one_hot(2)
  [0.0 0.0 0.0]  // one_hot(-1)
  [0.0 5.0 0.0]  // one_hot(1)</code></p>
<p>Suppose that</p>
<p><code>python
  indices = [[0, 2], [1, -1]]
  depth = 3
  on_value = 1.0
  off_value = 0.0
  axis = -1</code></p>
<p>Then output is <code>[2 x 2 x 3]</code>:</p>
<p><code>python
  output =
  [
    [1.0, 0.0, 0.0]  // one_hot(0)
    [0.0, 0.0, 1.0]  // one_hot(2)
  ][
    [0.0, 1.0, 0.0]  // one_hot(1)
    [0.0, 0.0, 0.0]  // one_hot(-1)
  ]</code></p>
<p>Using default values for <code>on_value</code> and <code>off_value</code>:</p>
<p><code>python
  indices = [0, 1, 2]
  depth = 3</code></p>
<p>The output will be</p>
<p><code>python
  output =
  [[1., 0., 0.],
   [0., 1., 0.],
   [0., 0., 1.]]</code></p>
<p>Args:
  indices: A <code>Tensor</code> of indices.
  depth: A scalar defining the depth of the one hot dimension.
  on_value: A scalar defining the value to fill in output when <code>indices[j]
    = i</code>. (default: 1)
  off_value: A scalar defining the value to fill in output when <code>indices[j]
    != i</code>. (default: 0)
  axis: The axis to fill (default: -1, a new inner-most axis).
  dtype: The data type of the output tensor.</p>
<p>Returns:
  output: The one-hot tensor.</p>
<p>Raises:
  TypeError: If dtype of either <code>on_value</code> or <code>off_value</code> don't match <code>dtype</code>
  TypeError: If dtype of <code>on_value</code> and <code>off_value</code> don't match one another</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.one_hot', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.one_hot" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ones">
    <p>def <span class="ident">ones</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ones(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ones</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ones(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ones(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ones</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to 1.
</pre></div>


<p>This operation returns a tensor of type <code>dtype</code> with shape <code>shape</code> and all
elements set to 1.</p>
<p>For example:</p>
<p><code>python
tf.ones([2, 3], tf.int32) ==&gt; [[1, 1, 1], [1, 1, 1]]</code></p>
<p>Args:
  shape: Either a list of integers, or a 1-D <code>Tensor</code> of type <code>int32</code>.
  dtype: The type of an element in the resulting <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ones', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ones" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ones_initializer">
    <p>def <span class="ident">ones_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ones_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ones_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ones_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ones_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ones_initializer</strong></p>
<div class="codehilite"><pre><span></span>An adaptor for ones() to match the Initializer spec.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ones_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ones_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.ones_like">
    <p>def <span class="ident">ones_like</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ones_like(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.ones_like</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.ones_like(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.ones_like(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.ones_like</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to 1.
</pre></div>


<p>Given a single tensor (<code>tensor</code>), this operation returns a tensor of the same
type and shape as <code>tensor</code> with all elements set to 1. Optionally, you can
specify a new type (<code>dtype</code>) for the returned tensor.</p>
<p>For example:</p>
<p>```python</p>
<h1>'tensor' is [[1, 2, 3], [4, 5, 6]]</h1>
<p>tf.ones_like(tensor) ==&gt; [[1, 1, 1], [1, 1, 1]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  dtype: A type for the returned <code>Tensor</code>. Must be <code>float32</code>, <code>float64</code>,
    <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>complex64</code>, <code>complex128</code> or
    <code>bool</code>.
  name: A name for the operation (optional).
  optimize: if true, attempt to statically determine the shape of 'tensor'
  and encode it as a constant.</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.ones_like', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.ones_like" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.op_scope">
    <p>def <span class="ident">op_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.op_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.op_scope</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.op_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.op_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.op_scope</strong></p>
<div class="codehilite"><pre><span></span>DEPRECATED. Same as name_scope above, just different argument order.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.op_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.op_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.orthogonal_initializer">
    <p>def <span class="ident">orthogonal_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.orthogonal_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.orthogonal_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.orthogonal_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.orthogonal_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.orthogonal_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates an orthogonal matrix or a reshaped
</pre></div>


<p>orthogonal matrix.</p>
<p>If the shape of the tensor to initialize is two-dimensional, i is initialized 
with an orthogonal matrix obtained from the singular value decomposition of a 
matrix of uniform random numbers.</p>
<p>If the shape of the tensor to initialize is more than two-dimensional, a matrix
of shape <code>(shape[0] * ... * shape[n - 2], shape[n - 1])</code> is initialized, where
<code>n</code> is the length of the shape vector. The matrix is subsequently reshaped to
give a tensor of the desired shape.</p>
<p>Args:
  gain: multiplicative factor to apply to the orthogonal matrix
  dtype: The type of the output.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.</p>
<p>Returns:
  An initializer that generates orthogonal tensors</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type or if <code>shape</code> has fewer than two entries.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.orthogonal_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.orthogonal_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pack">
    <p>def <span class="ident">pack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.pack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.pack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.pack</strong></p>
<div class="codehilite"><pre><span></span>Packs a list of rank-`R` tensors into one rank-`(R+1)` tensor.
</pre></div>


<p>Packs the list of tensors in <code>values</code> into a tensor with rank one higher than
each tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.
Given a list of length <code>N</code> of tensors of shape <code>(A, B, C)</code>;</p>
<p>if <code>axis == 0</code> then the <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>.
if <code>axis == 1</code> then the <code>output</code> tensor will have the shape <code>(A, N, B, C)</code>.
Etc.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'x' is [1, 4]</h1>
<h1>'y' is [2, 5]</h1>
<h1>'z' is [3, 6]</h1>
<p>pack([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
pack([x, y, z], axis=1) =&gt; [[1, 2, 3], [4, 5, 6]]
```</p>
<p>This is the opposite of unpack.  The numpy equivalent is</p>
<div class="codehilite"><pre><span></span>tf.pack([x, y, z]) = np.asarray([x, y, z])
</pre></div>


<p>Args:
  values: A list of <code>Tensor</code> objects with the same shape and type.
  axis: An <code>int</code>. The axis to pack along. Defaults to the first dimension.
    Supports negative indexes.
  name: A name for this operation (optional).</p>
<p>Returns:
  output: A packed <code>Tensor</code> with the same type as <code>values</code>.</p>
<p>Raises:
  ValueError: If <code>axis</code> is out of the range [-(R+1), R+1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pad">
    <p>def <span class="ident">pad</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pad(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.pad</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.pad(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pad(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.pad</strong></p>
<div class="codehilite"><pre><span></span>Pads a tensor.
</pre></div>


<p>This operation pads a <code>tensor</code> according to the <code>paddings</code> you specify.
<code>paddings</code> is an integer tensor with shape <code>[n, 2]</code>, where n is the rank of
<code>tensor</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates how
many values to add before the contents of <code>tensor</code> in that dimension, and
<code>paddings[D, 1]</code> indicates how many values to add after the contents of
<code>tensor</code> in that dimension. If <code>mode</code> is "REFLECT" then both <code>paddings[D, 0]</code>
and <code>paddings[D, 1]</code> must be no greater than <code>tensor.dim_size(D) - 1</code>. If
<code>mode</code> is "SYMMETRIC" then both <code>paddings[D, 0]</code> and <code>paddings[D, 1]</code> must be
no greater than <code>tensor.dim_size(D)</code>.</p>
<p>The padded size of each dimension D of the output is:</p>
<p><code>paddings[D, 0] + tensor.dim_size(D) + paddings[D, 1]</code></p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[1, 2, 3], [4, 5, 6]].</h1>
<h1>'paddings' is [[1, 1,], [2, 2]].</h1>
<h1>rank of 't' is 2.</h1>
<p>pad(t, paddings, "CONSTANT") ==&gt; [[0, 0, 0, 0, 0, 0, 0],
                                  [0, 0, 1, 2, 3, 0, 0],
                                  [0, 0, 4, 5, 6, 0, 0],
                                  [0, 0, 0, 0, 0, 0, 0]]</p>
<p>pad(t, paddings, "REFLECT") ==&gt; [[6, 5, 4, 5, 6, 5, 4],
                                 [3, 2, 1, 2, 3, 2, 1],
                                 [6, 5, 4, 5, 6, 5, 4],
                                 [3, 2, 1, 2, 3, 2, 1]]</p>
<p>pad(t, paddings, "SYMMETRIC") ==&gt; [[2, 1, 1, 2, 3, 3, 2],
                                   [2, 1, 1, 2, 3, 3, 2],
                                   [5, 4, 4, 5, 6, 6, 5],
                                   [5, 4, 4, 5, 6, 6, 5]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  paddings: A <code>Tensor</code> of type <code>int32</code>.
  mode: One of "CONSTANT", "REFLECT", or "SYMMETRIC" (case-insensitive)
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>.</p>
<p>Raises:
  ValueError: When mode is not one of "CONSTANT", "REFLECT", or "SYMMETRIC".</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pad', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pad" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_example">
    <p>def <span class="ident">parse_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_example</strong></p>
<div class="codehilite"><pre><span></span>Parses `Example` protos into a `dict` of tensors.
</pre></div>


<p>Parses a number of serialized <a href="https://www.tensorflow.org/code/tensorflow/core/example/example.proto"><code>Example</code></a>
protos given in <code>serialized</code>.</p>
<p><code>example_names</code> may contain descriptive names for the corresponding serialized
protos. These may be useful for debugging purposes, but they have no effect on
the output. If not <code>None</code>, <code>example_names</code> must be the same length as <code>serialized</code>.</p>
<p>This op parses serialized examples into a dictionary mapping keys to <code>Tensor</code>
and <code>SparseTensor</code> objects. <code>features</code> is a dict from keys to <code>VarLenFeature</code>
and <code>FixedLenFeature</code> objects. Each <code>VarLenFeature</code> is mapped to a
<code>SparseTensor</code>, and each <code>FixedLenFeature</code> is mapped to a <code>Tensor</code>.</p>
<p>Each <code>VarLenFeature</code> maps to a <code>SparseTensor</code> of the specified type
representing a ragged matrix. Its indices are <code>[batch, index]</code> where <code>batch</code>
is the batch entry the value is from in <code>serialized</code>, and <code>index</code> is the
value's index in the list of values associated with that feature and example.</p>
<p>Each <code>FixedLenFeature</code> <code>df</code> maps to a <code>Tensor</code> of the specified type (or
<code>tf.float32</code> if not specified) and shape <code>(serialized.size(),) + df.shape</code>.</p>
<p><code>FixedLenFeature</code> entries with a <code>default_value</code> are optional. With no default
value, we will fail if that <code>Feature</code> is missing from any example in
<code>serialized</code>.</p>
<p>Examples:</p>
<p>For example, if one expects a <code>tf.float32</code> sparse feature <code>ft</code> and three
serialized <code>Example</code>s are provided:</p>
<p><code>serialized = [
  features
    { feature { key: "ft" value { float_list { value: [1.0, 2.0] } } } },
  features
    { feature []},
  features
    { feature { key: "ft" value { float_list { value: [3.0] } } }
]</code></p>
<p>then the output will look like:</p>
<p><code>{"ft": SparseTensor(indices=[[0, 0], [0, 1], [2, 0]],
                    values=[1.0, 2.0, 3.0],
                    shape=(3, 2)) }</code></p>
<p>Given two <code>Example</code> input protos in <code>serialized</code>:</p>
<p><code>[
  features {
    feature { key: "kw" value { bytes_list { value: [ "knit", "big" ] } } }
    feature { key: "gps" value { float_list { value: [] } } }
  },
  features {
    feature { key: "kw" value { bytes_list { value: [ "emmy" ] } } }
    feature { key: "dank" value { int64_list { value: [ 42 ] } } }
    feature { key: "gps" value { } }
  }
]</code></p>
<p>And arguments</p>
<p><code>example_names: ["input0", "input1"],
features: {
    "kw": VarLenFeature(tf.string),
    "dank": VarLenFeature(tf.int64),
    "gps": VarLenFeature(tf.float32),
}</code></p>
<p>Then the output is a dictionary:</p>
<p><code>python
{
  "kw": SparseTensor(
      indices=[[0, 0], [0, 1], [1, 0]],
      values=["knit", "big", "emmy"]
      shape=[2, 2]),
  "dank": SparseTensor(
      indices=[[1, 0]],
      values=[42],
      shape=[2, 1]),
  "gps": SparseTensor(
      indices=[],
      values=[],
      shape=[2, 0]),
}</code></p>
<p>For dense results in two serialized <code>Example</code>s:</p>
<p><code>[
  features {
    feature { key: "age" value { int64_list { value: [ 0 ] } } }
    feature { key: "gender" value { bytes_list { value: [ "f" ] } } }
   },
   features {
    feature { key: "age" value { int64_list { value: [] } } }
    feature { key: "gender" value { bytes_list { value: [ "f" ] } } }
  }
]</code></p>
<p>We can use arguments:</p>
<p><code>example_names: ["input0", "input1"],
features: {
    "age": FixedLenFeature([], dtype=tf.int64, default_value=-1),
    "gender": FixedLenFeature([], dtype=tf.string),
}</code></p>
<p>And the expected output is:</p>
<p><code>python
{
  "age": [[0], [-1]],
  "gender": [["f"], ["f"]],
}</code></p>
<p>Args:
  serialized: A vector (1-D Tensor) of strings, a batch of binary
    serialized <code>Example</code> protos.
  features: A <code>dict</code> mapping feature keys to <code>FixedLenFeature</code> or
    <code>VarLenFeature</code> values.
  name: A name for this operation (optional).
  example_names: A vector (1-D Tensor) of strings (optional), the names of
    the serialized protos in the batch.</p>
<p>Returns:
  A <code>dict</code> mapping feature keys to <code>Tensor</code> and <code>SparseTensor</code> values.</p>
<p>Raises:
  ValueError: if any feature is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_single_example">
    <p>def <span class="ident">parse_single_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_single_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_single_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_single_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_single_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_single_example</strong></p>
<div class="codehilite"><pre><span></span>Parses a single `Example` proto.
</pre></div>


<p>Similar to <code>parse_example</code>, except:</p>
<p>For dense tensors, the returned <code>Tensor</code> is identical to the output of
<code>parse_example</code>, except there is no batch dimension, the output shape is the
same as the shape given in <code>dense_shape</code>.</p>
<p>For <code>SparseTensor</code>s, the first (batch) column of the indices matrix is removed
(the indices matrix is a column vector), the values vector is unchanged, and
the first (<code>batch_size</code>) entry of the shape vector is removed (it is now a
single element vector).</p>
<p>Args:
  serialized: A scalar string Tensor, a single serialized Example.
    See <code>_parse_single_example_raw</code> documentation for more details.
  features: A <code>dict</code> mapping feature keys to <code>FixedLenFeature</code> or
    <code>VarLenFeature</code> values.
  name: A name for this operation (optional).
  example_names: (Optional) A scalar string Tensor, the associated name.
    See <code>_parse_single_example_raw</code> documentation for more details.</p>
<p>Returns:
  A <code>dict</code> mapping feature keys to <code>Tensor</code> and <code>SparseTensor</code> values.</p>
<p>Raises:
  ValueError: if any feature is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_single_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_single_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_single_sequence_example">
    <p>def <span class="ident">parse_single_sequence_example</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_single_sequence_example(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_single_sequence_example</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_single_sequence_example(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_single_sequence_example(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_single_sequence_example</strong></p>
<div class="codehilite"><pre><span></span>Parses a single `SequenceExample` proto.
</pre></div>


<p>Parses a single serialized <a href="https://www.tensorflow.org/code/tensorflow/core/example/example.proto"><code>SequenceExample</code></a>
proto given in <code>serialized</code>.</p>
<p>This op parses a serialize sequence example into a tuple of dictionaries
mapping keys to <code>Tensor</code> and <code>SparseTensor</code> objects respectively.
The first dictionary contains mappings for keys appearing in
<code>context_features</code>, and the second dictionary contains mappings for keys
appearing in <code>sequence_features</code>.</p>
<p>At least one of <code>context_features</code> and <code>sequence_features</code> must be provided
and non-empty.</p>
<p>The <code>context_features</code> keys are associated with a <code>SequenceExample</code> as a
whole, independent of time / frame.  In contrast, the <code>sequence_features</code> keys
provide a way to access variable-length data within the <code>FeatureList</code> section
of the <code>SequenceExample</code> proto.  While the shapes of <code>context_features</code> values
are fixed with respect to frame, the frame dimension (the first dimension)
of <code>sequence_features</code> values may vary between <code>SequenceExample</code> protos,
and even between <code>feature_list</code> keys within the same <code>SequenceExample</code>.</p>
<p><code>context_features</code> contains <code>VarLenFeature</code> and <code>FixedLenFeature</code> objects.
Each <code>VarLenFeature</code> is mapped to a <code>SparseTensor</code>, and each <code>FixedLenFeature</code>
is mapped to a <code>Tensor</code>, of the specified type, shape, and default value.</p>
<p><code>sequence_features</code> contains <code>VarLenFeature</code> and <code>FixedLenSequenceFeature</code>
objects. Each <code>VarLenFeature</code> is mapped to a <code>SparseTensor</code>, and each
<code>FixedLenSequenceFeature</code> is mapped to a <code>Tensor</code>, each of the specified type.
The shape will be <code>(T,) + df.shape</code> for <code>FixedLenSequenceFeature</code> <code>df</code>, where
<code>T</code> is the length of the associated <code>FeatureList</code> in the <code>SequenceExample</code>.
For instance, <code>FixedLenSequenceFeature([])</code> yields a scalar 1-D <code>Tensor</code> of
static shape <code>[None]</code> and dynamic shape <code>[T]</code>, while
<code>FixedLenSequenceFeature([k])</code> (for <code>int k &gt;= 1</code>) yields a 2-D matrix <code>Tensor</code>
of static shape <code>[None, k]</code> and dynamic shape <code>[T, k]</code>.</p>
<p>Each <code>SparseTensor</code> corresponding to <code>sequence_features</code> represents a ragged
vector.  Its indices are <code>[time, index]</code>, where <code>time</code> is the <code>FeatureList</code>
entry and <code>index</code> is the value's index in the list of values associated with
that time.</p>
<p><code>FixedLenFeature</code> entries with a <code>default_value</code> and <code>FixedLenSequenceFeature</code>
entries with <code>allow_missing=True</code> are optional; otherwise, we will fail if
that <code>Feature</code> or <code>FeatureList</code> is missing from any example in <code>serialized</code>.</p>
<p><code>example_name</code> may contain a descriptive name for the corresponding serialized
proto. This may be useful for debugging purposes, but it has no effect on the
output. If not <code>None</code>, <code>example_name</code> must be a scalar.</p>
<p>Args:
  serialized: A scalar (0-D Tensor) of type string, a single binary
    serialized <code>SequenceExample</code> proto.
  context_features: A <code>dict</code> mapping feature keys to <code>FixedLenFeature</code> or
    <code>VarLenFeature</code> values. These features are associated with a
    <code>SequenceExample</code> as a whole.
  sequence_features: A <code>dict</code> mapping feature keys to
    <code>FixedLenSequenceFeature</code> or <code>VarLenFeature</code> values. These features are
    associated with data within the <code>FeatureList</code> section of the
    <code>SequenceExample</code> proto.
  example_name: A scalar (0-D Tensor) of strings (optional), the name of
    the serialized proto.
  name: A name for this operation (optional).</p>
<p>Returns:
  A tuple of two <code>dict</code>s, each mapping keys to <code>Tensor</code>s and <code>SparseTensor</code>s.
  The first dict contains the context key/values.
  The second dict contains the feature_list key/values.</p>
<p>Raises:
  ValueError: if any feature is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_single_sequence_example', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_single_sequence_example" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.parse_tensor">
    <p>def <span class="ident">parse_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.parse_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.parse_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.parse_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.parse_tensor</strong></p>
<div class="codehilite"><pre><span></span>Transforms a serialized tensorflow.TensorProto proto into a Tensor.
</pre></div>


<p>Args:
  serialized: A <code>Tensor</code> of type <code>string</code>.
    A scalar string containing a serialized TensorProto proto.
  out_type: A <code>tf.DType</code>.
    The type of the serialized tensor.  The provided type must match the
    type of the serialized tensor and no implicit conversion will take place.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>. A Tensor of type <code>out_type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.parse_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.parse_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.placeholder">
    <p>def <span class="ident">placeholder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.placeholder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.placeholder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.placeholder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.placeholder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.placeholder</strong></p>
<div class="codehilite"><pre><span></span>Inserts a placeholder for a tensor that will be always fed.
</pre></div>


<p><strong>Important</strong>: This tensor will produce an error if evaluated. Its value must
be fed using the <code>feed_dict</code> optional argument to <code>Session.run()</code>,
<code>Tensor.eval()</code>, or <code>Operation.run()</code>.</p>
<p>For example:</p>
<p>```python
x = tf.placeholder(tf.float32, shape=(1024, 1024))
y = tf.matmul(x, x)</p>
<p>with tf.Session() as sess:
  print(sess.run(y))  # ERROR: will fail because x was not fed.</p>
<p>rand_array = np.random.rand(1024, 1024)
  print(sess.run(y, feed_dict={x: rand_array}))  # Will succeed.
```</p>
<p>Args:
  dtype: The type of elements in the tensor to be fed.
  shape: The shape of the tensor to be fed (optional). If the shape is not
    specified, you can feed a tensor of any shape.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> that may be used as a handle for feeding a value, but not
  evaluated directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.placeholder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.placeholder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.placeholder_with_default">
    <p>def <span class="ident">placeholder_with_default</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.placeholder_with_default(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.placeholder_with_default</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.placeholder_with_default(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.placeholder_with_default(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.placeholder_with_default</strong></p>
<div class="codehilite"><pre><span></span>A placeholder op that passes though `input` when its output is not fed.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. The default value to produce when <code>output</code> is not fed.
  shape: A <code>tf.TensorShape</code> or list of <code>ints</code>.
    The (possibly partial) shape of the tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  A placeholder tensor that defaults to <code>input</code> if it is not fed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.placeholder_with_default', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.placeholder_with_default" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.polygamma">
    <p>def <span class="ident">polygamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.polygamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.polygamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.polygamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.polygamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.polygamma</strong></p>
<div class="codehilite"><pre><span></span>Compute the polygamma function \\(\psi^{(n)}(x)\\).
</pre></div>


<p>The polygamma function is defined as:</p>
<p><code>\psi^{(n)}(x) = \frac{d^n}{dx^n} \psi(x)</code>
where \(\psi(x)\) is the digamma function.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  x: A <code>Tensor</code>. Must have the same type as <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>a</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.polygamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.polygamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.polynomial_layer">
    <p>def <span class="ident">polynomial_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.polynomial_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderfully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorbuilderfully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.polynomial_layer(*args, **kwargs)(x1)
</pre></div>


<p>However, it uses an activation function of the form
<code>y(i) = z(i)^(i+1)</code>
where <code>z = w*x + b</code></p>
<p><strong>tensorbuilderfully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.polynomial_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.polynomial_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pool">
    <p>def <span class="ident">pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnpool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnpool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnpool</strong></p>
<div class="codehilite"><pre><span></span>Performs an N-D pooling operation.
</pre></div>


<p>In the case that <code>data_format</code> does not start with "NC", computes for
    0 &lt;= b &lt; batch_size,
    0 &lt;= x[i] &lt; output_spatial_shape[i],
    0 &lt;= c &lt; num_channels:</p>
<p>output[b, x[0], ..., x[N-1], c] =
    REDUCE_{z[0], ..., z[N-1]}
      input[b,
            x[0] * strides[0] - pad_before[0] + dilation_rate[0]<em>z[0],
            ...
            x[N-1]</em>strides[N-1] - pad_before[N-1] + dilation_rate[N-1]*z[N-1],
            c],</p>
<p>where the reduction function REDUCE depends on the value of <code>pooling_type</code>,
and pad_before is defined based on the value of <code>padding</code> as described in the
<a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.
The reduction never includes out-of-bounds positions.</p>
<p>In the case that <code>data_format</code> starts with <code>"NC"</code>, the <code>input</code> and output are
simply transposed as follows:</p>
<p>pool(input, data_format, <strong>kwargs) =
    tf.transpose(pool(tf.transpose(input, [0] + range(2,N+2) + [1]),
                      </strong>kwargs),
                 [0, N+1] + range(1, N+1))</p>
<p>Args:
  input: Tensor of rank N+2, of shape
    <code>[batch_size] + input_spatial_shape + [num_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, num_channels] + input_spatial_shape</code> if data_format starts
    with "NC".  Pooling happens over the spatial dimensions only.
  window_shape: Sequence of N ints &gt;= 1.
  pooling_type: Specifies pooling operation, must be "AVG" or "MAX".
  padding: The padding algorithm, must be "SAME" or "VALID".
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  dilation_rate: Optional.  Dilation rate.  List of N ints &gt;= 1.
    Defaults to [1]<em>N.  If any value of dilation_rate is &gt; 1, then all values
    of strides must be 1.
  strides: Optional.  Sequence of N ints &gt;= 1.  Defaults to [1]</em>N.
    If any value of strides is &gt; 1, then all values of dilation_rate must be
    1.
  name: Optional. Name of the op.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, the valid value is "NDHWC".</p>
<p>Returns:
  Tensor of rank N+2, of shape
    [batch_size] + output_spatial_shape + [num_channels]</p>
<p>if data_format is None or does not start with "NC", or</p>
<div class="codehilite"><pre><span></span>[batch_size, num_channels] + output_spatial_shape
</pre></div>


<p>if data_format starts with "NC",
  where <code>output_spatial_shape</code> depends on the value of padding:</p>
<p>If padding = "SAME":
    output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])
  If padding = "VALID":
    output_spatial_shape[i] =
      ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i])
           / strides[i]).</p>
<p>Raises:
  ValueError: if arguments are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pool_conv2d_layer">
    <p>def <span class="ident">pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.pool</strong></p>
<div class="codehilite"><pre><span></span>Performs an N-D pooling operation.
</pre></div>


<p>In the case that <code>data_format</code> does not start with "NC", computes for
    0 &lt;= b &lt; batch_size,
    0 &lt;= x[i] &lt; output_spatial_shape[i],
    0 &lt;= c &lt; num_channels:</p>
<p>output[b, x[0], ..., x[N-1], c] =
    REDUCE_{z[0], ..., z[N-1]}
      input[b,
            x[0] * strides[0] - pad_before[0] + dilation_rate[0]<em>z[0],
            ...
            x[N-1]</em>strides[N-1] - pad_before[N-1] + dilation_rate[N-1]*z[N-1],
            c],</p>
<p>where the reduction function REDUCE depends on the value of <code>pooling_type</code>,
and pad_before is defined based on the value of <code>padding</code> as described in the
<a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.
The reduction never includes out-of-bounds positions.</p>
<p>In the case that <code>data_format</code> starts with <code>"NC"</code>, the <code>input</code> and output are
simply transposed as follows:</p>
<p>pool(input, data_format, <strong>kwargs) =
    tf.transpose(pool(tf.transpose(input, [0] + range(2,N+2) + [1]),
                      </strong>kwargs),
                 [0, N+1] + range(1, N+1))</p>
<p>Args:
  input: Tensor of rank N+2, of shape
    <code>[batch_size] + input_spatial_shape + [num_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, num_channels] + input_spatial_shape</code> if data_format starts
    with "NC".  Pooling happens over the spatial dimensions only.
  window_shape: Sequence of N ints &gt;= 1.
  pooling_type: Specifies pooling operation, must be "AVG" or "MAX".
  padding: The padding algorithm, must be "SAME" or "VALID".
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  dilation_rate: Optional.  Dilation rate.  List of N ints &gt;= 1.
    Defaults to [1]<em>N.  If any value of dilation_rate is &gt; 1, then all values
    of strides must be 1.
  strides: Optional.  Sequence of N ints &gt;= 1.  Defaults to [1]</em>N.
    If any value of strides is &gt; 1, then all values of dilation_rate must be
    1.
  name: Optional. Name of the op.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, the valid value is "NDHWC".</p>
<p>Returns:
  Tensor of rank N+2, of shape
    [batch_size] + output_spatial_shape + [num_channels]</p>
<p>if data_format is None or does not start with "NC", or</p>
<div class="codehilite"><pre><span></span>[batch_size, num_channels] + output_spatial_shape
</pre></div>


<p>if data_format starts with "NC",
  where <code>output_spatial_shape</code> depends on the value of padding:</p>
<p>If padding = "SAME":
    output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])
  If padding = "VALID":
    output_spatial_shape[i] =
      ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i])
           / strides[i]).</p>
<p>Raises:
  ValueError: if arguments are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pool_layer">
    <p>def <span class="ident">pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.pool</strong></p>
<div class="codehilite"><pre><span></span>Performs an N-D pooling operation.
</pre></div>


<p>In the case that <code>data_format</code> does not start with "NC", computes for
    0 &lt;= b &lt; batch_size,
    0 &lt;= x[i] &lt; output_spatial_shape[i],
    0 &lt;= c &lt; num_channels:</p>
<p>output[b, x[0], ..., x[N-1], c] =
    REDUCE_{z[0], ..., z[N-1]}
      input[b,
            x[0] * strides[0] - pad_before[0] + dilation_rate[0]<em>z[0],
            ...
            x[N-1]</em>strides[N-1] - pad_before[N-1] + dilation_rate[N-1]*z[N-1],
            c],</p>
<p>where the reduction function REDUCE depends on the value of <code>pooling_type</code>,
and pad_before is defined based on the value of <code>padding</code> as described in the
<a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.
The reduction never includes out-of-bounds positions.</p>
<p>In the case that <code>data_format</code> starts with <code>"NC"</code>, the <code>input</code> and output are
simply transposed as follows:</p>
<p>pool(input, data_format, <strong>kwargs) =
    tf.transpose(pool(tf.transpose(input, [0] + range(2,N+2) + [1]),
                      </strong>kwargs),
                 [0, N+1] + range(1, N+1))</p>
<p>Args:
  input: Tensor of rank N+2, of shape
    <code>[batch_size] + input_spatial_shape + [num_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, num_channels] + input_spatial_shape</code> if data_format starts
    with "NC".  Pooling happens over the spatial dimensions only.
  window_shape: Sequence of N ints &gt;= 1.
  pooling_type: Specifies pooling operation, must be "AVG" or "MAX".
  padding: The padding algorithm, must be "SAME" or "VALID".
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>
  dilation_rate: Optional.  Dilation rate.  List of N ints &gt;= 1.
    Defaults to [1]<em>N.  If any value of dilation_rate is &gt; 1, then all values
    of strides must be 1.
  strides: Optional.  Sequence of N ints &gt;= 1.  Defaults to [1]</em>N.
    If any value of strides is &gt; 1, then all values of dilation_rate must be
    1.
  name: Optional. Name of the op.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, the valid value is "NDHWC".</p>
<p>Returns:
  Tensor of rank N+2, of shape
    [batch_size] + output_spatial_shape + [num_channels]</p>
<p>if data_format is None or does not start with "NC", or</p>
<div class="codehilite"><pre><span></span>[batch_size, num_channels] + output_spatial_shape
</pre></div>


<p>if data_format starts with "NC",
  where <code>output_spatial_shape</code> depends on the value of padding:</p>
<p>If padding = "SAME":
    output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])
  If padding = "VALID":
    output_spatial_shape[i] =
      ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i])
           / strides[i]).</p>
<p>Raises:
  ValueError: if arguments are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.pow">
    <p>def <span class="ident">pow</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pow(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.pow</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.pow(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.pow(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.pow</strong></p>
<div class="codehilite"><pre><span></span>Computes the power of one value to another.
</pre></div>


<p>Given a tensor <code>x</code> and a tensor <code>y</code>, this operation computes \(x^y\) for
corresponding elements in <code>x</code> and <code>y</code>. For example:</p>
<p>```</p>
<h1>tensor 'x' is [[2, 2], [3, 3]]</h1>
<h1>tensor 'y' is [[8, 16], [2, 3]]</h1>
<p>tf.pow(x, y) ==&gt; [[256, 65536], [9, 27]]
```</p>
<p>Args:
  x: A <code>Tensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>,
   or <code>complex128</code>.
  y: A <code>Tensor</code> of type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>,
   or <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.pow', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.pow" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.py_func">
    <p>def <span class="ident">py_func</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.py_func(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.py_func</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.py_func(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.py_func(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.py_func</strong></p>
<div class="codehilite"><pre><span></span>Wraps a python function and uses it as a TensorFlow op.
</pre></div>


<p>Given a python function <code>func</code>, which takes numpy arrays as its
inputs and returns numpy arrays as its outputs, wrap this function as an
operation in a TensorFlow graph. The following snippet constructs a simple
TensorFlow graph that invokes the <code>np.sinh()</code> NumPy function as a operation
in the graph:</p>
<p><code>python
def my_func(x):
  # x will be a numpy array with the contents of the placeholder below
  return np.sinh(x)
inp = tf.placeholder(tf.float32)
y = tf.py_func(my_func, [inp], tf.float32)</code></p>
<p><strong>N.B.</strong> The <code>tf.py_func()</code> operation has the following known limitations:</p>
<ul>
<li>
<p>The body of the function (i.e. <code>func</code>) will not be serialized in a
  <code>GraphDef</code>. Therefore, you should not use this function if you need to
  serialize your model and restore it in a different environment.</p>
</li>
<li>
<p>The operation must run in the same address space as the Python program
  that calls <code>tf.py_func()</code>. If you are using distributed TensorFlow, you
  must run a <code>tf.train.Server</code> in the same process as the program that calls
  <code>tf.py_func()</code> and you must pin the created operation to a device in that
  server (e.g. using <code>with tf.device():</code>).</p>
</li>
</ul>
<p>Args:
  func: A Python function, which accepts a list of NumPy <code>ndarray</code> objects
    having element types that match the corresponding <code>tf.Tensor</code> objects
    in <code>inp</code>, and returns a list of <code>ndarray</code> objects (or a single <code>ndarray</code>)
    having element types that match the corresponding values in <code>Tout</code>.
  inp: A list of <code>Tensor</code> objects.
  Tout: A list or tuple of tensorflow data types or a single tensorflow data
    type if there is only one, indicating what <code>func</code> returns.
  stateful: (Boolean.) If True, the function should be considered stateful.
    If a function is stateless, when given the same input it will return the
    same output and have no observable side effects. Optimizations such as
    common subexpression elimination are only performed on stateless
    operations.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list of <code>Tensor</code> or a single <code>Tensor</code> which <code>func</code> computes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.py_func', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.py_func" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantize_v2">
    <p>def <span class="ident">quantize_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantize_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.quantize_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.quantize_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantize_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.quantize_v2</strong></p>
<div class="codehilite"><pre><span></span>Quantize the &#39;input&#39; tensor of type float to &#39;output&#39; tensor of type &#39;T&#39;.
</pre></div>


<p>[min_range, max_range] are scalar floats that specify the range for
the 'input' data. The 'mode' attribute controls exactly which calculations are
used to convert the float values to their quantized equivalents.</p>
<p>In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:</p>
<p><code>out[i] = (in[i] - min_range) * range(T) / (max_range - min_range)
if T == qint8, out[i] -= (range(T) + 1) / 2.0</code>
here <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code></p>
<p><em>MIN_COMBINED Mode Example</em></p>
<p>Assume the input is type float and has a possible range of [0.0, 6.0] and the
output type is quint8 ([0, 255]). The min_range and max_range values should be
specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each
value of the input by 255/6 and cast to quint8.</p>
<p>If the output type was qint8 ([-128, 127]), the operation will additionally
subtract each value by 128 prior to casting, so that the range of values aligns
with the range of qint8.</p>
<p>If the mode is 'MIN_FIRST', then this approach is used:</p>
<p><code>number_of_steps = 1 &lt;&lt; (# of bits in T)
range_adjust = number_of_steps / (number_of_steps - 1)
range = (range_max - range_min) * range_adjust
range_scale = number_of_steps / range
quantized = round(input * range_scale) - round(range_min * range_scale) +
  numeric_limits&lt;T&gt;::min()
quantized = max(quantized, numeric_limits&lt;T&gt;::min())
quantized = min(quantized, numeric_limits&lt;T&gt;::max())</code></p>
<p>The biggest difference between this and MIN_COMBINED is that the minimum range
is rounded first, before it's subtracted from the rounded value. With
MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing
and dequantizing will introduce a larger and larger error.</p>
<p>One thing to watch out for is that the operator may choose to adjust the
requested minimum and maximum values slightly during the quantization process,
so you should always use the output ports as the range for further calculations.
For example, if the requested minimum and maximum values are close to equal,
they will be separated by a small epsilon value to prevent ill-formed quantized
buffers from being created. Otherwise, you can end up with buffers where all the
quantized values map to the same float value, which causes problems for
operations that have to perform further calculations on them.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>float32</code>.
  min_range: A <code>Tensor</code> of type <code>float32</code>.
    The minimum scalar value possibly produced for the input.
  max_range: A <code>Tensor</code> of type <code>float32</code>.
    The maximum scalar value possibly produced for the input.
  T: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  mode: An optional <code>string</code> from: <code>"MIN_COMBINED", "MIN_FIRST"</code>. Defaults to <code>"MIN_COMBINED"</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, output_min, output_max).
  output: A <code>Tensor</code> of type <code>T</code>. The quantized data produced from the float input.
  output_min: A <code>Tensor</code> of type <code>float32</code>. The actual minimum scalar value used for the output.
  output_max: A <code>Tensor</code> of type <code>float32</code>. The actual maximum scalar value used for the output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantize_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantize_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_avg_pool">
    <p>def <span class="ident">quantized_avg_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_avg_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_avg_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Produces the average pool of the input tensor for quantized types.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  ksize: A list of <code>ints</code>.
    The size of the window for each dimension of the input tensor.
    The length must be 4 to match the number of dimensions of the input.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor.  The length must be 4 to match the number of dimensions of the input.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_avg_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_avg_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_avg_pool_conv2d_layer">
    <p>def <span class="ident">quantized_avg_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_avg_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_avg_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_avg_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Produces the average pool of the input tensor for quantized types.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  ksize: A list of <code>ints</code>.
    The size of the window for each dimension of the input tensor.
    The length must be 4 to match the number of dimensions of the input.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor.  The length must be 4 to match the number of dimensions of the input.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_avg_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_avg_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_avg_pool_layer">
    <p>def <span class="ident">quantized_avg_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_avg_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_avg_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_avg_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_avg_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_avg_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_avg_pool</strong></p>
<div class="codehilite"><pre><span></span>Produces the average pool of the input tensor for quantized types.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    4-D with shape <code>[batch, height, width, channels]</code>.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  ksize: A list of <code>ints</code>.
    The size of the window for each dimension of the input tensor.
    The length must be 4 to match the number of dimensions of the input.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor.  The length must be 4 to match the number of dimensions of the input.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_avg_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_avg_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization">
    <p>def <span class="ident">quantized_batch_norm_with_global_normalization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_batch_norm_with_global_normalization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_batch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_batch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_batch_norm_with_global_normalization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_batch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Quantized Batch normalization.
</pre></div>


<p>This op is deprecated and will be removed in the future. Prefer
<code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    A 4D input Tensor.
  t_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized input.
  t_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized input.
  m: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  m_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized mean.
  m_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized mean.
  v: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  v_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized variance.
  v_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized variance.
  beta: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  beta_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized offset.
  beta_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized offset.
  gamma: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  gamma_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized gamma.
  gamma_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized gamma.
  out_type: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  variance_epsilon: A <code>float</code>. A small float number to avoid dividing by 0.
  scale_after_normalization: A <code>bool</code>.
    A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (result, result_min, result_max).
  result: A <code>Tensor</code> of type <code>out_type</code>.
  result_min: A <code>Tensor</code> of type <code>float32</code>.
  result_max: A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_conv2d_layer">
    <p>def <span class="ident">quantized_batch_norm_with_global_normalization_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_batch_norm_with_global_normalization_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_batch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_batch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_batch_norm_with_global_normalization_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_batch_norm_with_global_normalization`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_batch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Quantized Batch normalization.
</pre></div>


<p>This op is deprecated and will be removed in the future. Prefer
<code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    A 4D input Tensor.
  t_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized input.
  t_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized input.
  m: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  m_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized mean.
  m_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized mean.
  v: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  v_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized variance.
  v_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized variance.
  beta: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  beta_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized offset.
  beta_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized offset.
  gamma: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  gamma_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized gamma.
  gamma_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized gamma.
  out_type: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  variance_epsilon: A <code>float</code>. A small float number to avoid dividing by 0.
  scale_after_normalization: A <code>bool</code>.
    A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (result, result_min, result_max).
  result: A <code>Tensor</code> of type <code>out_type</code>.
  result_min: A <code>Tensor</code> of type <code>float32</code>.
  result_max: A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_layer">
    <p>def <span class="ident">quantized_batch_norm_with_global_normalization_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_batch_norm_with_global_normalization_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_batch_norm_with_global_normalization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_batch_norm_with_global_normalization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_batch_norm_with_global_normalization_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_batch_norm_with_global_normalization`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_batch_norm_with_global_normalization</strong></p>
<div class="codehilite"><pre><span></span>Quantized Batch normalization.
</pre></div>


<p>This op is deprecated and will be removed in the future. Prefer
<code>tf.nn.batch_normalization</code>.</p>
<p>Args:
  t: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    A 4D input Tensor.
  t_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized input.
  t_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized input.
  m: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D mean Tensor with size matching the last dimension of t.
    This is the first output from tf.nn.moments,
    or a saved moving average thereof.
  m_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized mean.
  m_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized mean.
  v: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D variance Tensor with size matching the last dimension of t.
    This is the second output from tf.nn.moments,
    or a saved moving average thereof.
  v_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized variance.
  v_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized variance.
  beta: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D beta Tensor with size matching the last dimension of t.
    An offset to be added to the normalized tensor.
  beta_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized offset.
  beta_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized offset.
  gamma: A <code>Tensor</code>. Must have the same type as <code>t</code>.
    A 1D gamma Tensor with size matching the last dimension of t.
    If "scale_after_normalization" is true, this tensor will be multiplied
    with the normalized tensor.
  gamma_min: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the lowest quantized gamma.
  gamma_max: A <code>Tensor</code> of type <code>float32</code>.
    The value represented by the highest quantized gamma.
  out_type: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  variance_epsilon: A <code>float</code>. A small float number to avoid dividing by 0.
  scale_after_normalization: A <code>bool</code>.
    A bool indicating whether the resulted tensor
    needs to be multiplied with gamma.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (result, result_min, result_max).
  result: A <code>Tensor</code> of type <code>out_type</code>.
  result_min: A <code>Tensor</code> of type <code>float32</code>.
  result_max: A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_batch_norm_with_global_normalization_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_bias_add">
    <p>def <span class="ident">quantized_bias_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_bias_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_bias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_bias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_bias_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_bias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds Tensor &#39;bias&#39; to Tensor &#39;input&#39; for Quantized types.
</pre></div>


<p>Broadcasts the values of bias on dimensions 0..N-2 of 'input'.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  bias: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    A 1D bias Tensor with size matching the last dimension of 'input'.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  min_bias: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized bias value represents.
  max_bias: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized bias value represents.
  out_type: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_out, max_out).
  output: A <code>Tensor</code> of type <code>out_type</code>.
  min_out: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_out: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_bias_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_bias_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_bias_add_conv2d_layer">
    <p>def <span class="ident">quantized_bias_add_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_bias_add_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_bias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_bias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_bias_add_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_bias_add`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_bias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds Tensor &#39;bias&#39; to Tensor &#39;input&#39; for Quantized types.
</pre></div>


<p>Broadcasts the values of bias on dimensions 0..N-2 of 'input'.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  bias: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    A 1D bias Tensor with size matching the last dimension of 'input'.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  min_bias: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized bias value represents.
  max_bias: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized bias value represents.
  out_type: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_out, max_out).
  output: A <code>Tensor</code> of type <code>out_type</code>.
  min_out: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_out: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_bias_add_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_bias_add_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_bias_add_layer">
    <p>def <span class="ident">quantized_bias_add_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_bias_add_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_bias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_bias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_bias_add_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_bias_add`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_bias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds Tensor &#39;bias&#39; to Tensor &#39;input&#39; for Quantized types.
</pre></div>


<p>Broadcasts the values of bias on dimensions 0..N-2 of 'input'.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  bias: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    A 1D bias Tensor with size matching the last dimension of 'input'.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  min_bias: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized bias value represents.
  max_bias: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized bias value represents.
  out_type: A <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_out, max_out).
  output: A <code>Tensor</code> of type <code>out_type</code>.
  min_out: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_out: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_bias_add_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_bias_add_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_concat">
    <p>def <span class="ident">quantized_concat</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_concat(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.quantized_concat</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.quantized_concat(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_concat(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.quantized_concat</strong></p>
<div class="codehilite"><pre><span></span>Concatenates quantized tensors along one dimension.
</pre></div>


<p>Args:
  concat_dim: A <code>Tensor</code> of type <code>int32</code>.
    0-D.  The dimension along which to concatenate.  Must be in the
    range [0, rank(values)).
  values: A list of at least 2 <code>Tensor</code> objects of the same type.
    The <code>N</code> Tensors to concatenate. Their ranks and types must match,
    and their sizes must match in all dimensions except <code>concat_dim</code>.
  input_mins: A list with the same number of <code>Tensor</code> objects as <code>values</code> of <code>Tensor</code> objects of type <code>float32</code>.
    The minimum scalar values for each of the input tensors.
  input_maxes: A list with the same number of <code>Tensor</code> objects as <code>values</code> of <code>Tensor</code> objects of type <code>float32</code>.
    The maximum scalar values for each of the input tensors.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, output_min, output_max).
  output: A <code>Tensor</code>. Has the same type as <code>values</code>. A <code>Tensor</code> with the concatenation of values stacked along the
    <code>concat_dim</code> dimension.  This tensor's shape matches that of <code>values</code> except
    in <code>concat_dim</code> where it has the sum of the sizes.
  output_min: A <code>Tensor</code> of type <code>float32</code>. The float value that the minimum quantized output value represents.
  output_max: A <code>Tensor</code> of type <code>float32</code>. The float value that the maximum quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_concat', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_concat" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_conv2d">
    <p>def <span class="ident">quantized_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2D convolution given quantized 4D input and filter tensors.
</pre></div>


<p>The inputs are quantized tensors where the lowest value represents the real
number of the associated minimum, and the highest represents the maximum.
This means that you can only interpret the quantized output in the same way, by
taking the returned minimum and maximum values into account.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    filter's input_depth dimension must match input's depth dimensions.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  min_filter: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized filter value represents.
  max_filter: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized filter value represents.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code> of type <code>out_type</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_conv2d_conv2d_layer">
    <p>def <span class="ident">quantized_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2D convolution given quantized 4D input and filter tensors.
</pre></div>


<p>The inputs are quantized tensors where the lowest value represents the real
number of the associated minimum, and the highest represents the maximum.
This means that you can only interpret the quantized output in the same way, by
taking the returned minimum and maximum values into account.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    filter's input_depth dimension must match input's depth dimensions.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  min_filter: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized filter value represents.
  max_filter: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized filter value represents.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code> of type <code>out_type</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_conv2d_layer">
    <p>def <span class="ident">quantized_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Computes a 2D convolution given quantized 4D input and filter tensors.
</pre></div>


<p>The inputs are quantized tensors where the lowest value represents the real
number of the associated minimum, and the highest represents the maximum.
This means that you can only interpret the quantized output in the same way, by
taking the returned minimum and maximum values into account.</p>
<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  filter: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    filter's input_depth dimension must match input's depth dimensions.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  min_filter: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized filter value represents.
  max_filter: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized filter value represents.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code> of type <code>out_type</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_max_pool">
    <p>def <span class="ident">quantized_max_pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_max_pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_max_pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Produces the max pool of the input tensor for quantized types.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  ksize: A list of <code>ints</code>.
    The size of the window for each dimension of the input tensor.
    The length must be 4 to match the number of dimensions of the input.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor. The length must be 4 to match the number of dimensions of the input.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_max_pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_max_pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_max_pool_conv2d_layer">
    <p>def <span class="ident">quantized_max_pool_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_max_pool_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_max_pool_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_max_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Produces the max pool of the input tensor for quantized types.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  ksize: A list of <code>ints</code>.
    The size of the window for each dimension of the input tensor.
    The length must be 4 to match the number of dimensions of the input.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor. The length must be 4 to match the number of dimensions of the input.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_max_pool_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_max_pool_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_max_pool_layer">
    <p>def <span class="ident">quantized_max_pool_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_max_pool_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_max_pool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_max_pool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_max_pool_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_max_pool`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_max_pool</strong></p>
<div class="codehilite"><pre><span></span>Produces the max pool of the input tensor for quantized types.
</pre></div>


<p>Args:
  input: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
    The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.
  min_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized input value represents.
  max_input: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized input value represents.
  ksize: A list of <code>ints</code>.
    The size of the window for each dimension of the input tensor.
    The length must be 4 to match the number of dimensions of the input.
  strides: A list of <code>ints</code>.
    The stride of the sliding window for each dimension of the input
    tensor. The length must be 4 to match the number of dimensions of the input.
  padding: A <code>string</code> from: <code>"SAME", "VALID"</code>.
    The type of padding algorithm to use.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (output, min_output, max_output).
  output: A <code>Tensor</code>. Has the same type as <code>input</code>.
  min_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.
  max_output: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_max_pool_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_max_pool_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu">
    <p>def <span class="ident">quantized_relu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_relu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_relu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_relu</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear: `max(features, 0)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu6">
    <p>def <span class="ident">quantized_relu6</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu6(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_relu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_relu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu6(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_relu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu6', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu6" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu6_conv2d_layer">
    <p>def <span class="ident">quantized_relu6_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu6_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_relu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_relu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu6_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_relu6`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_relu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu6_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu6_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu6_layer">
    <p>def <span class="ident">quantized_relu6_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu6_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_relu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_relu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu6_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_relu6`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_relu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu6_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu6_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu_conv2d_layer">
    <p>def <span class="ident">quantized_relu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_relu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_relu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_relu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_relu</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear: `max(features, 0)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu_layer">
    <p>def <span class="ident">quantized_relu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_relu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_relu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_relu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_relu</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear: `max(features, 0)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu_x">
    <p>def <span class="ident">quantized_relu_x</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_x(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnquantized_relu_x</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnquantized_relu_x(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_x(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnquantized_relu_x</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  max_value: A <code>Tensor</code> of type <code>float32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu_x', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu_x" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu_x_conv2d_layer">
    <p>def <span class="ident">quantized_relu_x_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_x_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_relu_x</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_relu_x(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_x_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_relu_x`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_relu_x</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  max_value: A <code>Tensor</code> of type <code>float32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu_x_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu_x_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.quantized_relu_x_layer">
    <p>def <span class="ident">quantized_relu_x_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_x_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.quantized_relu_x</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.quantized_relu_x(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.quantized_relu_x_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.quantized_relu_x`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.quantized_relu_x</strong></p>
<div class="codehilite"><pre><span></span>Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.
  max_value: A <code>Tensor</code> of type <code>float32</code>.
  min_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the lowest quantized value represents.
  max_features: A <code>Tensor</code> of type <code>float32</code>.
    The float value that the highest quantized value represents.
  out_type: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).
  activations: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as "features".
  min_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.
  max_activations: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.quantized_relu_x_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.quantized_relu_x_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_crop">
    <p>def <span class="ident">random_crop</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_crop(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_crop</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_crop(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_crop(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_crop</strong></p>
<div class="codehilite"><pre><span></span>Randomly crops a tensor to a given size.
</pre></div>


<p>Slices a shape <code>size</code> portion out of <code>value</code> at a uniformly chosen offset.
Requires <code>value.shape &gt;= size</code>.</p>
<p>If a dimension should not be cropped, pass the full size of that dimension.
For example, RGB images can be cropped with
<code>size = [crop_height, crop_width, 3]</code>.</p>
<p>Args:
  value: Input tensor to crop.
  size: 1-D tensor with size the rank of <code>value</code>.
  seed: Python integer. Used to create a random seed. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for this operation (optional).</p>
<p>Returns:
  A cropped tensor of the same rank as <code>value</code> and shape <code>size</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_crop', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_crop" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_gamma">
    <p>def <span class="ident">random_gamma</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_gamma(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_gamma</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_gamma(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_gamma(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_gamma</strong></p>
<div class="codehilite"><pre><span></span>Draws `shape` samples from each of the given Gamma distribution(s).
</pre></div>


<p><code>alpha</code> is the shape parameter describing the distribution(s), and <code>beta</code> is
the inverse scale parameter(s).</p>
<p>Example:</p>
<p>samples = tf.random_gamma([10], [0.5, 1.5])
  # samples has shape [10, 2], where each slice [:, 0] and [:, 1] represents
  # the samples drawn from each distribution</p>
<p>samples = tf.random_gamma([7, 5], [0.5, 1.5])
  # samples has shape [7, 5, 2], where each slice [:, :, 0] and [:, :, 1]
  # represents the 7x5 samples drawn from each of the two distributions</p>
<p>samples = tf.random_gamma([30], [[1.],[3.],[5.]], beta=[[3., 4.]])
  # samples has shape [30, 3, 2], with 30 samples each of 3x2 distributions.</p>
<p>Note that for small alpha values, there is a chance you will draw a value of
  exactly 0, which gets worse for lower-precision dtypes, even though zero is
  not in the support of the gamma distribution.</p>
<p>Relevant cdfs (~chance you will draw a exactly-0 value):
  <code>stats.gamma(.01).cdf(np.finfo(np.float16).tiny)
        0.91269738769897879
    stats.gamma(.01).cdf(np.finfo(np.float32).tiny)
        0.41992668622045726
    stats.gamma(.01).cdf(np.finfo(np.float64).tiny)
        0.00084322740680686662
    stats.gamma(.35).cdf(np.finfo(np.float16).tiny)
        0.037583276135263931
    stats.gamma(.35).cdf(np.finfo(np.float32).tiny)
        5.9514895726818067e-14
    stats.gamma(.35).cdf(np.finfo(np.float64).tiny)
        2.3529843400647272e-108</code></p>
<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output samples
    to be drawn per alpha/beta-parameterized distribution.
  alpha: A Tensor or Python value or N-D array of type <code>dtype</code>. <code>alpha</code>
    provides the shape parameter(s) describing the gamma distribution(s) to
    sample. Must be broadcastable with <code>beta</code>.
  beta: A Tensor or Python value or N-D array of type <code>dtype</code>. Defaults to 1.
    <code>beta</code> provides the inverse scale parameter(s) of the gamma
    distribution(s) to sample. Must be broadcastable with <code>alpha</code>.
  dtype: The type of alpha, beta, and the output: <code>float16</code>, <code>float32</code>, or
    <code>float64</code>.
  seed: A Python integer. Used to create a random seed for the distributions.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: Optional name for the operation.</p>
<p>Returns:
  samples: a <code>Tensor</code> of shape <code>tf.concat(shape, tf.shape(alpha + beta))</code> with
    values of type <code>dtype</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_gamma', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_gamma" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_normal">
    <p>def <span class="ident">random_normal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_normal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_normal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_normal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_normal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_normal</strong></p>
<div class="codehilite"><pre><span></span>Outputs random values from a normal distribution.
</pre></div>


<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output tensor.
  mean: A 0-D Tensor or Python value of type <code>dtype</code>. The mean of the normal
    distribution.
  stddev: A 0-D Tensor or Python value of type <code>dtype</code>. The standard deviation
    of the normal distribution.
  dtype: The type of the output.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of the specified shape filled with random normal values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_normal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_normal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_normal_initializer">
    <p>def <span class="ident">random_normal_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_normal_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_normal_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_normal_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_normal_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_normal_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors with a normal distribution.
</pre></div>


<p>Args:
  mean: a python scalar or a scalar tensor. Mean of the random values
    to generate.
  stddev: a python scalar or a scalar tensor. Standard deviation of the
    random values to generate.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with a normal distribution.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_normal_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_normal_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_shuffle">
    <p>def <span class="ident">random_shuffle</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_shuffle(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_shuffle</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_shuffle(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_shuffle(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_shuffle</strong></p>
<div class="codehilite"><pre><span></span>Randomly shuffles a tensor along its first dimension.
</pre></div>


<p>The tensor is shuffled along dimension 0, such that each <code>value[j]</code> is mapped
to one and only one <code>output[i]</code>. For example, a mapping that might occur for a
3x2 tensor is:</p>
<p><code>python
[[1, 2],       [[5, 6],
 [3, 4],  ==&gt;   [1, 2],
 [5, 6]]        [3, 4]]</code></p>
<p>Args:
  value: A Tensor to be shuffled.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of same shape and type as <code>value</code>, shuffled along its first
  dimension.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_shuffle', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_shuffle" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_uniform">
    <p>def <span class="ident">random_uniform</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_uniform(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_uniform</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_uniform(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_uniform(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_uniform</strong></p>
<div class="codehilite"><pre><span></span>Outputs random values from a uniform distribution.
</pre></div>


<p>The generated values follow a uniform distribution in the range
<code>[minval, maxval)</code>. The lower bound <code>minval</code> is included in the range, while
the upper bound <code>maxval</code> is excluded.</p>
<p>For floats, the default range is <code>[0, 1)</code>.  For ints, at least <code>maxval</code> must
be specified explicitly.</p>
<p>In the integer case, the random integers are slightly biased unless
<code>maxval - minval</code> is an exact power of two.  The bias is small for values of
<code>maxval - minval</code> significantly smaller than the range of the output (either
<code>2**32</code> or <code>2**64</code>).</p>
<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output tensor.
  minval: A 0-D Tensor or Python value of type <code>dtype</code>. The lower bound on the
    range of random values to generate.  Defaults to 0.
  maxval: A 0-D Tensor or Python value of type <code>dtype</code>. The upper bound on
    the range of random values to generate.  Defaults to 1 if <code>dtype</code> is
    floating point.
  dtype: The type of the output: <code>float32</code>, <code>float64</code>, <code>int32</code>, or <code>int64</code>.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of the specified shape filled with random uniform values.</p>
<p>Raises:
  ValueError: If <code>dtype</code> is integral and <code>maxval</code> is not specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_uniform', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_uniform" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.random_uniform_initializer">
    <p>def <span class="ident">random_uniform_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_uniform_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.random_uniform_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.random_uniform_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.random_uniform_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.random_uniform_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors with a uniform distribution.
</pre></div>


<p>Args:
  minval: A python scalar or a scalar tensor. Lower bound of the range
    of random values to generate.
  maxval: A python scalar or a scalar tensor. Upper bound of the range
    of random values to generate.  Defaults to 1 for float types.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type.</p>
<p>Returns:
  An initializer that generates tensors with a uniform distribution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.random_uniform_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.random_uniform_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.range">
    <p>def <span class="ident">range</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.range(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.range</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.range(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.range(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.range</strong></p>
<div class="codehilite"><pre><span></span>Creates a sequence of numbers.
</pre></div>


<p>Creates a sequence of numbers that begins at <code>start</code> and extends by
increments of <code>delta</code> up to but not including <code>limit</code>.</p>
<p>The dtype of the resulting tensor is inferred from the inputs unless
it is provided explicitly.</p>
<p>Like the Python builtin <code>range</code>, <code>start</code> defaults to 0, so that
<code>range(n) = range(0, n)</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'start' is 3</h1>
<h1>'limit' is 18</h1>
<h1>'delta' is 3</h1>
<p>tf.range(start, limit, delta) ==&gt; [3, 6, 9, 12, 15]</p>
<h1>'start' is 3</h1>
<h1>'limit' is 1</h1>
<h1>'delta' is -0.5</h1>
<p>tf.range(start, limit, delta) ==&gt; [3, 2.5, 2, 1.5]</p>
<h1>'limit' is 5</h1>
<p>tf.range(limit) ==&gt; [0, 1, 2, 3, 4]
```</p>
<p>Args:
  start: A 0-D <code>Tensor</code> (scalar). Acts as first entry in the range if
    <code>limit</code> is not None; otherwise, acts as range limit and first entry
    defaults to 0.
  limit: A 0-D <code>Tensor</code> (scalar). Upper limit of sequence,
    exclusive. If None, defaults to the value of <code>start</code> while the first
    entry of the range defaults to 0.
  delta: A 0-D <code>Tensor</code> (scalar). Number that increments
    <code>start</code>. Defaults to 1.
  dtype: The type of the elements of the resulting tensor.
  name: A name for the operation. Defaults to "range".</p>
<p>Returns:
  An 1-D <code>Tensor</code> of type <code>dtype</code>.</p>
<p>@compatibility(numpy)
Equivalent to np.arange
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.range', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.range" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rank">
    <p>def <span class="ident">rank</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rank(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.rank</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.rank(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rank(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.rank</strong></p>
<div class="codehilite"><pre><span></span>Returns the rank of a tensor.
</pre></div>


<p>This operation returns an integer representing the rank of <code>input</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1>
<h1>shape of tensor 't' is [2, 2, 3]</h1>
<p>rank(t) ==&gt; 3
```</p>
<p><strong>Note</strong>: The rank of a tensor is not the same as the rank of a matrix. The
rank of a tensor is the number of indices required to uniquely select each
element of the tensor. Rank is also known as "order", "degree", or "ndims."</p>
<p>Args:
  input: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int32</code>.</p>
<p>@compatibility(numpy)
Equivalent to np.ndim
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rank', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rank" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.raw_rnn">
    <p>def <span class="ident">raw_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.raw_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnraw_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnraw_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.raw_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnraw_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates an `RNN` specified by RNNCell `cell` and loop function `loop_fn`.
</pre></div>


<p><strong>NOTE: This method is still in testing, and the API may change.</strong></p>
<p>This function is a more primitive version of <code>dynamic_rnn</code> that provides
more direct access to the inputs each iteration.  It also provides more
control over when to start and finish reading the sequence, and
what to emit for the output.</p>
<p>For example, it can be used to implement the dynamic decoder of a seq2seq
model.</p>
<p>Instead of working with <code>Tensor</code> objects, most operations work with
<code>TensorArray</code> objects directly.</p>
<p>The operation of <code>raw_rnn</code>, in pseudo-code, is basically the following:</p>
<p><code>python
time = tf.constant(0, dtype=tf.int32)
(finished, next_input, initial_state, _, loop_state) = loop_fn(
    time=time, cell_output=None, cell_state=None, loop_state=None)
emit_ta = TensorArray(dynamic_size=True, dtype=initial_state.dtype)
state = initial_state
while not all(finished):
  (output, cell_state) = cell(next_input, state)
  (next_finished, next_input, next_state, emit, loop_state) = loop_fn(
      time=time + 1, cell_output=output, cell_state=cell_state,
      loop_state=loop_state)
  # Emit zeros and copy forward state for minibatch entries that are finished.
  state = tf.where(finished, state, next_state)
  emit = tf.where(finished, tf.zeros_like(emit), emit)
  emit_ta = emit_ta.write(time, emit)
  # If any new minibatch entries are marked as finished, mark these.
  finished = tf.logical_or(finished, next_finished)
  time += 1
return (emit_ta, state, loop_state)</code></p>
<p>with the additional properties that output and state may be (possibly nested)
tuples, as determined by <code>cell.output_size</code> and <code>cell.state_size</code>, and
as a result the final <code>state</code> and <code>emit_ta</code> may themselves be tuples.</p>
<p>A simple implementation of <code>dynamic_rnn</code> via <code>raw_rnn</code> looks like this:</p>
<p>```python
inputs = tf.placeholder(shape=(max_time, batch_size, input_depth),
                        dtype=tf.float32)
sequence_length = tf.placeholder(shape=(batch_size,), dtype=tf.int32)
inputs_ta = tf.TensorArray(dtype=tf.float32, size=max_time)
inputs_ta = inputs_ta.unpack(inputs)</p>
<p>cell = tf.nn.rnn_cell.LSTMCell(num_units)</p>
<p>def loop_fn(time, cell_output, cell_state, loop_state):
  emit_output = cell_output  # == None for time == 0
  if cell_output is None:  # time == 0
    next_cell_state = cell.zero_state(batch_size, tf.float32)
  else:
    next_cell_state = cell_state
  elements_finished = (time &gt;= sequence_length)
  finished = tf.reduce_all(elements_finished)
  next_input = tf.cond(
      finished,
      lambda: tf.zeros([batch_size, input_depth], dtype=tf.float32),
      lambda: inputs_ta.read(time))
  next_loop_state = None
  return (elements_finished, next_input, next_cell_state,
          emit_output, next_loop_state)</p>
<p>outputs_ta, final_state, _ = raw_rnn(cell, loop_fn)
outputs = outputs_ta.pack()
```</p>
<p>Args:
  cell: An instance of RNNCell.
  loop_fn: A callable that takes inputs
    <code>(time, cell_output, cell_state, loop_state)</code>
    and returns the tuple
    <code>(finished, next_input, next_cell_state, emit_output, next_loop_state)</code>.
    Here <code>time</code> is an int32 scalar <code>Tensor</code>, <code>cell_output</code> is a
    <code>Tensor</code> or (possibly nested) tuple of tensors as determined by
    <code>cell.output_size</code>, and <code>cell_state</code> is a <code>Tensor</code>
    or (possibly nested) tuple of tensors, as determined by the <code>loop_fn</code>
    on its first call (and should match <code>cell.state_size</code>).
    The outputs are: <code>finished</code>, a boolean <code>Tensor</code> of
    shape <code>[batch_size]</code>, <code>next_input</code>: the next input to feed to <code>cell</code>,
    <code>next_cell_state</code>: the next state to feed to <code>cell</code>,
    and <code>emit_output</code>: the output to store for this iteration.</p>
<div class="codehilite"><pre><span></span>Note that `emit_output` should be a `Tensor` or (possibly nested)
tuple of tensors with shapes and structure matching `cell.output_size`
and `cell_output` above.  The parameter `cell_state` and output
`next_cell_state` may be either a single or (possibly nested) tuple
of tensors.  The parameter `loop_state` and
output `next_loop_state` may be either a single or (possibly nested) tuple
of `Tensor` and `TensorArray` objects.  This last parameter
may be ignored by `loop_fn` and the return value may be `None`.  If it
is not `None`, then the `loop_state` will be propagated through the RNN
loop, for use purely by `loop_fn` to keep track of its own state.
The `next_loop_state` parameter returned may be `None`.

The first call to `loop_fn` will be `time = 0`, `cell_output = None`,
`cell_state = None`, and `loop_state = None`.  For this call:
The `next_cell_state` value should be the value with which to initialize
the cell&#39;s state.  It may be a final state from a previous RNN or it
may be the output of `cell.zero_state()`.  It should be a
(possibly nested) tuple structure of tensors.
If `cell.state_size` is an integer, this must be
a `Tensor` of appropriate type and shape `[batch_size, cell.state_size]`.
If `cell.state_size` is a `TensorShape`, this must be a `Tensor` of
appropriate type and shape `[batch_size] + cell.state_size`.
If `cell.state_size` is a (possibly nested) tuple of ints or
`TensorShape`, this will be a tuple having the corresponding shapes.
The `emit_output` value may be  either `None` or a (possibly nested)
tuple structure of tensors, e.g.,
`(tf.zeros(shape_0, dtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1))`.
If this first `emit_output` return value is `None`,
then the `emit_ta` result of `raw_rnn` will have the same structure and
dtypes as `cell.output_size`.  Otherwise `emit_ta` will have the same
structure, shapes (prepended with a `batch_size` dimension), and dtypes
as `emit_output`.  The actual values returned for `emit_output` at this
initializing call are ignored.  Note, this emit structure must be
consistent across all time steps.
</pre></div>


<p>parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A tuple <code>(emit_ta, final_state, final_loop_state)</code> where:</p>
<p><code>emit_ta</code>: The RNN output <code>TensorArray</code>.
     If <code>loop_fn</code> returns a (possibly nested) set of Tensors for
     <code>emit_output</code> during initialization, (inputs <code>time = 0</code>,
     <code>cell_output = None</code>, and <code>loop_state = None</code>), then <code>emit_ta</code> will
     have the same structure, dtypes, and shapes as <code>emit_output</code> instead.
     If <code>loop_fn</code> returns <code>emit_output = None</code> during this call,
     the structure of <code>cell.output_size</code> is used:
     If <code>cell.output_size</code> is a (possibly nested) tuple of integers
     or <code>TensorShape</code> objects, then <code>emit_ta</code> will be a tuple having the
     same structure as <code>cell.output_size</code>, containing TensorArrays whose
     elements' shapes correspond to the shape data in <code>cell.output_size</code>.</p>
<p><code>final_state</code>: The final cell state.  If <code>cell.state_size</code> is an int, this
    will be shaped <code>[batch_size, cell.state_size]</code>.  If it is a
    <code>TensorShape</code>, this will be shaped <code>[batch_size] + cell.state_size</code>.
    If it is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will
    be a tuple having the corresponding shapes.</p>
<p><code>final_loop_state</code>: The final loop state as returned by <code>loop_fn</code>.</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell, or <code>loop_fn</code> is not
    a <code>callable</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.raw_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.raw_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer">
    <p>def <span class="ident">raw_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.raw_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.raw_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.raw_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.raw_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.raw_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.raw_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates an `RNN` specified by RNNCell `cell` and loop function `loop_fn`.
</pre></div>


<p><strong>NOTE: This method is still in testing, and the API may change.</strong></p>
<p>This function is a more primitive version of <code>dynamic_rnn</code> that provides
more direct access to the inputs each iteration.  It also provides more
control over when to start and finish reading the sequence, and
what to emit for the output.</p>
<p>For example, it can be used to implement the dynamic decoder of a seq2seq
model.</p>
<p>Instead of working with <code>Tensor</code> objects, most operations work with
<code>TensorArray</code> objects directly.</p>
<p>The operation of <code>raw_rnn</code>, in pseudo-code, is basically the following:</p>
<p><code>python
time = tf.constant(0, dtype=tf.int32)
(finished, next_input, initial_state, _, loop_state) = loop_fn(
    time=time, cell_output=None, cell_state=None, loop_state=None)
emit_ta = TensorArray(dynamic_size=True, dtype=initial_state.dtype)
state = initial_state
while not all(finished):
  (output, cell_state) = cell(next_input, state)
  (next_finished, next_input, next_state, emit, loop_state) = loop_fn(
      time=time + 1, cell_output=output, cell_state=cell_state,
      loop_state=loop_state)
  # Emit zeros and copy forward state for minibatch entries that are finished.
  state = tf.where(finished, state, next_state)
  emit = tf.where(finished, tf.zeros_like(emit), emit)
  emit_ta = emit_ta.write(time, emit)
  # If any new minibatch entries are marked as finished, mark these.
  finished = tf.logical_or(finished, next_finished)
  time += 1
return (emit_ta, state, loop_state)</code></p>
<p>with the additional properties that output and state may be (possibly nested)
tuples, as determined by <code>cell.output_size</code> and <code>cell.state_size</code>, and
as a result the final <code>state</code> and <code>emit_ta</code> may themselves be tuples.</p>
<p>A simple implementation of <code>dynamic_rnn</code> via <code>raw_rnn</code> looks like this:</p>
<p>```python
inputs = tf.placeholder(shape=(max_time, batch_size, input_depth),
                        dtype=tf.float32)
sequence_length = tf.placeholder(shape=(batch_size,), dtype=tf.int32)
inputs_ta = tf.TensorArray(dtype=tf.float32, size=max_time)
inputs_ta = inputs_ta.unpack(inputs)</p>
<p>cell = tf.nn.rnn_cell.LSTMCell(num_units)</p>
<p>def loop_fn(time, cell_output, cell_state, loop_state):
  emit_output = cell_output  # == None for time == 0
  if cell_output is None:  # time == 0
    next_cell_state = cell.zero_state(batch_size, tf.float32)
  else:
    next_cell_state = cell_state
  elements_finished = (time &gt;= sequence_length)
  finished = tf.reduce_all(elements_finished)
  next_input = tf.cond(
      finished,
      lambda: tf.zeros([batch_size, input_depth], dtype=tf.float32),
      lambda: inputs_ta.read(time))
  next_loop_state = None
  return (elements_finished, next_input, next_cell_state,
          emit_output, next_loop_state)</p>
<p>outputs_ta, final_state, _ = raw_rnn(cell, loop_fn)
outputs = outputs_ta.pack()
```</p>
<p>Args:
  cell: An instance of RNNCell.
  loop_fn: A callable that takes inputs
    <code>(time, cell_output, cell_state, loop_state)</code>
    and returns the tuple
    <code>(finished, next_input, next_cell_state, emit_output, next_loop_state)</code>.
    Here <code>time</code> is an int32 scalar <code>Tensor</code>, <code>cell_output</code> is a
    <code>Tensor</code> or (possibly nested) tuple of tensors as determined by
    <code>cell.output_size</code>, and <code>cell_state</code> is a <code>Tensor</code>
    or (possibly nested) tuple of tensors, as determined by the <code>loop_fn</code>
    on its first call (and should match <code>cell.state_size</code>).
    The outputs are: <code>finished</code>, a boolean <code>Tensor</code> of
    shape <code>[batch_size]</code>, <code>next_input</code>: the next input to feed to <code>cell</code>,
    <code>next_cell_state</code>: the next state to feed to <code>cell</code>,
    and <code>emit_output</code>: the output to store for this iteration.</p>
<div class="codehilite"><pre><span></span>Note that `emit_output` should be a `Tensor` or (possibly nested)
tuple of tensors with shapes and structure matching `cell.output_size`
and `cell_output` above.  The parameter `cell_state` and output
`next_cell_state` may be either a single or (possibly nested) tuple
of tensors.  The parameter `loop_state` and
output `next_loop_state` may be either a single or (possibly nested) tuple
of `Tensor` and `TensorArray` objects.  This last parameter
may be ignored by `loop_fn` and the return value may be `None`.  If it
is not `None`, then the `loop_state` will be propagated through the RNN
loop, for use purely by `loop_fn` to keep track of its own state.
The `next_loop_state` parameter returned may be `None`.

The first call to `loop_fn` will be `time = 0`, `cell_output = None`,
`cell_state = None`, and `loop_state = None`.  For this call:
The `next_cell_state` value should be the value with which to initialize
the cell&#39;s state.  It may be a final state from a previous RNN or it
may be the output of `cell.zero_state()`.  It should be a
(possibly nested) tuple structure of tensors.
If `cell.state_size` is an integer, this must be
a `Tensor` of appropriate type and shape `[batch_size, cell.state_size]`.
If `cell.state_size` is a `TensorShape`, this must be a `Tensor` of
appropriate type and shape `[batch_size] + cell.state_size`.
If `cell.state_size` is a (possibly nested) tuple of ints or
`TensorShape`, this will be a tuple having the corresponding shapes.
The `emit_output` value may be  either `None` or a (possibly nested)
tuple structure of tensors, e.g.,
`(tf.zeros(shape_0, dtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1))`.
If this first `emit_output` return value is `None`,
then the `emit_ta` result of `raw_rnn` will have the same structure and
dtypes as `cell.output_size`.  Otherwise `emit_ta` will have the same
structure, shapes (prepended with a `batch_size` dimension), and dtypes
as `emit_output`.  The actual values returned for `emit_output` at this
initializing call are ignored.  Note, this emit structure must be
consistent across all time steps.
</pre></div>


<p>parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A tuple <code>(emit_ta, final_state, final_loop_state)</code> where:</p>
<p><code>emit_ta</code>: The RNN output <code>TensorArray</code>.
     If <code>loop_fn</code> returns a (possibly nested) set of Tensors for
     <code>emit_output</code> during initialization, (inputs <code>time = 0</code>,
     <code>cell_output = None</code>, and <code>loop_state = None</code>), then <code>emit_ta</code> will
     have the same structure, dtypes, and shapes as <code>emit_output</code> instead.
     If <code>loop_fn</code> returns <code>emit_output = None</code> during this call,
     the structure of <code>cell.output_size</code> is used:
     If <code>cell.output_size</code> is a (possibly nested) tuple of integers
     or <code>TensorShape</code> objects, then <code>emit_ta</code> will be a tuple having the
     same structure as <code>cell.output_size</code>, containing TensorArrays whose
     elements' shapes correspond to the shape data in <code>cell.output_size</code>.</p>
<p><code>final_state</code>: The final cell state.  If <code>cell.state_size</code> is an int, this
    will be shaped <code>[batch_size, cell.state_size]</code>.  If it is a
    <code>TensorShape</code>, this will be shaped <code>[batch_size] + cell.state_size</code>.
    If it is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will
    be a tuple having the corresponding shapes.</p>
<p><code>final_loop_state</code>: The final loop state as returned by <code>loop_fn</code>.</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell, or <code>loop_fn</code> is not
    a <code>callable</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.raw_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.raw_rnn_layer">
    <p>def <span class="ident">raw_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.raw_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.raw_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.raw_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.raw_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.raw_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.raw_rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates an `RNN` specified by RNNCell `cell` and loop function `loop_fn`.
</pre></div>


<p><strong>NOTE: This method is still in testing, and the API may change.</strong></p>
<p>This function is a more primitive version of <code>dynamic_rnn</code> that provides
more direct access to the inputs each iteration.  It also provides more
control over when to start and finish reading the sequence, and
what to emit for the output.</p>
<p>For example, it can be used to implement the dynamic decoder of a seq2seq
model.</p>
<p>Instead of working with <code>Tensor</code> objects, most operations work with
<code>TensorArray</code> objects directly.</p>
<p>The operation of <code>raw_rnn</code>, in pseudo-code, is basically the following:</p>
<p><code>python
time = tf.constant(0, dtype=tf.int32)
(finished, next_input, initial_state, _, loop_state) = loop_fn(
    time=time, cell_output=None, cell_state=None, loop_state=None)
emit_ta = TensorArray(dynamic_size=True, dtype=initial_state.dtype)
state = initial_state
while not all(finished):
  (output, cell_state) = cell(next_input, state)
  (next_finished, next_input, next_state, emit, loop_state) = loop_fn(
      time=time + 1, cell_output=output, cell_state=cell_state,
      loop_state=loop_state)
  # Emit zeros and copy forward state for minibatch entries that are finished.
  state = tf.where(finished, state, next_state)
  emit = tf.where(finished, tf.zeros_like(emit), emit)
  emit_ta = emit_ta.write(time, emit)
  # If any new minibatch entries are marked as finished, mark these.
  finished = tf.logical_or(finished, next_finished)
  time += 1
return (emit_ta, state, loop_state)</code></p>
<p>with the additional properties that output and state may be (possibly nested)
tuples, as determined by <code>cell.output_size</code> and <code>cell.state_size</code>, and
as a result the final <code>state</code> and <code>emit_ta</code> may themselves be tuples.</p>
<p>A simple implementation of <code>dynamic_rnn</code> via <code>raw_rnn</code> looks like this:</p>
<p>```python
inputs = tf.placeholder(shape=(max_time, batch_size, input_depth),
                        dtype=tf.float32)
sequence_length = tf.placeholder(shape=(batch_size,), dtype=tf.int32)
inputs_ta = tf.TensorArray(dtype=tf.float32, size=max_time)
inputs_ta = inputs_ta.unpack(inputs)</p>
<p>cell = tf.nn.rnn_cell.LSTMCell(num_units)</p>
<p>def loop_fn(time, cell_output, cell_state, loop_state):
  emit_output = cell_output  # == None for time == 0
  if cell_output is None:  # time == 0
    next_cell_state = cell.zero_state(batch_size, tf.float32)
  else:
    next_cell_state = cell_state
  elements_finished = (time &gt;= sequence_length)
  finished = tf.reduce_all(elements_finished)
  next_input = tf.cond(
      finished,
      lambda: tf.zeros([batch_size, input_depth], dtype=tf.float32),
      lambda: inputs_ta.read(time))
  next_loop_state = None
  return (elements_finished, next_input, next_cell_state,
          emit_output, next_loop_state)</p>
<p>outputs_ta, final_state, _ = raw_rnn(cell, loop_fn)
outputs = outputs_ta.pack()
```</p>
<p>Args:
  cell: An instance of RNNCell.
  loop_fn: A callable that takes inputs
    <code>(time, cell_output, cell_state, loop_state)</code>
    and returns the tuple
    <code>(finished, next_input, next_cell_state, emit_output, next_loop_state)</code>.
    Here <code>time</code> is an int32 scalar <code>Tensor</code>, <code>cell_output</code> is a
    <code>Tensor</code> or (possibly nested) tuple of tensors as determined by
    <code>cell.output_size</code>, and <code>cell_state</code> is a <code>Tensor</code>
    or (possibly nested) tuple of tensors, as determined by the <code>loop_fn</code>
    on its first call (and should match <code>cell.state_size</code>).
    The outputs are: <code>finished</code>, a boolean <code>Tensor</code> of
    shape <code>[batch_size]</code>, <code>next_input</code>: the next input to feed to <code>cell</code>,
    <code>next_cell_state</code>: the next state to feed to <code>cell</code>,
    and <code>emit_output</code>: the output to store for this iteration.</p>
<div class="codehilite"><pre><span></span>Note that `emit_output` should be a `Tensor` or (possibly nested)
tuple of tensors with shapes and structure matching `cell.output_size`
and `cell_output` above.  The parameter `cell_state` and output
`next_cell_state` may be either a single or (possibly nested) tuple
of tensors.  The parameter `loop_state` and
output `next_loop_state` may be either a single or (possibly nested) tuple
of `Tensor` and `TensorArray` objects.  This last parameter
may be ignored by `loop_fn` and the return value may be `None`.  If it
is not `None`, then the `loop_state` will be propagated through the RNN
loop, for use purely by `loop_fn` to keep track of its own state.
The `next_loop_state` parameter returned may be `None`.

The first call to `loop_fn` will be `time = 0`, `cell_output = None`,
`cell_state = None`, and `loop_state = None`.  For this call:
The `next_cell_state` value should be the value with which to initialize
the cell&#39;s state.  It may be a final state from a previous RNN or it
may be the output of `cell.zero_state()`.  It should be a
(possibly nested) tuple structure of tensors.
If `cell.state_size` is an integer, this must be
a `Tensor` of appropriate type and shape `[batch_size, cell.state_size]`.
If `cell.state_size` is a `TensorShape`, this must be a `Tensor` of
appropriate type and shape `[batch_size] + cell.state_size`.
If `cell.state_size` is a (possibly nested) tuple of ints or
`TensorShape`, this will be a tuple having the corresponding shapes.
The `emit_output` value may be  either `None` or a (possibly nested)
tuple structure of tensors, e.g.,
`(tf.zeros(shape_0, dtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1))`.
If this first `emit_output` return value is `None`,
then the `emit_ta` result of `raw_rnn` will have the same structure and
dtypes as `cell.output_size`.  Otherwise `emit_ta` will have the same
structure, shapes (prepended with a `batch_size` dimension), and dtypes
as `emit_output`.  The actual values returned for `emit_output` at this
initializing call are ignored.  Note, this emit structure must be
consistent across all time steps.
</pre></div>


<p>parallel_iterations: (Default: 32).  The number of iterations to run in
    parallel.  Those operations which do not have any temporal dependency
    and can be run in parallel, will be.  This parameter trades off
    time for space.  Values &gt;&gt; 1 use more memory but take less time,
    while smaller values use less memory but computations take longer.
  swap_memory: Transparently swap the tensors produced in forward inference
    but needed for back prop from GPU to CPU.  This allows training RNNs
    which would typically not fit on a single GPU, with very minimal (or no)
    performance penalty.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A tuple <code>(emit_ta, final_state, final_loop_state)</code> where:</p>
<p><code>emit_ta</code>: The RNN output <code>TensorArray</code>.
     If <code>loop_fn</code> returns a (possibly nested) set of Tensors for
     <code>emit_output</code> during initialization, (inputs <code>time = 0</code>,
     <code>cell_output = None</code>, and <code>loop_state = None</code>), then <code>emit_ta</code> will
     have the same structure, dtypes, and shapes as <code>emit_output</code> instead.
     If <code>loop_fn</code> returns <code>emit_output = None</code> during this call,
     the structure of <code>cell.output_size</code> is used:
     If <code>cell.output_size</code> is a (possibly nested) tuple of integers
     or <code>TensorShape</code> objects, then <code>emit_ta</code> will be a tuple having the
     same structure as <code>cell.output_size</code>, containing TensorArrays whose
     elements' shapes correspond to the shape data in <code>cell.output_size</code>.</p>
<p><code>final_state</code>: The final cell state.  If <code>cell.state_size</code> is an int, this
    will be shaped <code>[batch_size, cell.state_size]</code>.  If it is a
    <code>TensorShape</code>, this will be shaped <code>[batch_size] + cell.state_size</code>.
    If it is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will
    be a tuple having the corresponding shapes.</p>
<p><code>final_loop_state</code>: The final loop state as returned by <code>loop_fn</code>.</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell, or <code>loop_fn</code> is not
    a <code>callable</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.raw_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.raw_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.read_file">
    <p>def <span class="ident">read_file</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.read_file(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.read_file</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.read_file(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.read_file(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.read_file</strong></p>
<div class="codehilite"><pre><span></span>Reads and outputs the entire contents of the input filename.
</pre></div>


<p>Args:
  filename: A <code>Tensor</code> of type <code>string</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.read_file', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.read_file" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.real">
    <p>def <span class="ident">real</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.real(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.real</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.real(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.real(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.real</strong></p>
<div class="codehilite"><pre><span></span>Returns the real part of a complex number.
</pre></div>


<p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
type <code>float32</code> or <code>float64</code> that is the real part of each element in <code>input</code>.
All elements in <code>input</code> must be complex numbers of the form (a + bj),
where <em>a</em> is the real part returned by this operation and <em>b</em> is the
imaginary part.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]</h1>
<p>tf.real(input) ==&gt; [-2.25, 3.25]
```</p>
<p>If <code>input</code> is already real, it is returned unchanged.</p>
<p>Args:
  input: A <code>Tensor</code>. Must have numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.real', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.real" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.realdiv">
    <p>def <span class="ident">realdiv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.realdiv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.realdiv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.realdiv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.realdiv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.realdiv</strong></p>
<div class="codehilite"><pre><span></span>Returns x / y element-wise for real types.
</pre></div>


<p>If <code>x</code> and <code>y</code> are reals, this will return the floating-point division.</p>
<p><em>NOTE</em>: <code>Div</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.realdiv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.realdiv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reciprocal">
    <p>def <span class="ident">reciprocal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reciprocal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reciprocal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reciprocal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reciprocal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reciprocal</strong></p>
<div class="codehilite"><pre><span></span>Computes the reciprocal of x element-wise.
</pre></div>


<p>I.e., \(y = 1 / x\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reciprocal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reciprocal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_all">
    <p>def <span class="ident">reduce_all</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_all(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_all(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_all</strong></p>
<div class="codehilite"><pre><span></span>Computes the &quot;logical and&quot; of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[True,  True]</h1>
<h1>[False, False]]</h1>
<p>tf.reduce_all(x) ==&gt; False
tf.reduce_all(x, 0) ==&gt; [False, False]
tf.reduce_all(x, 1) ==&gt; [True, False]
```</p>
<p>Args:
  input_tensor: The boolean tensor to reduce.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.all
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_all', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_all" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_any">
    <p>def <span class="ident">reduce_any</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_any(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_any</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_any(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_any(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_any</strong></p>
<div class="codehilite"><pre><span></span>Computes the &quot;logical or&quot; of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[True,  True]</h1>
<h1>[False, False]]</h1>
<p>tf.reduce_any(x) ==&gt; True
tf.reduce_any(x, 0) ==&gt; [True, True]
tf.reduce_any(x, 1) ==&gt; [True, False]
```</p>
<p>Args:
  input_tensor: The boolean tensor to reduce.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.any
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_any', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_any" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_join">
    <p>def <span class="ident">reduce_join</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_join(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_join</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_join(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_join(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_join</strong></p>
<div class="codehilite"><pre><span></span>Joins a string Tensor across the given dimensions.
</pre></div>


<p>Computes the string join across dimensions in the given string Tensor of shape
<code>[d_0, d_1, ..., d_n-1]</code>.  Returns a new Tensor created by joining the input
strings with the given separator (default: empty string).  Negative indices are
counted backwards from the end, with <code>-1</code> being equivalent to <code>n - 1</code>.  Passing
an empty <code>reduction_indices</code> joins all strings in linear index order and outputs
a scalar string.</p>
<p>For example:</p>
<p>```</p>
<h1>tensor <code>a</code> is [["a", "b"], ["c", "d"]]</h1>
<p>tf.reduce_join(a, 0) ==&gt; ["ac", "bd"]
tf.reduce_join(a, 1) ==&gt; ["ab", "cd"]
tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==&gt; ["ac", "bd"]
tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==&gt; ["ab", "cd"]
tf.reduce_join(a, 0, keep_dims=True) ==&gt; [["ac", "bd"]]
tf.reduce_join(a, 1, keep_dims=True) ==&gt; [["ab"], ["cd"]]
tf.reduce_join(a, 0, separator=".") ==&gt; ["a.c", "b.d"]
tf.reduce_join(a, [0, 1]) ==&gt; ["acbd"]
tf.reduce_join(a, [1, 0]) ==&gt; ["abcd"]
tf.reduce_join(a, []) ==&gt; ["abcd"]
```</p>
<p>Args:
  inputs: A <code>Tensor</code> of type <code>string</code>.
    The input to be joined.  All reduced indices must have non-zero size.
  reduction_indices: A <code>Tensor</code> of type <code>int32</code>.
    The dimensions to reduce over.  Dimensions are reduced in the
    order specified.  Omitting <code>reduction_indices</code> is equivalent to passing
    <code>[n-1, n-2, ..., 0]</code>.  Negative indices from <code>-n</code> to <code>-1</code> are supported.
  keep_dims: An optional <code>bool</code>. Defaults to <code>False</code>.
    If <code>True</code>, retain reduced dimensions with length <code>1</code>.
  separator: An optional <code>string</code>. Defaults to <code>""</code>.
    The separator to use when joining.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.
  Has shape equal to that of the input with reduced dimensions removed or
  set to <code>1</code> depending on <code>keep_dims</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_join', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_join" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_logsumexp">
    <p>def <span class="ident">reduce_logsumexp</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_logsumexp(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_logsumexp</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_logsumexp(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_logsumexp(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_logsumexp</strong></p>
<div class="codehilite"><pre><span></span>Computes log(sum(exp(elements across dimensions of a tensor))).
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>This function is more numerically stable than log(sum(exp(input))). It avoids
overflows caused by taking the exp of large inputs and underflows caused by
taking the log of small inputs.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[0, 0, 0]]</h1>
<h1>[0, 0, 0]]</h1>
<p>tf.reduce_logsumexp(x) ==&gt; log(6)
tf.reduce_logsumexp(x, 0) ==&gt; [log(2), log(2), log(2)]
tf.reduce_logsumexp(x, 1) ==&gt; [log(3), log(3)]
tf.reduce_logsumexp(x, 1, keep_dims=True) ==&gt; [[log(3)], [log(3)]]
tf.reduce_logsumexp(x, [0, 1]) ==&gt; log(6)
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_logsumexp', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_logsumexp" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_max">
    <p>def <span class="ident">reduce_max</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_max(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_max</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_max(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_max(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_max</strong></p>
<div class="codehilite"><pre><span></span>Computes the maximum of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.max
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_max', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_max" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_mean">
    <p>def <span class="ident">reduce_mean</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_mean(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_mean</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_mean(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_mean(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_mean</strong></p>
<div class="codehilite"><pre><span></span>Computes the mean of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1., 1.]</h1>
<h1>[2., 2.]]</h1>
<p>tf.reduce_mean(x) ==&gt; 1.5
tf.reduce_mean(x, 0) ==&gt; [1.5, 1.5]
tf.reduce_mean(x, 1) ==&gt; [1.,  2.]
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.mean
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_mean', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_mean" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_min">
    <p>def <span class="ident">reduce_min</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_min(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_min</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_min(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_min(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_min</strong></p>
<div class="codehilite"><pre><span></span>Computes the minimum of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.min
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_min', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_min" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_prod">
    <p>def <span class="ident">reduce_prod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_prod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_prod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_prod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_prod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_prod</strong></p>
<div class="codehilite"><pre><span></span>Computes the product of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.prod
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_prod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_prod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reduce_sum">
    <p>def <span class="ident">reduce_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reduce_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reduce_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reduce_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reduce_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum of elements across dimensions of a tensor.
</pre></div>


<p>Reduces <code>input_tensor</code> along the dimensions given in <code>axis</code>.
Unless <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each
entry in <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions
are retained with length 1.</p>
<p>If <code>axis</code> has no entries, all dimensions are reduced, and a
tensor with a single element is returned.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1, 1, 1]</h1>
<h1>[1, 1, 1]]</h1>
<p>tf.reduce_sum(x) ==&gt; 6
tf.reduce_sum(x, 0) ==&gt; [2, 2, 2]
tf.reduce_sum(x, 1) ==&gt; [3, 3]
tf.reduce_sum(x, 1, keep_dims=True) ==&gt; [[3], [3]]
tf.reduce_sum(x, [0, 1]) ==&gt; 6
```</p>
<p>Args:
  input_tensor: The tensor to reduce. Should have numeric type.
  axis: The dimensions to reduce. If <code>None</code> (the default),
    reduces all dimensions.
  keep_dims: If true, retains reduced dimensions with length 1.
  name: A name for the operation (optional).
  reduction_indices: The old (deprecated) name for axis.</p>
<p>Returns:
  The reduced tensor.</p>
<p>@compatibility(numpy)
Equivalent to np.sum
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reduce_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reduce_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function">
    <p>def <span class="ident">register_tensor_conversion_function</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.register_tensor_conversion_function(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.register_tensor_conversion_function</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.register_tensor_conversion_function(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.register_tensor_conversion_function(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.register_tensor_conversion_function</strong></p>
<div class="codehilite"><pre><span></span>Registers a function for converting objects of `base_type` to `Tensor`.
</pre></div>


<p>The conversion function must have the following signature:</p>
<p><code>python
    def conversion_func(value, dtype=None, name=None, as_ref=False):
      # ...</code></p>
<p>It must return a <code>Tensor</code> with the given <code>dtype</code> if specified. If the
conversion function creates a new <code>Tensor</code>, it should use the given
<code>name</code> if specified. All exceptions will be propagated to the caller.</p>
<p>The conversion function may return <code>NotImplemented</code> for some
inputs. In this case, the conversion process will continue to try
subsequent conversion functions.</p>
<p>If <code>as_ref</code> is true, the function must return a <code>Tensor</code> reference,
such as a <code>Variable</code>.</p>
<p>NOTE: The conversion functions will execute in order of priority,
followed by order of registration. To ensure that a conversion function
<code>F</code> runs before another conversion function <code>G</code>, ensure that <code>F</code> is
registered with a smaller priority than <code>G</code>.</p>
<p>Args:
  base_type: The base type or tuple of base types for all objects that
    <code>conversion_func</code> accepts.
  conversion_func: A function that converts instances of <code>base_type</code> to
    <code>Tensor</code>.
  priority: Optional integer that indicates the priority for applying this
    conversion function. Conversion functions with smaller priority values
    run earlier than conversion functions with larger priority values.
    Defaults to 100.</p>
<p>Raises:
  TypeError: If the arguments do not have the appropriate type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.register_tensor_conversion_function" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu">
    <p>def <span class="ident">relu</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnrelu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnrelu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnrelu</strong></p>
<div class="codehilite"><pre><span></span>Computes rectified linear: `max(features, 0)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu6">
    <p>def <span class="ident">relu6</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu6(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnrelu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnrelu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu6(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnrelu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Rectified Linear 6: `min(max(features, 0), 6)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu6', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu6" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer">
    <p>def <span class="ident">relu6_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu6_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.relu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.relu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu6_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu6`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.relu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Rectified Linear 6: `min(max(features, 0), 6)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu6_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu6_layer">
    <p>def <span class="ident">relu6_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu6_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.relu6</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.relu6(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu6_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu6`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.relu6</strong></p>
<div class="codehilite"><pre><span></span>Computes Rectified Linear 6: `min(max(features, 0), 6)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>,
    <code>int16</code>, or <code>int8</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu6_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu6_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu_conv2d_layer">
    <p>def <span class="ident">relu_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.relu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.relu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.relu</strong></p>
<div class="codehilite"><pre><span></span>Computes rectified linear: `max(features, 0)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.relu_layer">
    <p>def <span class="ident">relu_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.relu</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.relu(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.relu_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.relu`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.relu</strong></p>
<div class="codehilite"><pre><span></span>Computes rectified linear: `max(features, 0)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.relu_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.relu_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.report_uninitialized_variables">
    <p>def <span class="ident">report_uninitialized_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.report_uninitialized_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.report_uninitialized_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.report_uninitialized_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.report_uninitialized_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.report_uninitialized_variables</strong></p>
<div class="codehilite"><pre><span></span>Adds ops to list the names of uninitialized variables.
</pre></div>


<p>When run, it returns a 1-D tensor containing the names of uninitialized
variables if there are any, or an empty array if there are none.</p>
<p>Args:
  var_list: List of <code>Variable</code> objects to check. Defaults to the
    value of <code>global_variables() + local_variables()</code>
  name: Optional name of the <code>Operation</code>.</p>
<p>Returns:
  A 1-D tensor containing names of the uninitialized variables, or an empty
  1-D tensor if there are no variables or no uninitialized variables.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.report_uninitialized_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.report_uninitialized_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings">
    <p>def <span class="ident">required_space_to_batch_paddings</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.required_space_to_batch_paddings(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.required_space_to_batch_paddings</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.required_space_to_batch_paddings(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.required_space_to_batch_paddings(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.required_space_to_batch_paddings</strong></p>
<div class="codehilite"><pre><span></span>Calculate padding required to make block_shape divide input_shape.
</pre></div>


<p>This function can be used to calculate a suitable paddings argument for use
with space_to_batch_nd and batch_to_space_nd.</p>
<p>Args:
  input_shape: int32 Tensor of shape [N].
  block_shape: int32 Tensor of shape [N].
  base_paddings: Optional int32 Tensor of shape [N, 2].  Specifies the minimum
    amount of padding to use.  All elements must be &gt;= 0.  If not specified,
    defaults to 0.
  name: string.  Optional name prefix.</p>
<p>Returns:
  (paddings, crops), where:</p>
<p><code>paddings</code> and <code>crops</code> are int32 Tensors of rank 2 and shape [N, 2]
  satisfying:</p>
<div class="codehilite"><pre><span></span>  paddings[i, 0] = base_paddings[i, 0].
  0 &lt;= paddings[i, 1] - base_paddings[i, 1] &lt; block_shape[i]
  (input_shape[i] + paddings[i, 0] + paddings[i, 1]) % block_shape[i] == 0

  crops[i, 0] = 0
  crops[i, 1] = paddings[i, 1] - base_paddings[i, 1]
</pre></div>


<p>Raises: ValueError if called with incompatible shapes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.required_space_to_batch_paddings" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reset_default_graph">
    <p>def <span class="ident">reset_default_graph</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reset_default_graph(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reset_default_graph</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reset_default_graph(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reset_default_graph(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reset_default_graph</strong></p>
<div class="codehilite"><pre><span></span>Clears the default graph stack and resets the global default graph.
</pre></div>


<p>NOTE: The default graph is a property of the current thread. This
function applies only to the current thread.  Calling this function while
a <code>tf.Session</code> or <code>tf.InteractiveSession</code> is active will result in undefined
behavior. Using any previously created <code>tf.Operation</code> or <code>tf.Tensor</code> objects
after calling this function will result in undefined behavior.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reset_default_graph', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reset_default_graph" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reshape">
    <p>def <span class="ident">reshape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reshape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reshape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reshape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reshape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reshape</strong></p>
<div class="codehilite"><pre><span></span>Reshapes a tensor.
</pre></div>


<p>Given <code>tensor</code>, this operation returns a tensor that has the same values
as <code>tensor</code> with shape <code>shape</code>.</p>
<p>If one component of <code>shape</code> is the special value -1, the size of that dimension
is computed so that the total size remains constant.  In particular, a <code>shape</code>
of <code>[-1]</code> flattens into 1-D.  At most one component of <code>shape</code> can be -1.</p>
<p>If <code>shape</code> is 1-D or higher, then the operation returns a tensor with shape
<code>shape</code> filled with the values of <code>tensor</code>. In this case, the number of elements
implied by <code>shape</code> must be the same as the number of elements in <code>tensor</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]</h1>
<h1>tensor 't' has shape [9]</h1>
<p>reshape(t, [3, 3]) ==&gt; [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]]</p>
<h1>tensor 't' is [[[1, 1], [2, 2]],</h1>
<h1>[[3, 3], [4, 4]]]</h1>
<h1>tensor 't' has shape [2, 2, 2]</h1>
<p>reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2],
                        [3, 3, 4, 4]]</p>
<h1>tensor 't' is [[[1, 1, 1],</h1>
<h1>[2, 2, 2]],</h1>
<h1>[[3, 3, 3],</h1>
<h1>[4, 4, 4]],</h1>
<h1>[[5, 5, 5],</h1>
<h1>[6, 6, 6]]]</h1>
<h1>tensor 't' has shape [3, 2, 3]</h1>
<h1>pass '[-1]' to flatten 't'</h1>
<p>reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]</p>
<h1>-1 can also be used to infer the shape</h1>
<h1>-1 is inferred to be 9:</h1>
<p>reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]</p>
<h1>-1 is inferred to be 2:</h1>
<p>reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]</p>
<h1>-1 is inferred to be 3:</h1>
<p>reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1],
                              [2, 2, 2],
                              [3, 3, 3]],
                             [[4, 4, 4],
                              [5, 5, 5],
                              [6, 6, 6]]]</p>
<h1>tensor 't' is [7]</h1>
<h1>shape <code>[]</code> reshapes to a scalar</h1>
<p>reshape(t, []) ==&gt; 7
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  shape: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Defines the shape of the output tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reshape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reshape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reverse">
    <p>def <span class="ident">reverse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reverse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reverse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reverse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reverse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reverse</strong></p>
<div class="codehilite"><pre><span></span>Reverses specific dimensions of a tensor.
</pre></div>


<p>Given a <code>tensor</code>, and a <code>bool</code> tensor <code>dims</code> representing the dimensions
of <code>tensor</code>, this operation reverses each dimension i of <code>tensor</code> where
<code>dims[i]</code> is <code>True</code>.</p>
<p><code>tensor</code> can have up to 8 dimensions. The number of dimensions
of <code>tensor</code> must equal the number of elements in <code>dims</code>. In other words:</p>
<p><code>rank(tensor) = size(dims)</code></p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 't' is [[[[ 0,  1,  2,  3],</h1>
<h1>[ 4,  5,  6,  7],</h1>
<h1>[ 8,  9, 10, 11]],</h1>
<h1>[[12, 13, 14, 15],</h1>
<h1>[16, 17, 18, 19],</h1>
<h1>[20, 21, 22, 23]]]]</h1>
<h1>tensor 't' shape is [1, 2, 3, 4]</h1>
<h1>'dims' is [False, False, False, True]</h1>
<p>reverse(t, dims) ==&gt; [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]</p>
<h1>'dims' is [False, True, False, False]</h1>
<p>reverse(t, dims) ==&gt; [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]</p>
<h1>'dims' is [False, False, True, False]</h1>
<p>reverse(t, dims) ==&gt; [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>. Must be one of the following types: <code>uint8</code>, <code>int8</code>, <code>int32</code>, <code>int64</code>, <code>bool</code>, <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
    Up to 8-D.
  dims: A <code>Tensor</code> of type <code>bool</code>. 1-D. The dimensions to reverse.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>. The same shape as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reverse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reverse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reverse_sequence">
    <p>def <span class="ident">reverse_sequence</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reverse_sequence(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reverse_sequence</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reverse_sequence(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reverse_sequence(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reverse_sequence</strong></p>
<div class="codehilite"><pre><span></span>Reverses variable length slices.
</pre></div>


<p>This op first slices <code>input</code> along the dimension <code>batch_dim</code>, and for each
slice <code>i</code>, reverses the first <code>seq_lengths[i]</code> elements along
the dimension <code>seq_dim</code>.</p>
<p>The elements of <code>seq_lengths</code> must obey <code>seq_lengths[i] &lt; input.dims[seq_dim]</code>,
and <code>seq_lengths</code> must be a vector of length <code>input.dims[batch_dim]</code>.</p>
<p>The output slice <code>i</code> along dimension <code>batch_dim</code> is then given by input
slice <code>i</code>, with the first <code>seq_lengths[i]</code> slices along dimension
<code>seq_dim</code> reversed.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>Given this:</h1>
<p>batch_dim = 0
seq_dim = 1
input.dims = (4, 8, ...)
seq_lengths = [7, 2, 3, 5]</p>
<h1>then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1>
<p>output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]</p>
<h1>while entries past seq_lens are copied through:</h1>
<p>output[0, 7:, :, ...] = input[0, 7:, :, ...]
output[1, 2:, :, ...] = input[1, 2:, :, ...]
output[2, 3:, :, ...] = input[2, 3:, :, ...]
output[3, 2:, :, ...] = input[3, 2:, :, ...]
```</p>
<p>In contrast, if:</p>
<p>```prettyprint</p>
<h1>Given this:</h1>
<p>batch_dim = 2
seq_dim = 0
input.dims = (8, ?, 4, ...)
seq_lengths = [7, 2, 3, 5]</p>
<h1>then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1>
<p>output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]</p>
<h1>while entries past seq_lens are copied through:</h1>
<p>output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
```</p>
<p>Args:
  input: A <code>Tensor</code>. The input to reverse.
  seq_lengths: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D with length <code>input.dims(batch_dim)</code> and
    <code>max(seq_lengths) &lt; input.dims(seq_dim)</code>
  seq_dim: An <code>int</code>. The dimension which is partially reversed.
  batch_dim: An optional <code>int</code>. Defaults to <code>0</code>.
    The dimension along which reversal is performed.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  The partially reversed input. It has the same shape as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reverse_sequence', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reverse_sequence" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.reverse_v2">
    <p>def <span class="ident">reverse_v2</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reverse_v2(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.reverse_v2</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.reverse_v2(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.reverse_v2(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.reverse_v2</strong></p>
<div class="codehilite"><pre><span></span>Reverses specific dimensions of a tensor.
</pre></div>


<p>Given a <code>tensor</code>, and a <code>int32</code> tensor <code>axis</code> representing the set of
dimensions of <code>tensor</code> to reverse. This operation reverses each dimension
<code>i</code> for which there exists <code>j</code> s.t. <code>axis[j] == i</code>.</p>
<p><code>tensor</code> can have up to 8 dimensions. The number of dimensions specified
in <code>axis</code> may be 0 or more entries. If an index is specified more than
once, a InvalidArgument error is raised.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 't' is [[[[ 0,  1,  2,  3],</h1>
<h1>[ 4,  5,  6,  7],</h1>
<h1>[ 8,  9, 10, 11]],</h1>
<h1>[[12, 13, 14, 15],</h1>
<h1>[16, 17, 18, 19],</h1>
<h1>[20, 21, 22, 23]]]]</h1>
<h1>tensor 't' shape is [1, 2, 3, 4]</h1>
<h1>'dims' is [3] or 'dims' is -1</h1>
<p>reverse(t, dims) ==&gt; [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]</p>
<h1>'dims' is '[1]' (or 'dims' is '[-3]')</h1>
<p>reverse(t, dims) ==&gt; [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]</p>
<h1>'dims' is '[2]' (or 'dims' is '[-2]')</h1>
<p>reverse(t, dims) ==&gt; [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>. Must be one of the following types: <code>uint8</code>, <code>int8</code>, <code>int32</code>, <code>int64</code>, <code>bool</code>, <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
    Up to 8-D.
  axis: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D. The indices of the dimensions to reverse.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>tensor</code>. The same shape as <code>tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.reverse_v2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.reverse_v2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rint">
    <p>def <span class="ident">rint</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rint(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.rint</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.rint(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rint(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.rint</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise integer closest to x.
</pre></div>


<p>If the result is midway between two representable values,
the even representable is chosen.
For example:</p>
<p><code>rint(-1.5) ==&gt; -2.0
rint(0.5000001) ==&gt; 1.0
rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==&gt; [-2., -2., -0., 0., 2., 2., 2.]</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rint', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rint" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn">
    <p>def <span class="ident">rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnrnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnrnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnrnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>The simplest form of RNN network generated is:</p>
<p><code>python
  state = cell.zero_state(...)
  outputs = []
  for input_ in inputs:
    output, state = cell(input_, state)
    outputs.append(output)
  return (outputs, state)</code>
However, a few other options are available:</p>
<p>An initial state can be provided.
If the sequence_length vector is provided, dynamic calculation is performed.
This method of calculation does not compute the RNN steps past the maximum
sequence length of the minibatch (thus saving computational time),
and properly propagates the state at an example's sequence length
to the final state output.</p>
<p>The dynamic calculation performed is, at time <code>t</code> for batch row <code>b</code>,</p>
<p><code>python
  (output, state)(b, t) =
    (t &gt;= sequence_length(b))
      ? (zeros(cell.output_size), states(b, sequence_length(b) - 1))
      : cell(input(b, t), state(b, t - 1))</code></p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>, or a nested tuple of such elements.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  sequence_length: Specifies the length of each sequence in inputs.
    An int32 or int64 vector (tensor) size <code>[batch_size]</code>, values in <code>[0, T)</code>.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<ul>
<li>outputs is a length T list of outputs (one for each input), or a nested
    tuple of such elements.</li>
<li>state is the final state</li>
</ul>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the input depth
    (column size) cannot be inferred from inputs via shape inference.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer">
    <p>def <span class="ident">rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>The simplest form of RNN network generated is:</p>
<p><code>python
  state = cell.zero_state(...)
  outputs = []
  for input_ in inputs:
    output, state = cell(input_, state)
    outputs.append(output)
  return (outputs, state)</code>
However, a few other options are available:</p>
<p>An initial state can be provided.
If the sequence_length vector is provided, dynamic calculation is performed.
This method of calculation does not compute the RNN steps past the maximum
sequence length of the minibatch (thus saving computational time),
and properly propagates the state at an example's sequence length
to the final state output.</p>
<p>The dynamic calculation performed is, at time <code>t</code> for batch row <code>b</code>,</p>
<p><code>python
  (output, state)(b, t) =
    (t &gt;= sequence_length(b))
      ? (zeros(cell.output_size), states(b, sequence_length(b) - 1))
      : cell(input(b, t), state(b, t - 1))</code></p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>, or a nested tuple of such elements.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  sequence_length: Specifies the length of each sequence in inputs.
    An int32 or int64 vector (tensor) size <code>[batch_size]</code>, values in <code>[0, T)</code>.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<ul>
<li>outputs is a length T list of outputs (one for each input), or a nested
    tuple of such elements.</li>
<li>state is the final state</li>
</ul>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the input depth
    (column size) cannot be inferred from inputs via shape inference.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_layer">
    <p>def <span class="ident">rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.rnn</strong></p>
<div class="codehilite"><pre><span></span>Creates a recurrent neural network specified by RNNCell `cell`.
</pre></div>


<p>The simplest form of RNN network generated is:</p>
<p><code>python
  state = cell.zero_state(...)
  outputs = []
  for input_ in inputs:
    output, state = cell(input_, state)
    outputs.append(output)
  return (outputs, state)</code>
However, a few other options are available:</p>
<p>An initial state can be provided.
If the sequence_length vector is provided, dynamic calculation is performed.
This method of calculation does not compute the RNN steps past the maximum
sequence length of the minibatch (thus saving computational time),
and properly propagates the state at an example's sequence length
to the final state output.</p>
<p>The dynamic calculation performed is, at time <code>t</code> for batch row <code>b</code>,</p>
<p><code>python
  (output, state)(b, t) =
    (t &gt;= sequence_length(b))
      ? (zeros(cell.output_size), states(b, sequence_length(b) - 1))
      : cell(input(b, t), state(b, t - 1))</code></p>
<p>Args:
  cell: An instance of RNNCell.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>, or a nested tuple of such elements.
  initial_state: (optional) An initial state for the RNN.
    If <code>cell.state_size</code> is an integer, this must be
    a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>.
    If <code>cell.state_size</code> is a tuple, this should be a tuple of
    tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.
  dtype: (optional) The data type for the initial state and expected output.
    Required if initial_state is not provided or RNN state has a heterogeneous
    dtype.
  sequence_length: Specifies the length of each sequence in inputs.
    An int32 or int64 vector (tensor) size <code>[batch_size]</code>, values in <code>[0, T)</code>.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:</p>
<ul>
<li>outputs is a length T list of outputs (one for each input), or a nested
    tuple of such elements.</li>
<li>state is the final state</li>
</ul>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the input depth
    (column size) cannot be inferred from inputs via shape inference.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state">
    <p>def <span class="ident">rnn_placeholders_from_state</span>(</p><p>self, zero_state, name=u&#39;rnn_state&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn_placeholders_from_state(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderrnn_placeholders_from_state</code>. </p>
<p><strong>tensorbuilderrnn_placeholders_from_state</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_placeholders_from_state" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.RegisterMethod</span><span class="p">(</span><span class="s2">&quot;tensorbuilder&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rnn_placeholders_from_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero_state</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rnn_state&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zero_state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rnn_placeholders_from_state</span><span class="p">(</span><span class="n">substate</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">substate</span> <span class="ow">in</span> <span class="n">zero_state</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">zero_state</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">zero_state</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict">
    <p>def <span class="ident">rnn_state_feed_dict</span>(</p><p>self, placeholders, values)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rnn_state_feed_dict(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorbuilderrnn_state_feed_dict</code>. </p>
<p><strong>tensorbuilderrnn_state_feed_dict</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rnn_state_feed_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.RegisterMethod</span><span class="p">(</span><span class="s2">&quot;tensorbuilder&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rnn_state_feed_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">placeholders</span><span class="p">),</span> <span class="n">utils</span><span class="o">.</span><span class="n">flatten_list</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.round">
    <p>def <span class="ident">round</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.round(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.round</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.round(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.round(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.round</strong></p>
<div class="codehilite"><pre><span></span>Rounds the values of a tensor to the nearest integer, element-wise.
</pre></div>


<p>Rounds half to even.  Also known as bankers rounding. If you want to round
according to the current system rounding mode use tf::cint.
For example:</p>
<p>```python</p>
<h1>'a' is [0.9, 2.5, 2.3, 1.5, -4.5]</h1>
<p>tf.round(a) ==&gt; [ 1.0, 2.0, 2.0, 2.0, -4.0 ]
```</p>
<p>Args:
  x: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of same shape and type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.round', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.round" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.rsqrt">
    <p>def <span class="ident">rsqrt</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rsqrt(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.rsqrt</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.rsqrt(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.rsqrt(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.rsqrt</strong></p>
<div class="codehilite"><pre><span></span>Computes reciprocal of square root of x element-wise.
</pre></div>


<p>I.e., \(y = 1 / \sqrt{x}\).</p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.rsqrt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.rsqrt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sampled_softmax_loss">
    <p>def <span class="ident">sampled_softmax_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sampled_softmax_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsampled_softmax_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsampled_softmax_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sampled_softmax_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsampled_softmax_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the sampled softmax training loss.
</pre></div>


<p>This is a faster way to train a softmax classifier over a huge number of
classes.</p>
<p>This operation is for training only.  It is generally an underestimate of
the full softmax loss.</p>
<p>At inference time, you can compute full softmax probabilities with the
expression <code>tf.nn.softmax(tf.matmul(inputs, tf.transpose(weights)) + biases)</code>.</p>
<p>See our [Candidate Sampling Algorithms Reference]
(../../extras/candidate_sampling.pdf)</p>
<p>Also see Section 3 of <a href="http://arxiv.org/abs/1412.2007">Jean et al., 2014</a>
(<a href="http://arxiv.org/pdf/1412.2007.pdf">pdf</a>) for the math.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-sharded) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.  Note that this format differs from
      the <code>labels</code> argument of <code>nn.softmax_cross_entropy_with_logits</code>.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  Default is
      True.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example sampled softmax losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer">
    <p>def <span class="ident">sampled_softmax_loss_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sampled_softmax_loss_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sampled_softmax_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sampled_softmax_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sampled_softmax_loss_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sampled_softmax_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sampled_softmax_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the sampled softmax training loss.
</pre></div>


<p>This is a faster way to train a softmax classifier over a huge number of
classes.</p>
<p>This operation is for training only.  It is generally an underestimate of
the full softmax loss.</p>
<p>At inference time, you can compute full softmax probabilities with the
expression <code>tf.nn.softmax(tf.matmul(inputs, tf.transpose(weights)) + biases)</code>.</p>
<p>See our [Candidate Sampling Algorithms Reference]
(../../extras/candidate_sampling.pdf)</p>
<p>Also see Section 3 of <a href="http://arxiv.org/abs/1412.2007">Jean et al., 2014</a>
(<a href="http://arxiv.org/pdf/1412.2007.pdf">pdf</a>) for the math.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-sharded) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.  Note that this format differs from
      the <code>labels</code> argument of <code>nn.softmax_cross_entropy_with_logits</code>.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  Default is
      True.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example sampled softmax losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer">
    <p>def <span class="ident">sampled_softmax_loss_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sampled_softmax_loss_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sampled_softmax_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sampled_softmax_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sampled_softmax_loss_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sampled_softmax_loss`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sampled_softmax_loss</strong></p>
<div class="codehilite"><pre><span></span>Computes and returns the sampled softmax training loss.
</pre></div>


<p>This is a faster way to train a softmax classifier over a huge number of
classes.</p>
<p>This operation is for training only.  It is generally an underestimate of
the full softmax loss.</p>
<p>At inference time, you can compute full softmax probabilities with the
expression <code>tf.nn.softmax(tf.matmul(inputs, tf.transpose(weights)) + biases)</code>.</p>
<p>See our [Candidate Sampling Algorithms Reference]
(../../extras/candidate_sampling.pdf)</p>
<p>Also see Section 3 of <a href="http://arxiv.org/abs/1412.2007">Jean et al., 2014</a>
(<a href="http://arxiv.org/pdf/1412.2007.pdf">pdf</a>) for the math.</p>
<p>Args:
  weights: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code>
      objects whose concatenation along dimension 0 has shape
      [num_classes, dim].  The (possibly-sharded) class embeddings.
  biases: A <code>Tensor</code> of shape <code>[num_classes]</code>.  The class biases.
  inputs: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>.  The forward
      activations of the input network.
  labels: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
      num_true]</code>. The target classes.  Note that this format differs from
      the <code>labels</code> argument of <code>nn.softmax_cross_entropy_with_logits</code>.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  num_classes: An <code>int</code>. The number of possible classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  sampled_values: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>,
      <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function.
      (if None, we default to <code>log_uniform_candidate_sampler</code>)
  remove_accidental_hits:  A <code>bool</code>.  whether to remove "accidental hits"
      where a sampled class equals one of the target classes.  Default is
      True.
  partition_strategy: A string specifying the partitioning strategy, relevant
      if <code>len(weights) &gt; 1</code>. Currently <code>"div"</code> and <code>"mod"</code> are supported.
      Default is <code>"mod"</code>. See <code>tf.nn.embedding_lookup</code> for more details.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>batch_size</code> 1-D tensor of per-example sampled softmax losses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sampled_softmax_loss_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.saturate_cast">
    <p>def <span class="ident">saturate_cast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.saturate_cast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.saturate_cast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.saturate_cast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.saturate_cast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.saturate_cast</strong></p>
<div class="codehilite"><pre><span></span>Performs a safe saturating cast of `value` to `dtype`.
</pre></div>


<p>This function casts the input to <code>dtype</code> without applying any scaling.  If
there is a danger that values would over or underflow in the cast, this op
applies the appropriate clamping before the cast.</p>
<p>Args:
  value: A <code>Tensor</code>.
  dtype: The desired output <code>DType</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>value</code> safely cast to <code>dtype</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.saturate_cast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.saturate_cast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scalar_mul">
    <p>def <span class="ident">scalar_mul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scalar_mul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scalar_mul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scalar_mul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scalar_mul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scalar_mul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies a scalar times a `Tensor` or `IndexedSlices` object.
</pre></div>


<p>Intended for use in gradient code which might deal with <code>IndexedSlices</code>
objects, which are easy to multiply by a scalar but more expensive to
multiply with arbitrary tensors.</p>
<p>Args:
  scalar: A 0-D scalar <code>Tensor</code>. Must have known shape.
  x: A <code>Tensor</code> or <code>IndexedSlices</code> to be scaled.</p>
<p>Returns:
  <code>scalar * x</code> of the same type (<code>Tensor</code> or <code>IndexedSlices</code>) as <code>x</code>.</p>
<p>Raises:
  ValueError: if scalar is not a 0-D <code>scalar</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scalar_mul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scalar_mul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scalar_summary">
    <p>def <span class="ident">scalar_summary</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scalar_summary(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scalar_summary</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scalar_summary(x1, x2, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scalar_summary(x1, *args, **kwargs)(x2)
</pre></div>


<p><strong>tensorflow.scalar_summary</strong></p>
<div class="codehilite"><pre><span></span>Outputs a `Summary` protocol buffer with scalar values. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-30.
Instructions for updating:
Please switch to tf.summary.scalar. Note that tf.summary.scalar uses the node name instead of the tag. This means that TensorFlow will automatically de-duplicate summary names based on the scope they are created in. Also, passing a tensor or list of tags to a scalar summary op is no longer supported.</p>
<p>The input <code>tags</code> and <code>values</code> must have the same shape.  The generated
  summary has a summary value for each tag-value pair in <code>tags</code> and <code>values</code>.</p>
<p>Args:
    tags: A <code>string</code> <code>Tensor</code>.  Tags for the summaries.
    values: A real numeric Tensor.  Values for the summaries.
    collections: Optional list of graph collections keys. The new summary op is
      added to these collections. Defaults to <code>[GraphKeys.SUMMARIES]</code>.
    name: A name for the operation (optional).</p>
<p>Returns:
    A scalar <code>Tensor</code> of type <code>string</code>. The serialized <code>Summary</code> protocol
    buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scalar_summary', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scalar_summary" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scan">
    <p>def <span class="ident">scan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scan</strong></p>
<div class="codehilite"><pre><span></span>scan on the list of tensors unpacked from `elems` on dimension 0.
</pre></div>


<p>The simplest version of <code>scan</code> repeatedly applies the callable <code>fn</code> to a
sequence of elements from first to last. The elements are made of the tensors
unpacked from <code>elems</code> on dimension 0. The callable fn takes two tensors as
arguments. The first argument is the accumulated value computed from the
preceding invocation of fn. If <code>initializer</code> is None, <code>elems</code> must contain
at least one element, and its first element is used as the initializer.</p>
<p>Suppose that <code>elems</code> is unpacked into <code>values</code>, a list of tensors. The shape
of the result tensor is <code>[len(values)] + fn(initializer, values[0]).shape</code>.</p>
<p>This method also allows multi-arity <code>elems</code> and accumulator.  If <code>elems</code>
is a (possibly nested) list or tuple of tensors, then each of these tensors
must have a matching first (unpack) dimension.  The second argument of
<code>fn</code> must match the structure of <code>elems</code>.</p>
<p>If no <code>initializer</code> is provided, the output structure and dtypes of <code>fn</code>
are assumed to be the same as its input; and in this case, the first
argument of <code>fn</code> must match the structure of <code>elems</code>.</p>
<p>If an <code>initializer</code> is provided, then the output of <code>fn</code> must have the same
structure as <code>initializer</code>; and the first argument of <code>fn</code> must match
this structure.</p>
<p>For example, if <code>elems</code> is <code>(t1, [t2, t3])</code> and <code>initializer</code> is
<code>[i1, i2]</code> then an appropriate signature for <code>fn</code> in <code>python2</code> is:
<code>fn = lambda (acc_p1, acc_p2), (t1 [t2, t3]):</code> and <code>fn</code> must return a list,
<code>[acc_n1, acc_n2]</code>.  An alternative correct signature for <code>fn</code>, and the
 one that works in <code>python3</code>, is:
<code>fn = lambda a, t:</code>, where <code>a</code> and <code>t</code> correspond to the input tuples.</p>
<p>Args:
  fn: The callable to be performed.  It accepts two arguments.  The first
    will have the same structure as <code>initializer</code> if one is provided,
    otherwise it will have the same structure as <code>elems</code>.  The second
    will have the same (possibly nested) structure as <code>elems</code>.  Its output
    must have the same structure as <code>initializer</code> if one is provided,
    otherwise it must have the same structure as <code>elems</code>.
  elems: A tensor or (possibly nested) sequence of tensors, each of which
    will be unpacked along their first dimension.  The nested sequence
    of the resulting slices will be the first argument to <code>fn</code>.
  initializer: (optional) A tensor or (possibly nested) sequence of tensors,
    initial value for the accumulator, and the expected output type of <code>fn</code>.
  parallel_iterations: (optional) The number of iterations allowed to run
    in parallel.
  back_prop: (optional) True enables support for back propagation.
  swap_memory: (optional) True enables GPU-CPU memory swapping.
  infer_shape: (optional) False disables tests for consistent output shapes.
  name: (optional) Name prefix for the returned tensors.</p>
<p>Returns:
  A tensor or (possibly nested) sequence of tensors.  Each tensor packs the
  results of applying <code>fn</code> to tensors unpacked from <code>elems</code> along the first
  dimension, and the previous accumulator value(s), from first to last.</p>
<p>Raises:
  TypeError: if <code>fn</code> is not callable or the structure of the output of
    <code>fn</code> and <code>initializer</code> do not match.
  ValueError: if the lengths of the output of <code>fn</code> and <code>initializer</code>
    do not match.</p>
<p>Examples:
  <code>python
  elems = np.array([1, 2, 3, 4, 5, 6])
  sum = scan(lambda a, x: a + x, elems)
  # sum == [1, 3, 6, 10, 15, 21]</code></p>
<p><code>python
  elems = np.array([1, 2, 3, 4, 5, 6])
  initializer = np.array(0)
  sum_one = scan(
      lambda a, x: x[0] - x[1] + a, (elems + 1, elems), initializer)
  # sum_one == [1, 2, 3, 4, 5, 6]</code></p>
<p><code>python
  elems = np.array([1, 0, 0, 0, 0, 0])
  initializer = (np.array(0), np.array(1))
  fibonaccis = scan(lambda a, _: (a[1], a[0] + a[1]), elems, initializer)
  # fibonaccis == ([1, 1, 2, 3, 5, 8], [1, 2, 3, 5, 8, 13])</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_add">
    <p>def <span class="ident">scatter_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_add</strong></p>
<div class="codehilite"><pre><span></span>Adds sparse updates to a variable reference.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] += updates[...]

# Vector indices (for each i)
ref[indices[i], ...] += updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions add.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterAdd.png" alt>
</div>

<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to add to <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the addition will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_div">
    <p>def <span class="ident">scatter_div</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_div(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_div</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_div(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_div(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_div</strong></p>
<div class="codehilite"><pre><span></span>Divides a variable reference by sparse updates.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] /= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] /= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions divide.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of values that <code>ref</code> is divided by.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the operation will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_div', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_div" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_mul">
    <p>def <span class="ident">scatter_mul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_mul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_mul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_mul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_mul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_mul</strong></p>
<div class="codehilite"><pre><span></span>Multiplies sparse updates into a variable reference.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] *= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] *= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions multiply.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to multiply to <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the operation will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_mul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_mul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_nd">
    <p>def <span class="ident">scatter_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_nd</strong></p>
<div class="codehilite"><pre><span></span>Creates a new tensor by applying sparse `updates` to individual
</pre></div>


<p>values or slices within a zero tensor of the given <code>shape</code> tensor according to
indices.  This operator is the inverse of the <a href="#gather_nd">tf.gather_nd</a>
operator which extracts values or slices from a given tensor.</p>
<p>TODO(simister): Add a link to Variable.<strong>getitem</strong> documentation on slice
syntax.</p>
<p><code>shape</code> is a <code>TensorShape</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank
<code>Q</code>.</p>
<p><code>indices</code> must be integer tensor, containing indices into <code>shape</code>.
It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.</p>
<p>The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to
indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th
dimension of <code>shape</code>.</p>
<p><code>updates</code> is Tensor of rank <code>Q-1+P-K</code> with shape:</p>
<p><code>[d_0, ..., d_{Q-2}, shape[K], ..., shape[P-1]].</code></p>
<p>The simplest form of scatter is to insert individual elements in a tensor by
index. For example, say we want to insert 4 scattered elements in a rank-1
tensor with 8 elements.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterNd1.png" alt>
</div>

<p>In Python, this scatter operation would look like this:</p>
<div class="codehilite"><pre><span></span>indices = tf.constant([[4], [3], [1], [7]])
updates = tf.constant([9, 10, 11, 12])
shape = tf.constant([8])
scatter = tf.scatter_nd(indices, updates, shape)
with tf.Session() as sess:
  print sess.run(scatter)
</pre></div>


<p>The resulting tensor would look like this:</p>
<div class="codehilite"><pre><span></span>[0, 11, 0, 10, 9, 0, 0, 12]
</pre></div>


<p>We can also, insert entire slices of a higher rank tensor all at once. For
example, if we wanted to insert two slices in the first dimension of a
rank-3 tensor with two matrices of new values.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterNd2.png" alt>
</div>

<p>In Python, this scatter operation would look like this:</p>
<div class="codehilite"><pre><span></span>indices = tf.constant([[0], [2]])
updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
                        [7, 7, 7, 7], [8, 8, 8, 8]],
                       [[5, 5, 5, 5], [6, 6, 6, 6],
                        [7, 7, 7, 7], [8, 8, 8, 8]]])
shape = tf.constant([4, 4, 4])
scatter = tf.scatter_nd(indices, updates, shape)
with tf.Session() as sess:
  print sess.run(scatter)
</pre></div>


<p>The resulting tensor would look like this:</p>
<div class="codehilite"><pre><span></span>[[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
 [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]
</pre></div>


<p>Args:
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A Tensor. Must be one of the following types: int32, int64.
    A tensor of indices into ref.
  updates: A <code>Tensor</code>.
    A Tensor. Must have the same type as tensor. A tensor of updated values
    to store in ref.
  shape: A <code>Tensor</code>. Must have the same type as <code>indices</code>.
    A vector. The shape of the resulting tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>updates</code>.
  A new tensor with the given shape and updates applied according
  to the indices.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_nd_add">
    <p>def <span class="ident">scatter_nd_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_nd_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_nd_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_nd_add</strong></p>
<div class="codehilite"><pre><span></span>Applies sparse addition between `updates` and individual values or slices
</pre></div>


<p>within a given variable according to <code>indices</code>.</p>
<p><code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.</p>
<p><code>indices</code> must be integer tensor, containing indices into <code>ref</code>.
It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.</p>
<p>The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to
indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th
dimension of <code>ref</code>.</p>
<p><code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:</p>
<p><code>[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].</code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
elements. In Python, that addition would look like this:</p>
<div class="codehilite"><pre><span></span>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1], [7]])
updates = tf.constant([9, 10, 11, 12])
add = tf.scatter_nd_add(ref, indices, updates)
with tf.Session() as sess:
  print sess.run(add)
</pre></div>


<p>The resulting update to ref would look like this:</p>
<div class="codehilite"><pre><span></span>[1, 13, 3, 14, 14, 6, 7, 20]
</pre></div>


<p>See <a href="#scatter_nd">tf.scatter_nd</a> for more details about how to make updates to
slices.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    A mutable Tensor. Should be from a Variable node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A Tensor. Must be one of the following types: int32, int64.
    A tensor of indices into ref.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A Tensor. Must have the same type as ref. A tensor of updated values
    to add to ref.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    An optional bool. Defaults to True. If True, the assignment will
    be protected by a lock; otherwise the behavior is undefined,
    but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  A mutable <code>Tensor</code>. Has the same type as <code>ref</code>.
  Same as ref. Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_nd_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_nd_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_nd_sub">
    <p>def <span class="ident">scatter_nd_sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd_sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_nd_sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_nd_sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd_sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_nd_sub</strong></p>
<div class="codehilite"><pre><span></span>Applies sparse subtraction between `updates` and individual values or slices
</pre></div>


<p>within a given variable according to <code>indices</code>.</p>
<p><code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.</p>
<p><code>indices</code> must be integer tensor, containing indices into <code>ref</code>.
It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.</p>
<p>The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to
indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th
dimension of <code>ref</code>.</p>
<p><code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:</p>
<p><code>[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].</code></p>
<p>For example, say we want to subtract 4 scattered elements from a rank-1 tensor
with 8 elements. In Python, that subtraction would look like this:</p>
<div class="codehilite"><pre><span></span>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1], [7]])
updates = tf.constant([9, 10, 11, 12])
sub = tf.scatter_nd_sub(ref, indices, updates)
with tf.Session() as sess:
  print sess.run(sub)
</pre></div>


<p>The resulting update to ref would look like this:</p>
<div class="codehilite"><pre><span></span>[1, -9, 3, -6, -4, 6, 7, -4]
</pre></div>


<p>See <a href="#scatter_nd">tf.scatter_nd</a> for more details about how to make updates to
slices.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    A mutable Tensor. Should be from a Variable node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A Tensor. Must be one of the following types: int32, int64.
    A tensor of indices into ref.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A Tensor. Must have the same type as ref. A tensor of updated values
    to subtract from ref.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    An optional bool. Defaults to True. If True, the assignment will
    be protected by a lock; otherwise the behavior is undefined,
    but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  A mutable <code>Tensor</code>. Has the same type as <code>ref</code>.
  Same as ref. Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_nd_sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_nd_sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_nd_update">
    <p>def <span class="ident">scatter_nd_update</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd_update(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_nd_update</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_nd_update(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_nd_update(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_nd_update</strong></p>
<div class="codehilite"><pre><span></span>Applies sparse `updates` to individual values or slices within a given
</pre></div>


<p>variable according to <code>indices</code>.</p>
<p><code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.</p>
<p><code>indices</code> must be integer tensor, containing indices into <code>ref</code>.
It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.</p>
<p>The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to
indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th
dimension of <code>ref</code>.</p>
<p><code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:</p>
<p><code>[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].</code></p>
<p>For example, say we want to update 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<div class="codehilite"><pre><span></span>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
update = tf.scatter_nd_update(ref, indices, updates)
with tf.Session() as sess:
  print sess.run(update)
</pre></div>


<p>The resulting update to ref would look like this:</p>
<div class="codehilite"><pre><span></span>[1, 11, 3, 10, 9, 6, 7, 12]
</pre></div>


<p>See <a href="#scatter_nd">tf.scatter_nd</a> for more details about how to make updates to
slices.</p>
<p>Args:
  ref: A mutable <code>Tensor</code>. A mutable Tensor. Should be from a Variable node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A Tensor. Must be one of the following types: int32, int64.
    A tensor of indices into ref.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A Tensor. Must have the same type as ref. A tensor of updated
    values to add to ref.
  use_locking: An optional <code>bool</code>. Defaults to <code>True</code>.
    An optional bool. Defaults to True. If True, the assignment will
    be protected by a lock; otherwise the behavior is undefined,
    but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  A mutable <code>Tensor</code>. Has the same type as <code>ref</code>.
  Same as ref. Returned as a convenience for operations that want to
  use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_nd_update', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_nd_update" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_sub">
    <p>def <span class="ident">scatter_sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_sub</strong></p>
<div class="codehilite"><pre><span></span>Subtracts sparse updates to a variable reference.

# Scalar indices
ref[indices, ...] -= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] -= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their (negated) contributions add.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterSub.png" alt>
</div>

<p>Args:
  ref: A mutable <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to subtract from <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>False</code>.
    If True, the subtraction will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.scatter_update">
    <p>def <span class="ident">scatter_update</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_update(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.scatter_update</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.scatter_update(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.scatter_update(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.scatter_update</strong></p>
<div class="codehilite"><pre><span></span>Applies sparse updates to a variable reference.
</pre></div>


<p>This operation computes</p>
<div class="codehilite"><pre><span></span># Scalar indices
ref[indices, ...] = updates[...]

# Vector indices (for each i)
ref[indices[i], ...] = updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
</pre></div>


<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<p>If values in <code>ref</code> is to be updated more than once, because there are
duplicate entires in <code>indices</code>, the order at which the updates happen
for each value is undefined.</p>
<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterUpdate.png" alt>
</div>

<p>Args:
  ref: A mutable <code>Tensor</code>. Should be from a <code>Variable</code> node.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor of indices into the first dimension of <code>ref</code>.
  updates: A <code>Tensor</code>. Must have the same type as <code>ref</code>.
    A tensor of updated values to store in <code>ref</code>.
  use_locking: An optional <code>bool</code>. Defaults to <code>True</code>.
    If True, the assignment will be protected by a lock;
    otherwise the behavior is undefined, but may exhibit less contention.
  name: A name for the operation (optional).</p>
<p>Returns:
  Same as <code>ref</code>.  Returned as a convenience for operations that want
  to use the updated values after the update is done.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.scatter_update', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.scatter_update" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_max">
    <p>def <span class="ident">segment_max</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_max(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_max</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_max(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_max(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_max</strong></p>
<div class="codehilite"><pre><span></span>Computes the maximum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on Segmentation</a>
for an explanation of segments.</p>
<p>Computes a tensor such that
\(output_i = \max_j(data_j)\) where <code>max</code> is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMax.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_max', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_max" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_mean">
    <p>def <span class="ident">segment_mean</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_mean(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_mean</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_mean(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_mean(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_mean</strong></p>
<div class="codehilite"><pre><span></span>Computes the mean along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
\(output_i = \frac{\sum_j data_j}{N}\) where <code>mean</code> is
over <code>j</code> such that <code>segment_ids[j] == i</code> and <code>N</code> is the total number of
values summed.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMean.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_mean', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_mean" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_min">
    <p>def <span class="ident">segment_min</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_min(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_min</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_min(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_min(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_min</strong></p>
<div class="codehilite"><pre><span></span>Computes the minimum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
\(output_i = \min_j(data_j)\) where <code>min</code> is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMin.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_min', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_min" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_prod">
    <p>def <span class="ident">segment_prod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_prod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_prod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_prod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_prod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_prod</strong></p>
<div class="codehilite"><pre><span></span>Computes the product along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
\(output_i = \prod_j data_j\) where the product is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentProd.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_prod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_prod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.segment_sum">
    <p>def <span class="ident">segment_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.segment_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.segment_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.segment_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.segment_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on Segmentation</a>
for an explanation of segments.</p>
<p>Computes a tensor such that
\(output_i = \sum_j data_j\) where sum is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentSum.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor whose rank is equal to the rank of <code>data</code>'s
    first dimension.  Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.segment_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.segment_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.select">
    <p>def <span class="ident">select</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.select(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.select</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.select(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.select(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.select</strong></p>
<div class="codehilite"><pre><span></span>Selects elements from `t` or `e`, depending on `condition`.
</pre></div>


<p>The <code>t</code>, and <code>e</code> tensors must all have the same shape, and the
output will also have that shape.</p>
<p>The <code>condition</code> tensor must be a scalar if <code>t</code> and <code>e</code> are scalars.
If <code>t</code> and <code>e</code> are vectors or higher rank, then <code>condition</code> must be either a
scalar, a vector with size matching the first dimension of <code>t</code>, or must have
the same shape as <code>t</code>.</p>
<p>The <code>condition</code> tensor acts as a mask that chooses, based on the value at each
element, whether the corresponding element / row in the output should be
taken from <code>t</code> (if true) or <code>e</code> (if false).</p>
<p>If <code>condition</code> is a vector and <code>t</code> and <code>e</code> are higher rank matrices, then
it chooses which row (outer dimension) to copy from <code>t</code> and <code>e</code>.
If <code>condition</code> has the same shape as <code>t</code> and <code>e</code>, then it chooses which
element to copy from <code>t</code> and <code>e</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'condition' tensor is [[True,  False]</h1>
<h1>[False, True]]</h1>
<h1>'t' is [[1, 2],</h1>
<h1>[3, 4]]</h1>
<h1>'e' is [[5, 6],</h1>
<h1>[7, 8]]</h1>
<p>select(condition, t, e) ==&gt; [[1, 6],
                             [7, 4]]</p>
<h1>'condition' tensor is [True, False]</h1>
<h1>'t' is [[1, 2],</h1>
<h1>[3, 4]]</h1>
<h1>'e' is [[5, 6],</h1>
<h1>[7, 8]]</h1>
<p>select(condition, t, e) ==&gt; [[1, 2],
                             [7, 8]]</p>
<p>```</p>
<p>Args:
  condition: A <code>Tensor</code> of type <code>bool</code>.
  t:  A <code>Tensor</code> which may have the same shape as <code>condition</code>.
    If <code>condition</code> is rank 1, <code>t</code> may have higher rank,
    but its first dimension must match the size of <code>condition</code>.
  e:  A <code>Tensor</code> with the same type and shape as <code>t</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type and shape as <code>t</code> and <code>e</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.select', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.select" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.self_adjoint_eig">
    <p>def <span class="ident">self_adjoint_eig</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.self_adjoint_eig(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.self_adjoint_eig</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.self_adjoint_eig(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.self_adjoint_eig(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.self_adjoint_eig</strong></p>
<div class="codehilite"><pre><span></span>Computes the eigen decomposition of a batch of self-adjoint matrices.
</pre></div>


<p>Computes the eigenvalues and eigenvectors of the innermost N-by-N matrices
in <code>tensor</code> such that
<code>tensor[...,:,:] * v[..., :,i] = e[..., i] * v[...,:,i]</code>, for i=0...N-1.</p>
<p>Args:
  tensor: <code>Tensor</code> of shape <code>[..., N, N]</code>. Only the lower triangular part of
    each inner inner matrix is referenced.
  name: string, optional name of the operation.</p>
<p>Returns:
  e: Eigenvalues. Shape is <code>[..., N]</code>.
  v: Eigenvectors. Shape is <code>[..., N, N]</code>. The columns of the inner most
    matrices contain eigenvectors of the corresponding matrices in <code>tensor</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.self_adjoint_eig', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.self_adjoint_eig" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals">
    <p>def <span class="ident">self_adjoint_eigvals</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.self_adjoint_eigvals(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.self_adjoint_eigvals</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.self_adjoint_eigvals(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.self_adjoint_eigvals(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.self_adjoint_eigvals</strong></p>
<div class="codehilite"><pre><span></span>Computes the eigenvalues of one or more self-adjoint matrices.
</pre></div>


<p>Args:
  tensor: <code>Tensor</code> of shape <code>[..., N, N]</code>.
  name: string, optional name of the operation.</p>
<p>Returns:
  e: Eigenvalues. Shape is <code>[..., N]</code>. The vector <code>e[..., :]</code> contains the <code>N</code>
    eigenvalues of <code>tensor[..., :, :]</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.self_adjoint_eigvals" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.separable_conv2d">
    <p>def <span class="ident">separable_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.separable_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnseparable_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnseparable_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.separable_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnseparable_conv2d</strong></p>
<div class="codehilite"><pre><span></span>2-D convolution with separable filters.
</pre></div>


<p>Performs a depthwise convolution that acts separately on channels followed by
a pointwise convolution that mixes channels.  Note that this is separability
between dimensions <code>[1, 2]</code> and <code>3</code>, not spatial separability between
dimensions <code>1</code> and <code>2</code>.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q, r]
    input[b, strides[1] * i + di, strides[2] * j + dj, q] *
    depthwise_filter[di, dj, q, r] *
    pointwise_filter[0, 0, q * channel_multiplier + r, k]
</pre></div>


<p><code>strides</code> controls the strides for the depthwise convolution only, since
the pointwise convolution has implicit strides of <code>[1, 1, 1, 1]</code>.  Must have
<code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D <code>Tensor</code> with shape <code>[batch, in_height, in_width, in_channels]</code>.
  depthwise_filter: 4-D <code>Tensor</code> with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
    Contains <code>in_channels</code> convolutional filters of depth 1.
  pointwise_filter: 4-D <code>Tensor</code> with shape
    <code>[1, 1, channel_multiplier * in_channels, out_channels]</code>.  Pointwise
    filter to mix channels after <code>depthwise_filter</code> has convolved spatially.
  strides: 1-D of size 4.  The strides for the depthwise convolution for
    each dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>.  The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape <code>[batch, out_height, out_width, out_channels]</code>.</p>
<p>Raises:
  ValueError: If channel_multiplier * in_channels &gt; out_channels,
    which means that the separable convolution is overparameterized.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.separable_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.separable_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer">
    <p>def <span class="ident">separable_conv2d_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.separable_conv2d_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.separable_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.separable_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.separable_conv2d_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.separable_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.separable_conv2d</strong></p>
<div class="codehilite"><pre><span></span>2-D convolution with separable filters.
</pre></div>


<p>Performs a depthwise convolution that acts separately on channels followed by
a pointwise convolution that mixes channels.  Note that this is separability
between dimensions <code>[1, 2]</code> and <code>3</code>, not spatial separability between
dimensions <code>1</code> and <code>2</code>.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q, r]
    input[b, strides[1] * i + di, strides[2] * j + dj, q] *
    depthwise_filter[di, dj, q, r] *
    pointwise_filter[0, 0, q * channel_multiplier + r, k]
</pre></div>


<p><code>strides</code> controls the strides for the depthwise convolution only, since
the pointwise convolution has implicit strides of <code>[1, 1, 1, 1]</code>.  Must have
<code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D <code>Tensor</code> with shape <code>[batch, in_height, in_width, in_channels]</code>.
  depthwise_filter: 4-D <code>Tensor</code> with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
    Contains <code>in_channels</code> convolutional filters of depth 1.
  pointwise_filter: 4-D <code>Tensor</code> with shape
    <code>[1, 1, channel_multiplier * in_channels, out_channels]</code>.  Pointwise
    filter to mix channels after <code>depthwise_filter</code> has convolved spatially.
  strides: 1-D of size 4.  The strides for the depthwise convolution for
    each dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>.  The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape <code>[batch, out_height, out_width, out_channels]</code>.</p>
<p>Raises:
  ValueError: If channel_multiplier * in_channels &gt; out_channels,
    which means that the separable convolution is overparameterized.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.separable_conv2d_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.separable_conv2d_layer">
    <p>def <span class="ident">separable_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.separable_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.separable_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.separable_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.separable_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.separable_conv2d`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.separable_conv2d</strong></p>
<div class="codehilite"><pre><span></span>2-D convolution with separable filters.
</pre></div>


<p>Performs a depthwise convolution that acts separately on channels followed by
a pointwise convolution that mixes channels.  Note that this is separability
between dimensions <code>[1, 2]</code> and <code>3</code>, not spatial separability between
dimensions <code>1</code> and <code>2</code>.</p>
<p>In detail,</p>
<div class="codehilite"><pre><span></span>output[b, i, j, k] = sum_{di, dj, q, r]
    input[b, strides[1] * i + di, strides[2] * j + dj, q] *
    depthwise_filter[di, dj, q, r] *
    pointwise_filter[0, 0, q * channel_multiplier + r, k]
</pre></div>


<p><code>strides</code> controls the strides for the depthwise convolution only, since
the pointwise convolution has implicit strides of <code>[1, 1, 1, 1]</code>.  Must have
<code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<p>Args:
  input: 4-D <code>Tensor</code> with shape <code>[batch, in_height, in_width, in_channels]</code>.
  depthwise_filter: 4-D <code>Tensor</code> with shape
    <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.
    Contains <code>in_channels</code> convolutional filters of depth 1.
  pointwise_filter: 4-D <code>Tensor</code> with shape
    <code>[1, 1, channel_multiplier * in_channels, out_channels]</code>.  Pointwise
    filter to mix channels after <code>depthwise_filter</code> has convolved spatially.
  strides: 1-D of size 4.  The strides for the depthwise convolution for
    each dimension of <code>input</code>.
  padding: A string, either <code>'VALID'</code> or <code>'SAME'</code>.  The padding algorithm.
    See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment
      here</a>
  name: A name for this operation (optional).</p>
<p>Returns:
  A 4-D <code>Tensor</code> of shape <code>[batch, out_height, out_width, out_channels]</code>.</p>
<p>Raises:
  ValueError: If channel_multiplier * in_channels &gt; out_channels,
    which means that the separable convolution is overparameterized.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.separable_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.separable_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sequence_mask">
    <p>def <span class="ident">sequence_mask</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sequence_mask(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sequence_mask</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sequence_mask(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sequence_mask(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sequence_mask</strong></p>
<div class="codehilite"><pre><span></span>Return a mask tensor representing the first N positions of each row.
</pre></div>


<p>Example:</p>
<p><code>python
tf.sequence_mask([1, 3, 2], 5) =
  [[True, False, False, False, False],
   [True, True, True, False, False],
   [True, True, False, False, False]]</code></p>
<p>Args:
  lengths: 1D integer tensor, all its values &lt; maxlen.
  maxlen: scalar integer tensor, maximum length of each row. Default: use
          maximum over lengths.
  dtype: output type of the resulting tensor.
  name: name of the op.
Returns:
  A 2D mask tensor, as shown in the example above, cast to specified dtype.</p>
<p>Raises:
  ValueError: if the arguments have invalid rank.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sequence_mask', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sequence_mask" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.serialize_many_sparse">
    <p>def <span class="ident">serialize_many_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.serialize_many_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.serialize_many_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.serialize_many_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.serialize_many_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.serialize_many_sparse</strong></p>
<div class="codehilite"><pre><span></span>Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`.
</pre></div>


<p>The <code>SparseTensor</code> must have rank <code>R</code> greater than 1, and the first dimension
is treated as the minibatch dimension.  Elements of the <code>SparseTensor</code>
must be sorted in increasing order of this first dimension.  The serialized
<code>SparseTensor</code> objects going into each row of the output <code>Tensor</code> will have
rank <code>R-1</code>.</p>
<p>The minibatch size <code>N</code> is extracted from <code>sparse_shape[0]</code>.</p>
<p>Args:
  sp_input: The input rank <code>R</code> <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A string matrix (2-D <code>Tensor</code>) with <code>N</code> rows and <code>3</code> columns.
  Each column represents serialized <code>SparseTensor</code>'s indices, values, and
  shape (respectively).</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.serialize_many_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.serialize_many_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.serialize_sparse">
    <p>def <span class="ident">serialize_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.serialize_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.serialize_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.serialize_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.serialize_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.serialize_sparse</strong></p>
<div class="codehilite"><pre><span></span>Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object.
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A string 3-vector (1D <code>Tensor</code>), with each column representing the
  serialized <code>SparseTensor</code>'s indices, values, and shape (respectively).</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.serialize_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.serialize_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.set_random_seed">
    <p>def <span class="ident">set_random_seed</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.set_random_seed(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.set_random_seed</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.set_random_seed(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.set_random_seed(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.set_random_seed</strong></p>
<div class="codehilite"><pre><span></span>Sets the graph-level random seed.
</pre></div>


<p>Operations that rely on a random seed actually derive it from two seeds:
the graph-level and operation-level seeds. This sets the graph-level seed.</p>
<p>Its interactions with operation-level seeds is as follows:</p>
<ol>
<li>If neither the graph-level nor the operation seed is set:
    A random seed is used for this op.</li>
<li>If the graph-level seed is set, but the operation seed is not:
    The system deterministically picks an operation seed in conjunction
    with the graph-level seed so that it gets a unique random sequence.</li>
<li>If the graph-level seed is not set, but the operation seed is set:
    A default graph-level seed and the specified operation seed are used to
    determine the random sequence.</li>
<li>If both the graph-level and the operation seed are set:
    Both seeds are used in conjunction to determine the random sequence.</li>
</ol>
<p>To illustrate the user-visible effects, consider these examples:</p>
<p>To generate different sequences across sessions, set neither
graph-level nor op-level seeds:</p>
<p>```python
a = tf.random_uniform([1])
b = tf.random_normal([1])</p>
<p>print("Session 1")
with tf.Session() as sess1:
  print(sess1.run(a))  # generates 'A1'
  print(sess1.run(a))  # generates 'A2'
  print(sess1.run(b))  # generates 'B1'
  print(sess1.run(b))  # generates 'B2'</p>
<p>print("Session 2")
with tf.Session() as sess2:
  print(sess2.run(a))  # generates 'A3'
  print(sess2.run(a))  # generates 'A4'
  print(sess2.run(b))  # generates 'B3'
  print(sess2.run(b))  # generates 'B4'
```</p>
<p>To generate the same repeatable sequence for an op across sessions, set the
seed for the op:</p>
<p>```python
a = tf.random_uniform([1], seed=1)
b = tf.random_normal([1])</p>
<h1>Repeatedly running this block with the same graph will generate the same</h1>
<h1>sequence of values for 'a', but different sequences of values for 'b'.</h1>
<p>print("Session 1")
with tf.Session() as sess1:
  print(sess1.run(a))  # generates 'A1'
  print(sess1.run(a))  # generates 'A2'
  print(sess1.run(b))  # generates 'B1'
  print(sess1.run(b))  # generates 'B2'</p>
<p>print("Session 2")
with tf.Session() as sess2:
  print(sess2.run(a))  # generates 'A1'
  print(sess2.run(a))  # generates 'A2'
  print(sess2.run(b))  # generates 'B3'
  print(sess2.run(b))  # generates 'B4'
```</p>
<p>To make the random sequences generated by all ops be repeatable across
sessions, set a graph-level seed:</p>
<p>```python
tf.set_random_seed(1234)
a = tf.random_uniform([1])
b = tf.random_normal([1])</p>
<h1>Repeatedly running this block with the same graph will generate different</h1>
<h1>sequences of 'a' and 'b'.</h1>
<p>print("Session 1")
with tf.Session() as sess1:
  print(sess1.run(a))  # generates 'A1'
  print(sess1.run(a))  # generates 'A2'
  print(sess1.run(b))  # generates 'B1'
  print(sess1.run(b))  # generates 'B2'</p>
<p>print("Session 2")
with tf.Session() as sess2:
  print(sess2.run(a))  # generates 'A1'
  print(sess2.run(a))  # generates 'A2'
  print(sess2.run(b))  # generates 'B1'
  print(sess2.run(b))  # generates 'B2'
```</p>
<p>Args:
  seed: integer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.set_random_seed', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.set_random_seed" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.setdiff1d">
    <p>def <span class="ident">setdiff1d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.setdiff1d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.setdiff1d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.setdiff1d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.setdiff1d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.setdiff1d</strong></p>
<div class="codehilite"><pre><span></span>Computes the difference between two lists of numbers or strings.
</pre></div>


<p>Given a list <code>x</code> and a list <code>y</code>, this operation returns a list <code>out</code> that
represents all values that are in <code>x</code> but not in <code>y</code>. The returned list <code>out</code>
is sorted in the same order that the numbers appear in <code>x</code> (duplicates are
preserved). This operation also returns a list <code>idx</code> that represents the
position of each <code>out</code> element in <code>x</code>. In other words:</p>
<p><code>out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]</code></p>
<p>For example, given this input:</p>
<p><code>prettyprint
x = [1, 2, 3, 4, 5, 6]
y = [1, 3, 5]</code></p>
<p>This operation would return:</p>
<p><code>prettyprint
out ==&gt; [2, 4, 6]
idx ==&gt; [1, 3, 5]</code></p>
<p>Args:
  x: A <code>Tensor</code>. 1-D. Values to keep.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>. 1-D. Values to remove.
  out_idx: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (out, idx).
  out: A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D. Values present in <code>x</code> but not in <code>y</code>.
  idx: A <code>Tensor</code> of type <code>out_idx</code>. 1-D. Positions of <code>x</code> values preserved in <code>out</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.setdiff1d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.setdiff1d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.shape">
    <p>def <span class="ident">shape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.shape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.shape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.shape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.shape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.shape</strong></p>
<div class="codehilite"><pre><span></span>Returns the shape of a tensor.
</pre></div>


<p>This operation returns a 1-D integer tensor representing the shape of <code>input</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1>
<p>shape(t) ==&gt; [2, 2, 3]
```</p>
<p>Args:
  input: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).
  out_type: (Optional) The specified output type of the operation
    (<code>int32</code> or <code>int64</code>). Defaults to <code>tf.int32</code>.</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.shape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.shape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.shape_n">
    <p>def <span class="ident">shape_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.shape_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.shape_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.shape_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.shape_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.shape_n</strong></p>
<div class="codehilite"><pre><span></span>Returns shape of tensors.
</pre></div>


<p>This operation returns N 1-D integer tensors representing shape of <code>input[i]s</code>.</p>
<p>Args:
  input: A list of at least 1 <code>Tensor</code> objects of the same type.
  out_type: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A list with the same number of <code>Tensor</code> objects as <code>input</code> of <code>Tensor</code> objects of type out_type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.shape_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.shape_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid">
    <p>def <span class="ident">sigmoid</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsigmoid</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsigmoid(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsigmoid</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid of `x` element-wise.
</pre></div>


<p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
<p>Args:
  x: A Tensor with type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>int64</code>,
    or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor with the same type as <code>x</code> if <code>x.dtype != qint32</code>
    otherwise the return type is <code>quint8</code>.</p>
<p>@compatibility(numpy)
Equivalent to np.scipy.special.expit
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer">
    <p>def <span class="ident">sigmoid_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sigmoid</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sigmoid(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sigmoid</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid of `x` element-wise.
</pre></div>


<p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
<p>Args:
  x: A Tensor with type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>int64</code>,
    or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor with the same type as <code>x</code> if <code>x.dtype != qint32</code>
    otherwise the return type is <code>quint8</code>.</p>
<p>@compatibility(numpy)
Equivalent to np.scipy.special.expit
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsigmoid_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsigmoid_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsigmoid_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid cross entropy given `logits`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which each
class is independent and not mutually exclusive.  For instance, one could
perform multilabel classification where a picture can contain both an elephant
and a dog at the same time.</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>.  The logistic loss is</p>
<div class="codehilite"><pre><span></span>  z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + log(1 + exp(-x))
= x - x * z + log(1 + exp(-x))
</pre></div>


<p>For x &lt; 0, to avoid overflow in exp(-x), we reformulate the above</p>
<div class="codehilite"><pre><span></span>  x - x * z + log(1 + exp(-x))
= log(exp(x)) - x * z + log(1 + exp(-x))
= - x * z + log(1 + exp(x))
</pre></div>


<p>Hence, to ensure stability and avoid overflow, the implementation uses this
equivalent formulation</p>
<div class="codehilite"><pre><span></span>max(x, 0) - x * z + log(1 + exp(-abs(x)))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sigmoid_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sigmoid_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sigmoid_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid cross entropy given `logits`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which each
class is independent and not mutually exclusive.  For instance, one could
perform multilabel classification where a picture can contain both an elephant
and a dog at the same time.</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>.  The logistic loss is</p>
<div class="codehilite"><pre><span></span>  z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + log(1 + exp(-x))
= x - x * z + log(1 + exp(-x))
</pre></div>


<p>For x &lt; 0, to avoid overflow in exp(-x), we reformulate the above</p>
<div class="codehilite"><pre><span></span>  x - x * z + log(1 + exp(-x))
= log(exp(x)) - x * z + log(1 + exp(-x))
= - x * z + log(1 + exp(x))
</pre></div>


<p>Hence, to ensure stability and avoid overflow, the implementation uses this
equivalent formulation</p>
<div class="codehilite"><pre><span></span>max(x, 0) - x * z + log(1 + exp(-abs(x)))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sigmoid_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sigmoid_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sigmoid_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sigmoid_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid cross entropy given `logits`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which each
class is independent and not mutually exclusive.  For instance, one could
perform multilabel classification where a picture can contain both an elephant
and a dog at the same time.</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>.  The logistic loss is</p>
<div class="codehilite"><pre><span></span>  z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + log(1 + exp(-x))
= x - x * z + log(1 + exp(-x))
</pre></div>


<p>For x &lt; 0, to avoid overflow in exp(-x), we reformulate the above</p>
<div class="codehilite"><pre><span></span>  x - x * z + log(1 + exp(-x))
= log(exp(x)) - x * z + log(1 + exp(-x))
= - x * z + log(1 + exp(x))
</pre></div>


<p>Hence, to ensure stability and avoid overflow, the implementation uses this
equivalent formulation</p>
<div class="codehilite"><pre><span></span>max(x, 0) - x * z + log(1 + exp(-abs(x)))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sigmoid_layer">
    <p>def <span class="ident">sigmoid_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sigmoid</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sigmoid(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sigmoid_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sigmoid`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sigmoid</strong></p>
<div class="codehilite"><pre><span></span>Computes sigmoid of `x` element-wise.
</pre></div>


<p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
<p>Args:
  x: A Tensor with type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>int64</code>,
    or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor with the same type as <code>x</code> if <code>x.dtype != qint32</code>
    otherwise the return type is <code>quint8</code>.</p>
<p>@compatibility(numpy)
Equivalent to np.scipy.special.expit
@end_compatibility</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sigmoid_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sigmoid_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sign">
    <p>def <span class="ident">sign</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sign(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sign(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sign</strong></p>
<div class="codehilite"><pre><span></span>Returns an element-wise indication of the sign of a number.
</pre></div>


<p><code>y = sign(x) = -1</code> if <code>x &lt; 0</code>; 0 if <code>x == 0</code>; 1 if <code>x &gt; 0</code>.</p>
<p>For complex numbers, <code>y = sign(x) = x / |x|</code> if <code>x != 0</code>, otherwise <code>y = 0</code>.</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sign', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sign" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sin">
    <p>def <span class="ident">sin</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sin(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sin</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sin(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sin(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sin</strong></p>
<div class="codehilite"><pre><span></span>Computes sin of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sin', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sin" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.size">
    <p>def <span class="ident">size</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.size(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.size</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.size(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.size(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.size</strong></p>
<div class="codehilite"><pre><span></span>Returns the size of a tensor.
</pre></div>


<p>This operation returns an integer representing the number of elements in
<code>input</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]</h1>
<p>size(t) ==&gt; 12
```</p>
<p>Args:
  input: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).
  out_type: (Optional) The specified output type of the operation
    (<code>int32</code> or <code>int64</code>). Defaults to tf.int32.</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>. Defaults to tf.int32.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.size', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.size" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.slice">
    <p>def <span class="ident">slice</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.slice(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.slice</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.slice(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.slice(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.slice</strong></p>
<div class="codehilite"><pre><span></span>Extracts a slice from a tensor.
</pre></div>


<p>This operation extracts a slice of size <code>size</code> from a tensor <code>input</code> starting
at the location specified by <code>begin</code>. The slice <code>size</code> is represented as a
tensor shape, where <code>size[i]</code> is the number of elements of the 'i'th dimension
of <code>input</code> that you want to slice. The starting location (<code>begin</code>) for the
slice is represented as an offset in each dimension of <code>input</code>. In other
words, <code>begin[i]</code> is the offset into the 'i'th dimension of <code>input</code> that you
want to slice from.</p>
<p><code>begin</code> is zero-based; <code>size</code> is one-based. If <code>size[i]</code> is -1,
all remaining elements in dimension i are included in the
slice. In other words, this is equivalent to setting:</p>
<p><code>size[i] = input.dim_size(i) - begin[i]</code></p>
<p>This operation requires that:</p>
<p><code>0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n]</code></p>
<p>For example:</p>
<p>```python</p>
<h1>'input' is [[[1, 1, 1], [2, 2, 2]],</h1>
<h1>[[3, 3, 3], [4, 4, 4]],</h1>
<h1>[[5, 5, 5], [6, 6, 6]]]</h1>
<p>tf.slice(input, [1, 0, 0], [1, 1, 3]) ==&gt; [[[3, 3, 3]]]
tf.slice(input, [1, 0, 0], [1, 2, 3]) ==&gt; [[[3, 3, 3],
                                            [4, 4, 4]]]
tf.slice(input, [1, 0, 0], [2, 1, 3]) ==&gt; [[[3, 3, 3]],
                                           [[5, 5, 5]]]
```</p>
<p>Args:
  input_: A <code>Tensor</code>.
  begin: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  size: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.slice', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.slice" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax">
    <p>def <span class="ident">softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsoftmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsoftmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsoftmax</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>softmax = exp(logits) / reduce_sum(exp(logits), dim)
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.
Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer">
    <p>def <span class="ident">softmax_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>softmax = exp(logits) / reduce_sum(exp(logits), dim)
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.
Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits">
    <p>def <span class="ident">softmax_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsoftmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsoftmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsoftmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  While the classes are mutually exclusive, their probabilities
need not be.  All that is required is that each row of <code>labels</code> is
a valid probability distribution.  If they are not, the computation of the
gradient will be incorrect.</p>
<p>If using exclusive <code>labels</code> (wherein one and only
one class is true at a time), see <code>sparse_softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a <code>softmax</code>
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p><code>logits</code> and <code>labels</code> must have the same shape <code>[batch_size, num_classes]</code>
and the same dtype (either <code>float16</code>, <code>float32</code>, or <code>float64</code>).</p>
<p>Args:
  logits: Unscaled log probabilities.
  labels: Each row <code>labels[i]</code> must be a valid probability distribution.
  dim: The class dimension. Defaulted to -1 which is the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A 1-D <code>Tensor</code> of length <code>batch_size</code> of the same type as <code>logits</code> with the
  softmax cross entropy loss.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">softmax_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  While the classes are mutually exclusive, their probabilities
need not be.  All that is required is that each row of <code>labels</code> is
a valid probability distribution.  If they are not, the computation of the
gradient will be incorrect.</p>
<p>If using exclusive <code>labels</code> (wherein one and only
one class is true at a time), see <code>sparse_softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a <code>softmax</code>
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p><code>logits</code> and <code>labels</code> must have the same shape <code>[batch_size, num_classes]</code>
and the same dtype (either <code>float16</code>, <code>float32</code>, or <code>float64</code>).</p>
<p>Args:
  logits: Unscaled log probabilities.
  labels: Each row <code>labels[i]</code> must be a valid probability distribution.
  dim: The class dimension. Defaulted to -1 which is the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A 1-D <code>Tensor</code> of length <code>batch_size</code> of the same type as <code>logits</code> with the
  softmax cross entropy loss.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">softmax_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  While the classes are mutually exclusive, their probabilities
need not be.  All that is required is that each row of <code>labels</code> is
a valid probability distribution.  If they are not, the computation of the
gradient will be incorrect.</p>
<p>If using exclusive <code>labels</code> (wherein one and only
one class is true at a time), see <code>sparse_softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a <code>softmax</code>
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p><code>logits</code> and <code>labels</code> must have the same shape <code>[batch_size, num_classes]</code>
and the same dtype (either <code>float16</code>, <code>float32</code>, or <code>float64</code>).</p>
<p>Args:
  logits: Unscaled log probabilities.
  labels: Each row <code>labels[i]</code> must be a valid probability distribution.
  dim: The class dimension. Defaulted to -1 which is the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A 1-D <code>Tensor</code> of length <code>batch_size</code> of the same type as <code>logits</code> with the
  softmax cross entropy loss.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softmax_layer">
    <p>def <span class="ident">softmax_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softmax_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softmax`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softmax</strong></p>
<div class="codehilite"><pre><span></span>Computes softmax activations.
</pre></div>


<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<div class="codehilite"><pre><span></span>softmax = exp(logits) / reduce_sum(exp(logits), dim)
</pre></div>


<p>Args:
  logits: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>.
  dim: The dimension softmax would be performed on. The default is -1 which
    indicates the last dimension.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.
Raises:
  InvalidArgumentError: if <code>logits</code> is empty or <code>dim</code> is beyond the last
    dimension of <code>logits</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softmax_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softmax_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softplus">
    <p>def <span class="ident">softplus</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softplus(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsoftplus</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsoftplus(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softplus(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsoftplus</strong></p>
<div class="codehilite"><pre><span></span>Computes softplus: `log(exp(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softplus', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softplus" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer">
    <p>def <span class="ident">softplus_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softplus_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softplus</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softplus(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softplus_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softplus`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softplus</strong></p>
<div class="codehilite"><pre><span></span>Computes softplus: `log(exp(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softplus_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softplus_layer">
    <p>def <span class="ident">softplus_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softplus_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softplus</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softplus(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softplus_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softplus`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softplus</strong></p>
<div class="codehilite"><pre><span></span>Computes softplus: `log(exp(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softplus_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softplus_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softsign">
    <p>def <span class="ident">softsign</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softsign(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsoftsign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsoftsign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softsign(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsoftsign</strong></p>
<div class="codehilite"><pre><span></span>Computes softsign: `features / (abs(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softsign', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softsign" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer">
    <p>def <span class="ident">softsign_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softsign_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softsign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softsign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softsign_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softsign`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softsign</strong></p>
<div class="codehilite"><pre><span></span>Computes softsign: `features / (abs(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softsign_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.softsign_layer">
    <p>def <span class="ident">softsign_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softsign_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.softsign</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.softsign(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.softsign_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.softsign`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.softsign</strong></p>
<div class="codehilite"><pre><span></span>Computes softsign: `features / (abs(features) + 1)`.
</pre></div>


<p>Args:
  features: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>features</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.softsign_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.softsign_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.space_to_batch">
    <p>def <span class="ident">space_to_batch</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.space_to_batch(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.space_to_batch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.space_to_batch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.space_to_batch(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.space_to_batch</strong></p>
<div class="codehilite"><pre><span></span>SpaceToBatch for 4-D tensors of type T.
</pre></div>


<p>This is a legacy version of the more general SpaceToBatchND.</p>
<p>Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
More specifically, this op outputs a copy of the input tensor where values from
the <code>height</code> and <code>width</code> dimensions are moved to the <code>batch</code> dimension. After
the zero-padding, both <code>height</code> and <code>width</code> of the input must be divisible by the
block size.</p>
<p>Args:
  input: A <code>Tensor</code>. 4-D with shape <code>[batch, height, width, depth]</code>.
  paddings: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
      the padding of the input with zeros across the spatial dimensions as follows:</p>
<div class="codehilite"><pre><span></span>      paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]

  The effective spatial dimensions of the zero-padded input tensor will be:

      height_pad = pad_top + height + pad_bottom
      width_pad = pad_left + width + pad_right

The attr `block_size` must be greater than one. It indicates the block size.

  * Non-overlapping blocks of size `block_size x block size` in the height and
    width dimensions are rearranged into the batch dimension at each location.
  * The batch of the output tensor is `batch * block_size * block_size`.
  * Both height_pad and width_pad must be divisible by block_size.

The shape of the output will be:

    [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
     depth]

Some examples:

(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:

```prettyprint
x = [[[[1], [2]], [[3], [4]]]]
```

The output tensor has shape `[4, 1, 1, 1]` and value:

```prettyprint
[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
```

(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

The output tensor has shape `[4, 1, 1, 3]` and value:

```prettyprint
[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
```

(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]],
      [[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[4, 2, 2, 1]` and value:

```prettyprint
x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
```

(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[8, 1, 2, 1]` and value:

```prettyprint
x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
```

Among others, this operation is useful for reducing atrous convolution into
regular convolution.
</pre></div>


<p>block_size: An <code>int</code> that is <code>&gt;= 2</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.space_to_batch', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.space_to_batch" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.space_to_batch_nd">
    <p>def <span class="ident">space_to_batch_nd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.space_to_batch_nd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.space_to_batch_nd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.space_to_batch_nd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.space_to_batch_nd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.space_to_batch_nd</strong></p>
<div class="codehilite"><pre><span></span>SpaceToBatch for N-D tensors of type T.
</pre></div>


<p>This operation divides "spatial" dimensions <code>[1, ..., M]</code> of the input into a
grid of blocks of shape <code>block_shape</code>, and interleaves these blocks with the
"batch" dimension (0) such that in the output, the spatial dimensions
<code>[1, ..., M]</code> correspond to the position within the grid, and the batch
dimension combines both the position within a spatial block and the original
batch position.  Prior to division into blocks, the spatial dimensions of the
input are optionally zero padded according to <code>paddings</code>.  See below for a
precise description.</p>
<p>Args:
  input: A <code>Tensor</code>.
    N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
    where spatial_shape has <code>M</code> dimensions.
  block_shape: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D with shape <code>[M]</code>, all values must be &gt;= 1.
  paddings: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.
      <code>paddings[i] = [pad_start, pad_end]</code> specifies the padding for input dimension
      <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is required that
      <code>block_shape[i]</code> divides <code>input_shape[i + 1] + pad_start + pad_end</code>.</p>
<div class="codehilite"><pre><span></span>This operation is equivalent to the following steps:

1. Zero-pad the start and end of dimensions `[1, ..., M]` of the
   input according to `paddings` to produce `padded` of shape `padded_shape`.

2. Reshape `padded` to `reshaped_padded` of shape:

     [batch] +
     [padded_shape[1] / block_shape[0],
       block_shape[0],
      ...,
      padded_shape[M] / block_shape[M-1],
      block_shape[M-1]] +
     remaining_shape

3. Permute dimensions of `reshaped_padded` to produce
   `permuted_reshaped_padded` of shape:

     block_shape +
     [batch] +
     [padded_shape[1] / block_shape[0],
      ...,
      padded_shape[M] / block_shape[M-1]] +
     remaining_shape

4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch
   dimension, producing an output tensor of shape:

     [batch * prod(block_shape)] +
     [padded_shape[1] / block_shape[0],
      ...,
      padded_shape[M] / block_shape[M-1]] +
     remaining_shape

Some examples:

(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1], [2]], [[3], [4]]]]
```

The output tensor has shape `[4, 1, 1, 1]` and value:

```prettyprint
[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
```

(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

The output tensor has shape `[4, 1, 1, 3]` and value:

```prettyprint
[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
```

(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]],
      [[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[4, 2, 2, 1]` and value:

```prettyprint
x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
```

(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and
    paddings = `[[0, 0], [2, 0]]`:

```prettyprint
x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
```

The output tensor has shape `[8, 1, 3, 1]` and value:

```prettyprint
x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
     [[[0], [2], [4]]], [[[0], [10], [12]]],
     [[[0], [5], [7]]], [[[0], [13], [15]]],
     [[[0], [6], [8]]], [[[0], [14], [16]]]]
```

Among others, this operation is useful for reducing atrous convolution into
regular convolution.
</pre></div>


<p>name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.space_to_batch_nd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.space_to_batch_nd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.space_to_depth">
    <p>def <span class="ident">space_to_depth</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.space_to_depth(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.space_to_depth</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.space_to_depth(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.space_to_depth(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.space_to_depth</strong></p>
<div class="codehilite"><pre><span></span>SpaceToDepth for tensors of type T.
</pre></div>


<p>Rearranges blocks of spatial data, into depth. More specifically,
this op outputs a copy of the input tensor where values from the <code>height</code>
and <code>width</code> dimensions are moved to the <code>depth</code> dimension.
The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>
<ul>
<li>Non-overlapping blocks of size <code>block_size x block size</code> are rearranged
    into depth at each location.</li>
<li>The depth of the output tensor is <code>input_depth * block_size * block_size</code>.</li>
<li>The input tensor's height and width must be divisible by block_size.</li>
</ul>
<p>That is, assuming the input is in the shape:
<code>[batch, height, width, depth]</code>,
the shape of the output will be:
<code>[batch, height/block_size, width/block_size, depth*block_size*block_size]</code></p>
<p>This operation requires that the input tensor be of rank 4, and that
<code>block_size</code> be &gt;=1 and a divisor of both the input <code>height</code> and <code>width</code>.</p>
<p>This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</p>
<p>For example, given this input of shape <code>[1, 2, 2, 1]</code>, and block_size of 2:</p>
<p><code>prettyprint
x = [[[[1], [2]],
      [[3], [4]]]]</code></p>
<p>This operation will output a tensor of shape <code>[1, 1, 1, 4]</code>:</p>
<p><code>prettyprint
[[[[1, 2, 3, 4]]]]</code></p>
<p>Here, the input has a batch of 1 and each batch element has shape <code>[2, 2, 1]</code>,
the corresponding output will have a single element (i.e. width and height are
both 1) and will have a depth of 4 channels (1 * block_size * block_size).
The output element shape is <code>[1, 1, 4]</code>.</p>
<p>For an input tensor with larger depth, here of shape <code>[1, 2, 2, 3]</code>, e.g.</p>
<p><code>prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]</code></p>
<p>This operation, for block_size of 2, will return the following tensor of shape
<code>[1, 1, 1, 12]</code></p>
<p><code>prettyprint
[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]</code></p>
<p>Similarly, for the following input of shape <code>[1 4 4 1]</code>, and a block size of 2:</p>
<p><code>prettyprint
x = [[[[1],   [2],  [5],  [6]],
      [[3],   [4],  [7],  [8]],
      [[9],  [10], [13],  [14]],
      [[11], [12], [15],  [16]]]]</code></p>
<p>the operator will return the following tensor of shape <code>[1 2 2 4]</code>:</p>
<p><code>prettyprint
x = [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]</code></p>
<p>Args:
  input: A <code>Tensor</code>.
  block_size: An <code>int</code> that is <code>&gt;= 2</code>. The size of the spatial block.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.space_to_depth', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.space_to_depth" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_add">
    <p>def <span class="ident">sparse_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_add</strong></p>
<div class="codehilite"><pre><span></span>Adds two tensors, at least one of each is a `SparseTensor`.
</pre></div>


<p>If one <code>SparseTensor</code> and one <code>Tensor</code> are passed in, returns a <code>Tensor</code>.  If
both arguments are <code>SparseTensor</code>s, this returns a <code>SparseTensor</code>.  The order
of arguments does not matter.  Use vanilla <code>tf.add()</code> for adding two dense
<code>Tensor</code>s.</p>
<p>The indices of any input <code>SparseTensor</code> are assumed ordered in standard
lexicographic order.  If this is not the case, before this step run
<code>SparseReorder</code> to restore index ordering.</p>
<p>If both arguments are sparse, we perform "clipping" as follows.  By default,
if two values sum to zero at some index, the output <code>SparseTensor</code> would still
include that particular location in its index, storing a zero in the
corresponding value slot.  To override this, callers can specify <code>thresh</code>,
indicating that if the sum has a magnitude strictly smaller than <code>thresh</code>, its
corresponding value and index would then not be included.  In particular,
<code>thresh == 0.0</code> (default) means everything is kept and actual thresholding
happens only for a positive value.</p>
<p>For example, suppose the logical sum of two sparse operands is (densified):</p>
<div class="codehilite"><pre><span></span><span class="k">[       2]</span>
<span class="k">[.1     0]</span>
<span class="k">[ 6   -.2]</span>
</pre></div>


<p>Then,</p>
<div class="codehilite"><pre><span></span>* `thresh == 0` (the default): all 5 index/value pairs will be returned.
* `thresh == 0.11`: only .1 and 0  will vanish, and the remaining three
    index/value pairs will be returned.
* `thresh == 0.21`: .1, 0, and -.2 will vanish.
</pre></div>


<p>Args:
  a: The first operand; <code>SparseTensor</code> or <code>Tensor</code>.
  b: The second operand; <code>SparseTensor</code> or <code>Tensor</code>.  At least one operand
    must be sparse.
  thresh: A 0-D <code>Tensor</code>.  The magnitude threshold that determines if an
  output value/index pair takes space.  Its dtype should match that of the
  values if they are real; if the latter are complex64/complex128, then the
  dtype should be float32/float64, correspondingly.</p>
<p>Returns:
  A <code>SparseTensor</code> or a <code>Tensor</code>, representing the sum.</p>
<p>Raises:
  TypeError: If both <code>a</code> and <code>b</code> are <code>Tensor</code>s.  Use <code>tf.add()</code> instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_concat">
    <p>def <span class="ident">sparse_concat</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_concat(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_concat</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_concat(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_concat(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_concat</strong></p>
<div class="codehilite"><pre><span></span>Concatenates a list of `SparseTensor` along the specified dimension.
</pre></div>


<p>Concatenation is with respect to the dense versions of each sparse input.
It is assumed that each inputs is a <code>SparseTensor</code> whose elements are ordered
along increasing dimension number.</p>
<p>If expand_nonconcat_dim is False, all inputs' shapes must match, except for
the concat dimension. If expand_nonconcat_dim is True, then inputs' shapes are
allowed to vary among all inputs.</p>
<p>The <code>indices</code>, <code>values</code>, and <code>shapes</code> lists must have the same length.</p>
<p>If expand_nonconcat_dim is False, then the output shape is identical to the
inputs', except along the concat dimension, where it is the sum of the inputs'
sizes along that dimension.</p>
<p>If expand_nonconcat_dim is True, then the output shape along the non-concat
dimensions will be expand to be the largest among all inputs, and it is the
sum of the inputs sizes along the concat dimension.</p>
<p>The output elements will be resorted to preserve the sort order along
increasing dimension number.</p>
<p>This op runs in <code>O(M log M)</code> time, where <code>M</code> is the total number of non-empty
values across all inputs. This is due to the need for an internal sort in
order to concatenate efficiently across an arbitrary dimension.</p>
<p>For example, if <code>concat_dim = 1</code> and the inputs are</p>
<div class="codehilite"><pre><span></span>sp_inputs[0]: shape = [2, 3]
[0, 2]: &quot;a&quot;
[1, 0]: &quot;b&quot;
[1, 1]: &quot;c&quot;

sp_inputs[1]: shape = [2, 4]
[0, 1]: &quot;d&quot;
[0, 2]: &quot;e&quot;
</pre></div>


<p>then the output will be</p>
<div class="codehilite"><pre><span></span>shape = [2, 7]
[0, 2]: &quot;a&quot;
[0, 4]: &quot;d&quot;
[0, 5]: &quot;e&quot;
[1, 0]: &quot;b&quot;
[1, 1]: &quot;c&quot;
</pre></div>


<p>Graphically this is equivalent to doing</p>
<div class="codehilite"><pre><span></span><span class="k">[    a] concat [  d e  ] = [    a   d e  ]</span>
<span class="k">[b c  ]        [       ]   [b c          ]</span>
</pre></div>


<p>Another example, if 'concat_dim = 1' and the inputs are</p>
<div class="codehilite"><pre><span></span>sp_inputs[0]: shape = [3, 3]
[0, 2]: &quot;a&quot;
[1, 0]: &quot;b&quot;
[2, 1]: &quot;c&quot;

sp_inputs[1]: shape = [2, 4]
[0, 1]: &quot;d&quot;
[0, 2]: &quot;e&quot;
</pre></div>


<p>if expand_nonconcat_dim = False, this will result in an error. But if
expand_nonconcat_dim = True, this will result in:</p>
<div class="codehilite"><pre><span></span>shape = [3, 7]
[0, 2]: &quot;a&quot;
[0, 4]: &quot;d&quot;
[0, 5]: &quot;e&quot;
[1, 0]: &quot;b&quot;
[2, 1]: &quot;c&quot;
</pre></div>


<p>Graphically this is equivalent to doing</p>
<div class="codehilite"><pre><span></span><span class="k">[    a] concat [  d e  ] = [    a   d e  ]</span>
<span class="k">[b    ]        [       ]   [b            ]</span>
<span class="k">[  c  ]                    [  c          ]</span>
</pre></div>


<p>Args:
  concat_dim: Dimension to concatenate along. Must be in range [-rank, rank),
    where rank is the number of dimensions in each input <code>SparseTensor</code>.
  sp_inputs: List of <code>SparseTensor</code> to concatenate.
  name: A name prefix for the returned tensors (optional).
  expand_nonconcat_dim: Whether to allow the expansion in the non-concat
    dimensions. Defaulted to False.</p>
<p>Returns:
  A <code>SparseTensor</code> with the concatenated output.</p>
<p>Raises:
  TypeError: If <code>sp_inputs</code> is not a list of <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_concat', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_concat" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows">
    <p>def <span class="ident">sparse_fill_empty_rows</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_fill_empty_rows(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_fill_empty_rows</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_fill_empty_rows(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_fill_empty_rows(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_fill_empty_rows</strong></p>
<div class="codehilite"><pre><span></span>Fills empty rows in the input 2-D `SparseTensor` with a default value.
</pre></div>


<p>This op adds entries with the specified <code>default_value</code> at index
<code>[row, 0]</code> for any row in the input that does not already have a value.</p>
<p>For example, suppose <code>sp_input</code> has shape <code>[5, 6]</code> and non-empty values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
</pre></div>


<p>Rows 1 and 4 are empty, so the output will be of shape <code>[5, 6]</code> with values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[1, 0]: default_value
[2, 0]: c
[3, 1]: d
[4, 0]: default_value
</pre></div>


<p>Note that the input may have empty columns at the end, with no effect on
this op.</p>
<p>The output <code>SparseTensor</code> will be in row-major order and will have the
same shape as the input.</p>
<p>This op also returns an indicator vector such that</p>
<div class="codehilite"><pre><span></span>empty_row_indicator[i] = True iff row i was an empty row.
</pre></div>


<p>Args:
  sp_input: A <code>SparseTensor</code> with shape <code>[N, M]</code>.
  default_value: The value to fill for empty rows, with the same type as
    <code>sp_input.</code>
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  sp_ordered_output: A <code>SparseTensor</code> with shape <code>[N, M]</code>, and with all empty
    rows filled in with <code>default_value</code>.
  empty_row_indicator: A bool vector of length <code>N</code> indicating whether each
    input row was empty.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_fill_empty_rows" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_mask">
    <p>def <span class="ident">sparse_mask</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_mask(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_mask</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_mask(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_mask(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_mask</strong></p>
<div class="codehilite"><pre><span></span>Masks elements of `IndexedSlices`.
</pre></div>


<p>Given an <code>IndexedSlices</code> instance <code>a</code>, returns another <code>IndexedSlices</code> that
contains a subset of the slices of <code>a</code>. Only the slices at indices not
specified in <code>mask_indices</code> are returned.</p>
<p>This is useful when you need to extract a subset of slices in an
<code>IndexedSlices</code> object.</p>
<p>For example:</p>
<p>```python</p>
<h1><code>a</code> contains slices at indices [12, 26, 37, 45] from a large tensor</h1>
<h1>with shape [1000, 10]</h1>
<p>a.indices =&gt; [12, 26, 37, 45]
tf.shape(a.values) =&gt; [4, 10]</p>
<h1><code>b</code> will be the subset of <code>a</code> slices at its second and third indices, so</h1>
<h1>we want to mask its first and last indices (which are at absolute</h1>
<h1>indices 12, 45)</h1>
<p>b = tf.sparse_mask(a, [12, 45])</p>
<p>b.indices =&gt; [26, 37]
tf.shape(b.values) =&gt; [2, 10]</p>
<p>```</p>
<p>Args:
  * <code>a</code>: An <code>IndexedSlices</code> instance.
  * <code>mask_indices</code>: Indices of elements to mask.
  * <code>name</code>: A name for the operation (optional).</p>
<p>Returns:
  The masked <code>IndexedSlices</code> instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_mask', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_mask" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_matmul">
    <p>def <span class="ident">sparse_matmul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_matmul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_matmul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_matmul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_matmul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_matmul</strong></p>
<div class="codehilite"><pre><span></span>Multiply matrix &quot;a&quot; by matrix &quot;b&quot;.
</pre></div>


<p>The inputs must be two-dimensional matrices and the inner dimension of "a" must
match the outer dimension of "b". This op is optimized for the case where at
least one of "a" or "b" is sparse. The breakeven for using this versus a dense
matrix multiply on one platform was 30% zero values in the sparse matrix.</p>
<p>Args:
  a: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>bfloat16</code>.
  b: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>bfloat16</code>.
  transpose_a: An optional <code>bool</code>. Defaults to <code>False</code>.
  transpose_b: An optional <code>bool</code>. Defaults to <code>False</code>.
  a_is_sparse: An optional <code>bool</code>. Defaults to <code>False</code>.
  b_is_sparse: An optional <code>bool</code>. Defaults to <code>False</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_matmul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_matmul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_maximum">
    <p>def <span class="ident">sparse_maximum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_maximum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_maximum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_maximum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_maximum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_maximum</strong></p>
<div class="codehilite"><pre><span></span>Returns the element-wise max of two SparseTensors.
</pre></div>


<p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
Example:</p>
<p>```python
sp_zero = sparse_tensor.SparseTensor([[0]], [0], [7])
sp_one = sparse_tensor.SparseTensor([[1]], [1], [7])
res = tf.sparse_maximum(sp_zero, sp_one).eval()</p>
<h1>"res" should be equal to SparseTensor([[0], [1]], [0, 1], [7]).</h1>
<p>```</p>
<p>Args:
  sp_a: a <code>SparseTensor</code> operand whose dtype is real, and indices
    lexicographically ordered.
  sp_b: the other <code>SparseTensor</code> operand with the same requirements (and the
    same shape).
  name: optional name of the operation.
Returns:
  output: the output SparseTensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_maximum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_maximum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_merge">
    <p>def <span class="ident">sparse_merge</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_merge(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_merge</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_merge(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_merge(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_merge</strong></p>
<div class="codehilite"><pre><span></span>Combines a batch of feature ids and values into a single `SparseTensor`.
</pre></div>


<p>The most common use case for this function occurs when feature ids and
their corresponding values are stored in <code>Example</code> protos on disk.
<code>parse_example</code> will return a batch of ids and a batch of values, and this
function joins them into a single logical <code>SparseTensor</code> for use in
functions such as <code>sparse_tensor_dense_matmul</code>, <code>sparse_to_dense</code>, etc.</p>
<p>The <code>SparseTensor</code> returned by this function has the following properties:</p>
<ul>
<li><code>indices</code> is equivalent to <code>sp_ids.indices</code> with the last
    dimension discarded and replaced with <code>sp_ids.values</code>.</li>
<li><code>values</code> is simply <code>sp_values.values</code>.</li>
<li>If <code>sp_ids.shape = [D0, D1, ..., Dn, K]</code>, then
    <code>output.shape = [D0, D1, ..., Dn, vocab_size]</code>.</li>
</ul>
<p>For example, consider the following feature vectors:</p>
<p><code>python
  vector1 = [-3, 0, 0, 0, 0, 0]
  vector2 = [ 0, 1, 0, 4, 1, 0]
  vector3 = [ 5, 0, 0, 9, 0, 0]</code></p>
<p>These might be stored sparsely in the following Example protos by storing
only the feature ids (column number if the vectors are treated as a matrix)
of the non-zero elements and the corresponding values:</p>
<p><code>python
  examples = [Example(features={
                  "ids": Feature(int64_list=Int64List(value=[0])),
                  "values": Feature(float_list=FloatList(value=[-3]))}),
              Example(features={
                  "ids": Feature(int64_list=Int64List(value=[1, 4, 3])),
                  "values": Feature(float_list=FloatList(value=[1, 1, 4]))}),
              Example(features={
                  "ids": Feature(int64_list=Int64List(value=[0, 3])),
                  "values": Feature(float_list=FloatList(value=[5, 9]))})]</code></p>
<p>The result of calling parse_example on these examples will produce a
dictionary with entries for "ids" and "values". Passing those two objects
to this function along with vocab_size=6, will produce a <code>SparseTensor</code> that
sparsely represents all three instances. Namely, the <code>indices</code> property will
contain the coordinates of the non-zero entries in the feature matrix (the
first dimension is the row number in the matrix, i.e., the index within the
batch, and the second dimension is the column number, i.e., the feature id);
<code>values</code> will contain the actual values. <code>shape</code> will be the shape of the
original matrix, i.e., (3, 6). For our example above, the output will be
equal to:</p>
<p><code>python
  SparseTensor(indices=[[0, 0], [1, 1], [1, 3], [1, 4], [2, 0], [2, 3]],
               values=[-3, 1, 4, 1, 5, 9],
               shape=[3, 6])</code></p>
<p>Args:
  sp_ids: A <code>SparseTensor</code> with <code>values</code> property of type <code>int32</code>
    or <code>int64</code>.
  sp_values: A<code>SparseTensor</code> of any type.
  vocab_size: A scalar <code>int64</code> Tensor (or Python int) containing the new size
    of the last dimension, <code>all(0 &lt;= sp_ids.values &lt; vocab_size)</code>.
  name: A name prefix for the returned tensors (optional)
  already_sorted: A boolean to specify whether the per-batch values in
   <code>sp_values</code> are already sorted. If so skip sorting, False by default
   (optional).</p>
<p>Returns:
  A <code>SparseTensor</code> compactly representing a batch of feature ids and values,
  useful for passing to functions that expect such a <code>SparseTensor</code>.</p>
<p>Raises:
  TypeError: If <code>sp_ids</code> or <code>sp_values</code> are not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_merge', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_merge" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_minimum">
    <p>def <span class="ident">sparse_minimum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_minimum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_minimum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_minimum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_minimum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_minimum</strong></p>
<div class="codehilite"><pre><span></span>Returns the element-wise min of two SparseTensors.
</pre></div>


<p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
Example:</p>
<p>```python
sp_zero = sparse_tensor.SparseTensor([[0]], [0], [7])
sp_one = sparse_tensor.SparseTensor([[1]], [1], [7])
res = tf.sparse_minimum(sp_zero, sp_one).eval()</p>
<h1>"res" should be equal to SparseTensor([[0], [1]], [0, 0], [7]).</h1>
<p>```</p>
<p>Args:
  sp_a: a <code>SparseTensor</code> operand whose dtype is real, and indices
    lexicographically ordered.
  sp_b: the other <code>SparseTensor</code> operand with the same requirements (and the
    same shape).
  name: optional name of the operation.
Returns:
  output: the output SparseTensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_minimum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_minimum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_placeholder">
    <p>def <span class="ident">sparse_placeholder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_placeholder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_placeholder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_placeholder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_placeholder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_placeholder</strong></p>
<div class="codehilite"><pre><span></span>Inserts a placeholder for a sparse tensor that will be always fed.
</pre></div>


<p><strong>Important</strong>: This sparse tensor will produce an error if evaluated.
Its value must be fed using the <code>feed_dict</code> optional argument to
<code>Session.run()</code>, <code>Tensor.eval()</code>, or <code>Operation.run()</code>.</p>
<p>For example:</p>
<p>```python
x = tf.sparse_placeholder(tf.float32)
y = tf.sparse_reduce_sum(x)</p>
<p>with tf.Session() as sess:
  print(sess.run(y))  # ERROR: will fail because x was not fed.</p>
<p>indices = np.array([[3, 2, 0], [4, 5, 1]], dtype=np.int64)
  values = np.array([1.0, 2.0], dtype=np.float32)
  shape = np.array([7, 9, 2], dtype=np.int64)
  print(sess.run(y, feed_dict={
    x: tf.SparseTensorValue(indices, values, shape)}))  # Will succeed.
  print(sess.run(y, feed_dict={
    x: (indices, values, shape)}))  # Will succeed.</p>
<p>sp = tf.SparseTensor(indices=indices, values=values, shape=shape)
  sp_value = sp.eval(session)
  print(sess.run(y, feed_dict={x: sp_value}))  # Will succeed.
```</p>
<p>Args:
  dtype: The type of <code>values</code> elements in the tensor to be fed.
  shape: The shape of the tensor to be fed (optional). If the shape is not
    specified, you can feed a sparse tensor of any shape.
  name: A name for prefixing the operations (optional).</p>
<p>Returns:
  A <code>SparseTensor</code> that may be used as a handle for feeding a value, but not
  evaluated directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_placeholder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_placeholder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reduce_sum">
    <p>def <span class="ident">sparse_reduce_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reduce_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reduce_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reduce_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reduce_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reduce_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum of elements across dimensions of a SparseTensor.
</pre></div>


<p>This Op takes a SparseTensor and is the sparse counterpart to
<code>tf.reduce_sum()</code>.  In particular, this Op also returns a dense <code>Tensor</code>
instead of a sparse one.</p>
<p>Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained
with length 1.</p>
<p>If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
similar to the indexing rules in Python.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' represents [[1, ?, 1]</h1>
<h1>[?, 1, ?]]</h1>
<h1>where ? is implicitly-zero.</h1>
<p>tf.sparse_reduce_sum(x) ==&gt; 3
tf.sparse_reduce_sum(x, 0) ==&gt; [1, 1, 1]
tf.sparse_reduce_sum(x, 1) ==&gt; [2, 1]  # Can also use -1 as the axis.
tf.sparse_reduce_sum(x, 1, keep_dims=True) ==&gt; [[2], [1]]
tf.sparse_reduce_sum(x, [0, 1]) ==&gt; 3
```</p>
<p>Args:
  sp_input: The SparseTensor to reduce. Should have numeric type.
  axis: The dimensions to reduce; list or scalar. If <code>None</code> (the
    default), reduces all dimensions.
  keep_dims: If true, retain reduced dimensions with length 1.
  reduction_axes: Deprecated name of axis.</p>
<p>Returns:
  The reduced Tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse">
    <p>def <span class="ident">sparse_reduce_sum_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reduce_sum_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reduce_sum_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reduce_sum_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reduce_sum_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reduce_sum_sparse</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum of elements across dimensions of a SparseTensor.
</pre></div>


<p>This Op takes a SparseTensor and is the sparse counterpart to
<code>tf.reduce_sum()</code>.  In contrast to SparseReduceSum, this Op returns a
SparseTensor.</p>
<p>Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained
with length 1.</p>
<p>If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
which are interpreted according to the indexing rules in Python.</p>
<p>Args:
  sp_input: The SparseTensor to reduce. Should have numeric type.
  axis: The dimensions to reduce; list or scalar. If <code>None</code> (the
    default), reduces all dimensions.
  keep_dims: If true, retain reduced dimensions with length 1.
  reduction_axes: Deprecated name of axis</p>
<p>Returns:
  The reduced SparseTensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reduce_sum_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reorder">
    <p>def <span class="ident">sparse_reorder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reorder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reorder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reorder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reorder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reorder</strong></p>
<div class="codehilite"><pre><span></span>Reorders a `SparseTensor` into the canonical, row-major ordering.
</pre></div>


<p>Note that by convention, all sparse ops preserve the canonical ordering
along increasing dimension number. The only time ordering can be violated
is during manual manipulation of the indices and values to add entries.</p>
<p>Reordering does not affect the shape of the <code>SparseTensor</code>.</p>
<p>For example, if <code>sp_input</code> has shape <code>[4, 5]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 3]: b
[0, 1]: a
[3, 1]: d
[2, 0]: c
</pre></div>


<p>then the output will be a <code>SparseTensor</code> of shape <code>[4, 5]</code> and
<code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A <code>SparseTensor</code> with the same shape and non-empty values, but in
  canonical ordering.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reorder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reorder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reset_shape">
    <p>def <span class="ident">sparse_reset_shape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reset_shape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reset_shape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reset_shape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reset_shape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reset_shape</strong></p>
<div class="codehilite"><pre><span></span>Resets the shape of a `SparseTensor` with indices and values unchanged.
</pre></div>


<p>If <code>new_shape</code> is None, returns a copy of <code>sp_input</code> with its shape reset
to the tight bounding box of <code>sp_input</code>.</p>
<p>If <code>new_shape</code> is provided, then it must be larger or equal in all dimensions
compared to the shape of <code>sp_input</code>. When this condition is met, the returned
SparseTensor will have its shape reset to <code>new_shape</code> and its indices and
values unchanged from that of <code>sp_input.</code></p>
<p>For example:</p>
<p>Consider a <code>sp_input</code> with shape [2, 3, 5]:</p>
<div class="codehilite"><pre><span></span>[0, 0, 1]: a
[0, 1, 0]: b
[0, 2, 2]: c
[1, 0, 3]: d
</pre></div>


<ul>
<li>
<p>It is an error to set <code>new_shape</code> as [3, 7] since this represents a
    rank-2 tensor while <code>sp_input</code> is rank-3. This is either a ValueError
    during graph construction (if both shapes are known) or an OpError during
    run time.</p>
</li>
<li>
<p>Setting <code>new_shape</code> as [2, 3, 6] will be fine as this shape is larger or
    equal in every dimension compared to the original shape [2, 3, 5].</p>
</li>
<li>
<p>On the other hand, setting new_shape as [2, 3, 4] is also an error: The
    third dimension is smaller than the original shape [2, 3, 5] (and an
    <code>InvalidArgumentError</code> will be raised).</p>
</li>
<li>
<p>If <code>new_shape</code> is None, the returned SparseTensor will have a shape
    [2, 3, 4], which is the tight bounding box of <code>sp_input</code>.</p>
</li>
</ul>
<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  new_shape: None or a vector representing the new shape for the returned
    <code>SparseTensor</code>.</p>
<p>Returns:
  A <code>SparseTensor</code> indices and values unchanged from <code>input_sp</code>. Its shape is
    <code>new_shape</code> if that is set. Otherwise it is  the tight bounding box of
     <code>input_sp</code></p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.
  ValueError: If <code>new_shape</code> represents a tensor with a different rank from
    that of <code>sp_input</code> (if shapes are known when graph is constructed).
  OpError:
    - If <code>new_shape</code> has dimension sizes that are too small.
    - If shapes are not known during graph construction time, and during run
      time it is found out that the ranks do not match.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reset_shape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reset_shape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_reshape">
    <p>def <span class="ident">sparse_reshape</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reshape(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_reshape</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_reshape(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_reshape(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_reshape</strong></p>
<div class="codehilite"><pre><span></span>Reshapes a `SparseTensor` to represent values in a new dense shape.
</pre></div>


<p>This operation has the same semantics as <code>reshape</code> on the represented dense
tensor.  The indices of non-empty values in <code>sp_input</code> are recomputed based
on the new dense shape, and a new <code>SparseTensor</code> is returned containing the
new indices and new shape.  The order of non-empty values in <code>sp_input</code> is
unchanged.</p>
<p>If one component of <code>shape</code> is the special value -1, the size of that
dimension is computed so that the total dense size remains constant.  At
most one component of <code>shape</code> can be -1.  The number of dense elements
implied by <code>shape</code> must be the same as the number of dense elements
originally represented by <code>sp_input</code>.</p>
<p>For example, if <code>sp_input</code> has shape <code>[2, 3, 6]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 0, 0]: a
[0, 0, 1]: b
[0, 1, 0]: c
[1, 0, 0]: d
[1, 2, 3]: e
</pre></div>


<p>and <code>shape</code> is <code>[9, -1]</code>, then the output will be a <code>SparseTensor</code> of
shape <code>[9, 4]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 0]: a
[0, 1]: b
[1, 2]: c
[4, 2]: d
[8, 1]: e
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  shape: A 1-D (vector) int64 <code>Tensor</code> specifying the new dense shape of the
    represented <code>SparseTensor</code>.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A <code>SparseTensor</code> with the same non-empty values but with indices calculated
  by the new dense shape.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_reshape', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_reshape" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_retain">
    <p>def <span class="ident">sparse_retain</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_retain(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_retain</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_retain(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_retain(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_retain</strong></p>
<div class="codehilite"><pre><span></span>Retains specified non-empty values within a `SparseTensor`.
</pre></div>


<p>For example, if <code>sp_input</code> has shape <code>[4, 5]</code> and 4 non-empty string values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
</pre></div>


<p>and <code>to_retain = [True, False, False, True]</code>, then the output will
be a <code>SparseTensor</code> of shape <code>[4, 5]</code> with 2 non-empty values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[3, 1]: d
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code> with <code>N</code> non-empty elements.
  to_retain: A bool vector of length <code>N</code> with <code>M</code> true values.</p>
<p>Returns:
  A <code>SparseTensor</code> with the same shape as the input and <code>M</code> non-empty
  elements corresponding to the true positions in <code>to_retain</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_retain', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_retain" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_segment_mean">
    <p>def <span class="ident">sparse_segment_mean</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_segment_mean(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_segment_mean</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_segment_mean(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_segment_mean(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_segment_mean</strong></p>
<div class="codehilite"><pre><span></span>Computes the mean along sparse segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Like <code>SegmentMean</code>, but <code>segment_ids</code> can have rank less than <code>data</code>'s first
dimension, selecting a subset of dimension 0, specified by <code>indices</code>.</p>
<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor. Has same rank as <code>segment_ids</code>.
  segment_ids: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D tensor. Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_segment_mean', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_segment_mean" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n">
    <p>def <span class="ident">sparse_segment_sqrt_n</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_segment_sqrt_n(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_segment_sqrt_n</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_segment_sqrt_n(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_segment_sqrt_n(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_segment_sqrt_n</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along sparse segments of a tensor divided by the sqrt of N.
</pre></div>


<p>N is the size of the segment being reduced.</p>
<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor. Has same rank as <code>segment_ids</code>.
  segment_ids: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D tensor. Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_segment_sqrt_n" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_segment_sum">
    <p>def <span class="ident">sparse_segment_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_segment_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_segment_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_segment_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_segment_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_segment_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along sparse segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Like <code>SegmentSum</code>, but <code>segment_ids</code> can have rank less than <code>data</code>'s first
dimension, selecting a subset of dimension 0, specified by <code>indices</code>.</p>
<p>For example:</p>
<p>```prettyprint
c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])</p>
<h1>Select two rows, one segment.</h1>
<p>tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
  ==&gt; [[0 0 0 0]]</p>
<h1>Select two rows, two segment.</h1>
<p>tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
  ==&gt; [[ 1  2  3  4]
       [-1 -2 -3 -4]]</p>
<h1>Select all rows, two segments.</h1>
<p>tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
  ==&gt; [[0 0 0 0]
       [5 6 7 8]]</p>
<h1>Which is equivalent to:</h1>
<p>tf.segment_sum(c, tf.constant([0, 0, 1]))
```</p>
<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.
  indices: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A 1-D tensor. Has same rank as <code>segment_ids</code>.
  segment_ids: A <code>Tensor</code> of type <code>int32</code>.
    A 1-D tensor. Values should be sorted and can be repeated.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for dimension 0 which
  has size <code>k</code>, the number of segments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_segment_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_segment_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax">
    <p>def <span class="ident">sparse_softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_softmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_softmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_softmax</strong></p>
<div class="codehilite"><pre><span></span>Applies softmax to a batched N-D `SparseTensor`.
</pre></div>


<p>The inputs represent an N-D SparseTensor  with logical shape <code>[..., B, C]</code>
(where <code>N &gt;= 2</code>), and with indices sorted in the canonical lexicographic
order.</p>
<p>This op is equivalent to applying the normal <code>tf.nn.softmax()</code> to each
innermost logical submatrix with shape <code>[B, C]</code>, but with the catch that <em>the
implicitly zero elements do not participate</em>.  Specifically, the algorithm is
equivalent to:</p>
<p>(1) Applies <code>tf.nn.softmax()</code> to a densified view of each innermost
      submatrix with shape <code>[B, C]</code>, along the size-C dimension;
  (2) Masks out the original implicitly-zero locations;
  (3) Renormalizes the remaining elements.</p>
<p>Hence, the <code>SparseTensor</code> result has exactly the same non-zero indices and
shape.</p>
<p>Example:</p>
<p>```python</p>
<h1>First batch:</h1>
<h1>[?   e.]</h1>
<h1>[1.  ? ]</h1>
<h1>Second batch:</h1>
<h1>[e   ? ]</h1>
<h1>[e   e ]</h1>
<p>shape = [2, 2, 2]  # 3-D SparseTensor
values = np.asarray([[[0., np.e], [1., 0.]], [[np.e, 0.], [np.e, np.e]]])
indices = np.vstack(np.where(values)).astype(np.int64).T</p>
<p>result = tf.sparse_softmax(tf.SparseTensor(indices, values, shape))</p>
<h1>...returning a 3-D SparseTensor, equivalent to:</h1>
<h1>[?   1.]     [1    ?]</h1>
<h1>[1.  ? ] and [.5  .5]</h1>
<h1>where ? means implicitly zero.</h1>
<p>```</p>
<p>Args:
  sp_input: N-D <code>SparseTensor</code>, where <code>N &gt;= 2</code>.
  name: optional name of the operation.
Returns:
  output: N-D <code>SparseTensor</code> representing the results.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsparse_softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsparse_softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsparse_softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sparse softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  For this operation, the probability of a given label is considered
exclusive.  That is, soft classes are not allowed, and the <code>labels</code> vector
must provide a single specific index for the true class for each row of
<code>logits</code> (each minibatch entry).  For soft softmax classification with
a probability distribution for each entry, see
<code>softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a softmax
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p>A common use case is to have logits of shape <code>[batch_size, num_classes]</code> and
labels of shape <code>[batch_size]</code>. But higher dimensions are supported.</p>
<p>Args:</p>
<p>logits: Unscaled log probabilities of rank <code>r</code> and shape
    <code>[d_0, d_1, ..., d_{r-2}, num_classes]</code> and dtype <code>float32</code> or <code>float64</code>.
  labels: <code>Tensor</code> of shape <code>[d_0, d_1, ..., d_{r-2}]</code> and dtype <code>int32</code> or
    <code>int64</code>. Each entry in <code>labels</code> must be an index in <code>[0, num_classes)</code>.
    Other values will raise an exception when this op is run on CPU, and
    return <code>NaN</code> for corresponding corresponding loss and gradient rows
    on GPU.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>labels</code> and of the same type as <code>logits</code>
  with the softmax cross entropy loss.</p>
<p>Raises:
  ValueError: If logits are scalars (need to have rank &gt;= 1) or if the rank
    of the labels is not equal to the rank of the labels minus one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sparse_softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sparse_softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sparse_softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sparse_softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sparse softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  For this operation, the probability of a given label is considered
exclusive.  That is, soft classes are not allowed, and the <code>labels</code> vector
must provide a single specific index for the true class for each row of
<code>logits</code> (each minibatch entry).  For soft softmax classification with
a probability distribution for each entry, see
<code>softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a softmax
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p>A common use case is to have logits of shape <code>[batch_size, num_classes]</code> and
labels of shape <code>[batch_size]</code>. But higher dimensions are supported.</p>
<p>Args:</p>
<p>logits: Unscaled log probabilities of rank <code>r</code> and shape
    <code>[d_0, d_1, ..., d_{r-2}, num_classes]</code> and dtype <code>float32</code> or <code>float64</code>.
  labels: <code>Tensor</code> of shape <code>[d_0, d_1, ..., d_{r-2}]</code> and dtype <code>int32</code> or
    <code>int64</code>. Each entry in <code>labels</code> must be an index in <code>[0, num_classes)</code>.
    Other values will raise an exception when this op is run on CPU, and
    return <code>NaN</code> for corresponding corresponding loss and gradient rows
    on GPU.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>labels</code> and of the same type as <code>logits</code>
  with the softmax cross entropy loss.</p>
<p>Raises:
  ValueError: If logits are scalars (need to have rank &gt;= 1) or if the rank
    of the labels is not equal to the rank of the labels minus one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer">
    <p>def <span class="ident">sparse_softmax_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sparse_softmax_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sparse_softmax_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sparse_softmax_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sparse_softmax_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes sparse softmax cross entropy between `logits` and `labels`.
</pre></div>


<p>Measures the probability error in discrete classification tasks in which the
classes are mutually exclusive (each entry is in exactly one class).  For
example, each CIFAR-10 image is labeled with one and only one label: an image
can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong>  For this operation, the probability of a given label is considered
exclusive.  That is, soft classes are not allowed, and the <code>labels</code> vector
must provide a single specific index for the true class for each row of
<code>logits</code> (each minibatch entry).  For soft softmax classification with
a probability distribution for each entry, see
<code>softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a softmax
on <code>logits</code> internally for efficiency.  Do not call this op with the
output of <code>softmax</code>, as it will produce incorrect results.</p>
<p>A common use case is to have logits of shape <code>[batch_size, num_classes]</code> and
labels of shape <code>[batch_size]</code>. But higher dimensions are supported.</p>
<p>Args:</p>
<p>logits: Unscaled log probabilities of rank <code>r</code> and shape
    <code>[d_0, d_1, ..., d_{r-2}, num_classes]</code> and dtype <code>float32</code> or <code>float64</code>.
  labels: <code>Tensor</code> of shape <code>[d_0, d_1, ..., d_{r-2}]</code> and dtype <code>int32</code> or
    <code>int64</code>. Each entry in <code>labels</code> must be an index in <code>[0, num_classes)</code>.
    Other values will raise an exception when this op is run on CPU, and
    return <code>NaN</code> for corresponding corresponding loss and gradient rows
    on GPU.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>labels</code> and of the same type as <code>logits</code>
  with the softmax cross entropy loss.</p>
<p>Raises:
  ValueError: If logits are scalars (need to have rank &gt;= 1) or if the rank
    of the labels is not equal to the rank of the labels minus one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_softmax_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_split">
    <p>def <span class="ident">sparse_split</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_split(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_split</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_split(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_split(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_split</strong></p>
<div class="codehilite"><pre><span></span>Split a `SparseTensor` into `num_split` tensors along `split_dim`.
</pre></div>


<p>If the <code>sp_input.shape[split_dim]</code> is not an integer multiple of <code>num_split</code>
each slice starting from 0:<code>shape[split_dim] % num_split</code> gets extra one
dimension. For example, if <code>split_dim = 1</code> and <code>num_split = 2</code> and the
input is:</p>
<div class="codehilite"><pre><span></span>input_tensor = shape = [2, 7]
[    a   d e  ]
[b c          ]
</pre></div>


<p>Graphically the output tensors are:</p>
<div class="codehilite"><pre><span></span>output_tensor[0] =
[    a ]
[b c   ]

output_tensor[1] =
[ d e  ]
[      ]
</pre></div>


<p>Args:
  split_dim: A 0-D <code>int32</code> <code>Tensor</code>. The dimension along which to split.
  num_split: A Python integer. The number of ways to split.
  sp_input: The <code>SparseTensor</code> to split.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>num_split</code> <code>SparseTensor</code> objects resulting from splitting <code>value</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_split', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_split" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul">
    <p>def <span class="ident">sparse_tensor_dense_matmul</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_tensor_dense_matmul(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_tensor_dense_matmul</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_tensor_dense_matmul(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_tensor_dense_matmul(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_tensor_dense_matmul</strong></p>
<div class="codehilite"><pre><span></span>Multiply SparseTensor (of rank 2) &quot;A&quot; by dense matrix &quot;B&quot;.
</pre></div>


<p>No validity checking is performed on the indices of A.  However, the following
input format is recommended for optimal behavior:</p>
<p>if adjoint_a == false:
  A should be sorted in lexicographically increasing order.  Use
  sparse_reorder if you're not sure.
if adjoint_a == true:
  A should be sorted in order of increasing dimension 1 (i.e., "column major"
  order instead of "row major" order).</p>
<p>Deciding when to use sparse_tensor_dense_matmul vs. matmul(sp_a=True):</p>
<p>There are a number of questions to ask in the decision process, including:</p>
<ul>
<li>Will the SparseTensor A fit in memory if densified?</li>
<li>Is the column count of the product large (&gt;&gt; 1)?</li>
<li>Is the density of A larger than approximately 15%?</li>
</ul>
<p>If the answer to several of these questions is yes, consider
converting the <code>SparseTensor</code> to a dense one and using <code>tf.matmul</code> with
<code>sp_a=True</code>.</p>
<p>This operation tends to perform well when A is more sparse, if the column size
of the product is small (e.g. matrix-vector multiplication), if sp_a.shape
takes on large values.</p>
<p>Below is a rough speed comparison between sparse_tensor_dense_matmul,
labelled 'sparse', and matmul(sp_a=True), labelled 'dense'.  For purposes of
the comparison, the time spent converting from a SparseTensor to a dense
Tensor is not included, so it is overly conservative with respect to
the time ratio.</p>
<p>Benchmark system:
CPU: Intel Ivybridge with HyperThreading (6 cores) dL1:32KB dL2:256KB dL3:12MB
GPU: NVidia Tesla k40c</p>
<p>Compiled with:
-c opt --config=cuda --copt=-mavx</p>
<p>```tensorflow/python/sparse_tensor_dense_matmul_op_test --benchmarks
A sparse [m, k] with % nonzero values between 1% and 80%
B dense [k, n]</p>
<p>% nnz  n   gpu   m     k     dt(dense)     dt(sparse)   dt(sparse)/dt(dense)
0.01   1   True  100   100   0.000221166   0.00010154   0.459112
0.01   1   True  100   1000  0.00033858    0.000109275  0.322745
0.01   1   True  1000  100   0.000310557   9.85661e-05  0.317385
0.01   1   True  1000  1000  0.0008721     0.000100875  0.115669
0.01   1   False 100   100   0.000208085   0.000107603  0.51711
0.01   1   False 100   1000  0.000327112   9.51118e-05  0.290762
0.01   1   False 1000  100   0.000308222   0.00010345   0.335635
0.01   1   False 1000  1000  0.000865721   0.000101397  0.117124
0.01   10  True  100   100   0.000218522   0.000105537  0.482958
0.01   10  True  100   1000  0.000340882   0.000111641  0.327506
0.01   10  True  1000  100   0.000315472   0.000117376  0.372064
0.01   10  True  1000  1000  0.000905493   0.000123263  0.136128
0.01   10  False 100   100   0.000221529   9.82571e-05  0.44354
0.01   10  False 100   1000  0.000330552   0.000112615  0.340687
0.01   10  False 1000  100   0.000341277   0.000114097  0.334324
0.01   10  False 1000  1000  0.000819944   0.000120982  0.147549
0.01   25  True  100   100   0.000207806   0.000105977  0.509981
0.01   25  True  100   1000  0.000322879   0.00012921   0.400181
0.01   25  True  1000  100   0.00038262    0.00014158   0.370035
0.01   25  True  1000  1000  0.000865438   0.000202083  0.233504
0.01   25  False 100   100   0.000209401   0.000104696  0.499979
0.01   25  False 100   1000  0.000321161   0.000130737  0.407076
0.01   25  False 1000  100   0.000377012   0.000136801  0.362856
0.01   25  False 1000  1000  0.000861125   0.00020272   0.235413
0.2    1   True  100   100   0.000206952   9.69219e-05  0.46833
0.2    1   True  100   1000  0.000348674   0.000147475  0.422959
0.2    1   True  1000  100   0.000336908   0.00010122   0.300439
0.2    1   True  1000  1000  0.001022      0.000203274  0.198898
0.2    1   False 100   100   0.000207532   9.5412e-05   0.459746
0.2    1   False 100   1000  0.000356127   0.000146824  0.41228
0.2    1   False 1000  100   0.000322664   0.000100918  0.312764
0.2    1   False 1000  1000  0.000998987   0.000203442  0.203648
0.2    10  True  100   100   0.000211692   0.000109903  0.519165
0.2    10  True  100   1000  0.000372819   0.000164321  0.440753
0.2    10  True  1000  100   0.000338651   0.000144806  0.427596
0.2    10  True  1000  1000  0.00108312    0.000758876  0.70064
0.2    10  False 100   100   0.000215727   0.000110502  0.512231
0.2    10  False 100   1000  0.000375419   0.0001613    0.429653
0.2    10  False 1000  100   0.000336999   0.000145628  0.432132
0.2    10  False 1000  1000  0.00110502    0.000762043  0.689618
0.2    25  True  100   100   0.000218705   0.000129913  0.594009
0.2    25  True  100   1000  0.000394794   0.00029428   0.745402
0.2    25  True  1000  100   0.000404483   0.0002693    0.665788
0.2    25  True  1000  1000  0.0012002     0.00194494   1.62052
0.2    25  False 100   100   0.000221494   0.0001306    0.589632
0.2    25  False 100   1000  0.000396436   0.000297204  0.74969
0.2    25  False 1000  100   0.000409346   0.000270068  0.659754
0.2    25  False 1000  1000  0.00121051    0.00193737   1.60046
0.5    1   True  100   100   0.000214981   9.82111e-05  0.456836
0.5    1   True  100   1000  0.000415328   0.000223073  0.537101
0.5    1   True  1000  100   0.000358324   0.00011269   0.314492
0.5    1   True  1000  1000  0.00137612    0.000437401  0.317851
0.5    1   False 100   100   0.000224196   0.000101423  0.452386
0.5    1   False 100   1000  0.000400987   0.000223286  0.556841
0.5    1   False 1000  100   0.000368825   0.00011224   0.304318
0.5    1   False 1000  1000  0.00136036    0.000429369  0.31563
0.5    10  True  100   100   0.000222125   0.000112308  0.505608
0.5    10  True  100   1000  0.000461088   0.00032357   0.701753
0.5    10  True  1000  100   0.000394624   0.000225497  0.571422
0.5    10  True  1000  1000  0.00158027    0.00190898   1.20801
0.5    10  False 100   100   0.000232083   0.000114978  0.495418
0.5    10  False 100   1000  0.000454574   0.000324632  0.714146
0.5    10  False 1000  100   0.000379097   0.000227768  0.600817
0.5    10  False 1000  1000  0.00160292    0.00190168   1.18638
0.5    25  True  100   100   0.00023429    0.000151703  0.647501
0.5    25  True  100   1000  0.000497462   0.000598873  1.20386
0.5    25  True  1000  100   0.000460778   0.000557038  1.20891
0.5    25  True  1000  1000  0.00170036    0.00467336   2.74845
0.5    25  False 100   100   0.000228981   0.000155334  0.678371
0.5    25  False 100   1000  0.000496139   0.000620789  1.25124
0.5    25  False 1000  100   0.00045473    0.000551528  1.21287
0.5    25  False 1000  1000  0.00171793    0.00467152   2.71927
0.8    1   True  100   100   0.000222037   0.000105301  0.47425
0.8    1   True  100   1000  0.000410804   0.000329327  0.801664
0.8    1   True  1000  100   0.000349735   0.000131225  0.375212
0.8    1   True  1000  1000  0.00139219    0.000677065  0.48633
0.8    1   False 100   100   0.000214079   0.000107486  0.502085
0.8    1   False 100   1000  0.000413746   0.000323244  0.781261
0.8    1   False 1000  100   0.000348983   0.000131983  0.378193
0.8    1   False 1000  1000  0.00136296    0.000685325  0.50282
0.8    10  True  100   100   0.000229159   0.00011825   0.516017
0.8    10  True  100   1000  0.000498845   0.000532618  1.0677
0.8    10  True  1000  100   0.000383126   0.00029935   0.781336
0.8    10  True  1000  1000  0.00162866    0.00307312   1.88689
0.8    10  False 100   100   0.000230783   0.000124958  0.541452
0.8    10  False 100   1000  0.000493393   0.000550654  1.11606
0.8    10  False 1000  100   0.000377167   0.000298581  0.791642
0.8    10  False 1000  1000  0.00165795    0.00305103   1.84024
0.8    25  True  100   100   0.000233496   0.000175241  0.75051
0.8    25  True  100   1000  0.00055654    0.00102658   1.84458
0.8    25  True  1000  100   0.000463814   0.000783267  1.68875
0.8    25  True  1000  1000  0.00186905    0.00755344   4.04132
0.8    25  False 100   100   0.000240243   0.000175047  0.728625
0.8    25  False 100   1000  0.000578102   0.00104499   1.80763
0.8    25  False 1000  100   0.000485113   0.000776849  1.60138
0.8    25  False 1000  1000  0.00211448    0.00752736   3.55992
```</p>
<p>Args:
  sp_a: SparseTensor A, of rank 2.
  b: A dense Matrix with the same dtype as sp_a.
  adjoint_a: Use the adjoint of A in the matrix multiply.  If A is complex,
    this is transpose(conj(A)).  Otherwise it's transpose(A).
  adjoint_b: Use the adjoint of B in the matrix multiply.  If B is complex,
    this is transpose(conj(B)).  Otherwise it's transpose(B).
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A dense matrix (pseudo-code in dense np.matrix notation):
    A = A.H if adjoint_a else A
    B = B.H if adjoint_b else B
    return A*B</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_tensor_dense_matmul" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense">
    <p>def <span class="ident">sparse_tensor_to_dense</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_tensor_to_dense(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_tensor_to_dense</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_tensor_to_dense(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_tensor_to_dense(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_tensor_to_dense</strong></p>
<div class="codehilite"><pre><span></span>Converts a `SparseTensor` into a dense tensor.
</pre></div>


<p>This op is a convenience wrapper around <code>sparse_to_dense</code> for <code>SparseTensor</code>s.</p>
<p>For example, if <code>sp_input</code> has shape <code>[3, 5]</code> and non-empty string values:</p>
<div class="codehilite"><pre><span></span>[0, 1]: a
[0, 3]: b
[2, 0]: c
</pre></div>


<p>and <code>default_value</code> is <code>x</code>, then the output will be a dense <code>[3, 5]</code>
string tensor with values:</p>
<div class="codehilite"><pre><span></span><span class="k">[[x a x b x]</span>
 <span class="k">[x x x x x]</span>
 <span class="k">[c x x x x]]</span>
</pre></div>


<p>Indices must be without repeats.  This is only
tested if validate_indices is True.</p>
<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  default_value: Scalar value to set for indices not specified in
    <code>sp_input</code>.  Defaults to zero.
  validate_indices: A boolean value.  If <code>True</code>, indices are checked to make
    sure they are sorted in lexicographic order and that there are no repeats.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A dense tensor with shape <code>sp_input.shape</code> and values specified by
  the non-empty values in <code>sp_input</code>. Indices not in <code>sp_input</code> are assigned
  <code>default_value</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_tensor_to_dense" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_to_dense">
    <p>def <span class="ident">sparse_to_dense</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_to_dense(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_to_dense</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_to_dense(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_to_dense(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_to_dense</strong></p>
<div class="codehilite"><pre><span></span>Converts a sparse representation into a dense tensor.
</pre></div>


<p>Builds an array <code>dense</code> with shape <code>output_shape</code> such that</p>
<p>```python</p>
<h1>If sparse_indices is scalar</h1>
<p>dense[i] = (i == sparse_indices ? sparse_values : default_value)</p>
<h1>If sparse_indices is a vector, then for each i</h1>
<p>dense[sparse_indices[i]] = sparse_values[i]</p>
<h1>If sparse_indices is an n by d matrix, then for each i in [0, n)</h1>
<p>dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
```</p>
<p>All other values in <code>dense</code> are set to <code>default_value</code>.  If <code>sparse_values</code>
is a scalar, all sparse indices are set to this single value.</p>
<p>Indices should be sorted in lexicographic order, and indices must not
contain any repeats. If <code>validate_indices</code> is True, these properties
are checked during execution.</p>
<p>Args:
  sparse_indices: A 0-D, 1-D, or 2-D <code>Tensor</code> of type <code>int32</code> or <code>int64</code>.
    <code>sparse_indices[i]</code> contains the complete index where <code>sparse_values[i]</code>
    will be placed.
  output_shape: A 1-D <code>Tensor</code> of the same type as <code>sparse_indices</code>.  Shape
    of the dense output tensor.
  sparse_values: A 0-D or 1-D <code>Tensor</code>.  Values corresponding to each row of
    <code>sparse_indices</code>, or a scalar value to be used for all sparse indices.
  default_value: A 0-D <code>Tensor</code> of the same type as <code>sparse_values</code>.  Value
    to set for indices not specified in <code>sparse_indices</code>.  Defaults to zero.
  validate_indices: A boolean value.  If True, indices are checked to make
    sure they are sorted in lexicographic order and that there are no repeats.
  name: A name for the operation (optional).</p>
<p>Returns:
  Dense <code>Tensor</code> of shape <code>output_shape</code>.  Has the same type as
  <code>sparse_values</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_to_dense', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_to_dense" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_to_indicator">
    <p>def <span class="ident">sparse_to_indicator</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_to_indicator(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_to_indicator</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_to_indicator(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_to_indicator(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_to_indicator</strong></p>
<div class="codehilite"><pre><span></span>Converts a `SparseTensor` of ids into a dense bool indicator tensor.
</pre></div>


<p>The last dimension of <code>sp_input.indices</code> is discarded and replaced with
the values of <code>sp_input</code>.  If <code>sp_input.shape = [D0, D1, ..., Dn, K]</code>, then
<code>output.shape = [D0, D1, ..., Dn, vocab_size]</code>, where</p>
<div class="codehilite"><pre><span></span>output[d_0, d_1, ..., d_n, sp_input[d_0, d_1, ..., d_n, k]] = True
</pre></div>


<p>and False elsewhere in <code>output</code>.</p>
<p>For example, if <code>sp_input.shape = [2, 3, 4]</code> with non-empty values:</p>
<div class="codehilite"><pre><span></span>[0, 0, 0]: 0
[0, 1, 0]: 10
[1, 0, 3]: 103
[1, 1, 2]: 150
[1, 1, 3]: 149
[1, 1, 4]: 150
[1, 2, 1]: 121
</pre></div>


<p>and <code>vocab_size = 200</code>, then the output will be a <code>[2, 3, 200]</code> dense bool
tensor with False everywhere except at positions</p>
<div class="codehilite"><pre><span></span>(0, 0, 0), (0, 1, 10), (1, 0, 103), (1, 1, 149), (1, 1, 150),
(1, 2, 121).
</pre></div>


<p>Note that repeats are allowed in the input SparseTensor.
This op is useful for converting <code>SparseTensor</code>s into dense formats for
compatibility with ops that expect dense tensors.</p>
<p>The input <code>SparseTensor</code> must be in row-major order.</p>
<p>Args:
  sp_input: A <code>SparseTensor</code> with <code>values</code> property of type <code>int32</code> or
    <code>int64</code>.
  vocab_size: A scalar int64 Tensor (or Python int) containing the new size
    of the last dimension, <code>all(0 &lt;= sp_input.values &lt; vocab_size)</code>.
  name: A name prefix for the returned tensors (optional)</p>
<p>Returns:
  A dense bool indicator tensor representing the indices with specified value.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_to_indicator', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_to_indicator" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sparse_transpose">
    <p>def <span class="ident">sparse_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sparse_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sparse_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sparse_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sparse_transpose</strong></p>
<div class="codehilite"><pre><span></span>Transposes a `SparseTensor`
</pre></div>


<p>The returned tensor's dimension i will correspond to the input dimension
<code>perm[i]</code>. If <code>perm</code> is not given, it is set to (n-1...0), where n is
the rank of the input tensor. Hence by default, this operation performs a
regular matrix transpose on 2-D input Tensors.</p>
<p>For example, if <code>sp_input</code> has shape <code>[4, 5]</code> and <code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 3]: b
[0, 1]: a
[3, 1]: d
[2, 0]: c
</pre></div>


<p>then the output will be a <code>SparseTensor</code> of shape <code>[5, 4]</code> and
<code>indices</code> / <code>values</code>:</p>
<div class="codehilite"><pre><span></span>[0, 2]: c
[1, 0]: a
[1, 3]: d
[3, 0]: b
</pre></div>


<p>Args:
  sp_input: The input <code>SparseTensor</code>.
  perm: A permutation of the dimensions of <code>sp_input</code>.
  name: A name prefix for the returned tensors (optional)
Returns:
  A transposed <code>SparseTensor</code>.</p>
<p>Raises:
  TypeError: If <code>sp_input</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sparse_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sparse_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.split">
    <p>def <span class="ident">split</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.split(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.split</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.split(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.split(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.split</strong></p>
<div class="codehilite"><pre><span></span>Splits a tensor into `num_split` tensors along one dimension.
</pre></div>


<p>Splits <code>value</code> along dimension <code>split_dim</code> into <code>num_split</code> smaller tensors.
Requires that <code>num_split</code> evenly divide <code>value.shape[split_dim]</code>.</p>
<p>For example:</p>
<p>```python</p>
<h1>'value' is a tensor with shape [5, 30]</h1>
<h1>Split 'value' into 3 tensors along dimension 1</h1>
<p>split0, split1, split2 = tf.split(1, 3, value)
tf.shape(split0) ==&gt; [5, 10]
```</p>
<p>Note: If you are splitting along an axis by the length of that axis, consider
using unpack, e.g.</p>
<p><code>python
num_items = t.get_shape()[axis].value
[tf.squeeze(s, [axis]) for s in tf.split(axis, num_items, t)]</code></p>
<p>can be rewritten as</p>
<p><code>python
tf.unpack(t, axis=axis)</code></p>
<p>Args:
  split_dim: A 0-D <code>int32</code> <code>Tensor</code>. The dimension along which to split.
    Must be in the range <code>[0, rank(value))</code>.
  num_split: A Python integer. The number of ways to split.
  value: The <code>Tensor</code> to split.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>num_split</code> <code>Tensor</code> objects resulting from splitting <code>value</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.split', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.split" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.split_v">
    <p>def <span class="ident">split_v</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.split_v(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.split_v</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.split_v(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.split_v(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.split_v</strong></p>
<div class="codehilite"><pre><span></span>Splits a tensor into sub tensors.
</pre></div>


<p>If size_splits is a scalar, <code>num_split</code>, then
splits <code>value</code> along dimension <code>split_dim</code> into <code>num_split</code> smaller tensors.
Requires that <code>num_split</code> evenly divide <code>value.shape[split_dim]</code>.</p>
<p>If size_splits is a tensor, then
splits <code>value</code> into len(size_splits) pieces each the same size as the input
except along dimension split_dim where the size is size_splits[i].</p>
<p>For example:</p>
<p>```python</p>
<h1>'value' is a tensor with shape [5, 30]</h1>
<h1>Split 'value' into 3 tensors with sizes [4, 15, 11] along dimension 1</h1>
<p>split0, split1, split2 = tf.split_v(1, [4, 15, 11], value)
tf.shape(split0) ==&gt; [5, 4]
tf.shape(split1) ==&gt; [5, 15]
tf.shape(split2) ==&gt; [5, 11]</p>
<h1>Split 'value' into 3 tensors along dimension 1</h1>
<p>split0, split1, split2 = tf.split(value, 3, 1)
tf.shape(split0) ==&gt; [5, 10]
```</p>
<p>Args:
  value: The <code>Tensor</code> to split.
  size_splits: Either an integer indicating the number of splits along
    split_dim or a 1-D Tensor containing the sizes of each output tensor
    along split_dim. If an integer then it must evenly divide
    value.shape[split_dim]; otherwise the sum of sizes along the split
    dimension must match that of the input.
  split_dim: A 0-D <code>int32</code> <code>Tensor</code>. The dimension along which to split.
    Must be in the range <code>[0, rank(value))</code>. Defaults to 0.
  num: Optional, used to specify the number of outputs when it cannot be
       inferred from the shape of size_splits.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>len(size_splits)</code> <code>Tensor</code> objects resulting from splitting <code>value</code>.</p>
<p>Raises:
  ValueError: If <code>num</code> is unspecified and cannot be inferred.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.split_v', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.split_v" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sqrt">
    <p>def <span class="ident">sqrt</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sqrt(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sqrt</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sqrt(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sqrt(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sqrt</strong></p>
<div class="codehilite"><pre><span></span>Computes square root of x element-wise.
</pre></div>


<p>I.e., (y = \sqrt{x} = x^{1/2}).</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>, respectively. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sqrt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sqrt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.square">
    <p>def <span class="ident">square</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.square(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.square</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.square(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.square(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.square</strong></p>
<div class="codehilite"><pre><span></span>Computes square of x element-wise.
</pre></div>


<p>I.e., (y = x * x = x^2).</p>
<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>. Must be one of the following types: <code>half</code>,
    <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.square', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.square" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.squared_difference">
    <p>def <span class="ident">squared_difference</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.squared_difference(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.squared_difference</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.squared_difference(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.squared_difference(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.squared_difference</strong></p>
<div class="codehilite"><pre><span></span>Returns (x - y)(x - y) element-wise.
</pre></div>


<p><em>NOTE</em>: <code>SquaredDifference</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.squared_difference', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.squared_difference" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.squeeze">
    <p>def <span class="ident">squeeze</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.squeeze(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.squeeze</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.squeeze(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.squeeze(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.squeeze</strong></p>
<div class="codehilite"><pre><span></span>Removes dimensions of size 1 from the shape of a tensor.
</pre></div>


<p>Given a tensor <code>input</code>, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don't want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
<code>axis</code>.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1>
<p>shape(squeeze(t)) ==&gt; [2, 3]
          ```</p>
<p>Or, to remove specific size 1 dimensions:</p>
<p>```prettyprint</p>
<h1>'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1>
<p>shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1]
```</p>
<p>Args:
  input: A <code>Tensor</code>. The <code>input</code> to squeeze.
  axis: An optional list of <code>ints</code>. Defaults to <code>[]</code>.
    If specified, only squeezes the dimensions listed. The dimension
    index starts at 0. It is an error to squeeze a dimension that is not 1.
  name: A name for the operation (optional).
  squeeze_dims: Deprecated keyword argument that is now axis.</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.
  Contains the same data as <code>input</code>, but has one or more dimensions of
  size 1 removed.</p>
<p>Raises:
  ValueError: When both <code>squeeze_dims</code> and <code>axis</code> are specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.squeeze', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.squeeze" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.stack">
    <p>def <span class="ident">stack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.stack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.stack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.stack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.stack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.stack</strong></p>
<div class="codehilite"><pre><span></span>Stacks a list of rank-`R` tensors into one rank-`(R+1)` tensor.
</pre></div>


<p>Packs the list of tensors in <code>values</code> into a tensor with rank one higher than
each tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.
Given a list of length <code>N</code> of tensors of shape <code>(A, B, C)</code>;</p>
<p>if <code>axis == 0</code> then the <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>.
if <code>axis == 1</code> then the <code>output</code> tensor will have the shape <code>(A, N, B, C)</code>.
Etc.</p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>'x' is [1, 4]</h1>
<h1>'y' is [2, 5]</h1>
<h1>'z' is [3, 6]</h1>
<p>stack([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
stack([x, y, z], axis=1) =&gt; [[1, 2, 3], [4, 5, 6]]
```</p>
<p>This is the opposite of unstack.  The numpy equivalent is</p>
<div class="codehilite"><pre><span></span>tf.stack([x, y, z]) = np.asarray([x, y, z])
</pre></div>


<p>Args:
  values: A list of <code>Tensor</code> objects with the same shape and type.
  axis: An <code>int</code>. The axis to stack along. Defaults to the first dimension.
    Supports negative indexes.
  name: A name for this operation (optional).</p>
<p>Returns:
  output: A stacked <code>Tensor</code> with the same type as <code>values</code>.</p>
<p>Raises:
  ValueError: If <code>axis</code> is out of the range [-(R+1), R+1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.stack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.stack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.state_saving_rnn">
    <p>def <span class="ident">state_saving_rnn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.state_saving_rnn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnstate_saving_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnstate_saving_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.state_saving_rnn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnstate_saving_rnn</strong></p>
<div class="codehilite"><pre><span></span>RNN that accepts a state saver for time-truncated RNN calculation.
</pre></div>


<p>Args:
  cell: An instance of <code>RNNCell</code>.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>.
  state_saver: A state saver object with methods <code>state</code> and <code>save_state</code>.
  state_name: Python string or tuple of strings.  The name to use with the
    state_saver. If the cell returns tuples of states (i.e.,
    <code>cell.state_size</code> is a tuple) then <code>state_name</code> should be a tuple of
    strings having the same length as <code>cell.state_size</code>.  Otherwise it should
    be a single string.
  sequence_length: (optional) An int32/int64 vector size [batch_size].
    See the documentation for rnn() for more details about sequence_length.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:
    outputs is a length T list of outputs (one for each input)
    states is the final state</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the arity and
   type of <code>state_name</code> does not match that of <code>cell.state_size</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.state_saving_rnn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.state_saving_rnn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer">
    <p>def <span class="ident">state_saving_rnn_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.state_saving_rnn_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.state_saving_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.state_saving_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.state_saving_rnn_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.state_saving_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.state_saving_rnn</strong></p>
<div class="codehilite"><pre><span></span>RNN that accepts a state saver for time-truncated RNN calculation.
</pre></div>


<p>Args:
  cell: An instance of <code>RNNCell</code>.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>.
  state_saver: A state saver object with methods <code>state</code> and <code>save_state</code>.
  state_name: Python string or tuple of strings.  The name to use with the
    state_saver. If the cell returns tuples of states (i.e.,
    <code>cell.state_size</code> is a tuple) then <code>state_name</code> should be a tuple of
    strings having the same length as <code>cell.state_size</code>.  Otherwise it should
    be a single string.
  sequence_length: (optional) An int32/int64 vector size [batch_size].
    See the documentation for rnn() for more details about sequence_length.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:
    outputs is a length T list of outputs (one for each input)
    states is the final state</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the arity and
   type of <code>state_name</code> does not match that of <code>cell.state_size</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer">
    <p>def <span class="ident">state_saving_rnn_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.state_saving_rnn_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.state_saving_rnn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.state_saving_rnn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.state_saving_rnn_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.state_saving_rnn`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.state_saving_rnn</strong></p>
<div class="codehilite"><pre><span></span>RNN that accepts a state saver for time-truncated RNN calculation.
</pre></div>


<p>Args:
  cell: An instance of <code>RNNCell</code>.
  inputs: A length T list of inputs, each a <code>Tensor</code> of shape
    <code>[batch_size, input_size]</code>.
  state_saver: A state saver object with methods <code>state</code> and <code>save_state</code>.
  state_name: Python string or tuple of strings.  The name to use with the
    state_saver. If the cell returns tuples of states (i.e.,
    <code>cell.state_size</code> is a tuple) then <code>state_name</code> should be a tuple of
    strings having the same length as <code>cell.state_size</code>.  Otherwise it should
    be a single string.
  sequence_length: (optional) An int32/int64 vector size [batch_size].
    See the documentation for rnn() for more details about sequence_length.
  scope: VariableScope for the created subgraph; defaults to "RNN".</p>
<p>Returns:
  A pair (outputs, state) where:
    outputs is a length T list of outputs (one for each input)
    states is the final state</p>
<p>Raises:
  TypeError: If <code>cell</code> is not an instance of RNNCell.
  ValueError: If <code>inputs</code> is <code>None</code> or an empty list, or if the arity and
   type of <code>state_name</code> does not match that of <code>cell.state_size</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.state_saving_rnn_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.stop_gradient">
    <p>def <span class="ident">stop_gradient</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.stop_gradient(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.stop_gradient</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.stop_gradient(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.stop_gradient(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.stop_gradient</strong></p>
<div class="codehilite"><pre><span></span>Stops gradient computation.
</pre></div>


<p>When executed in a graph, this op outputs its input tensor as-is.</p>
<p>When building ops to compute gradients, this op prevents the contribution of
its inputs to be taken into account.  Normally, the gradient generator adds ops
to a graph to compute the derivatives of a specified 'loss' by recursively
finding out inputs that contributed to its computation.  If you insert this op
in the graph it inputs are masked from the gradient generator.  They are not
taken into account for computing gradients.</p>
<p>This is useful any time you want to compute a value with TensorFlow but need
to pretend that the value was a constant. Some examples include:</p>
<ul>
<li>The <em>EM</em> algorithm where the <em>M-step</em> should not involve backpropagation
   through the output of the <em>E-step</em>.</li>
<li>Contrastive divergence training of Boltzmann machines where, when
   differentiating the energy function, the training must not backpropagate
   through the graph that generated the samples from the model.</li>
<li>Adversarial training, where no backprop should happen through the adversarial
   example generation process.</li>
</ul>
<p>Args:
  input: A <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.stop_gradient', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.stop_gradient" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.strided_slice">
    <p>def <span class="ident">strided_slice</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.strided_slice(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.strided_slice</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.strided_slice(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.strided_slice(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.strided_slice</strong></p>
<div class="codehilite"><pre><span></span>Extracts a strided slice from a tensor.
</pre></div>


<p>To a first order, this operation extracts a slice of size <code>end - begin</code>
from a tensor <code>input</code>
starting at the location specified by <code>begin</code>. The slice continues by adding
<code>stride</code> to the <code>begin</code> index until all dimensions are not less than <code>end</code>.
Note that components of stride can be negative, which causes a reverse
slice.</p>
<p>This operation can be thought of an encoding of a numpy style sliced
range. Given a python slice input[<spec0>, <spec1>, ..., <specn>]
this function will be called as follows.</p>
<p><code>begin</code>, <code>end</code>, and <code>strides</code> will be all length n. n is in general
not the same dimensionality as <code>input</code>.</p>
<p>For the ith spec,
<code>begin_mask</code>, <code>end_mask</code>, <code>ellipsis_mask</code>, <code>new_axis_mask</code>,
and <code>shrink_axis_mask</code> will have the ith bit corresponding to
the ith spec.</p>
<p>If the ith bit of <code>begin_mask</code> is non-zero, <code>begin[i]</code> is ignored and
the fullest possible range in that dimension is used instead.
<code>end_mask</code> works analogously, except with the end range.</p>
<p><code>foo[5:,:,:3]</code> on a 7x8x9 tensor is equivalent to <code>foo[5:7,0:8,0:3]</code>.
<code>foo[::-1]</code> reverses a tensor with shape 8.</p>
<p>If the ith bit of <code>ellipsis_mask</code>, as many unspecified dimensions
as needed will be inserted between other dimensions. Only one
non-zero bit is allowed in <code>ellipsis_mask</code>.</p>
<p>For example <code>foo[3:5,...,4:5]</code> on a shape 10x3x3x10 tensor is
equivalent to <code>foo[3:5,:,:,4:5]</code> and
<code>foo[3:5,...]</code> is equivalent to <code>foo[3:5,:,:,:]</code>.</p>
<p>If the ith bit of <code>new_axis_mask</code> is one, then a <code>begin</code>,
<code>end</code>, and <code>stride</code> are ignored and a new length 1 dimension is
added at this point in the output tensor.</p>
<p>For example <code>foo[3:5,4]</code> on a 10x8 tensor produces a shape 2 tensor
whereas <code>foo[3:5,4:5]</code> produces a shape 2x1 tensor with shrink_mask
being 1&lt;&lt;1 == 2.</p>
<p>If the ith bit of <code>shrink_axis_mask</code> is one, then <code>begin</code>,
<code>end[i]</code>, and <code>stride[i]</code> are used to do a slice in the appropriate
dimension, but the output tensor will be reduced in dimensionality
by one. This is only valid if the ith entry of slice[i]==1.</p>
<p>NOTE: <code>begin</code> and <code>end</code> are zero-indexed<code>.</code>strides` entries must be non-zero.</p>
<p>```python</p>
<h1>'input' is [[[1, 1, 1], [2, 2, 2]],</h1>
<h1>[[3, 3, 3], [4, 4, 4]],</h1>
<h1>[[5, 5, 5], [6, 6, 6]]]</h1>
<p>tf.slice(input, [1, 0, 0], [2, 1, 3], [1, 1, 1]) ==&gt; [[[3, 3, 3]]]
tf.slice(input, [1, 0, 0], [2, 2, 3], [1, 1, 1]) ==&gt; [[[3, 3, 3],
                                                       [4, 4, 4]]]
tf.slice(input, [1, 1, 0], [2, -1, 3], [1, -1, 1]) ==&gt;[[[4, 4, 4],
                                                        [3, 3, 3]]]
```</p>
<p>Args:
  input_: A <code>Tensor</code>.
  begin: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  end: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  strides: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.
  begin_mask: An <code>int32</code> mask.
  end_mask: An <code>int32</code> mask.
  ellipsis_mask: An <code>int32</code> mask.
  new_axis_mask: An <code>int32</code> mask.
  shrink_axis_mask: An <code>int32</code> mask.
  var: The variable corresponding to <code>input_</code> or None
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.strided_slice', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.strided_slice" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_join">
    <p>def <span class="ident">string_join</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_join(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_join</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_join(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_join(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_join</strong></p>
<div class="codehilite"><pre><span></span>Joins the strings in the given list of string tensors into one tensor;
</pre></div>


<p>with the given separator (default is an empty separator).</p>
<p>Args:
  inputs: A list of at least 1 <code>Tensor</code> objects of type <code>string</code>.
    A list of string tensors.  The tensors must all have the same shape,
    or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
    of non-scalar inputs.
  separator: An optional <code>string</code>. Defaults to <code>""</code>.
    string, an optional join separator.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_join', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_join" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_split">
    <p>def <span class="ident">string_split</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_split(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_split</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_split(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_split(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_split</strong></p>
<div class="codehilite"><pre><span></span>Split elements of `source` based on `delimiter` into a `SparseTensor`.
</pre></div>


<p>Let N be the size of source (typically N will be the batch size). Split each
element of <code>source</code> based on <code>delimiter</code> and return a <code>SparseTensor</code>
containing the splitted tokens. Empty tokens are ignored.</p>
<p>If <code>delimiter</code> is an empty string, each element of the <code>source</code> is split
into individual strings, each containing one byte. (This includes splitting
multibyte sequences of UTF-8.)</p>
<p>For example:
N = 2, source[0] is 'hello world' and source[1] is 'a b c', then the output
will be</p>
<p>st.indices = [0, 0;
              0, 1;
              1, 0;
              1, 1;
              1, 2]
st.shape = [2, 3]
st.values = ['hello', 'world', 'a', 'b', 'c']</p>
<p>Args:
  source: <code>1-D</code> string <code>Tensor</code>, the strings to split.
  delimiter: <code>0-D</code> string <code>Tensor</code>, the delimiter character, the string should
    be length 0 or 1.</p>
<p>Returns:
  A <code>SparseTensor</code> of rank <code>2</code>, the strings split according to the delimiter.
  The first column of the indices corresponds to the row in <code>source</code> and the
  second column corresponds to the index of the split component in this row.</p>
<p>Raises:
  ValueError: If delimiter is not a single-byte character.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_split', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_split" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_hash_bucket">
    <p>def <span class="ident">string_to_hash_bucket</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_hash_bucket(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_hash_bucket</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_hash_bucket(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_hash_bucket(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_hash_bucket</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to its hash mod by a number of buckets.
</pre></div>


<p>The hash function is deterministic on the content of the string within the
process.</p>
<p>Note that the hash function may change from time to time.
This functionality will be deprecated and it's recommended to use
<code>tf.string_to_hash_bucket_fast()</code> or <code>tf.string_to_hash_bucket_strong()</code>.</p>
<p>Args:
  string_tensor: A <code>Tensor</code> of type <code>string</code>.
  num_buckets: An <code>int</code> that is <code>&gt;= 1</code>. The number of buckets.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast">
    <p>def <span class="ident">string_to_hash_bucket_fast</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_hash_bucket_fast(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_hash_bucket_fast</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_hash_bucket_fast(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_hash_bucket_fast(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_hash_bucket_fast</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to its hash mod by a number of buckets.
</pre></div>


<p>The hash function is deterministic on the content of the string within the
process and will never change. However, it is not suitable for cryptography.
This function may be used when CPU time is scarce and inputs are trusted or
unimportant. There is a risk of adversaries constructing inputs that all hash
to the same bucket. To prevent this problem, use a strong hash function with
<code>tf.string_to_hash_bucket_strong</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. The strings to assign a hash bucket.
  num_buckets: An <code>int</code> that is <code>&gt;= 1</code>. The number of buckets.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_fast" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong">
    <p>def <span class="ident">string_to_hash_bucket_strong</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_hash_bucket_strong(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_hash_bucket_strong</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_hash_bucket_strong(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_hash_bucket_strong(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_hash_bucket_strong</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to its hash mod by a number of buckets.
</pre></div>


<p>The hash function is deterministic on the content of the string within the
process. The hash function is a keyed hash function, where attribute <code>key</code>
defines the key of the hash function. <code>key</code> is an array of 2 elements.</p>
<p>A strong hash is important when inputs may be malicious, e.g. URLs with
additional components. Adversaries could try to make their inputs hash to the
same bucket for a denial-of-service attack or to skew the results. A strong
hash prevents this by making it dificult, if not infeasible, to compute inputs
that hash to the same bucket. This comes at a cost of roughly 4x higher compute
time than <code>tf.string_to_hash_bucket_fast</code>.</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. The strings to assign a hash bucket.
  num_buckets: An <code>int</code> that is <code>&gt;= 1</code>. The number of buckets.
  key: A list of <code>ints</code>.
    The key for the keyed hash function passed as a list of two uint64
    elements.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>int64</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_hash_bucket_strong" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.string_to_number">
    <p>def <span class="ident">string_to_number</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_number(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.string_to_number</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.string_to_number(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.string_to_number(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.string_to_number</strong></p>
<div class="codehilite"><pre><span></span>Converts each string in the input Tensor to the specified numeric type.
</pre></div>


<p>(Note that int32 overflow results in an error while float overflow
results in a rounded value.)</p>
<p>Args:
  string_tensor: A <code>Tensor</code> of type <code>string</code>.
  out_type: An optional <code>tf.DType</code> from: <code>tf.float32, tf.int32</code>. Defaults to <code>tf.float32</code>.
    The numeric type to interpret each string in <code>string_tensor</code> as.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>out_type</code>.
  A Tensor of the same shape as the input <code>string_tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.string_to_number', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.string_to_number" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sub">
    <p>def <span class="ident">sub</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sub(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.sub</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.sub(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sub(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.sub</strong></p>
<div class="codehilite"><pre><span></span>Returns x - y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Sub</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sub', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sub" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.substr">
    <p>def <span class="ident">substr</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.substr(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.substr</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.substr(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.substr(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.substr</strong></p>
<div class="codehilite"><pre><span></span>Return substrings from `Tensor` of strings.
</pre></div>


<p>For each string in the input <code>Tensor</code>, creates a substring starting at index
<code>pos</code> with a total length of <code>len</code>.</p>
<p>If <code>len</code> defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used.</p>
<p>If <code>pos</code> is negative or specifies a character index larger than any of the input
strings, then an <code>InvalidArgumentError</code> is thrown.</p>
<p><code>pos</code> and <code>len</code> must have the same shape, otherwise a <code>ValueError</code> is thrown on
Op creation.</p>
<p><em>NOTE</em>: <code>Substr</code> supports broadcasting up to two dimensions. More about
broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<hr />
<p>Examples</p>
<p>Using scalar <code>pos</code> and <code>len</code>:</p>
<p>```
input = [b'Hello', b'World']
position = 1
length = 3</p>
<p>output = [b'ell', b'orl']
```</p>
<p>Using <code>pos</code> and <code>len</code> with same shape as <code>input</code>:</p>
<p>```
input = [[b'ten', b'eleven', b'twelve'],
         [b'thirteen', b'fourteen', b'fifteen'],
         [b'sixteen', b'seventeen', b'eighteen']]
position = [[1, 2, 3],
            [1, 2, 3],
            [1, 2, 3]]
length =   [[2, 3, 4],
            [4, 3, 2],
            [5, 5, 5]]</p>
<p>output = [[b'en', b'eve', b'lve'],
          [b'hirt', b'urt', b'te'],
          [b'ixtee', b'vente', b'hteen']]
```</p>
<p>Broadcasting <code>pos</code> and <code>len</code> onto <code>input</code>:</p>
<p>```
input = [[b'ten', b'eleven', b'twelve'],
         [b'thirteen', b'fourteen', b'fifteen'],
         [b'sixteen', b'seventeen', b'eighteen'],
         [b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3]</p>
<p>output = [[b'e', b'ev', b'lve'],
          [b'h', b'ur', b'tee'],
          [b'i', b've', b'hte'],
          [b'i', b'en', b'nty']]
```</p>
<p>Broadcasting <code>input</code> onto <code>pos</code> and <code>len</code>:</p>
<p>```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1]</p>
<p>output = [b'hir', b'ee', b'n"]
```</p>
<p>Args:
  input: A <code>Tensor</code> of type <code>string</code>. Tensor of strings
  pos: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    Scalar defining the position of first character in each substring
  len: A <code>Tensor</code>. Must have the same type as <code>pos</code>.
    Scalar defining the number of characters to include in each substring
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of type <code>string</code>. Tensor of substrings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.substr', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.substr" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.subtract">
    <p>def <span class="ident">subtract</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.subtract(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.subtract</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.subtract(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.subtract(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.subtract</strong></p>
<div class="codehilite"><pre><span></span>Returns x - y element-wise.
</pre></div>


<p><em>NOTE</em>: <code>Sub</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.subtract', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.subtract" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sufficient_statistics">
    <p>def <span class="ident">sufficient_statistics</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sufficient_statistics(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnsufficient_statistics</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnsufficient_statistics(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sufficient_statistics(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnsufficient_statistics</strong></p>
<div class="codehilite"><pre><span></span>Calculate the sufficient statistics for the mean and variance of `x`.
</pre></div>


<p>These sufficient statistics are computed using the one pass algorithm on
an input that's optionally shifted. See:
https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</p>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints. Axes along which to compute mean and variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  keep_dims: produce statistics with the same dimensionality as the input.
  name: Name used to scope the operations that compute the sufficient stats.</p>
<p>Returns:
  Four <code>Tensor</code> objects of the same type as <code>x</code>:</p>
<ul>
<li>the count (number of elements to average over).</li>
<li>the (possibly shifted) sum of the elements in the array.</li>
<li>the (possibly shifted) sum of squares of the elements in the array.</li>
<li>the shift by which the mean must be corrected or None if <code>shift</code> is None.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sufficient_statistics', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sufficient_statistics" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer">
    <p>def <span class="ident">sufficient_statistics_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sufficient_statistics_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sufficient_statistics</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sufficient_statistics(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sufficient_statistics_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sufficient_statistics`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sufficient_statistics</strong></p>
<div class="codehilite"><pre><span></span>Calculate the sufficient statistics for the mean and variance of `x`.
</pre></div>


<p>These sufficient statistics are computed using the one pass algorithm on
an input that's optionally shifted. See:
https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</p>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints. Axes along which to compute mean and variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  keep_dims: produce statistics with the same dimensionality as the input.
  name: Name used to scope the operations that compute the sufficient stats.</p>
<p>Returns:
  Four <code>Tensor</code> objects of the same type as <code>x</code>:</p>
<ul>
<li>the count (number of elements to average over).</li>
<li>the (possibly shifted) sum of the elements in the array.</li>
<li>the (possibly shifted) sum of squares of the elements in the array.</li>
<li>the shift by which the mean must be corrected or None if <code>shift</code> is None.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer">
    <p>def <span class="ident">sufficient_statistics_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sufficient_statistics_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.sufficient_statistics</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.sufficient_statistics(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.sufficient_statistics_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.sufficient_statistics`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.sufficient_statistics</strong></p>
<div class="codehilite"><pre><span></span>Calculate the sufficient statistics for the mean and variance of `x`.
</pre></div>


<p>These sufficient statistics are computed using the one pass algorithm on
an input that's optionally shifted. See:
https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</p>
<p>Args:
  x: A <code>Tensor</code>.
  axes: Array of ints. Axes along which to compute mean and variance.
  shift: A <code>Tensor</code> containing the value by which to shift the data for
    numerical stability, or <code>None</code> if no shift is to be performed. A shift
    close to the true mean provides the most numerically stable results.
  keep_dims: produce statistics with the same dimensionality as the input.
  name: Name used to scope the operations that compute the sufficient stats.</p>
<p>Returns:
  Four <code>Tensor</code> objects of the same type as <code>x</code>:</p>
<ul>
<li>the count (number of elements to average over).</li>
<li>the (possibly shifted) sum of the elements in the array.</li>
<li>the (possibly shifted) sum of squares of the elements in the array.</li>
<li>the shift by which the mean must be corrected or None if <code>shift</code> is None.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.sufficient_statistics_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.svd">
    <p>def <span class="ident">svd</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.svd(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.svd</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.svd(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.svd(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.svd</strong></p>
<div class="codehilite"><pre><span></span>Computes the singular value decompositions of one or more matrices.
</pre></div>


<p>Computes the SVD of each inner matrix in <code>tensor</code> such that
<code>tensor[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :,
:])</code></p>
<p>```prettyprint</p>
<h1>a is a tensor.</h1>
<h1>s is a tensor of singular values.</h1>
<h1>u is a tensor of left singular vectors.</h1>
<h1>v is a tensor of right singular vectors.</h1>
<p>s, u, v = svd(a)
s = svd(a, compute_uv=False)
```</p>
<p>Args:
  matrix: <code>Tensor</code> of shape <code>[..., M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and
    <code>N</code>.
  full_matrices: If true, compute full-sized <code>u</code> and <code>v</code>. If false
    (the default), compute only the leading <code>P</code> singular vectors.
    Ignored if <code>compute_uv</code> is <code>False</code>.
  compute_uv: If <code>True</code> then left and right singular vectors will be
    computed and returned in <code>u</code> and <code>v</code>, respectively. Otherwise, only the
    singular values will be computed, which can be significantly faster.
  name: string, optional name of the operation.</p>
<p>Returns:
  s: Singular values. Shape is <code>[..., P]</code>.
  u: Right singular vectors. If <code>full_matrices</code> is <code>False</code> (default) then
    shape is <code>[..., M, P]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
    <code>[..., M, M]</code>. Not returned if <code>compute_uv</code> is <code>False</code>.
  v: Left singular vectors. If <code>full_matrices</code> is <code>False</code> (default) then
    shape is <code>[..., N, P]</code>. If <code>full_matrices</code> is <code>True</code> then shape is
    <code>[..., N, N]</code>. Not returned if <code>compute_uv</code> is <code>False</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.svd', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.svd" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tan">
    <p>def <span class="ident">tan</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tan(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.tan</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.tan(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tan(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.tan</strong></p>
<div class="codehilite"><pre><span></span>Computes tan of x element-wise.
</pre></div>


<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tan', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tan" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tanh">
    <p>def <span class="ident">tanh</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tanh(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nntanh</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nntanh(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tanh(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nntanh</strong></p>
<div class="codehilite"><pre><span></span>Computes hyperbolic tangent of `x` element-wise.
</pre></div>


<p>Args:
  x: A Tensor or SparseTensor with type <code>float</code>, <code>double</code>, <code>int32</code>,
    <code>complex64</code>, <code>int64</code>, or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor or SparseTensor respectively with the same type as <code>x</code> if
  <code>x.dtype != qint32</code> otherwise the return type is <code>quint8</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tanh', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tanh" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer">
    <p>def <span class="ident">tanh_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tanh_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.tanh</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.tanh(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tanh_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.tanh`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.tanh</strong></p>
<div class="codehilite"><pre><span></span>Computes hyperbolic tangent of `x` element-wise.
</pre></div>


<p>Args:
  x: A Tensor or SparseTensor with type <code>float</code>, <code>double</code>, <code>int32</code>,
    <code>complex64</code>, <code>int64</code>, or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor or SparseTensor respectively with the same type as <code>x</code> if
  <code>x.dtype != qint32</code> otherwise the return type is <code>quint8</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tanh_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tanh_layer">
    <p>def <span class="ident">tanh_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tanh_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.tanh</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.tanh(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tanh_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.tanh`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.tanh</strong></p>
<div class="codehilite"><pre><span></span>Computes hyperbolic tangent of `x` element-wise.
</pre></div>


<p>Args:
  x: A Tensor or SparseTensor with type <code>float</code>, <code>double</code>, <code>int32</code>,
    <code>complex64</code>, <code>int64</code>, or <code>qint32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A Tensor or SparseTensor respectively with the same type as <code>x</code> if
  <code>x.dtype != qint32</code> otherwise the return type is <code>quint8</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tanh_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tanh_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tile">
    <p>def <span class="ident">tile</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tile(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.tile</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.tile(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tile(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.tile</strong></p>
<div class="codehilite"><pre><span></span>Constructs a tensor by tiling a given tensor.
</pre></div>


<p>This operation creates a new tensor by replicating <code>input</code> <code>multiples</code> times.
The output tensor's i'th dimension has <code>input.dims(i) * multiples[i]</code> elements,
and the values of <code>input</code> are replicated <code>multiples[i]</code> times along the 'i'th
dimension. For example, tiling <code>[a b c d]</code> by <code>[2]</code> produces
<code>[a b c d a b c d]</code>.</p>
<p>Args:
  input: A <code>Tensor</code>. 1-D or higher.
  multiples: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    1-D. Length must be the same as the number of dimensions in <code>input</code>
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tile', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tile" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_bfloat16">
    <p>def <span class="ident">to_bfloat16</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_bfloat16(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_bfloat16</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_bfloat16(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_bfloat16(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_bfloat16</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `bfloat16`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>bfloat16</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>bfloat16</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_bfloat16', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_bfloat16" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_double">
    <p>def <span class="ident">to_double</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_double(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_double</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_double(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_double(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_double</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `float64`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>float64</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>float64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_double', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_double" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_float">
    <p>def <span class="ident">to_float</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_float(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_float</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_float(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_float(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_float</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `float32`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>float32</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_float', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_float" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_int32">
    <p>def <span class="ident">to_int32</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_int32(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_int32</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_int32(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_int32(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_int32</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `int32`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>int32</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>int32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_int32', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_int32" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.to_int64">
    <p>def <span class="ident">to_int64</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_int64(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.to_int64</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.to_int64(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.to_int64(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.to_int64</strong></p>
<div class="codehilite"><pre><span></span>Casts a tensor to type `int64`.
</pre></div>


<p>Args:
  x: A <code>Tensor</code> or <code>SparseTensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> or <code>SparseTensor</code> with same shape as <code>x</code> with type <code>int64</code>.</p>
<p>Raises:
  TypeError: If <code>x</code> cannot be cast to the <code>int64</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.to_int64', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.to_int64" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.top_k">
    <p>def <span class="ident">top_k</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.top_k(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nntop_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nntop_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.top_k(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nntop_k</strong></p>
<div class="codehilite"><pre><span></span>Finds values and indices of the `k` largest entries for the last dimension.
</pre></div>


<p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
<code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each
row (resp. vector along the last dimension).  Thus,</p>
<div class="codehilite"><pre><span></span><span class="s s-Atom">values</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">indices</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">input</span><span class="p">.</span><span class="s s-Atom">shape</span><span class="p">[:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">k</span><span class="p">]</span>
</pre></div>


<p>If two elements are equal, the lower-index element appears first.</p>
<p>Args:
  input: 1-D or higher <code>Tensor</code> with last dimension at least <code>k</code>.
  k: 0-D <code>int32</code> <code>Tensor</code>.  Number of top elements to look for along the last
    dimension (along each row for matrices).
  sorted: If true the resulting <code>k</code> elements will be sorted by the values in
    descending order.
  name: Optional name for the operation.</p>
<p>Returns:
  values: The <code>k</code> largest elements along each last dimensional slice.
  indices: The indices of <code>values</code> within the last dimension of <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.top_k', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.top_k" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer">
    <p>def <span class="ident">top_k_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.top_k_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.top_k_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.top_k`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.top_k</strong></p>
<div class="codehilite"><pre><span></span>Finds values and indices of the `k` largest entries for the last dimension.
</pre></div>


<p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
<code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each
row (resp. vector along the last dimension).  Thus,</p>
<div class="codehilite"><pre><span></span><span class="s s-Atom">values</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">indices</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">input</span><span class="p">.</span><span class="s s-Atom">shape</span><span class="p">[:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">k</span><span class="p">]</span>
</pre></div>


<p>If two elements are equal, the lower-index element appears first.</p>
<p>Args:
  input: 1-D or higher <code>Tensor</code> with last dimension at least <code>k</code>.
  k: 0-D <code>int32</code> <code>Tensor</code>.  Number of top elements to look for along the last
    dimension (along each row for matrices).
  sorted: If true the resulting <code>k</code> elements will be sorted by the values in
    descending order.
  name: Optional name for the operation.</p>
<p>Returns:
  values: The <code>k</code> largest elements along each last dimensional slice.
  indices: The indices of <code>values</code> within the last dimension of <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.top_k_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.top_k_layer">
    <p>def <span class="ident">top_k_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.top_k_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.top_k</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.top_k(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.top_k_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.top_k`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.top_k</strong></p>
<div class="codehilite"><pre><span></span>Finds values and indices of the `k` largest entries for the last dimension.
</pre></div>


<p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
<code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each
row (resp. vector along the last dimension).  Thus,</p>
<div class="codehilite"><pre><span></span><span class="s s-Atom">values</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">indices</span><span class="p">.</span><span class="s s-Atom">shape</span> <span class="o">=</span> <span class="s s-Atom">input</span><span class="p">.</span><span class="s s-Atom">shape</span><span class="p">[:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">k</span><span class="p">]</span>
</pre></div>


<p>If two elements are equal, the lower-index element appears first.</p>
<p>Args:
  input: 1-D or higher <code>Tensor</code> with last dimension at least <code>k</code>.
  k: 0-D <code>int32</code> <code>Tensor</code>.  Number of top elements to look for along the last
    dimension (along each row for matrices).
  sorted: If true the resulting <code>k</code> elements will be sorted by the values in
    descending order.
  name: Optional name for the operation.</p>
<p>Returns:
  values: The <code>k</code> largest elements along each last dimensional slice.
  indices: The indices of <code>values</code> within the last dimension of <code>input</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.top_k_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.top_k_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.trace">
    <p>def <span class="ident">trace</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.trace(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.trace</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.trace(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.trace(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.trace</strong></p>
<div class="codehilite"><pre><span></span>Compute the trace of a tensor `x`.
</pre></div>


<p><code>trace(x)</code> returns the sum along the main diagonal of each inner-most matrix
in x. If x is of rank <code>k</code> with shape <code>[I, J, K, ..., L, M, N]</code>, then output
is a tensor of rank <code>k-2</code> with dimensions <code>[I, J, K, ..., L]</code> where</p>
<p><code>output[i, j, k, ..., l] = trace(x[i, j, i, ..., l, :, :])</code></p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1, 2],</h1>
<h1>[3, 4]]</h1>
<p>tf.trace(x) ==&gt; 5</p>
<h1>'x' is [[1,2,3],</h1>
<h1>[4,5,6],</h1>
<h1>[7,8,9]]</h1>
<p>tf.trace(x) ==&gt; 15</p>
<h1>'x' is [[[1,2,3],</h1>
<h1>[4,5,6],</h1>
<h1>[7,8,9]],</h1>
<h1>[[-1,-2,-3],</h1>
<h1>[-4,-5,-6],</h1>
<h1>[-7,-8,-9]]]</h1>
<p>tf.trace(x) ==&gt; [15,-15]
```</p>
<p>Args:
  x: tensor.
  name: A name for the operation (optional).</p>
<p>Returns:
  The trace of input tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.trace', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.trace" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.trainable_variables">
    <p>def <span class="ident">trainable_variables</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.trainable_variables(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.trainable_variables</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.trainable_variables(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.trainable_variables(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.trainable_variables</strong></p>
<div class="codehilite"><pre><span></span>Returns all variables created with `trainable=True`.
</pre></div>


<p>When passed <code>trainable=True</code>, the <code>Variable()</code> constructor automatically
adds new variables to the graph collection
<code>GraphKeys.TRAINABLE_VARIABLES</code>. This convenience function returns the
contents of that collection.</p>
<p>Returns:
  A list of Variable objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.trainable_variables', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.trainable_variables" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.transpose">
    <p>def <span class="ident">transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.transpose</strong></p>
<div class="codehilite"><pre><span></span>Transposes `a`. Permutes the dimensions according to `perm`.
</pre></div>


<p>The returned tensor's dimension i will correspond to the input dimension
<code>perm[i]</code>. If <code>perm</code> is not given, it is set to (n-1...0), where n is
the rank of the input tensor. Hence by default, this operation performs a
regular matrix transpose on 2-D input Tensors.</p>
<p>For example:</p>
<p>```python</p>
<h1>'x' is [[1 2 3]</h1>
<h1>[4 5 6]]</h1>
<p>tf.transpose(x) ==&gt; [[1 4]
                     [2 5]
                     [3 6]]</p>
<h1>Equivalently</h1>
<p>tf.transpose(x, perm=[1, 0]) ==&gt; [[1 4]
                                  [2 5]
                                  [3 6]]</p>
<h1>'perm' is more useful for n-dimensional tensors, for n &gt; 2</h1>
<h1>'x' is   [[[1  2  3]</h1>
<h1>[4  5  6]]</h1>
<h1>[[7  8  9]</h1>
<h1>[10 11 12]]]</h1>
<h1>Take the transpose of the matrices in dimension-0</h1>
<p>tf.transpose(x, perm=[0, 2, 1]) ==&gt; [[[1  4]
                                      [2  5]
                                      [3  6]]</p>
<div class="codehilite"><pre><span></span>                                 [[7 10]
                                  [8 11]
                                  [9 12]]]
</pre></div>


<p>```</p>
<p>Args:
  a: A <code>Tensor</code>.
  perm: A permutation of the dimensions of <code>a</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A transposed <code>Tensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truediv">
    <p>def <span class="ident">truediv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truediv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truediv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truediv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truediv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truediv</strong></p>
<div class="codehilite"><pre><span></span>Divides x / y elementwise, always producing floating point results.
</pre></div>


<p>The same as <code>tf.div</code> for floating point arguments, but casts integer arguments
to floating point before dividing so that the result is always floating point.
This op is generated by normal <code>x / y</code> division in Python 3 and in Python 2.7
with <code>from __future__ import division</code>.  If you want integer division that
rounds down, use <code>x // y</code> or <code>tf.floordiv</code>.</p>
<p><code>x</code> and <code>y</code> must have the same numeric type.  If the inputs are floating
point, the output will have the same type.  If the inputs are integral, the
inputs are cast to <code>float32</code> for <code>int8</code> and <code>int16</code> and <code>float64</code> for <code>int32</code>
and <code>int64</code> (matching the behavior of Numpy).</p>
<p>Args:
  x: <code>Tensor</code> numerator of numeric type.
  y: <code>Tensor</code> denominator of numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  <code>x / y</code> evaluated in floating point.</p>
<p>Raises:
  TypeError: If <code>x</code> and <code>y</code> have different dtypes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truediv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truediv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truncated_normal">
    <p>def <span class="ident">truncated_normal</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncated_normal(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truncated_normal</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truncated_normal(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncated_normal(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truncated_normal</strong></p>
<div class="codehilite"><pre><span></span>Outputs random values from a truncated normal distribution.
</pre></div>


<p>The generated values follow a normal distribution with specified mean and
standard deviation, except that values whose magnitude is more than 2 standard
deviations from the mean are dropped and re-picked.</p>
<p>Args:
  shape: A 1-D integer Tensor or Python array. The shape of the output tensor.
  mean: A 0-D Tensor or Python value of type <code>dtype</code>. The mean of the
    truncated normal distribution.
  stddev: A 0-D Tensor or Python value of type <code>dtype</code>. The standard deviation
    of the truncated normal distribution.
  dtype: The type of the output.
  seed: A Python integer. Used to create a random seed for the distribution.
    See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tensor of the specified shape filled with random truncated normal values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truncated_normal', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truncated_normal" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truncated_normal_initializer">
    <p>def <span class="ident">truncated_normal_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncated_normal_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truncated_normal_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truncated_normal_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncated_normal_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truncated_normal_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates a truncated normal distribution.
</pre></div>


<p>These values are similar to values from a <code>random_normal_initializer</code>
except that values more than two standard deviations from the mean
are discarded and re-drawn. This is the recommended initializer for
neural network weights and filters.</p>
<p>Args:
  mean: a python scalar or a scalar tensor. Mean of the random values
    to generate.
  stddev: a python scalar or a scalar tensor. Standard deviation of the
    random values to generate.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with a truncated normal
  distribution.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truncated_normal_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truncated_normal_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truncatediv">
    <p>def <span class="ident">truncatediv</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncatediv(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truncatediv</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truncatediv(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncatediv(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truncatediv</strong></p>
<div class="codehilite"><pre><span></span>Returns x / y element-wise for integer types.
</pre></div>


<p>Truncation designates that negative numbers will round fractional quantities
toward zero. I.e. -7 / 5 = 1. This matches C semantics but it is different
than Python semantics. See <code>FloorDiv</code> for a division function that matches
Python Semantics.</p>
<p><em>NOTE</em>: <code>TruncateDiv</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>complex64</code>, <code>complex128</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truncatediv', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truncatediv" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.truncatemod">
    <p>def <span class="ident">truncatemod</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncatemod(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.truncatemod</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.truncatemod(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.truncatemod(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.truncatemod</strong></p>
<div class="codehilite"><pre><span></span>Returns element-wise remainder of division. This emulates C semantics where
</pre></div>


<p>true, this follows C semantics in that the result here is consistent
with a flooring divide. E.g. <code>floor(x / y) * y + mod(x, y) = x</code>.</p>
<p><em>NOTE</em>: <code>Mod</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>, <code>float32</code>, <code>float64</code>.
  y: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.truncatemod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.truncatemod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.tuple">
    <p>def <span class="ident">tuple</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tuple(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.tuple</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.tuple(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.tuple(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.tuple</strong></p>
<div class="codehilite"><pre><span></span>Group tensors together.
</pre></div>


<p>This creates a tuple of tensors with the same values as the <code>tensors</code>
argument, except that the value of each tensor is only returned after the
values of all tensors have been computed.</p>
<p><code>control_inputs</code> contains additional ops that have to finish before this op
finishes, but whose outputs are not returned.</p>
<p>This can be used as a "join" mechanism for parallel computations: all the
argument tensors can be computed in parallel, but the values of any tensor
returned by <code>tuple</code> are only available after all the parallel computations
are done.</p>
<p>See also <code>group</code> and <code>with_dependencies</code>.</p>
<p>Args:
  tensors: A list of <code>Tensor</code>s or <code>IndexedSlices</code>, some entries can be <code>None</code>.
  name: (optional) A name to use as a <code>name_scope</code> for the operation.
  control_inputs: List of additional ops to finish before returning.</p>
<p>Returns:
  Same as <code>tensors</code>.</p>
<p>Raises:
  ValueError: If <code>tensors</code> does not contain any <code>Tensor</code> or <code>IndexedSlices</code>.
  TypeError: If <code>control_inputs</code> is not a list of <code>Operation</code> or <code>Tensor</code>
    objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.tuple', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.tuple" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler">
    <p>def <span class="ident">uniform_candidate_sampler</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_candidate_sampler(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnuniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnuniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_candidate_sampler(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnuniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a uniform base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is the uniform distribution
over the range of integers <code>[0, range_max)</code>.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer">
    <p>def <span class="ident">uniform_candidate_sampler_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_candidate_sampler_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_candidate_sampler_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.uniform_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a uniform base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is the uniform distribution
over the range of integers <code>[0, range_max)</code>.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer">
    <p>def <span class="ident">uniform_candidate_sampler_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_candidate_sampler_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.uniform_candidate_sampler</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.uniform_candidate_sampler(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_candidate_sampler_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.uniform_candidate_sampler`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.uniform_candidate_sampler</strong></p>
<div class="codehilite"><pre><span></span>Samples a set of classes using a uniform base distribution.
</pre></div>


<p>This operation randomly samples a tensor of sampled classes
(<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement
(if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from
the base distribution.</p>
<p>The base distribution for this operation is the uniform distribution
over the range of integers <code>[0, range_max)</code>.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code>
and <code>sampled_expected_count</code> representing the number of times each
of the target classes (<code>true_classes</code>) and the sampled
classes (<code>sampled_candidates</code>) is expected to occur in an average
tensor of sampled classes.  These values correspond to <code>Q(y|x)</code>
defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this
document</a>.
If <code>unique=True</code>, then these are post-rejection probabilities and we
compute them approximately.</p>
<p>Args:
  true_classes: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,
    num_true]</code>. The target classes.
  num_true: An <code>int</code>.  The number of target classes per training example.
  num_sampled: An <code>int</code>.  The number of classes to randomly sample per batch.
  unique: A <code>bool</code>. Determines whether all sampled classes in a batch are
    unique.
  range_max: An <code>int</code>. The number of possible classes.
  seed: An <code>int</code>. An operation-specific seed. Default is 0.
  name: A name for the operation (optional).</p>
<p>Returns:
  sampled_candidates: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>.
    The sampled classes.
  true_expected_count: A tensor of type <code>float</code>.  Same shape as
    <code>true_classes</code>. The expected counts under the sampling distribution
    of each of <code>true_classes</code>.
  sampled_expected_count: A tensor of type <code>float</code>. Same shape as
    <code>sampled_candidates</code>. The expected counts under the sampling distribution
    of each of <code>sampled_candidates</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_candidate_sampler_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer">
    <p>def <span class="ident">uniform_unit_scaling_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_unit_scaling_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.uniform_unit_scaling_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.uniform_unit_scaling_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.uniform_unit_scaling_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.uniform_unit_scaling_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors without scaling variance.
</pre></div>


<p>When initializing a deep network, it is in principle advantageous to keep
the scale of the input variance constant, so it does not explode or diminish
by reaching the final layer. If the input is <code>x</code> and the operation <code>x * W</code>,
and we want to initialize <code>W</code> uniformly at random, we need to pick <code>W</code> from</p>
<div class="codehilite"><pre><span></span>[-sqrt(3) / sqrt(dim), sqrt(3) / sqrt(dim)]
</pre></div>


<p>to keep the scale intact, where <code>dim = W.shape[0]</code> (the size of the input).
A similar calculation for convolutional networks gives an analogous result
with <code>dim</code> equal to the product of the first 3 dimensions.  When
nonlinearities are present, we need to multiply this by a constant <code>factor</code>.
See <a href="https://arxiv.org/abs/1412.6558">Sussillo et al., 2014</a>
(<a href="http://arxiv.org/pdf/1412.6558.pdf">pdf</a>) for deeper motivation, experiments
and the calculation of constants. In section 2.3 there, the constants were
numerically computed: for a linear layer it's 1.0, relu: ~1.43, tanh: ~1.15.</p>
<p>Args:
  factor: Float.  A multiplicative factor by which the values will be scaled.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with unit variance.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.uniform_unit_scaling_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unique">
    <p>def <span class="ident">unique</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unique(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unique</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unique(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unique(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unique</strong></p>
<div class="codehilite"><pre><span></span>Finds unique elements in a 1-D tensor.
</pre></div>


<p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
sorted in the same order that they occur in <code>x</code>. This operation also returns a
tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
in the unique output <code>y</code>. In other words:</p>
<p><code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code></p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1>
<p>y, idx = unique(x)
y ==&gt; [1, 2, 4, 7, 8]
idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
```</p>
<p>Args:
  x: A <code>Tensor</code>. 1-D.
  out_idx: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (y, idx).
  y: A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D.
  idx: A <code>Tensor</code> of type <code>out_idx</code>. 1-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unique', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unique" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unique_with_counts">
    <p>def <span class="ident">unique_with_counts</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unique_with_counts(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unique_with_counts</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unique_with_counts(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unique_with_counts(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unique_with_counts</strong></p>
<div class="codehilite"><pre><span></span>Finds unique elements in a 1-D tensor.
</pre></div>


<p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
sorted in the same order that they occur in <code>x</code>. This operation also returns a
tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
in the unique output <code>y</code>. Finally, it returns a third tensor <code>count</code> that
contains the count of each element of <code>y</code> in <code>x</code>. In other words:</p>
<p><code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code></p>
<p>For example:</p>
<p>```prettyprint</p>
<h1>tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1>
<p>y, idx, count = unique_with_counts(x)
y ==&gt; [1, 2, 4, 7, 8]
idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
count ==&gt; [2, 1, 3, 1, 2]
```</p>
<p>Args:
  x: A <code>Tensor</code>. 1-D.
  out_idx: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A tuple of <code>Tensor</code> objects (y, idx, count).
  y: A <code>Tensor</code>. Has the same type as <code>x</code>. 1-D.
  idx: A <code>Tensor</code> of type <code>out_idx</code>. 1-D.
  count: A <code>Tensor</code> of type <code>out_idx</code>. 1-D.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unique_with_counts', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unique_with_counts" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unpack">
    <p>def <span class="ident">unpack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unpack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unpack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unpack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unpack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unpack</strong></p>
<div class="codehilite"><pre><span></span>DEPRECATED: Use unstack.
</pre></div>


<p>Unpacks the given dimension of a rank-<code>R</code> tensor into rank-<code>(R-1)</code> tensors.</p>
<p>Unpacks <code>num</code> tensors from <code>value</code> by chipping it along the <code>axis</code> dimension.
If <code>num</code> is not specified (the default), it is inferred from <code>value</code>'s shape.
If <code>value.shape[axis]</code> is not known, <code>ValueError</code> is raised.</p>
<p>For example, given a tensor of shape <code>(A, B, C, D)</code>;</p>
<p>If <code>axis == 0</code> then the i'th tensor in <code>output</code> is the slice
  <code>value[i, :, :, :]</code> and each tensor in <code>output</code> will have shape <code>(B, C, D)</code>.
  (Note that the dimension unpacked along is gone, unlike <code>split</code>).</p>
<p>If <code>axis == 1</code> then the i'th tensor in <code>output</code> is the slice
  <code>value[:, i, :, :]</code> and each tensor in <code>output</code> will have shape <code>(A, C, D)</code>.
Etc.</p>
<p>This is the opposite of pack.  The numpy equivalent is</p>
<div class="codehilite"><pre><span></span>tf.unpack(x, n) = list(x)
</pre></div>


<p>Args:
  value: A rank <code>R &gt; 0</code> <code>Tensor</code> to be unpacked.
  num: An <code>int</code>. The length of the dimension <code>axis</code>. Automatically inferred
    if <code>None</code> (the default).
  axis: An <code>int</code>. The axis to unpack along. Defaults to the first
    dimension. Supports negative indexes.
  name: A name for the operation (optional).</p>
<p>Returns:
  The list of <code>Tensor</code> objects unpacked from <code>value</code>.</p>
<p>Raises:
  ValueError: If <code>num</code> is unspecified and cannot be inferred.
  ValueError: If <code>axis</code> is out of the range [-R, R).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unpack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unpack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unsorted_segment_sum">
    <p>def <span class="ident">unsorted_segment_sum</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unsorted_segment_sum(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unsorted_segment_sum</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unsorted_segment_sum(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unsorted_segment_sum(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unsorted_segment_sum</strong></p>
<div class="codehilite"><pre><span></span>Computes the sum along segments of a tensor.
</pre></div>


<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<p>Computes a tensor such that
<code>(output[i] = sum_{j...} data[j...]</code> where the sum is over tuples <code>j...</code> such
that <code>segment_ids[j...] == i</code>.  Unlike <code>SegmentSum</code>, <code>segment_ids</code>
need not be sorted and need not cover all values in the full
range of valid values.</p>
<p>If the sum is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.</p>
<p><code>num_segments</code> should equal the number of distinct segment IDs.</p>
<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/UnsortedSegmentSum.png" alt>
</div>

<p>Args:
  data: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
  segment_ids: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>.
    A tensor whose shape is a prefix of <code>data.shape</code>.
  num_segments: A <code>Tensor</code> of type <code>int32</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>data</code>.
  Has same shape as data, except for the first <code>segment_ids.rank</code>
  dimensions, which are replaced with a single dimension which has size
  <code>num_segments</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unsorted_segment_sum', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unsorted_segment_sum" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.unstack">
    <p>def <span class="ident">unstack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unstack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.unstack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.unstack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.unstack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.unstack</strong></p>
<div class="codehilite"><pre><span></span>Unpacks the given dimension of a rank-`R` tensor into rank-`(R-1)` tensors.
</pre></div>


<p>Unpacks <code>num</code> tensors from <code>value</code> by chipping it along the <code>axis</code> dimension.
If <code>num</code> is not specified (the default), it is inferred from <code>value</code>'s shape.
If <code>value.shape[axis]</code> is not known, <code>ValueError</code> is raised.</p>
<p>For example, given a tensor of shape <code>(A, B, C, D)</code>;</p>
<p>If <code>axis == 0</code> then the i'th tensor in <code>output</code> is the slice
  <code>value[i, :, :, :]</code> and each tensor in <code>output</code> will have shape <code>(B, C, D)</code>.
  (Note that the dimension unpacked along is gone, unlike <code>split</code>).</p>
<p>If <code>axis == 1</code> then the i'th tensor in <code>output</code> is the slice
  <code>value[:, i, :, :]</code> and each tensor in <code>output</code> will have shape <code>(A, C, D)</code>.
Etc.</p>
<p>This is the opposite of pack.  The numpy equivalent is</p>
<div class="codehilite"><pre><span></span>tf.unstack(x, n) = list(x)
</pre></div>


<p>Args:
  value: A rank <code>R &gt; 0</code> <code>Tensor</code> to be unstacked.
  num: An <code>int</code>. The length of the dimension <code>axis</code>. Automatically inferred
    if <code>None</code> (the default).
  axis: An <code>int</code>. The axis to unstack along. Defaults to the first
    dimension. Supports negative indexes.
  name: A name for the operation (optional).</p>
<p>Returns:
  The list of <code>Tensor</code> objects unstacked from <code>value</code>.</p>
<p>Raises:
  ValueError: If <code>num</code> is unspecified and cannot be inferred.
  ValueError: If <code>axis</code> is out of the range [-R, R).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.unstack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.unstack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner">
    <p>def <span class="ident">variable_axis_size_partitioner</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variable_axis_size_partitioner(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variable_axis_size_partitioner</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variable_axis_size_partitioner(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variable_axis_size_partitioner(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.variable_axis_size_partitioner</strong></p>
<div class="codehilite"><pre><span></span>Get a partitioner for VariableScope to keep shards below `max_shard_bytes`.
</pre></div>


<p>This partitioner will shard a Variable along one axis, attempting to keep
the maximum shard size below <code>max_shard_bytes</code>.  In practice, this is not
always possible when sharding along only one axis.  When this happens,
this axis is sharded as much as possible (i.e., every dimension becomes
a separate shard).</p>
<p>If the partitioner hits the <code>max_shards</code> limit, then each shard may end up
larger than <code>max_shard_bytes</code>. By default <code>max_shards</code> equals <code>None</code> and no
limit on the number of shards is enforced.</p>
<p>One reasonable value for <code>max_shard_bytes</code> is <code>(64 &lt;&lt; 20) - 1</code>, or almost
<code>64MB</code>, to keep below the protobuf byte limit.</p>
<p>Args:
  max_shard_bytes: The maximum size any given shard is allowed to be.
  axis: The axis to partition along.  Default: outermost axis.
  bytes_per_string_element: If the <code>Variable</code> is of type string, this provides
    an estimate of how large each scalar in the <code>Variable</code> is.
  max_shards: The maximum number of shards in int created taking precedence
    over <code>max_shard_bytes</code>.</p>
<p>Returns:
  A partition function usable as the <code>partitioner</code> argument to
  <code>variable_scope</code>, <code>get_variable</code>, and <code>get_partitioned_variable_list</code>.</p>
<p>Raises:
  ValueError: If any of the byte counts are non-positive.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variable_axis_size_partitioner" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variable_op_scope">
    <p>def <span class="ident">variable_op_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variable_op_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variable_op_scope</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variable_op_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variable_op_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.variable_op_scope</strong></p>
<div class="codehilite"><pre><span></span>Deprecated: context manager for defining an op that creates variables.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variable_op_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variable_op_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variable_scope">
    <p>def <span class="ident">variable_scope</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variable_scope(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variable_scope</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variable_scope(*args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variable_scope(*args, **kwargs)(x)
</pre></div>


<p><strong>tensorflow.variable_scope</strong></p>
<div class="codehilite"><pre><span></span>Returns a context manager for defining ops that creates variables (layers).
</pre></div>


<p>This context manager validates that the (optional) <code>values</code> are from
the same graph, ensures that graph is the default graph, and pushes a
name scope and a variable scope.</p>
<p>If <code>name_or_scope</code> is not None, it is used as is. If <code>scope</code> is None, then
<code>default_name</code> is used.  In that case, if the same name has been previously
used in the same scope, it will made unique be appending <code>_N</code> to it.</p>
<p>Variable scope allows to create new variables and to share already created
ones while providing checks to not create or share by accident. For details,
see the <a href="../../how_tos/variable_scope/index.md">Variable Scope How To</a>,
here we present only a few basic examples.</p>
<p>Simple example of how to create a new variable:</p>
<p><code>python
with tf.variable_scope("foo"):
    with tf.variable_scope("bar"):
        v = tf.get_variable("v", [1])
        assert v.name == "foo/bar/v:0"</code></p>
<p>Basic example of sharing a variable:</p>
<p><code>python
with tf.variable_scope("foo"):
    v = tf.get_variable("v", [1])
with tf.variable_scope("foo", reuse=True):
    v1 = tf.get_variable("v", [1])
assert v1 == v</code></p>
<p>Sharing a variable by capturing a scope and setting reuse:</p>
<p><code>python
with tf.variable_scope("foo") as scope:
    v = tf.get_variable("v", [1])
    scope.reuse_variables()
    v1 = tf.get_variable("v", [1])
assert v1 == v</code></p>
<p>To prevent accidental sharing of variables, we raise an exception when
getting an existing variable in a non-reusing scope.</p>
<p><code>python
with tf.variable_scope("foo"):
    v = tf.get_variable("v", [1])
    v1 = tf.get_variable("v", [1])
    #  Raises ValueError("... v already exists ...").</code></p>
<p>Similarly, we raise an exception when trying to get a variable that
does not exist in reuse mode.</p>
<p><code>python
with tf.variable_scope("foo", reuse=True):
    v = tf.get_variable("v", [1])
    #  Raises ValueError("... v does not exists ...").</code></p>
<p>Note that the <code>reuse</code> flag is inherited: if we open a reusing scope,
then all its sub-scopes become reusing as well.</p>
<p>Args:
  name_or_scope: <code>string</code> or <code>VariableScope</code>: the scope to open.
  default_name: The default name to use if the <code>name_or_scope</code> argument is
    <code>None</code>, this name will be uniquified. If name_or_scope is provided it
    won't be used and therefore it is not required and can be None.
  values: The list of <code>Tensor</code> arguments that are passed to the op function.
  initializer: default initializer for variables within this scope.
  regularizer: default regularizer for variables within this scope.
  caching_device: default caching device for variables within this scope.
  partitioner: default partitioner for variables within this scope.
  custom_getter: default custom getter for variables within this scope.
  reuse: <code>True</code> or <code>None</code>; if <code>True</code>, we go into reuse mode for this scope as
    well as all sub-scopes; if <code>None</code>, we just inherit the parent scope reuse.
  dtype: type of variables created in this scope (defaults to the type
    in the passed scope, or inherited from parent scope).</p>
<p>Returns:
  A scope that can be to captured and reused.</p>
<p>Raises:
  ValueError: when trying to reuse within a create scope, or create within
    a reuse scope, or if reuse is not <code>None</code> or <code>True</code>.
  TypeError: when the types of some arguments are not appropriate.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variable_scope', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variable_scope" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.variables_initializer">
    <p>def <span class="ident">variables_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variables_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.variables_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.variables_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.variables_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.variables_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an Op that initializes a list of variables.
</pre></div>


<p>After you launch the graph in a session, you can run the returned Op to
initialize all the variables in <code>var_list</code>. This Op runs all the
initializers of the variables in <code>var_list</code> in parallel.</p>
<p>Calling <code>initialize_variables()</code> is equivalent to passing the list of
initializers to <code>Group()</code>.</p>
<p>If <code>var_list</code> is empty, however, the function still returns an Op that can
be run. That Op just has no effect.</p>
<p>Args:
  var_list: List of <code>Variable</code> objects to initialize.
  name: Optional name for the returned operation.</p>
<p>Returns:
  An Op that run the initializers of all the specified variables.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.variables_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.variables_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite">
    <p>def <span class="ident">verify_tensor_all_finite</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.verify_tensor_all_finite(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.verify_tensor_all_finite</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.verify_tensor_all_finite(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.verify_tensor_all_finite(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.verify_tensor_all_finite</strong></p>
<div class="codehilite"><pre><span></span>Assert that the tensor does not contain any NaN&#39;s or Inf&#39;s.
</pre></div>


<p>Args:
  t: Tensor to check.
  msg: Message to log on failure.
  name: A name for this operation (optional).</p>
<p>Returns:
  Same tensor as <code>t</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.verify_tensor_all_finite" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits">
    <p>def <span class="ident">weighted_cross_entropy_with_logits</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_cross_entropy_with_logits(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnweighted_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnweighted_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_cross_entropy_with_logits(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnweighted_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes a weighted cross entropy.
</pre></div>


<p>This is like <code>sigmoid_cross_entropy_with_logits()</code> except that <code>pos_weight</code>,
allows one to trade off recall and precision by up- or down-weighting the
cost of a positive error relative to a negative error.</p>
<p>The usual cross-entropy cost is defined as:</p>
<p>targets * -log(sigmoid(logits)) + (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>The argument <code>pos_weight</code> is used as a multiplier for the positive targets:</p>
<p>targets * -log(sigmoid(logits)) * pos_weight +
      (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>, <code>q = pos_weight</code>.
The loss is:</p>
<div class="codehilite"><pre><span></span>  qz * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= qz * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + (qz +  1 - z) * log(1 + exp(-x))
= (1 - z) * x + (1 + (q - 1) * z) * log(1 + exp(-x))
</pre></div>


<p>Setting <code>l = (1 + (q - 1) * z)</code>, to ensure stability and avoid overflow,
the implementation uses</p>
<div class="codehilite"><pre><span></span>(1 - z) * x + l * (log(1 + exp(-abs(x))) + max(-x, 0))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  pos_weight: A coefficient to use on the positive examples.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  weighted logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer">
    <p>def <span class="ident">weighted_cross_entropy_with_logits_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.weighted_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.weighted_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.weighted_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.weighted_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes a weighted cross entropy.
</pre></div>


<p>This is like <code>sigmoid_cross_entropy_with_logits()</code> except that <code>pos_weight</code>,
allows one to trade off recall and precision by up- or down-weighting the
cost of a positive error relative to a negative error.</p>
<p>The usual cross-entropy cost is defined as:</p>
<p>targets * -log(sigmoid(logits)) + (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>The argument <code>pos_weight</code> is used as a multiplier for the positive targets:</p>
<p>targets * -log(sigmoid(logits)) * pos_weight +
      (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>, <code>q = pos_weight</code>.
The loss is:</p>
<div class="codehilite"><pre><span></span>  qz * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= qz * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + (qz +  1 - z) * log(1 + exp(-x))
= (1 - z) * x + (1 + (q - 1) * z) * log(1 + exp(-x))
</pre></div>


<p>Setting <code>l = (1 + (q - 1) * z)</code>, to ensure stability and avoid overflow,
the implementation uses</p>
<div class="codehilite"><pre><span></span>(1 - z) * x + l * (log(1 + exp(-abs(x))) + max(-x, 0))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  pos_weight: A coefficient to use on the positive examples.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  weighted logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer">
    <p>def <span class="ident">weighted_cross_entropy_with_logits_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_cross_entropy_with_logits_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.weighted_cross_entropy_with_logits</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.weighted_cross_entropy_with_logits(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_cross_entropy_with_logits_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.weighted_cross_entropy_with_logits`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.weighted_cross_entropy_with_logits</strong></p>
<div class="codehilite"><pre><span></span>Computes a weighted cross entropy.
</pre></div>


<p>This is like <code>sigmoid_cross_entropy_with_logits()</code> except that <code>pos_weight</code>,
allows one to trade off recall and precision by up- or down-weighting the
cost of a positive error relative to a negative error.</p>
<p>The usual cross-entropy cost is defined as:</p>
<p>targets * -log(sigmoid(logits)) + (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>The argument <code>pos_weight</code> is used as a multiplier for the positive targets:</p>
<p>targets * -log(sigmoid(logits)) * pos_weight +
      (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>, <code>q = pos_weight</code>.
The loss is:</p>
<div class="codehilite"><pre><span></span>  qz * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= qz * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + (qz +  1 - z) * log(1 + exp(-x))
= (1 - z) * x + (1 + (q - 1) * z) * log(1 + exp(-x))
</pre></div>


<p>Setting <code>l = (1 + (q - 1) * z)</code>, to ensure stability and avoid overflow,
the implementation uses</p>
<div class="codehilite"><pre><span></span>(1 - z) * x + l * (log(1 + exp(-abs(x))) + max(-x, 0))
</pre></div>


<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<p>Args:
  logits: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.
  targets: A <code>Tensor</code> of the same type and shape as <code>logits</code>.
  pos_weight: A coefficient to use on the positive examples.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise
  weighted logistic losses.</p>
<p>Raises:
  ValueError: If <code>logits</code> and <code>targets</code> do not have the same shape.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_cross_entropy_with_logits_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_moments">
    <p>def <span class="ident">weighted_moments</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_moments(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnweighted_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnweighted_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_moments(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnweighted_moments</strong></p>
<div class="codehilite"><pre><span></span>Returns the frequency-weighted mean and variance of `x`.
</pre></div>


<p>Args:
  x: A tensor.
  axes: 1-d tensor of int32 values; these are the axes along which
    to compute mean and variance.
  frequency_weights: A tensor of positive weights which can be
    broadcast with x.
  name: Name used to scope the operation.
  keep_dims: Produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two tensors: <code>weighted_mean</code> and <code>weighted_variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_moments', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_moments" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_moments_conv2d_layer">
    <p>def <span class="ident">weighted_moments_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_moments_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.weighted_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.weighted_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_moments_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.weighted_moments`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.weighted_moments</strong></p>
<div class="codehilite"><pre><span></span>Returns the frequency-weighted mean and variance of `x`.
</pre></div>


<p>Args:
  x: A tensor.
  axes: 1-d tensor of int32 values; these are the axes along which
    to compute mean and variance.
  frequency_weights: A tensor of positive weights which can be
    broadcast with x.
  name: Name used to scope the operation.
  keep_dims: Produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two tensors: <code>weighted_mean</code> and <code>weighted_variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_moments_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_moments_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.weighted_moments_layer">
    <p>def <span class="ident">weighted_moments_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_moments_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.weighted_moments</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.weighted_moments(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.weighted_moments_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.weighted_moments`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.weighted_moments</strong></p>
<div class="codehilite"><pre><span></span>Returns the frequency-weighted mean and variance of `x`.
</pre></div>


<p>Args:
  x: A tensor.
  axes: 1-d tensor of int32 values; these are the axes along which
    to compute mean and variance.
  frequency_weights: A tensor of positive weights which can be
    broadcast with x.
  name: Name used to scope the operation.
  keep_dims: Produce moments with the same dimensionality as the input.</p>
<p>Returns:
  Two tensors: <code>weighted_mean</code> and <code>weighted_variance</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.weighted_moments_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.weighted_moments_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.where">
    <p>def <span class="ident">where</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.where(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.where</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.where(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.where(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.where</strong></p>
<div class="codehilite"><pre><span></span>Return the elements, either from `x` or `y`, depending on the `condition`.
</pre></div>


<p>If both <code>x</code> and <code>y</code> are None, then this operation returns the coordinates of
true elements of <code>condition</code>.  The coordinates are returned in a 2-D tensor
where the first dimension (rows) represents the number of true elements, and
the second dimension (columns) represents the coordinates of the true
elements. Keep in mind, the shape of the output tensor can vary depending on
how many true values there are in input. Indices are output in row-major
order.</p>
<p>If both non-None, <code>x</code> and <code>y</code> must have the same shape.
The <code>condition</code> tensor must be a scalar if <code>x</code> and <code>y</code> are scalar.
If <code>x</code> and <code>y</code> are vectors or higher rank, then <code>condition</code> must be either a
vector with size matching the first dimension of <code>x</code>, or must have the same
shape as <code>x</code>.</p>
<p>The <code>condition</code> tensor acts as a mask that chooses, based on the value at each
element, whether the corresponding element / row in the output should be taken
from <code>x</code> (if true) or <code>y</code> (if false).</p>
<p>If <code>condition</code> is a vector and <code>x</code> and <code>y</code> are higher rank matrices, then it
chooses which row (outer dimension) to copy from <code>x</code> and <code>y</code>. If <code>condition</code>
has the same shape as <code>x</code> and <code>y</code>, then it chooses which element to copy from
<code>x</code> and <code>y</code>.</p>
<p>Args:
  condition: A <code>Tensor</code> of type <code>bool</code>
  x: A Tensor which may have the same shape as <code>condition</code>. If <code>condition</code> is
    rank 1, <code>x</code> may have higher rank, but its first dimension must match the
    size of <code>condition</code>.
  y: A <code>tensor</code> with the same shape and type as <code>x</code>.
  name: A name of the operation (optional)</p>
<p>Returns:
  A <code>Tensor</code> with the same type and shape as <code>x</code>, <code>y</code> if they are non-None.
  A <code>Tensor</code> with shape <code>(num_true, dim_size(condition))</code>.</p>
<p>Raises:
  ValueError: When exactly one of <code>x</code> or <code>y</code> is non-None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.where', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.where" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.while_loop">
    <p>def <span class="ident">while_loop</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.while_loop(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.while_loop</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.while_loop(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.while_loop(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.while_loop</strong></p>
<div class="codehilite"><pre><span></span>Repeat `body` while the condition `cond` is true.
</pre></div>


<p><code>cond</code> is a callable returning a boolean scalar tensor. <code>body</code> is a callable
returning a (possibly nested) tuple, namedtuple or list of tensors of the same
arity (length and structure) and types as <code>loop_vars</code>. <code>loop_vars</code> is a
(possibly nested) tuple, namedtuple or list of tensors that is passed to both
<code>cond</code> and <code>body</code>. <code>cond</code> and <code>body</code> both take as many arguments as there are
<code>loop_vars</code>.</p>
<p>While <code>cond</code> evaluates to true, <code>body</code> is executed.</p>
<p>In addition to regular Tensors or IndexedSlices, the body may accept and
return TensorArray objects.  The flows of the TensorArray objects will
be appropriately forwarded between loops and during gradient calculations.</p>
<p>For correctness, <code>tf.while_loop()</code> strictly enforces shape invariants for
the loop variables. A shape invariant is a (possibly partial) shape that
is unchanged across the iterations of the loop. An error will be raised
if the shape of a loop variable after an iteration is determined to be more
general than or incompatible with its shape invariant. For example, a shape
of [11, None] is more general than a shape of [11, 17], and [11, 21] is not
compatible with [11, 17]. By default (if the argument <code>shape_invariants</code> is
not specified), it is assumed that the initial shape of each tensor in
<code>loop_vars</code> is the same in every iteration. The <code>shape_invariants</code> argument
allows the caller to specify a less specific shape invariant for each loop
variable, which is needed if the shape varies between iterations. The
<a href="../../api_docs/python/framework.md#Tensor.set_shape"><code>Tensor.set_shape()</code></a>
function may also be used in the <code>body</code> function to indicate that
the output loop variable has a particular shape. The shape invariant for
SparseTensor and IndexedSlices are treated specially as follows:</p>
<p>a) If a loop variable is a SparseTensor, the shape invariant must be
TensorShape([r]) where r is the rank of the dense tensor represented
by the sparse tensor. It means the shapes of the three tensors of the
SparseTensor are ([None], [None, r], [r]). NOTE: The shape invariant here
is the shape of the SparseTensor.shape property. It must be the shape of
a vector.</p>
<p>b) If a loop variable is an IndexedSlices, the shape invariant must be
a shape invariant of the values tensor of the IndexedSlices. It means
the shapes of the three tensors of the IndexedSlices are (shape, [shape[0]],
[shape.ndims]).</p>
<p><code>while_loop</code> implements non-strict semantics, enabling multiple iterations
to run in parallel. The maximum number of parallel iterations can be
controlled by <code>parallel_iterations</code>, which gives users some control over
memory consumption and execution order. For correct programs, <code>while_loop</code>
should return the same result for any parallel_iterations &gt; 0.</p>
<p>For training, TensorFlow remembers the tensors that are produced in the
forward inference but needed in back propagation. These tensors can be a
main source of memory consumption and often cause OOM problems when training
on GPUs.  When the flag swap_memory is true, we swap out these tensors from
GPU to CPU.  This for example allows us to train RNN models with very long
sequences and large batches.</p>
<p>Args:
  cond: A callable that represents the termination condition of the loop.
  body: A callable that represents the loop body.
  loop_vars: A (possibly nested) tuple, namedtuple or list of numpy array,
    <code>Tensor</code>, and <code>TensorArray</code> objects.
  shape_invariants: The shape invariants for the loop variables.
  parallel_iterations: The number of iterations allowed to run in parallel.
    It must be a positive integer.
  back_prop: Whether backprop is enabled for this while loop.
  swap_memory: Whether GPU-CPU memory swap is enabled for this loop.
  name: Optional name prefix for the returned tensors.</p>
<p>Returns:
  The output tensors for the loop variables after the loop. When the length
  of <code>loop_vars</code> is 1 this is a Tensor, TensorArray or IndexedSlice and when
  the length of <code>loop_vars</code> is greater than 1 it returns a list.</p>
<p>Raises:
  TypeError: if <code>cond</code> or <code>body</code> is not callable.
  ValueError: if <code>loop_vars</code> is empty.</p>
<p>Example:</p>
<p><code>python
  i = tf.constant(0)
  c = lambda i: tf.less(i, 10)
  b = lambda i: tf.add(i, 1)
  r = tf.while_loop(c, b, [i])</code></p>
<p>Example with nesting and a namedtuple:</p>
<p><code>python
  import collections
  Pair = collections.namedtuple('Pair', 'j, k')
  ijk_0 = (tf.constant(0), Pair(tf.constant(1), tf.constant(2)))
  c = lambda i, p: i &lt; 10
  b = lambda i, p: (i + 1, Pair((p.j + p.k), (p.j - p.k)))
  ijk_final = tf.while_loop(c, b, ijk_0)</code></p>
<p>Example using shape_invariants:</p>
<p><code>python
  i0 = tf.constant(0)
  m0 = tf.ones([2, 2])
  c = lambda i, m: i &lt; 10
  b = lambda i, m: [i+1, tf.concat(0, [m, m])]
  tf.while_loop(
      c, b, loop_vars=[i0, m0],
      shape_invariants=[i0.get_shape(), tensor_shape.TensorShape([None, 2])])</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.while_loop', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.while_loop" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.with_space_to_batch">
    <p>def <span class="ident">with_space_to_batch</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.with_space_to_batch(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnwith_space_to_batch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnwith_space_to_batch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.with_space_to_batch(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnwith_space_to_batch</strong></p>
<div class="codehilite"><pre><span></span>Performs `op` on the space-to-batch representation of `input`.
</pre></div>


<p>This has the effect of transforming sliding window operations into the
corresponding "atrous" operation in which the input is sampled at the
specified <code>dilation_rate</code>.</p>
<p>In the special case that <code>dilation_rate</code> is uniformly 1, this simply returns:</p>
<p>op(input, num_spatial_dims, padding)</p>
<p>Otherwise, it returns:</p>
<p>batch_to_space_nd(
    op(space_to_batch_nd(input, adjusted_dilation_rate, adjusted_paddings),
       num_spatial_dims,
       "VALID")
    adjusted_dilation_rate,
    adjusted_crops),</p>
<p>where:</p>
<p>adjusted_dilation_rate is an int64 tensor of shape [max(spatial_dims)],
  adjusted_{paddings,crops} are int64 tensors of shape [max(spatial_dims), 2]</p>
<p>defined as follows:</p>
<p>We first define two int64 tensors <code>paddings</code> and <code>crops</code> of shape
<code>[num_spatial_dims, 2]</code> based on the value of <code>padding</code> and the spatial
dimensions of the <code>input</code>:</p>
<p>If <code>padding = "VALID"</code>, then:</p>
<p>paddings, crops = required_space_to_batch_paddings(
    input_shape[spatial_dims],
    dilation_rate)</p>
<p>If <code>padding = "SAME"</code>, then:</p>
<p>dilated_filter_shape =
    filter_shape + (filter_shape - 1) * (dilation_rate - 1)</p>
<p>paddings, crops = required_space_to_batch_paddings(
    input_shape[spatial_dims],
    dilation_rate,
    [(dilated_filter_shape - 1) // 2,
     dilated_filter_shape - 1 - (dilated_filter_shape - 1) // 2])</p>
<p>Because <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> assume that the spatial
dimensions are contiguous starting at the second dimension, but the specified
<code>spatial_dims</code> may not be, we must adjust <code>dilation_rate</code>, <code>paddings</code> and
<code>crops</code> in order to be usable with these operations.  For a given dimension,
if the block size is 1, and both the starting and ending padding and crop
amounts are 0, then space_to_batch_nd effectively leaves that dimension alone,
which is what is needed for dimensions not part of <code>spatial_dims</code>.
Furthermore, <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> handle this case
efficiently for any number of leading and trailing dimensions.</p>
<p>For 0 &lt;= i &lt; len(spatial_dims), we assign:</p>
<p>adjusted_dilation_rate[spatial_dims[i] - 1] = dilation_rate[i]
  adjusted_paddings[spatial_dims[i] - 1, :] = paddings[i, :]
  adjusted_crops[spatial_dims[i] - 1, :] = crops[i, :]</p>
<p>All unassigned values of <code>adjusted_dilation_rate</code> default to 1, while all
unassigned values of <code>adjusted_paddings</code> and <code>adjusted_crops</code> default to 0.</p>
<p>Note in the case that <code>dilation_rate</code> is not uniformly 1, specifying "VALID"
padding is equivalent to specifying <code>padding = "SAME"</code> with a filter_shape of
<code>[1]*N</code>.</p>
<p>Advanced usage. Note the following optimization: A sequence of
<code>with_space_to_batch</code> operations with identical (not uniformly 1)
<code>dilation_rate</code> parameters and "VALID" padding</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", op_1)
  ...
  net = with_space_to_batch(net, dilation_rate, "VALID", op_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _):
    result = op_1(converted_input, num_spatial_dims, "VALID")
    ...
    result = op_k(result, num_spatial_dims, "VALID")</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", combined_op)</p>
<p>This eliminates the overhead of <code>k-1</code> calls to <code>space_to_batch_nd</code> and
<code>batch_to_space_nd</code>.</p>
<p>Similarly, a sequence of <code>with_space_to_batch</code> operations with identical (not
uniformly 1) <code>dilation_rate</code> parameters, "SAME" padding, and odd filter
dimensions</p>
<p>net = with_space_to_batch(net, dilation_rate, "SAME", op_1, filter_shape_1)
  ...
  net = with_space_to_batch(net, dilation_rate, "SAME", op_k, filter_shape_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _):
    result = op_1(converted_input, num_spatial_dims, "SAME")
    ...
    result = op_k(result, num_spatial_dims, "SAME")</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", combined_op)</p>
<p>Args:
  input: Tensor of rank &gt; max(spatial_dims).
  dilation_rate: int32 Tensor of <em>known</em> shape [num_spatial_dims].
  padding: str constant equal to "VALID" or "SAME"
  op: Function that maps (input, num_spatial_dims, padding) -&gt; output
  filter_shape: If padding = "SAME", specifies the shape of the convolution
    kernel/pooling window as an integer Tensor of shape [&gt;=num_spatial_dims].
    If padding = "VALID", filter_shape is ignored and need not be specified.
  spatial_dims: Monotonically increasing sequence of <code>num_spatial_dims</code>
    integers (which are &gt;= 1) specifying the spatial dimensions of <code>input</code>
    and output.  Defaults to: <code>range(1, num_spatial_dims+1)</code>.</p>
<p>Returns:
  The output Tensor as described above.</p>
<p>Raises:
  ValueError: if <code>padding</code> is invalid or the arguments are incompatible.
  ValueError: if <code>spatial_dims</code> are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.with_space_to_batch', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.with_space_to_batch" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.with_space_to_batch_conv2d_layer">
    <p>def <span class="ident">with_space_to_batch_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.with_space_to_batch_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.with_space_to_batch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.with_space_to_batch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.with_space_to_batch_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.with_space_to_batch`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.with_space_to_batch</strong></p>
<div class="codehilite"><pre><span></span>Performs `op` on the space-to-batch representation of `input`.
</pre></div>


<p>This has the effect of transforming sliding window operations into the
corresponding "atrous" operation in which the input is sampled at the
specified <code>dilation_rate</code>.</p>
<p>In the special case that <code>dilation_rate</code> is uniformly 1, this simply returns:</p>
<p>op(input, num_spatial_dims, padding)</p>
<p>Otherwise, it returns:</p>
<p>batch_to_space_nd(
    op(space_to_batch_nd(input, adjusted_dilation_rate, adjusted_paddings),
       num_spatial_dims,
       "VALID")
    adjusted_dilation_rate,
    adjusted_crops),</p>
<p>where:</p>
<p>adjusted_dilation_rate is an int64 tensor of shape [max(spatial_dims)],
  adjusted_{paddings,crops} are int64 tensors of shape [max(spatial_dims), 2]</p>
<p>defined as follows:</p>
<p>We first define two int64 tensors <code>paddings</code> and <code>crops</code> of shape
<code>[num_spatial_dims, 2]</code> based on the value of <code>padding</code> and the spatial
dimensions of the <code>input</code>:</p>
<p>If <code>padding = "VALID"</code>, then:</p>
<p>paddings, crops = required_space_to_batch_paddings(
    input_shape[spatial_dims],
    dilation_rate)</p>
<p>If <code>padding = "SAME"</code>, then:</p>
<p>dilated_filter_shape =
    filter_shape + (filter_shape - 1) * (dilation_rate - 1)</p>
<p>paddings, crops = required_space_to_batch_paddings(
    input_shape[spatial_dims],
    dilation_rate,
    [(dilated_filter_shape - 1) // 2,
     dilated_filter_shape - 1 - (dilated_filter_shape - 1) // 2])</p>
<p>Because <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> assume that the spatial
dimensions are contiguous starting at the second dimension, but the specified
<code>spatial_dims</code> may not be, we must adjust <code>dilation_rate</code>, <code>paddings</code> and
<code>crops</code> in order to be usable with these operations.  For a given dimension,
if the block size is 1, and both the starting and ending padding and crop
amounts are 0, then space_to_batch_nd effectively leaves that dimension alone,
which is what is needed for dimensions not part of <code>spatial_dims</code>.
Furthermore, <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> handle this case
efficiently for any number of leading and trailing dimensions.</p>
<p>For 0 &lt;= i &lt; len(spatial_dims), we assign:</p>
<p>adjusted_dilation_rate[spatial_dims[i] - 1] = dilation_rate[i]
  adjusted_paddings[spatial_dims[i] - 1, :] = paddings[i, :]
  adjusted_crops[spatial_dims[i] - 1, :] = crops[i, :]</p>
<p>All unassigned values of <code>adjusted_dilation_rate</code> default to 1, while all
unassigned values of <code>adjusted_paddings</code> and <code>adjusted_crops</code> default to 0.</p>
<p>Note in the case that <code>dilation_rate</code> is not uniformly 1, specifying "VALID"
padding is equivalent to specifying <code>padding = "SAME"</code> with a filter_shape of
<code>[1]*N</code>.</p>
<p>Advanced usage. Note the following optimization: A sequence of
<code>with_space_to_batch</code> operations with identical (not uniformly 1)
<code>dilation_rate</code> parameters and "VALID" padding</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", op_1)
  ...
  net = with_space_to_batch(net, dilation_rate, "VALID", op_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _):
    result = op_1(converted_input, num_spatial_dims, "VALID")
    ...
    result = op_k(result, num_spatial_dims, "VALID")</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", combined_op)</p>
<p>This eliminates the overhead of <code>k-1</code> calls to <code>space_to_batch_nd</code> and
<code>batch_to_space_nd</code>.</p>
<p>Similarly, a sequence of <code>with_space_to_batch</code> operations with identical (not
uniformly 1) <code>dilation_rate</code> parameters, "SAME" padding, and odd filter
dimensions</p>
<p>net = with_space_to_batch(net, dilation_rate, "SAME", op_1, filter_shape_1)
  ...
  net = with_space_to_batch(net, dilation_rate, "SAME", op_k, filter_shape_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _):
    result = op_1(converted_input, num_spatial_dims, "SAME")
    ...
    result = op_k(result, num_spatial_dims, "SAME")</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", combined_op)</p>
<p>Args:
  input: Tensor of rank &gt; max(spatial_dims).
  dilation_rate: int32 Tensor of <em>known</em> shape [num_spatial_dims].
  padding: str constant equal to "VALID" or "SAME"
  op: Function that maps (input, num_spatial_dims, padding) -&gt; output
  filter_shape: If padding = "SAME", specifies the shape of the convolution
    kernel/pooling window as an integer Tensor of shape [&gt;=num_spatial_dims].
    If padding = "VALID", filter_shape is ignored and need not be specified.
  spatial_dims: Monotonically increasing sequence of <code>num_spatial_dims</code>
    integers (which are &gt;= 1) specifying the spatial dimensions of <code>input</code>
    and output.  Defaults to: <code>range(1, num_spatial_dims+1)</code>.</p>
<p>Returns:
  The output Tensor as described above.</p>
<p>Raises:
  ValueError: if <code>padding</code> is invalid or the arguments are incompatible.
  ValueError: if <code>spatial_dims</code> are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.with_space_to_batch_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.with_space_to_batch_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.with_space_to_batch_layer">
    <p>def <span class="ident">with_space_to_batch_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.with_space_to_batch_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.with_space_to_batch</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.with_space_to_batch(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.with_space_to_batch_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.with_space_to_batch`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.with_space_to_batch</strong></p>
<div class="codehilite"><pre><span></span>Performs `op` on the space-to-batch representation of `input`.
</pre></div>


<p>This has the effect of transforming sliding window operations into the
corresponding "atrous" operation in which the input is sampled at the
specified <code>dilation_rate</code>.</p>
<p>In the special case that <code>dilation_rate</code> is uniformly 1, this simply returns:</p>
<p>op(input, num_spatial_dims, padding)</p>
<p>Otherwise, it returns:</p>
<p>batch_to_space_nd(
    op(space_to_batch_nd(input, adjusted_dilation_rate, adjusted_paddings),
       num_spatial_dims,
       "VALID")
    adjusted_dilation_rate,
    adjusted_crops),</p>
<p>where:</p>
<p>adjusted_dilation_rate is an int64 tensor of shape [max(spatial_dims)],
  adjusted_{paddings,crops} are int64 tensors of shape [max(spatial_dims), 2]</p>
<p>defined as follows:</p>
<p>We first define two int64 tensors <code>paddings</code> and <code>crops</code> of shape
<code>[num_spatial_dims, 2]</code> based on the value of <code>padding</code> and the spatial
dimensions of the <code>input</code>:</p>
<p>If <code>padding = "VALID"</code>, then:</p>
<p>paddings, crops = required_space_to_batch_paddings(
    input_shape[spatial_dims],
    dilation_rate)</p>
<p>If <code>padding = "SAME"</code>, then:</p>
<p>dilated_filter_shape =
    filter_shape + (filter_shape - 1) * (dilation_rate - 1)</p>
<p>paddings, crops = required_space_to_batch_paddings(
    input_shape[spatial_dims],
    dilation_rate,
    [(dilated_filter_shape - 1) // 2,
     dilated_filter_shape - 1 - (dilated_filter_shape - 1) // 2])</p>
<p>Because <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> assume that the spatial
dimensions are contiguous starting at the second dimension, but the specified
<code>spatial_dims</code> may not be, we must adjust <code>dilation_rate</code>, <code>paddings</code> and
<code>crops</code> in order to be usable with these operations.  For a given dimension,
if the block size is 1, and both the starting and ending padding and crop
amounts are 0, then space_to_batch_nd effectively leaves that dimension alone,
which is what is needed for dimensions not part of <code>spatial_dims</code>.
Furthermore, <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> handle this case
efficiently for any number of leading and trailing dimensions.</p>
<p>For 0 &lt;= i &lt; len(spatial_dims), we assign:</p>
<p>adjusted_dilation_rate[spatial_dims[i] - 1] = dilation_rate[i]
  adjusted_paddings[spatial_dims[i] - 1, :] = paddings[i, :]
  adjusted_crops[spatial_dims[i] - 1, :] = crops[i, :]</p>
<p>All unassigned values of <code>adjusted_dilation_rate</code> default to 1, while all
unassigned values of <code>adjusted_paddings</code> and <code>adjusted_crops</code> default to 0.</p>
<p>Note in the case that <code>dilation_rate</code> is not uniformly 1, specifying "VALID"
padding is equivalent to specifying <code>padding = "SAME"</code> with a filter_shape of
<code>[1]*N</code>.</p>
<p>Advanced usage. Note the following optimization: A sequence of
<code>with_space_to_batch</code> operations with identical (not uniformly 1)
<code>dilation_rate</code> parameters and "VALID" padding</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", op_1)
  ...
  net = with_space_to_batch(net, dilation_rate, "VALID", op_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _):
    result = op_1(converted_input, num_spatial_dims, "VALID")
    ...
    result = op_k(result, num_spatial_dims, "VALID")</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", combined_op)</p>
<p>This eliminates the overhead of <code>k-1</code> calls to <code>space_to_batch_nd</code> and
<code>batch_to_space_nd</code>.</p>
<p>Similarly, a sequence of <code>with_space_to_batch</code> operations with identical (not
uniformly 1) <code>dilation_rate</code> parameters, "SAME" padding, and odd filter
dimensions</p>
<p>net = with_space_to_batch(net, dilation_rate, "SAME", op_1, filter_shape_1)
  ...
  net = with_space_to_batch(net, dilation_rate, "SAME", op_k, filter_shape_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _):
    result = op_1(converted_input, num_spatial_dims, "SAME")
    ...
    result = op_k(result, num_spatial_dims, "SAME")</p>
<p>net = with_space_to_batch(net, dilation_rate, "VALID", combined_op)</p>
<p>Args:
  input: Tensor of rank &gt; max(spatial_dims).
  dilation_rate: int32 Tensor of <em>known</em> shape [num_spatial_dims].
  padding: str constant equal to "VALID" or "SAME"
  op: Function that maps (input, num_spatial_dims, padding) -&gt; output
  filter_shape: If padding = "SAME", specifies the shape of the convolution
    kernel/pooling window as an integer Tensor of shape [&gt;=num_spatial_dims].
    If padding = "VALID", filter_shape is ignored and need not be specified.
  spatial_dims: Monotonically increasing sequence of <code>num_spatial_dims</code>
    integers (which are &gt;= 1) specifying the spatial dimensions of <code>input</code>
    and output.  Defaults to: <code>range(1, num_spatial_dims+1)</code>.</p>
<p>Returns:
  The output Tensor as described above.</p>
<p>Raises:
  ValueError: if <code>padding</code> is invalid or the arguments are incompatible.
  ValueError: if <code>spatial_dims</code> are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.with_space_to_batch_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.with_space_to_batch_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.write_file">
    <p>def <span class="ident">write_file</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.write_file(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.write_file</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.write_file(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.write_file(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.write_file</strong></p>
<div class="codehilite"><pre><span></span>Writes contents to the file at input filename. Creates file if not existing.
</pre></div>


<p>Args:
  filename: A <code>Tensor</code> of type <code>string</code>.
    scalar. The name of the file to which we write the contents.
  contents: A <code>Tensor</code> of type <code>string</code>.
    scalar. The content to be written to the output file.
  name: A name for the operation (optional).</p>
<p>Returns:
  The created Operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.write_file', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.write_file" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b">
    <p>def <span class="ident">xw_plus_b</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnxw_plus_b</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnxw_plus_b(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnxw_plus_b</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer">
    <p>def <span class="ident">xw_plus_b_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.xw_plus_b</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.xw_plus_b(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.xw_plus_b</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_layer">
    <p>def <span class="ident">xw_plus_b_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.xw_plus_b</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.xw_plus_b(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.xw_plus_b</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_v1">
    <p>def <span class="ident">xw_plus_b_v1</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_v1(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnxw_plus_b_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnxw_plus_b_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_v1(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnxw_plus_b_v1</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>This is a deprecated version of that will soon be removed.</p>
<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b_v1" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer">
    <p>def <span class="ident">xw_plus_b_v1_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_v1_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.xw_plus_b_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.xw_plus_b_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_v1_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b_v1`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.xw_plus_b_v1</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>This is a deprecated version of that will soon be removed.</p>
<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b_v1" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer">
    <p>def <span class="ident">xw_plus_b_v1_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_v1_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.xw_plus_b_v1</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.xw_plus_b_v1(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.xw_plus_b_v1_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.xw_plus_b_v1`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.xw_plus_b_v1</strong></p>
<div class="codehilite"><pre><span></span>Computes matmul(x, weights) + biases.
</pre></div>


<p>This is a deprecated version of that will soon be removed.</p>
<p>Args:
  x: a 2D tensor.  Dimensions typically: batch, in_units
  weights: a 2D tensor.  Dimensions typically: in_units, out_units
  biases: a 1D tensor.  Dimensions: out_units
  name: A name for the operation (optional).  If not specified
    "xw_plus_b_v1" is used.</p>
<p>Returns:
  A 2-D Tensor computing matmul(x, weights) + biases.
  Dimensions typically: batch, out_units.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.xw_plus_b_v1_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zero_fraction">
    <p>def <span class="ident">zero_fraction</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zero_fraction(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.nnzero_fraction</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.nnzero_fraction(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zero_fraction(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.nnzero_fraction</strong></p>
<div class="codehilite"><pre><span></span>Returns the fraction of zeros in `value`.
</pre></div>


<p>If <code>value</code> is empty, the result is <code>nan</code>.</p>
<p>This is useful in summaries to measure and report sparsity.  For example,</p>
<p><code>python
    z = tf.Relu(...)
    summ = tf.scalar_summary('sparsity', tf.nn.zero_fraction(z))</code></p>
<p>Args:
  value: A tensor of numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  The fraction of zeros in <code>value</code>, with type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zero_fraction', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zero_fraction" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer">
    <p>def <span class="ident">zero_fraction_conv2d_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zero_fraction_conv2d_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.zero_fraction</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.zero_fraction(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zero_fraction_conv2d_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.zero_fraction`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.zero_fraction</strong></p>
<div class="codehilite"><pre><span></span>Returns the fraction of zeros in `value`.
</pre></div>


<p>If <code>value</code> is empty, the result is <code>nan</code>.</p>
<p>This is useful in summaries to measure and report sparsity.  For example,</p>
<p><code>python
    z = tf.Relu(...)
    summ = tf.scalar_summary('sparsity', tf.nn.zero_fraction(z))</code></p>
<p>Args:
  value: A tensor of numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  The fraction of zeros in <code>value</code>, with type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zero_fraction_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zero_fraction_layer">
    <p>def <span class="ident">zero_fraction_layer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zero_fraction_layer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.python.ops.nn.zero_fraction</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.python.ops.nn.zero_fraction(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zero_fraction_layer(*args, **kwargs)(x1)

    and the keyword argument `activation_fn` is set to `tf.nn.zero_fraction`.
</pre></div>


<p><strong>tensorflow.python.ops.nn.zero_fraction</strong></p>
<div class="codehilite"><pre><span></span>Returns the fraction of zeros in `value`.
</pre></div>


<p>If <code>value</code> is empty, the result is <code>nan</code>.</p>
<p>This is useful in summaries to measure and report sparsity.  For example,</p>
<p><code>python
    z = tf.Relu(...)
    summ = tf.scalar_summary('sparsity', tf.nn.zero_fraction(z))</code></p>
<p>Args:
  value: A tensor of numeric type.
  name: A name for the operation (optional).</p>
<p>Returns:
  The fraction of zeros in <code>value</code>, with type <code>float32</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zero_fraction_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zero_fraction_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeros">
    <p>def <span class="ident">zeros</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeros(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeros</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeros(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeros(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeros</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to zero.
</pre></div>


<p>This operation returns a tensor of type <code>dtype</code> with shape <code>shape</code> and
all elements set to zero.</p>
<p>For example:</p>
<p><code>python
tf.zeros([3, 4], tf.int32) ==&gt; [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]</code></p>
<p>Args:
  shape: Either a list of integers, or a 1-D <code>Tensor</code> of type <code>int32</code>.
  dtype: The type of an element in the resulting <code>Tensor</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to zero.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeros', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeros" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeros_initializer">
    <p>def <span class="ident">zeros_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeros_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeros_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeros_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeros_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeros_initializer</strong></p>
<div class="codehilite"><pre><span></span>An adaptor for zeros() to match the Initializer spec.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeros_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeros_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeros_like">
    <p>def <span class="ident">zeros_like</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeros_like(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeros_like</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeros_like(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeros_like(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeros_like</strong></p>
<div class="codehilite"><pre><span></span>Creates a tensor with all elements set to zero.
</pre></div>


<p>Given a single tensor (<code>tensor</code>), this operation returns a tensor of the
same type and shape as <code>tensor</code> with all elements set to zero. Optionally,
you can use <code>dtype</code> to specify a new type for the returned tensor.</p>
<p>For example:</p>
<p>```python</p>
<h1>'tensor' is [[1, 2, 3], [4, 5, 6]]</h1>
<p>tf.zeros_like(tensor) ==&gt; [[0, 0, 0], [0, 0, 0]]
```</p>
<p>Args:
  tensor: A <code>Tensor</code>.
  dtype: A type for the returned <code>Tensor</code>. Must be <code>float32</code>, <code>float64</code>,
  <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>complex64</code>, or <code>complex128</code>.
  name: A name for the operation (optional).
  optimize: if true, attempt to statically determine the shape of 'tensor'
  and encode it as a constant.</p>
<p>Returns:
  A <code>Tensor</code> with all elements set to zero.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeros_like', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeros_like" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.builder.TensorBuilder.zeta">
    <p>def <span class="ident">zeta</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeta(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tensorflow.zeta</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tensorflow.zeta(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>TensorBuilder.zeta(*args, **kwargs)(x1)
</pre></div>


<p><strong>tensorflow.zeta</strong></p>
<div class="codehilite"><pre><span></span>Compute the Hurwitz zeta function \\(\zeta(x, q)\\).
</pre></div>


<p>The Hurwitz zeta function is defined as:</p>
<p><code>\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}</code></p>
<p>Args:
  x: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.
  q: A <code>Tensor</code>. Must have the same type as <code>x</code>.
  name: A name for the operation (optional).</p>
<p>Returns:
  A <code>Tensor</code>. Has the same type as <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.builder.TensorBuilder.zeta', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.builder.TensorBuilder.zeta" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>

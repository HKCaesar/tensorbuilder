<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>tensorbuilder.patches.layers_patch API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.blacklist">blacklist</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.explanation">explanation</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.whitelist">whitelist</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.afine_layer_wrapper">afine_layer_wrapper</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.convolution_layer_wrapper">convolution_layer_wrapper</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.linear_conv2d_layer">linear_conv2d_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.linear_layer">linear_layer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.polynomial_layer">polynomial_layer</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder">LayerBuilder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Context">Context</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.__init__">__init__</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Dict">Dict</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Elif">Elif</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Else">Else</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.F">F</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.If">If</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.List">List</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.PatchAt">PatchAt</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Pipe">Pipe</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.ProblemType">ProblemType</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.ReadList">ReadList</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Register">Register</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Register0">Register0</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Register2">Register2</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Register3">Register3</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Register4">Register4</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Register5">Register5</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.RegisterAt">RegisterAt</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.RegisterMethod">RegisterMethod</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Seq">Seq</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Set">Set</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then">Then</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then0">Then0</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then1">Then1</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then2">Then2</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then3">Then3</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then4">Then4</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Then5">Then5</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.ThenAt">ThenAt</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Tuple">Tuple</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Val">Val</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.With">With</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.Write">Write</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.adaptive_clipping_fn">adaptive_clipping_fn</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.apply_regularization">apply_regularization</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.avg_pool2d">avg_pool2d</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.batch_norm">batch_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.bias_add">bias_add</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.binary_svm_target">binary_svm_target</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.bow_encoder">bow_encoder</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.bucketize">bucketize</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.bucketized_column">bucketized_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.check_feature_columns">check_feature_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.conv2d">conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_in_plane">conv2d_in_plane</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_transpose">conv2d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.convolution">convolution</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d">convolution2d</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_in_plane">convolution2d_in_plane</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_transpose">convolution2d_transpose</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.create_feature_spec_for_parsing">create_feature_spec_for_parsing</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.crossed_column">crossed_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.deprecated">deprecated</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.deprecated_arg_values">deprecated_arg_values</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.dropout">dropout</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.embed_sequence">embed_sequence</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.embedding_column">embedding_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.embedding_lookup_unique">embedding_lookup_unique</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.experimental">experimental</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.flatten">flatten</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.fully_connected">fully_connected</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.get_default_binary_metrics_for_eval">get_default_binary_metrics_for_eval</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_column">hashed_embedding_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup">hashed_embedding_lookup</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup_sparse">hashed_embedding_lookup_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.infer_real_valued_columns">infer_real_valued_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.input_from_feature_columns">input_from_feature_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.joint_weighted_sum_from_feature_columns">joint_weighted_sum_from_feature_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.l1_l2_regularizer">l1_l2_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.l1_regularizer">l1_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.l2_regularizer">l2_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.layer_norm">layer_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.legacy_fully_connected">legacy_fully_connected</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.make_all">make_all</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.make_place_holder_tensors_for_base_features">make_place_holder_tensors_for_base_features</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.max_pool2d">max_pool2d</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.multi_class_target">multi_class_target</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_column">one_hot_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_encoding">one_hot_encoding</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.optimize_loss">optimize_loss</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_examples">parse_feature_columns_from_examples</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_sequence_examples">parse_feature_columns_from_sequence_examples</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.pool">pool</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.real_valued_column">real_valued_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.regression_target">regression_target</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.repeat">repeat</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.safe_embedding_lookup_sparse">safe_embedding_lookup_sparse</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.separable_conv2d">separable_conv2d</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.separable_convolution2d">separable_convolution2d</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.sequence_input_from_feature_columns">sequence_input_from_feature_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.shared_embedding_columns">shared_embedding_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.softmax">softmax</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_hash_bucket">sparse_column_with_hash_bucket</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_integerized_feature">sparse_column_with_integerized_feature</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_keys">sparse_column_with_keys</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.sparse_feature_cross">sparse_feature_cross</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.stack">stack</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.sum_regularizer">sum_regularizer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activation">summarize_activation</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activations">summarize_activations</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.summarize_collection">summarize_collection</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensor">summarize_tensor</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensors">summarize_tensors</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.transform_features">transform_features</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.unit_norm">unit_norm</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.variance_scaling_initializer">variance_scaling_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sparse_column">weighted_sparse_column</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sum_from_feature_columns">weighted_sum_from_feature_columns</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer">xavier_initializer</a></li>
    <li class="mono"><a href="#tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer_conv2d">xavier_initializer_conv2d</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">tensorbuilder.patches.layers_patch</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch" class="source">
    <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">tensorflow.contrib</span> <span class="kn">import</span> <span class="n">layers</span>
<span class="kn">from</span> <span class="nn">tensorflow.contrib.layers</span> <span class="kn">import</span> <span class="n">fully_connected</span><span class="p">,</span> <span class="n">convolution2d</span>
<span class="kn">from</span> <span class="nn">tensorbuilder</span> <span class="kn">import</span> <span class="n">TensorBuilder</span>
<span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">utils</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Builder</span>

<span class="n">blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;relu_layer&quot;</span><span class="p">]</span>

<span class="c1">#########################</span>
<span class="c1">## LayerBuilder</span>
<span class="c1">#########################</span>

<span class="k">class</span> <span class="nc">LayerBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for LayerBuilder.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">TensorBuilder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&gt;&gt;</span> <span class="n">TensorBuilder</span><span class="p">()</span>

<span class="c1">#Add property to TensorBuilder</span>
<span class="n">TensorBuilder</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">LayerBuilder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">))</span>

<span class="c1"># patch all layer functions</span>
<span class="n">LayerBuilder</span><span class="o">.</span><span class="n">PatchAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">module_alias</span><span class="o">=</span><span class="s2">&quot;tf.contrib.layers&quot;</span><span class="p">,</span> <span class="n">return_type_predicate</span><span class="o">=</span><span class="n">TensorBuilder</span><span class="p">)</span>

<span class="c1">#########################</span>
<span class="c1">## Layer methods</span>
<span class="c1">#########################</span>


<span class="n">whitelist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;convolution2d&quot;</span><span class="p">,</span> <span class="s2">&quot;max_pool2d&quot;</span><span class="p">,</span> <span class="s2">&quot;avg_pool2d&quot;</span><span class="p">,</span> <span class="s2">&quot;flatten&quot;</span><span class="p">]</span>
<span class="n">TensorBuilder</span><span class="o">.</span><span class="n">PatchAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">module_alias</span><span class="o">=</span><span class="s2">&quot;tf.contrib.layers&quot;</span><span class="p">,</span> <span class="n">whitelist_predicate</span><span class="o">=</span><span class="n">whitelist</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">TensorBuilder</span><span class="o">.</span><span class="n">convolution2d</span>


<span class="c1">#########################</span>
<span class="c1">## Afine layers</span>
<span class="c1">#########################</span>

<span class="k">def</span> <span class="nf">afine_layer_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>

<span class="n">TensorBuilder</span><span class="o">.</span><span class="n">PatchAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="p">,</span>
    <span class="n">method_wrapper</span><span class="o">=</span><span class="n">afine_layer_wrapper</span><span class="p">,</span>
    <span class="n">method_name_modifier</span> <span class="o">=</span> <span class="s2">&quot;{0}_layer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
    <span class="n">blacklist_predicate</span><span class="o">=</span><span class="n">blacklist</span><span class="p">,</span>
    <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;and the keyword argument `activation_fn` is set to `tf.nn.{original_name}`.&quot;&quot;&quot;</span>
<span class="p">)</span>


<span class="c1">#########################</span>
<span class="c1">## Convolutional layers</span>
<span class="c1">#########################</span>

<span class="k">def</span> <span class="nf">convolution_layer_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">convolution2d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>

<span class="n">TensorBuilder</span><span class="o">.</span><span class="n">PatchAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="p">,</span>
    <span class="n">method_wrapper</span><span class="o">=</span><span class="n">convolution_layer_wrapper</span><span class="p">,</span>
    <span class="n">method_name_modifier</span> <span class="o">=</span> <span class="s2">&quot;{0}_conv2d_layer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
    <span class="n">blacklist_predicate</span><span class="o">=</span><span class="n">blacklist</span><span class="p">,</span>
    <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;and the keyword argument `activation_fn` is set to `tf.nn.{original_name}`.&quot;&quot;&quot;</span>
<span class="p">)</span>

<span class="c1">#########################</span>
<span class="c1">## Custom Methods</span>
<span class="c1">#########################</span>

<span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;and the keyword argument `activation_fn` is set to `None`.&quot;&quot;&quot;</span>

<span class="nd">@TensorBuilder.Register</span><span class="p">(</span><span class="s2">&quot;tf.contrib.layers&quot;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;linear_layer&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">fully_connected</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span> <span class="c1">#, _return_type=TensorBuilder)</span>
<span class="k">def</span> <span class="nf">linear_layer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nd">@TensorBuilder.Register</span><span class="p">(</span><span class="s2">&quot;tf.contrib.layers&quot;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;linear_conv2d_layer&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">convolution2d</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span> <span class="c1">#, _return_type=TensorBuilder)</span>
<span class="k">def</span> <span class="nf">linear_conv2d_layer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_polynomial</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pows</span> <span class="o">=</span> <span class="p">[</span> <span class="n">tf</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">tensor</span><span class="p">[:,</span> <span class="n">n</span><span class="p">],</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">pows</span><span class="p">))</span>

<span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">However, it uses an activation function of the form</span>
<span class="s2">```</span>
<span class="s2">y(i) = z(i)^(i+1)</span>
<span class="s2">```</span>
<span class="s2">where `z = w*x + b`</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@TensorBuilder.Register</span><span class="p">(</span><span class="s2">&quot;tensorbuilder&quot;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;polynomial_layer&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">fully_connected</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span> <span class="c1">#, _return_type=TensorBuilder)</span>
<span class="k">def</span> <span class="nf">polynomial_layer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_polynomial</span>
    <span class="k">return</span> <span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="tensorbuilder.patches.layers_patch.blacklist" class="name">var <span class="ident">blacklist</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="tensorbuilder.patches.layers_patch.explanation" class="name">var <span class="ident">explanation</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="tensorbuilder.patches.layers_patch.whitelist" class="name">var <span class="ident">whitelist</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.afine_layer_wrapper">
    <p>def <span class="ident">afine_layer_wrapper</span>(</p><p>f)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.afine_layer_wrapper', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.afine_layer_wrapper" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">afine_layer_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.convolution_layer_wrapper">
    <p>def <span class="ident">convolution_layer_wrapper</span>(</p><p>f)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.convolution_layer_wrapper', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.convolution_layer_wrapper" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">convolution_layer_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">convolution2d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.linear_conv2d_layer">
    <p>def <span class="ident">linear_conv2d_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.linear_conv2d_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.linear_conv2d_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.Register</span><span class="p">(</span><span class="s2">&quot;tf.contrib.layers&quot;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;linear_conv2d_layer&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">convolution2d</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span> <span class="c1">#, _return_type=TensorBuilder)</span>
<span class="k">def</span> <span class="nf">linear_conv2d_layer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.linear_layer">
    <p>def <span class="ident">linear_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.linear_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.linear_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.Register</span><span class="p">(</span><span class="s2">&quot;tf.contrib.layers&quot;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;linear_layer&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">fully_connected</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span> <span class="c1">#, _return_type=TensorBuilder)</span>
<span class="k">def</span> <span class="nf">linear_layer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.polynomial_layer">
    <p>def <span class="ident">polynomial_layer</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.polynomial_layer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.polynomial_layer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@TensorBuilder.Register</span><span class="p">(</span><span class="s2">&quot;tensorbuilder&quot;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;polynomial_layer&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">fully_connected</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span> <span class="c1">#, _return_type=TensorBuilder)</span>
<span class="k">def</span> <span class="nf">polynomial_layer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;activation_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_polynomial</span>
    <span class="k">return</span> <span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="tensorbuilder.patches.layers_patch.LayerBuilder" class="name">class <span class="ident">LayerBuilder</span></p>
      
  
    <div class="desc"><p>docstring for LayerBuilder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LayerBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;docstring for LayerBuilder.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">TensorBuilder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&gt;&gt;</span> <span class="n">TensorBuilder</span><span class="p">()</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#tensorbuilder.patches.layers_patch.LayerBuilder">LayerBuilder</a></li>
          <li>phi.builder.Builder</li>
          <li>phi.dsl.Expression</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Context">
    <p>def <span class="ident">Context</span>(</p><p>*args)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>Builder Core</strong>. Also available as a global function as <code>phi.Context</code>.</p>
<p>Returns the context object of the current <code>dsl.With</code> statemente.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong>: By design <code>Context</code> accepts any number of arguments and completely ignores them.</li>
</ul>
<p>This is a classmethod and it doesnt return a <code>Builder</code>/<code>Expression</code> by design so it can be called directly:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span>
        <span class="n">read_file</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Here we called <code>Context</code> with no arguments to get the context back, however, since you can also give this function an argument (which it will ignore) it can be passed to the DSL so we can rewrite the previous as:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Obj</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span>
        <span class="n">Context</span><span class="p">,</span> <span class="c1"># f</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p><code>Context</code> yields an exception when used outside of a <code>With</code> block.</p>
<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Context', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Context" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">Context</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ilder Core**. Also available as a global function as `phi.Context`.</span>
<span class="sd">rns the context object of the current `dsl.With` statemente.</span>
<span class="sd">guments**</span>
<span class="sd">*args**: By design `Context` accepts any number of arguments and completely ignores them.</span>
<span class="sd"> is a classmethod and it doesnt return a `Builder`/`Expression` by design so it can be called directly:</span>
<span class="sd">from phi import P, Context, Obj</span>
<span class="sd">def read_file(z):</span>
<span class="sd">    f = Context()</span>
<span class="sd">    return f.read()</span>
<span class="sd">lines = P.Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    P.With( open,</span>
<span class="sd">        read_file,</span>
<span class="sd">        Obj.split(&quot;\\n&quot;)</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd"> we called `Context` with no arguments to get the context back, however, since you can also give this function an argument (which it will ignore) it can be passed to the DSL so we can rewrite the previous as:</span>
<span class="sd">from phi import P, Context, Obj</span>
<span class="sd">lines = P.Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    P.With( open,</span>
<span class="sd">        Context, # f</span>
<span class="sd">        Obj.read()</span>
<span class="sd">        Obj.split(&quot;\\n&quot;)</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">text` yields an exception when used outside of a `With` block.</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Obj`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_WithContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span> <span class="ow">is</span> <span class="n">utils</span><span class="o">.</span><span class="n">NO_VALUE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot use &#39;Context&#39; outside of a &#39;With&#39; block&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_WithContextManager</span><span class="o">.</span><span class="n">WITH_GLOBAL_CONTEXT</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="tensorbuilder.patches.layers_patch.LayerBuilder.Obj" class="name">var <span class="ident">Obj</span></p>
            

            
  
    <div class="desc"><p><code>Obj</code> is a <code>property</code> that returns an object that defines the <code>__getattr__</code> method which when called helps you create a partial that emulates a method call. The following expression</p>
<div class="codehilite"><pre><span></span>Obj.some_method(x1, x2, ...)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda obj: obj.some_method(x1, x2, ...)
</pre></div>


<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">assert</span> <span class="s2">&quot;hello world&quot;</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;  HELLO HELLO {0}     &quot;</span><span class="p">,</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;WORLD&quot;</span><span class="p">),</span>  <span class="c1"># &quot;   HELLO HELLO WORLD     &quot;</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>          <span class="c1"># &quot;HELLO HELLO WORLD&quot;</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>           <span class="c1"># &quot;hello hello world&quot;</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>        <span class="c1"># [&quot;hello&quot;, &quot;hello&quot;, &quot;world&quot;]</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>    <span class="c1"># 2</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Rec</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write">dsl.Write</a></li>
<li><code>phi.builder.Builder.Write</code></li>
</ul></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.patches.layers_patch.LayerBuilder.Read" class="name">var <span class="ident">Read</span></p>
            

            
  
    <div class="desc"><p>Giving names and saving parts of your computation to use then latter is useful to say the least. In Phi the expression</p>
<div class="codehilite"><pre><span></span>Write(x = expr)
</pre></div>


<p>creates a reference <code>x</code> given the value of <code>expr</code> which you can call latter. To read the previous you would use any of the following expressions</p>
<div class="codehilite"><pre><span></span>Read(&#39;x&#39;)
Read.x
</pre></div>


<h3>Example</h3>
<p>Lets see a common situation where you would use this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Seq</span><span class="p">,</span> <span class="n">Read</span><span class="p">,</span> <span class="n">Write</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">ref</span> <span class="o">=</span> <span class="n">f1</span><span class="p">),</span>
    <span class="n">f2</span><span class="p">,</span>
    <span class="n">List</span><span class="p">(</span>
        <span class="n">f3</span>
    <span class="p">,</span>
        <span class="n">Seq</span><span class="p">(</span>
            <span class="n">Read</span><span class="p">(</span><span class="s1">&#39;ref&#39;</span><span class="p">),</span>
            <span class="n">f4</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Here you <em>save</em> the value outputed by <code>fun_1</code> and the load it as the initial value of the second branch. In normal python the previous would be <em>almost</em> equivalent to</p>
<div class="codehilite"><pre><span></span>x = f1(input)
ref = x
x = f2(x)

result = [
    f3(x)
,
    f4(ref)
]
</pre></div></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.patches.layers_patch.LayerBuilder.Rec" class="name">var <span class="ident">Rec</span></p>
            

            
  
    <div class="desc"><p><code>Rec</code> is a <code>property</code> that returns an object that defines the <code>__getattr__</code> and <code>__getitem__</code> methods which when called help you create lambdas that emulates a field access. The following expression</p>
<div class="codehilite"><pre><span></span>Rec.some_field
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda rec: rec.some_field
</pre></div>


<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Rec</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">flip_cords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">assert</span> <span class="mi">4</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>         <span class="c1"># point(x=1, y=2)</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">flip_cords</span><span class="p">(),</span>    <span class="c1"># point(x=2, y=1)</span>
    <span class="n">Rec</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>               <span class="c1"># point.x = 2</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span>                <span class="c1"># 2 * 2 = 4</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><code>phi.builder.Builder.Read</code></li>
<li><code>phi.builder.Builder.Write</code></li>
</ul></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.patches.layers_patch.LayerBuilder.Ref" class="name">var <span class="ident">Ref</span></p>
            

            
  
    <div class="desc"><p>Returns an object that helps you to inmediatly create and <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read">read</a> <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Ref">references</a>.</p>
<p><strong>Creating Refences</strong></p>
<p>You can manually create a <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Ref">Ref</a> outside the DSL using <code>Ref</code> and then pass to as/to a <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Read">Read</a> or <a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Write">Write</a> expression. Here is a contrived example</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Ref</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

<span class="k">assert</span> <span class="p">[</span><span class="mi">600</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">},</span>  <span class="c1"># a = 2 + 1 = 3</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">},</span>  <span class="c1"># b = 3 * 2 = 6</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">r</span> <span class="p">},</span>  <span class="c1"># c = r = 6 * 100 = 600</span>
    <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">r</span><span class="p">()</span> <span class="o">==</span> <span class="mi">600</span>
</pre></div>


<p><strong>Reading Refences from the Current Context</strong></p>
<p>While the expression <code>Read.a</code> with return a function that will discard its argument and return the value of the reference <code>x</code> in the current context, the expression <code>Ref.x</code> will return the value inmediatly, this is useful when using it inside pyton lambdas.</p>
<div class="codehilite"><pre><span></span>Read.x(None) &lt;=&gt; Ref.x
</pre></div>


<p>As an example</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Ref</span>

<span class="k">assert</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">97</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">98</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;a b c&quot;</span><span class="p">,</span> <span class="n">Obj</span>
    <span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Write</span><span class="o">.</span><span class="n">keys</span>  <span class="c1"># keys = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
    <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">ord</span><span class="p">),</span>  <span class="c1"># [ord(&#39;a&#39;), ord(&#39;b&#39;), ord(&#39;c&#39;)] == [97, 98, 99]</span>
    <span class="k">lambda</span> <span class="n">it</span><span class="p">:</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ref</span><span class="o">.</span><span class="n">keys</span><span class="p">,</span> <span class="n">it</span><span class="p">),</span>  <span class="c1"># [(&#39;a&#39;, 97), (&#39;b&#39;, 98), (&#39;c&#39;, 99)]</span>
    <span class="nb">dict</span>   <span class="c1"># {&#39;a&#39;: 97, &#39;b&#39;: 98, &#39;c&#39;: 99}</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="tensorbuilder.patches.layers_patch.LayerBuilder.TensorBuilder" class="name">var <span class="ident">TensorBuilder</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f=&lt;function state_identity at 0x7f9366297b18&gt;)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">state_identity</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Dict">
    <p>def <span class="ident">Dict</span>(</p><p>self, **branches)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Dict', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Dict" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">branches</span><span class="p">):</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="p">:</span> <span class="n">_parse</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">ys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span> <span class="n">_RecordObject</span><span class="p">(</span><span class="o">**</span><span class="n">ys</span><span class="p">),</span> <span class="n">state</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Elif">
    <p>def <span class="ident">Elif</span>(</p><p>self, condition, *then, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>See <code>phi.dsl.Expression.If</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Elif', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Elif" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Elif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="o">*</span><span class="n">then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;See `phi.dsl.Expression.If`&quot;&quot;&quot;</span>
    <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ast</span>
    <span class="n">cond_f</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">then_f</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">then</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">else_f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">state_identity</span>
    <span class="n">next_else</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond_f</span><span class="p">,</span> <span class="n">then_f</span><span class="p">,</span> <span class="n">else_f</span><span class="p">)</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">_add_else</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="n">next_else</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_compile_if</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_ast</span> <span class="o">=</span> <span class="n">ast</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_root</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">return</span> <span class="n">expr</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Else">
    <p>def <span class="ident">Else</span>(</p><p>self, *Else, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>See <code>phi.dsl.Expression.If</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Else', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Else" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Else</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">Else</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;See `phi.dsl.Expression.If`&quot;&quot;&quot;</span>
    <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ast</span>
    <span class="n">next_else</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">Else</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">_add_else</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="n">next_else</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_compile_if</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.F">
    <p>def <span class="ident">F</span>(</p><p>self, expr)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.F', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.F" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span> <span class="o">&gt;&gt;</span> <span class="n">expr</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.If">
    <p>def <span class="ident">If</span>(</p><p>self, condition, *then, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>If</strong></p>
<div class="codehilite"><pre><span></span>If(Predicate, *Then)
</pre></div>


<p>Having conditionals expressions a necesity in every language, Phi includes the <code>If</code> expression for such a purpose.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>Predicate</strong> : a predicate expression uses to determine if the <code>Then</code> or <code>Else</code> branches should be used.</li>
<li><strong>*Then</strong> : an expression to be excecuted if the <code>Predicate</code> yields <code>True</code>, since this parameter is variadic you can stack expression and they will be interpreted as a tuple <code>phi.dsl.Seq</code>.</li>
</ul>
<p>This class also includes the <code>Elif</code> and <code>Else</code> methods which let you write branched conditionals in sequence, however the following rules apply</p>
<ul>
<li>If no branch is entered the whole expression behaves like the identity</li>
<li><code>Elif</code> can only be used after an <code>If</code> or another <code>Elif</code> expression</li>
<li>Many <code>Elif</code> expressions can be stacked sequentially</li>
<li><code>Else</code> can only be used after an <code>If</code> or <code>Elif</code> expression</li>
</ul>
<p><strong> Examples </strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">If</span>

<span class="k">assert</span> <span class="s2">&quot;Between 2 and 10&quot;</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">5</span><span class="p">,</span>
    <span class="n">If</span><span class="p">(</span><span class="n">P</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s2">&quot;Greater than 10&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">Elif</span><span class="p">(</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;Less than 2&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">Else</span><span class="p">(</span>
        <span class="s2">&quot;Between 2 and 10&quot;</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.If', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.If" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="o">*</span><span class="n">then</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**</span>
<span class="sd">If(Predicate, *Then)</span>
<span class="sd">ng conditionals expressions a necesity in every language, Phi includes the `If` expression for such a purpose.</span>
<span class="sd">guments**</span>
<span class="sd">Predicate** : a predicate expression uses to determine if the `Then` or `Else` branches should be used.</span>
<span class="sd">*Then** : an expression to be excecuted if the `Predicate` yields `True`, since this parameter is variadic you can stack expression and they will be interpreted as a tuple `phi.dsl.Seq`.</span>
<span class="sd"> class also includes the `Elif` and `Else` methods which let you write branched conditionals in sequence, however the following rules apply</span>
<span class="sd"> no branch is entered the whole expression behaves like the identity</span>
<span class="sd">lif` can only be used after an `If` or another `Elif` expression</span>
<span class="sd">ny `Elif` expressions can be stacked sequentially</span>
<span class="sd">lse` can only be used after an `If` or `Elif` expression</span>
<span class="sd">xamples **</span>
<span class="sd">from phi import P, If</span>
<span class="sd">assert &quot;Between 2 and 10&quot; == P.Pipe(</span>
<span class="sd">    5,</span>
<span class="sd">    If(P &gt; 10,</span>
<span class="sd">        &quot;Greater than 10&quot;</span>
<span class="sd">    ).Elif(P &lt; 2,</span>
<span class="sd">        &quot;Less than 2&quot;</span>
<span class="sd">    ).Else(</span>
<span class="sd">        &quot;Between 2 and 10&quot;</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cond_f</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">then_f</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">then</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">else_f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">state_identity</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond_f</span><span class="p">,</span> <span class="n">then_f</span><span class="p">,</span> <span class="n">else_f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_compile_if</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_ast</span> <span class="o">=</span> <span class="n">ast</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">_root</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">return</span> <span class="n">expr</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.List">
    <p>def <span class="ident">List</span>(</p><p>self, *branches, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>While <code>Seq</code> is sequential, <code>phi.dsl.Expression.List</code> allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements <code>__iter__</code>) that is not a tuple and yields a valid expresion.</p>
<p>The expression</p>
<div class="codehilite"><pre><span></span>k = List(f, g)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>k = lambda x: [ f(x), g(x) ]
</pre></div>


<p>In general, the following rules apply after compilation:</p>
<p><strong>General Branching</strong></p>
<div class="codehilite"><pre><span></span>List(f0, f1, ..., fn)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: [ f0(x), f1(x), ..., fn(x) ]
</pre></div>


<p><strong>Composing &amp; Branching</strong></p>
<p>It is interesting to see how braching interacts with composing. The expression</p>
<div class="codehilite"><pre><span></span>Seq(f, List(g, h))
</pre></div>


<p>is <em>almost</em> equivalent to</p>
<div class="codehilite"><pre><span></span>List( Seq(f, g), Seq(f, h) )
</pre></div>


<p>As you see its as if <code>f</code> where distributed over the List. We say <em>almost</em> because their implementation is different</p>
<div class="codehilite"><pre><span></span>def _lambda(x):
    x = f(x)
    return [ g(x), h(x) ]
</pre></div>


<p>vs</p>
<div class="codehilite"><pre><span></span>lambda x: [ g(f(x)), h(f(x)) ]
</pre></div>


<p>As you see <code>f</code> is only executed once in the first one. Both should yield the same result if <code>f</code> is a pure function.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="n">form</span> <span class="n">phi</span> <span class="kn">import</span> <span class="nn">P</span><span class="o">,</span> <span class="nn">List</span>

<span class="n">avg_word_length</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;1 22 333&quot;</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="c1"># [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="c1"># [1, 2, 3]</span>
    <span class="n">List</span><span class="p">(</span>
        <span class="nb">sum</span> <span class="c1"># 1 + 2 + 3 == 6</span>
    <span class="p">,</span>
        <span class="nb">len</span> <span class="c1"># len([1, 2, 3]) == 3</span>
    <span class="p">),</span>
    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># sum / len == 6 / 3 == 2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">avg_word_length</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>The previous could also be done more briefly like this</p>
<div class="codehilite"><pre><span></span><span class="n">form</span> <span class="n">phi</span> <span class="kn">import</span> <span class="nn">P</span><span class="o">,</span> <span class="nn">Obj</span><span class="o">,</span> <span class="nn">List</span>

<span class="n">avg_word_length</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;1 22 333&quot;</span><span class="p">,</span> <span class="n">Obj</span>
    <span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  <span class="c1"># [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
    <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>    <span class="c1"># [1, 2, 3]</span>
    <span class="o">.</span><span class="n">List</span><span class="p">(</span>
        <span class="nb">sum</span>  <span class="c1">#sum([1, 2, 3]) == 6</span>
    <span class="p">,</span>
        <span class="nb">len</span>  <span class="c1">#len([1, 2, 3]) == 3</span>
    <span class="p">),</span>
    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#6 / 3 == 2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">avg_word_length</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>In the example above the last expression</p>
<div class="codehilite"><pre><span></span>P[0] / P[1]
</pre></div>


<p>works for a couple of reasons</p>
<ol>
<li>The previous expression returns a list</li>
<li>In general the expression <code>P[x]</code> compiles to a function with the form <code>lambda obj: obj[x]</code></li>
<li>
<p>The class <code>Expression</code> (the class from which the object <code>P</code> inherits) overrides most operators to create functions easily. For example, the expression</p>
<p>(P * 2) / (P + 1)</p>
</li>
</ol>
<p>compile to a function of the form</p>
<div class="codehilite"><pre><span></span>lambda x: (x * 2) / (x + 1)
</pre></div>


<p>Check out the documentatio for Phi <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.List', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.List" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">List</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">branches</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">e `Seq` is sequential, `phi.dsl.Expression.List` allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements `__iter__`) that is not a tuple and yields a valid expresion.</span>
<span class="sd">expression</span>
<span class="sd">k = List(f, g)</span>
<span class="sd">quivalent to</span>
<span class="sd">k = lambda x: [ f(x), g(x) ]</span>
<span class="sd">eneral, the following rules apply after compilation:</span>
<span class="sd">neral Branching**</span>
<span class="sd">List(f0, f1, ..., fn)</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: [ f0(x), f1(x), ..., fn(x) ]</span>
<span class="sd">mposing &amp; Branching**</span>
<span class="sd">s interesting to see how braching interacts with composing. The expression</span>
<span class="sd">Seq(f, List(g, h))</span>
<span class="sd">almost* equivalent to</span>
<span class="sd">List( Seq(f, g), Seq(f, h) )</span>
<span class="sd">ou see its as if `f` where distributed over the List. We say *almost* because their implementation is different</span>
<span class="sd">def _lambda(x):</span>
<span class="sd">    x = f(x)</span>
<span class="sd">    return [ g(x), h(x) ]</span>
<span class="sd">lambda x: [ g(f(x)), h(f(x)) ]</span>
<span class="sd">ou see `f` is only executed once in the first one. Both should yield the same result if `f` is a pure function.</span>
<span class="sd">Examples</span>
<span class="sd">form phi import P, List</span>
<span class="sd">avg_word_length = P.Pipe(</span>
<span class="sd">    &quot;1 22 333&quot;,</span>
<span class="sd">    lambda s: s.split(&#39; &#39;), # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">    lambda l: map(len, l), # [1, 2, 3]</span>
<span class="sd">    List(</span>
<span class="sd">        sum # 1 + 2 + 3 == 6</span>
<span class="sd">    ,</span>
<span class="sd">        len # len([1, 2, 3]) == 3</span>
<span class="sd">    ),</span>
<span class="sd">    lambda l: l[0] / l[1] # sum / len == 6 / 3 == 2</span>
<span class="sd">)</span>
<span class="sd">assert avg_word_length == 2</span>
<span class="sd">previous could also be done more briefly like this</span>
<span class="sd">form phi import P, Obj, List</span>
<span class="sd">avg_word_length = P.Pipe(</span>
<span class="sd">    &quot;1 22 333&quot;, Obj</span>
<span class="sd">    .split(&#39; &#39;)  # [&#39;1&#39;, &#39;22&#39;, &#39;333&#39;]</span>
<span class="sd">    .map(len)    # [1, 2, 3]</span>
<span class="sd">    .List(</span>
<span class="sd">        sum  #sum([1, 2, 3]) == 6</span>
<span class="sd">    ,</span>
<span class="sd">        len  #len([1, 2, 3]) == 3</span>
<span class="sd">    ),</span>
<span class="sd">    P[0] / P[1]  #6 / 3 == 2</span>
<span class="sd">)</span>
<span class="sd">assert avg_word_length == 2</span>
<span class="sd">he example above the last expression</span>
<span class="sd">P[0] / P[1]</span>
<span class="sd">s for a couple of reasons</span>
<span class="sd">he previous expression returns a list</span>
<span class="sd">n general the expression `P[x]` compiles to a function with the form `lambda obj: obj[x]`</span>
<span class="sd">he class `Expression` (the class from which the object `P` inherits) overrides most operators to create functions easily. For example, the expression</span>
<span class="sd">(P * 2) / (P + 1)</span>
<span class="sd">ile to a function of the form</span>
<span class="sd">lambda x: (x * 2) / (x + 1)</span>
<span class="sd">k out the documentatio for Phi [lambdas](https://cgarciae.github.io/phi/lambdas.m.html).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">branches</span> <span class="p">]</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.PatchAt">
    <p>def <span class="ident">PatchAt</span>(</p><p>cls, n, module, method_wrapper=None, module_alias=None, method_name_modifier=&lt;function identity at 0x7f9366297aa0&gt;, blacklist_predicate=&lt;function &lt;lambda&gt; at 0x7f93662458c0&gt;, whitelist_predicate=&lt;function &lt;lambda&gt; at 0x7f9366245848&gt;, return_type_predicate=&lt;function &lt;lambda&gt; at 0x7f9366245938&gt;, getmembers_predicate=&lt;function isfunction at 0x7f9367769488&gt;, admit_private=False, explanation=u&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>This classmethod lets you easily patch all of functions/callables from a module or class as methods a Builder class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>n</strong> : the position the the object being piped will take in the arguments when the function being patched is applied. See <code>RegisterMethod</code> and <code>ThenAt</code>.</li>
<li><strong>module</strong> : a module or class from which the functions/methods/callables will be taken.</li>
<li><code>module_alias = None</code> : an optional alias for the module used for documentation purposes.</li>
<li><code>method_name_modifier = lambda f_name: None</code> : a function that can modify the name of the method will take. If <code>None</code> the name of the function will be used.</li>
<li><code>blacklist_predicate = lambda f_name: name[0] != "_"</code> : A predicate that determines which functions are banned given their name. By default it excludes all function whose name start with <code>'_'</code>. <code>blacklist_predicate</code> can also be of type list, in which case all names contained in this list will be banned.</li>
<li><code>whitelist_predicate = lambda f_name: True</code> : A predicate that determines which functions are admitted given their name. By default it include any function. <code>whitelist_predicate</code> can also be of type list, in which case only names contained in this list will be admitted. You can use both <code>blacklist_predicate</code> and <code>whitelist_predicate</code> at the same time.</li>
<li><code>return_type_predicate = lambda f_name: None</code> : a predicate that determines the <code>_return_type</code> of the Builder. By default it will always return <code>None</code>. See <code>phi.builder.Builder.ThenAt</code>.</li>
<li><code>getmembers_predicate = inspect.isfunction</code> : a predicate that determines what type of elements/members will be fetched by the <code>inspect</code> module, defaults to <a href="https://docs.python.org/2/library/inspect.html#inspect.isfunction">inspect.isfunction</a>. See <a href="https://docs.python.org/2/library/inspect.html#inspect.getmembers">getmembers</a>.</li>
</ul>
<p><strong>Examples</strong></p>
<p>Lets patch ALL the main functions from numpy into a custom builder!</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">PythonBuilder</span> <span class="c1">#or Builder</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">NumpyBuilder</span><span class="p">(</span><span class="n">PythonBuilder</span><span class="p">):</span> <span class="c1">#or Builder</span>
    <span class="s2">&quot;A Builder for numpy functions!&quot;</span>
    <span class="k">pass</span>

<span class="n">NumpyBuilder</span><span class="o">.</span><span class="n">PatchAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="n">NumpyBuilder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
</pre></div>


<p>Thats it! Although a serious patch would involve filtering out functions that don't take arrays. Another common task would be to use <code>NumpyBuilder.PatchAt(2, ...)</code> (<code>PatchAt(n, ..)</code> in general) when convenient to send the object being pipe to the relevant argument of the function. The previous is usually done with and a combination of <code>whitelist_predicate</code>s and <code>blacklist_predicate</code>s on <code>PatchAt(1, ...)</code> and <code>PatchAt(2, ...)</code> to filter or include the approriate functions on each kind of patch. Given the previous code we could now do</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">N</span>
    <span class="o">.</span><span class="kp">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="o">.</span><span class="kp">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="o">.</span><span class="kp">transpose</span><span class="p">()</span>
    <span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Which is strictly equivalent to</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">add</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">transpose</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<p>The thing to notice is that with the <code>NumpyBuilder</code> we avoid the repetitive and needless passing and reassigment of the <code>z</code> variable, this removes a lot of noise from our code.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.PatchAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.PatchAt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">PatchAt</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">method_wrapper</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">module_alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method_name_modifier</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">blacklist_predicate</span><span class="o">=</span><span class="n">_False</span><span class="p">,</span> <span class="n">whitelist_predicate</span><span class="o">=</span><span class="n">_True</span><span class="p">,</span> <span class="n">return_type_predicate</span><span class="o">=</span><span class="n">_None</span><span class="p">,</span> <span class="n">getmembers_predicate</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">,</span> <span class="n">admit_private</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> classmethod lets you easily patch all of functions/callables from a module or class as methods a Builder class.</span>
<span class="sd">guments**</span>
<span class="sd">n** : the position the the object being piped will take in the arguments when the function being patched is applied. See `RegisterMethod` and `ThenAt`.</span>
<span class="sd">module** : a module or class from which the functions/methods/callables will be taken.</span>
<span class="sd">odule_alias = None` : an optional alias for the module used for documentation purposes.</span>
<span class="sd">ethod_name_modifier = lambda f_name: None` : a function that can modify the name of the method will take. If `None` the name of the function will be used.</span>
<span class="sd">lacklist_predicate = lambda f_name: name[0] != &quot;_&quot;` : A predicate that determines which functions are banned given their name. By default it excludes all function whose name start with `&#39;_&#39;`. `blacklist_predicate` can also be of type list, in which case all names contained in this list will be banned.</span>
<span class="sd">hitelist_predicate = lambda f_name: True` : A predicate that determines which functions are admitted given their name. By default it include any function. `whitelist_predicate` can also be of type list, in which case only names contained in this list will be admitted. You can use both `blacklist_predicate` and `whitelist_predicate` at the same time.</span>
<span class="sd">eturn_type_predicate = lambda f_name: None` : a predicate that determines the `_return_type` of the Builder. By default it will always return `None`. See `phi.builder.Builder.ThenAt`.</span>
<span class="sd">etmembers_predicate = inspect.isfunction` : a predicate that determines what type of elements/members will be fetched by the `inspect` module, defaults to [inspect.isfunction](https://docs.python.org/2/library/inspect.html#inspect.isfunction). See [getmembers](https://docs.python.org/2/library/inspect.html#inspect.getmembers).</span>
<span class="sd">amples**</span>
<span class="sd"> patch ALL the main functions from numpy into a custom builder!</span>
<span class="sd">from phi import PythonBuilder #or Builder</span>
<span class="sd">import numpy as np</span>
<span class="sd">class NumpyBuilder(PythonBuilder): #or Builder</span>
<span class="sd">    &quot;A Builder for numpy functions!&quot;</span>
<span class="sd">    pass</span>
<span class="sd">NumpyBuilder.PatchAt(1, np)</span>
<span class="sd">N = NumpyBuilder(lambda x: x)</span>
<span class="sd">s it! Although a serious patch would involve filtering out functions that don&#39;t take arrays. Another common task would be to use `NumpyBuilder.PatchAt(2, ...)` (`PatchAt(n, ..)` in general) when convenient to send the object being pipe to the relevant argument of the function. The previous is usually done with and a combination of `whitelist_predicate`s and `blacklist_predicate`s on `PatchAt(1, ...)` and `PatchAt(2, ...)` to filter or include the approriate functions on each kind of patch. Given the previous code we could now do</span>
<span class="sd">import numpy as np</span>
<span class="sd">x = np.array([[1,2],[3,4]])</span>
<span class="sd">y = np.array([[5,6],[7,8]])</span>
<span class="sd">z = N.Pipe(</span>
<span class="sd">    x, N</span>
<span class="sd">    .dot(y)</span>
<span class="sd">    .add(x)</span>
<span class="sd">    .transpose()</span>
<span class="sd">    .sum(axis=1)</span>
<span class="sd">)</span>
<span class="sd">h is strictly equivalent to</span>
<span class="sd">import numpy as np</span>
<span class="sd">x = np.array([[1,2],[3,4]])</span>
<span class="sd">y = np.array([[5,6],[7,8]])</span>
<span class="sd">z = np.dot(x, y)</span>
<span class="sd">z = np.add(z, x)</span>
<span class="sd">z = np.transpose(z)</span>
<span class="sd">z = np.sum(z, axis=1)</span>
<span class="sd">thing to notice is that with the `NumpyBuilder` we avoid the repetitive and needless passing and reassigment of the `z` variable, this removes a lot of noise from our code.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_rtp</span> <span class="o">=</span> <span class="n">return_type_predicate</span>
    <span class="n">return_type_predicate</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_rtp</span><span class="p">)</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">_rtp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_rtp</span><span class="p">,</span> <span class="n">Builder</span><span class="p">)</span> <span class="k">else</span> <span class="n">_rtp</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="n">module_alias</span> <span class="k">if</span> <span class="n">module_alias</span> <span class="k">else</span> <span class="n">module</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
    <span class="n">patch_members</span> <span class="o">=</span> <span class="n">_get_patch_members</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">blacklist_predicate</span><span class="o">=</span><span class="n">blacklist_predicate</span><span class="p">,</span> <span class="n">whitelist_predicate</span><span class="o">=</span><span class="n">whitelist_predicate</span><span class="p">,</span> <span class="n">getmembers_predicate</span><span class="o">=</span><span class="n">getmembers_predicate</span><span class="p">,</span> <span class="n">admit_private</span><span class="o">=</span><span class="n">admit_private</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">patch_members</span><span class="p">:</span>
        <span class="n">wrapped</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">method_wrapper</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">method_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">wrapped</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">return_type_predicate</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">alias</span><span class="o">=</span><span class="n">method_name_modifier</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">explanation</span><span class="o">=</span><span class="n">explanation</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Pipe">
    <p>def <span class="ident">Pipe</span>(</p><p>self, *sequence, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Pipe</code> runs any <code>phi.dsl.Expression</code>. Its highly inspired by Elixir's <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2">|&gt; (pipe)</a> operator.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*sequence</strong>: any variable amount of expressions. All expressions inside of <code>sequence</code> will be composed together using <code>phi.dsl.Expression.Seq</code>.</li>
<li><strong>**kwargs</strong>: <code>Pipe</code> forwards all <code>kwargs</code> to <code>phi.builder.Builder.Seq</code>, visit its documentation for more info.</li>
</ul>
<p>The expression</p>
<div class="codehilite"><pre><span></span>Pipe(*sequence, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>Seq(*sequence, **kwargs)(None)
</pre></div>


<p>Normally the first argument or <code>Pipe</code> is a value, that is reinterpreted as a <code>phi.dsl.Expression.Val</code>, therfore, the input <code>None</code> is discarded.</p>
<p><strong>Examples</strong></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">mul3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>     <span class="c1">#input</span>
    <span class="n">add1</span><span class="p">,</span>  <span class="c1">#1 + 1 == 2</span>
    <span class="n">mul3</span>   <span class="c1">#2 * 3 == 6</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p>The previous using <a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a> to create the functions</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>      <span class="c1">#input</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">#1 + 1 == 2</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">#2 * 3 == 6</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Seq</code></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html">dsl</a></li>
<li><a href="https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile">Compile</a></li>
<li><a href="https://cgarciae.github.io/phi/lambdas.m.html">lambdas</a></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Pipe', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Pipe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">e` runs any `phi.dsl.Expression`. Its highly inspired by Elixir&#39;s [|&gt; (pipe)](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2) operator.</span>
<span class="sd">guments**</span>
<span class="sd">*sequence**: any variable amount of expressions. All expressions inside of `sequence` will be composed together using `phi.dsl.Expression.Seq`.</span>
<span class="sd">**kwargs**: `Pipe` forwards all `kwargs` to `phi.builder.Builder.Seq`, visit its documentation for more info.</span>
<span class="sd">expression</span>
<span class="sd">Pipe(*sequence, **kwargs)</span>
<span class="sd">quivalent to</span>
<span class="sd">Seq(*sequence, **kwargs)(None)</span>
<span class="sd">ally the first argument or `Pipe` is a value, that is reinterpreted as a `phi.dsl.Expression.Val`, therfore, the input `None` is discarded.</span>
<span class="sd">amples**</span>
<span class="sd">from phi import P</span>
<span class="sd">def add1(x): return x + 1</span>
<span class="sd">def mul3(x): return x * 3</span>
<span class="sd">x = P.Pipe(</span>
<span class="sd">    1,     #input</span>
<span class="sd">    add1,  #1 + 1 == 2</span>
<span class="sd">    mul3   #2 * 3 == 6</span>
<span class="sd">)</span>
<span class="sd">assert x == 6</span>
<span class="sd">previous using [lambdas](https://cgarciae.github.io/phi/lambdas.m.html) to create the functions</span>
<span class="sd">from phi import P</span>
<span class="sd">x = P.Pipe(</span>
<span class="sd">    1,      #input</span>
<span class="sd">    P + 1,  #1 + 1 == 2</span>
<span class="sd">    P * 3   #2 * 3 == 6</span>
<span class="sd">)</span>
<span class="sd">assert x == 6</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Seq`</span>
<span class="sd">sl](https://cgarciae.github.io/phi/dsl.m.html)</span>
<span class="sd">ompile](https://cgarciae.github.io/phi/dsl.m.html#phi.dsl.Compile)</span>
<span class="sd">ambdas](https://cgarciae.github.io/phi/lambdas.m.html)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;refs&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">state</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.ProblemType">
    <p>def <span class="ident">ProblemType</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.ProblemType(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersProblemType</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersProblemType(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.ProblemType(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersProblemType</strong></p>
<div class="codehilite"><pre><span></span>DEPRECATED FUNCTION
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-12.
Instructions for updating:
This file will be removed after the deprecation date.Please switch to third_party/tensorflow/contrib/learn/python/learn/estimators/head.py</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.ProblemType', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.ProblemType" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.ReadList">
    <p>def <span class="ident">ReadList</span>(</p><p>self, *branches, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Same as <code>phi.dsl.Expression.List</code> but any string argument <code>x</code> is translated to <code>Read(x)</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.ReadList', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.ReadList" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ReadList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">branches</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> as `phi.dsl.Expression.List` but any string argument `x` is translated to `Read(x)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">E</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">,</span> <span class="n">branches</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="o">*</span><span class="n">branches</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Register">
    <p>def <span class="ident">Register</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register(...)</code> is a shortcut for <code>RegisterAt(1, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Register', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Register" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister(...)` is a shortcut for `RegisterAt(1, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Register0">
    <p>def <span class="ident">Register0</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register0(...)</code> is a shortcut for <code>RegisterAt(0, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Register0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Register0" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register0</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister0(...)` is a shortcut for `RegisterAt(0, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Register2">
    <p>def <span class="ident">Register2</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register2(...)</code> is a shortcut for <code>RegisterAt(2, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Register2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Register2" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register2</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister2(...)` is a shortcut for `RegisterAt(2, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Register3">
    <p>def <span class="ident">Register3</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register3(...)</code> is a shortcut for <code>RegisterAt(3, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Register3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Register3" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register3</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister3(...)` is a shortcut for `RegisterAt(3, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Register4">
    <p>def <span class="ident">Register4</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register4(...)</code> is a shortcut for <code>RegisterAt(4, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Register4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Register4" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register4</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister4(...)` is a shortcut for `RegisterAt(4, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Register5">
    <p>def <span class="ident">Register5</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Register5(...)</code> is a shortcut for <code>RegisterAt(5, ...)</code></p>
<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterAt</code></li>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Register5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Register5" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">Register5</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ister5(...)` is a shortcut for `RegisterAt(5, ...)`</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">RegisterAt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.RegisterAt">
    <p>def <span class="ident">RegisterAt</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>RegisterAt</strong></p>
<div class="codehilite"><pre><span></span>RegisterAt(n, f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True, _return_type=None)
</pre></div>


<p>Most of the time you don't want to register an method as such, that is, you don't care about the <code>self</code> builder object, instead you want to register a function that transforms the value being piped down the DSL. For this you can use <code>RegisterAt</code> so e.g.</p>
<div class="codehilite"><pre><span></span>def some_fun(obj, arg1, arg2):
    # code

@MyBuilder.RegisterMethod(&quot;my_lib.&quot;)
def some_fun_wrapper(self, arg1, arg2):
    return self.ThenAt(1, some_fun, arg1, arg2)
</pre></div>


<p>can be written directly as</p>
<div class="codehilite"><pre><span></span>@MyBuilder.RegisterAt(1, &quot;my_lib.&quot;)
def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p>For this case you can just use <code>Register</code> which is a shortcut for <code>RegisterAt(1, ...)</code></p>
<div class="codehilite"><pre><span></span>@MyBuilder.Register(&quot;my_lib.&quot;)
def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p><strong>Also See</strong></p>
<ul>
<li><code>phi.builder.Builder.RegisterMethod</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.RegisterAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.RegisterAt" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterAt</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">gisterAt**</span>
<span class="sd">RegisterAt(n, f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True, _return_type=None)</span>
<span class="sd"> of the time you don&#39;t want to register an method as such, that is, you don&#39;t care about the `self` builder object, instead you want to register a function that transforms the value being piped down the DSL. For this you can use `RegisterAt` so e.g.</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">@MyBuilder.RegisterMethod(&quot;my_lib.&quot;)</span>
<span class="sd">def some_fun_wrapper(self, arg1, arg2):</span>
<span class="sd">    return self.ThenAt(1, some_fun, arg1, arg2)</span>
<span class="sd">be written directly as</span>
<span class="sd">@MyBuilder.RegisterAt(1, &quot;my_lib.&quot;)</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">this case you can just use `Register` which is a shortcut for `RegisterAt(1, ...)`</span>
<span class="sd">@MyBuilder.Register(&quot;my_lib.&quot;)</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">so See**</span>
<span class="sd">hi.builder.Builder.RegisterMethod`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unpack_error</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">library_path</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.RegisterMethod">
    <p>def <span class="ident">RegisterMethod</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>RegisterMethod</strong></p>
<div class="codehilite"><pre><span></span>RegisterMethod(f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True)
</pre></div>


<p><code>classmethod</code> for registering functions as methods of this class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>f</strong> : the particular function being registered as a method</li>
<li><strong>library_path</strong> : library from where <code>f</code> comes from, unless you pass an empty string, put a period <code>"."</code> at the end of the library name.</li>
<li><code>alias=None</code> : alias for the name/method being registered</li>
<li><code>original_name=None</code> : name of the original function, used for documentation purposes.</li>
<li><code>doc=None</code> : complete documentation of the method being registered</li>
<li><code>wrapped=None</code> : if you are registering a function which wraps around another function, pass this other function through <code>wrapped</code> to get better documentation, this is specially useful is you register a bunch of functions in a for loop. Please include an <code>explanation</code> to tell how the actual function differs from the wrapped one.</li>
<li><code>explanation=""</code> : especify any additional information for the documentation of the method being registered, you can use any of the following format tags within this string and they will be replace latter on: <code>{original_name}</code>, <code>{name}</code>, <code>{fn_docs}</code>, <code>{library_path}</code>, <code>{builder_class}</code>.</li>
<li><code>method_type=identity</code> : by default its applied but does nothing, you might also want to register functions as <code>property</code>, <code>classmethod</code>, <code>staticmethod</code></li>
<li><code>explain=True</code> : decide whether or not to show any kind of explanation, its useful to set it to <code>False</code> if you are using a <code>Register*</code> decorator and will only use the function as a registered method.</li>
</ul>
<p>A main feature of <code>phi</code> is that it enables you to integrate your library or even an existing library with the DSL. You can achieve three levels of integration</p>
<ol>
<li>Passing your functions to the DSL. This a very general machanism -since you could actually do everything with python lamdas- but in practice functions often receive multiple parameters.</li>
<li>Creating partials with the <code>Then*</code> method family. Using this you could integrate any function, but it will add a lot of noise if you use heavily on it.</li>
<li>Registering functions as methods of a <code>Builder</code> derived class. This produces the most readable code and its the approach you should take if you want to create a Phi-based library or a helper class.</li>
</ol>
<p>While point 3 is the most desirable it has a cost: you need to create your own <code>phi.builder.Builder</code>-derived class. This is because SHOULD NOT register functions to existing builders e.g. the <code>phi.builder.Builder</code> or <a href="https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder">PythonBuilder</a> provided by phi because that would pollute the <code>P</code> object. Instead you should create a custom class that derives from <code>phi.builder.Builder</code>,  <a href="https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder">PythonBuilder</a> or another custom builder depending on your needs and register your functions to that class.</p>
<p><strong>Examples</strong></p>
<p>Say you have a function on a library called <code>"my_lib"</code></p>
<div class="codehilite"><pre><span></span>def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p>You could use it with the dsl like this</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Then</span>

<span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">Then</span><span class="p">(</span><span class="n">some_fun</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>


<p>assuming the first parameter <code>obj</code> is being piped down. However if you do this very often or you are creating a library, you are better off creating a custom class derived from <code>Builder</code> or <code>PythonBuilder</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">Builder</span> <span class="c1">#or PythonBuilder</span>

<span class="k">class</span> <span class="nc">MyBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span> <span class="c1"># or PythonBuilder</span>
    <span class="k">pass</span>
</pre></div>


<p>and registering your function as a method. The first way you could do this is by creating a wrapper function for <code>some_fun</code> and registering it as a method</p>
<div class="codehilite"><pre><span></span>def some_fun_wrapper(self, arg1, arg2):
    return self.Then(some_fun, arg1, arg2)

MyBuilder.RegisterMethod(some_fun_wrapper, &quot;my_lib.&quot;, wrapped=some_fun)
</pre></div>


<p>Here we basically created a shortcut for the original expression <code>Then(some_fun, arg1, arg2)</code>. You could also do this using a decorator</p>
<div class="codehilite"><pre><span></span>@MyBuilder.RegisterMethod(&quot;my_lib.&quot;, wrapped=some_fun)
def some_fun_wrapper(self, arg1, arg2):
    return self.Then(some_fun, arg1, arg2)
</pre></div>


<p>However, this is such a common task that we've created the method <code>Register</code> to avoid you from having to create the wrapper. With it you could register the function <code>some_fun</code> directly as a method like this</p>
<div class="codehilite"><pre><span></span>MyBuilder.Register(some_fun, &quot;my_lib.&quot;)
</pre></div>


<p>or by using a decorator over the original function definition</p>
<div class="codehilite"><pre><span></span>@MyBuilder.Register(&quot;my_lib.&quot;)
def some_fun(obj, arg1, arg2):
    # code
</pre></div>


<p>Once done you've done any of the previous approaches you can create a custom global object e.g. <code>M</code> and use it instead of/along with <code>P</code></p>
<div class="codehilite"><pre><span></span>M = MyBuilder(lambda x: x)

M.Pipe(
    input,
    ...
    M.some_fun(arg1, args)
    ...
)
</pre></div>


<p><strong>Argument position</strong></p>
<p><code>phi.builder.Builder.Register</code> internally uses <code>phi.builder.Builder.Then</code>, this is only useful if the object being piped is intended to be passed as the first argument of the function being registered, if this is not the case you could use <code>phi.builder.Builder.Register2</code>, <code>phi.builder.Builder.Register3</code>, ..., <code>phi.builder.Builder.Register5</code> or <code>phi.builder.Builder.RegisterAt</code> to set an arbitrary position, these functions will internally use <code>phi.builder.Builder.Then2</code>, <code>phi.builder.Builder.Then3</code>, ..., <code>phi.builder.Builder.Then5</code> or <code>phi.builder.Builder.ThenAt</code> respectively.</p>
<p><strong>Wrapping functions</strong></p>
<p>Sometimes you have an existing function that you would like to modify slightly so it plays nicely with the DSL, what you normally do is create a function that wraps around it and passes the arguments to it in a way that is convenient</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">some_lib</span>

<span class="nd">@MyBuilder.Register</span><span class="p">(</span><span class="s2">&quot;some_lib.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">some_lib</span><span class="o">.</span><span class="n">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># forward the args, n slightly modified</span>
</pre></div>


<p>When you do this -as a side effect- you loose the original documentation, to avoid this you can use the Registers <code>wrapped</code> argument along with the <code>explanation</code> argument to clarity the situation</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">some_lib</span>

<span class="n">some_fun_explanation</span> <span class="o">=</span> <span class="s2">&quot;However, it differs in that `n` is automatically subtracted `1`&quot;</span>

<span class="nd">@MyBuilder.Register</span><span class="p">(</span><span class="s2">&quot;some_lib.&quot;</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">some_lib</span><span class="o">.</span><span class="n">some_fun</span><span class="p">,</span> <span class="n">explanation</span><span class="o">=</span><span class="n">some_fun_explanation</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">some_lib</span><span class="o">.</span><span class="n">some_fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># forward the args, n slightly modified</span>
</pre></div>


<p>Now the documentation for <code>MyBuilder.some_fun</code> will be a little bit nicer since it includes the original documentation from <code>some_lib.some_fun</code>. This behaviour is specially useful if you are wrapping an entire 3rd party library, you usually automate the process iterating over all the funcitions in a for loop. The <code>phi.builder.Builder.PatchAt</code> method lets you register and entire module using a few lines of code, however, something you have to do thing more manually and do the iteration yourself.</p>
<p><strong>See Also</strong></p>
<ul>
<li><code>phi.builder.Builder.PatchAt</code></li>
<li><code>phi.builder.Builder.RegisterAt</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.RegisterMethod', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.RegisterMethod" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">RegisterMethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">gisterMethod**</span>
<span class="sd">RegisterMethod(f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=&quot;&quot;, method_type=utils.identity, explain=True)</span>
<span class="sd">ssmethod` for registering functions as methods of this class.</span>
<span class="sd">guments**</span>
<span class="sd">f** : the particular function being registered as a method</span>
<span class="sd">library_path** : library from where `f` comes from, unless you pass an empty string, put a period `&quot;.&quot;` at the end of the library name.</span>
<span class="sd">lias=None` : alias for the name/method being registered</span>
<span class="sd">riginal_name=None` : name of the original function, used for documentation purposes.</span>
<span class="sd">oc=None` : complete documentation of the method being registered</span>
<span class="sd">rapped=None` : if you are registering a function which wraps around another function, pass this other function through `wrapped` to get better documentation, this is specially useful is you register a bunch of functions in a for loop. Please include an `explanation` to tell how the actual function differs from the wrapped one.</span>
<span class="sd">xplanation=&quot;&quot;` : especify any additional information for the documentation of the method being registered, you can use any of the following format tags within this string and they will be replace latter on: `{original_name}`, `{name}`, `{fn_docs}`, `{library_path}`, `{builder_class}`.</span>
<span class="sd">ethod_type=identity` : by default its applied but does nothing, you might also want to register functions as `property`, `classmethod`, `staticmethod`</span>
<span class="sd">xplain=True` : decide whether or not to show any kind of explanation, its useful to set it to `False` if you are using a `Register*` decorator and will only use the function as a registered method.</span>
<span class="sd">in feature of `phi` is that it enables you to integrate your library or even an existing library with the DSL. You can achieve three levels of integration</span>
<span class="sd">assing your functions to the DSL. This a very general machanism -since you could actually do everything with python lamdas- but in practice functions often receive multiple parameters.</span>
<span class="sd">reating partials with the `Then*` method family. Using this you could integrate any function, but it will add a lot of noise if you use heavily on it.</span>
<span class="sd">egistering functions as methods of a `Builder` derived class. This produces the most readable code and its the approach you should take if you want to create a Phi-based library or a helper class.</span>
<span class="sd">e point 3 is the most desirable it has a cost: you need to create your own `phi.builder.Builder`-derived class. This is because SHOULD NOT register functions to existing builders e.g. the `phi.builder.Builder` or [PythonBuilder](https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder) provided by phi because that would pollute the `P` object. Instead you should create a custom class that derives from `phi.builder.Builder`,  [PythonBuilder](https://cgarciae.github.io/phi/builder.m.html#phi.python_builder.PythonBuilder) or another custom builder depending on your needs and register your functions to that class.</span>
<span class="sd">amples**</span>
<span class="sd">you have a function on a library called `&quot;my_lib&quot;`</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd">could use it with the dsl like this</span>
<span class="sd">from phi import P, Then</span>
<span class="sd">P.Pipe(</span>
<span class="sd">    input,</span>
<span class="sd">    ...</span>
<span class="sd">    Then(some_fun, arg1, arg2)</span>
<span class="sd">    ...</span>
<span class="sd">)</span>
<span class="sd">ming the first parameter `obj` is being piped down. However if you do this very often or you are creating a library, you are better off creating a custom class derived from `Builder` or `PythonBuilder`</span>
<span class="sd">from phi import Builder #or PythonBuilder</span>
<span class="sd">class MyBuilder(Builder): # or PythonBuilder</span>
<span class="sd">    pass</span>
<span class="sd">registering your function as a method. The first way you could do this is by creating a wrapper function for `some_fun` and registering it as a method</span>
<span class="sd">def some_fun_wrapper(self, arg1, arg2):</span>
<span class="sd">    return self.Then(some_fun, arg1, arg2)</span>
<span class="sd">MyBuilder.RegisterMethod(some_fun_wrapper, &quot;my_lib.&quot;, wrapped=some_fun)</span>
<span class="sd"> we basically created a shortcut for the original expression `Then(some_fun, arg1, arg2)`. You could also do this using a decorator</span>
<span class="sd">@MyBuilder.RegisterMethod(&quot;my_lib.&quot;, wrapped=some_fun)</span>
<span class="sd">def some_fun_wrapper(self, arg1, arg2):</span>
<span class="sd">    return self.Then(some_fun, arg1, arg2)</span>
<span class="sd">ver, this is such a common task that we&#39;ve created the method `Register` to avoid you from having to create the wrapper. With it you could register the function `some_fun` directly as a method like this</span>
<span class="sd">MyBuilder.Register(some_fun, &quot;my_lib.&quot;)</span>
<span class="sd">y using a decorator over the original function definition</span>
<span class="sd">@MyBuilder.Register(&quot;my_lib.&quot;)</span>
<span class="sd">def some_fun(obj, arg1, arg2):</span>
<span class="sd">    # code</span>
<span class="sd"> done you&#39;ve done any of the previous approaches you can create a custom global object e.g. `M` and use it instead of/along with `P`</span>
<span class="sd">M = MyBuilder(lambda x: x)</span>
<span class="sd">M.Pipe(</span>
<span class="sd">    input,</span>
<span class="sd">    ...</span>
<span class="sd">    M.some_fun(arg1, args)</span>
<span class="sd">    ...</span>
<span class="sd">)</span>
<span class="sd">gument position**</span>
<span class="sd">.builder.Builder.Register` internally uses `phi.builder.Builder.Then`, this is only useful if the object being piped is intended to be passed as the first argument of the function being registered, if this is not the case you could use `phi.builder.Builder.Register2`, `phi.builder.Builder.Register3`, ..., `phi.builder.Builder.Register5` or `phi.builder.Builder.RegisterAt` to set an arbitrary position, these functions will internally use `phi.builder.Builder.Then2`, `phi.builder.Builder.Then3`, ..., `phi.builder.Builder.Then5` or `phi.builder.Builder.ThenAt` respectively.</span>
<span class="sd">apping functions**</span>
<span class="sd">times you have an existing function that you would like to modify slightly so it plays nicely with the DSL, what you normally do is create a function that wraps around it and passes the arguments to it in a way that is convenient</span>
<span class="sd">import some_lib</span>
<span class="sd">@MyBuilder.Register(&quot;some_lib.&quot;)</span>
<span class="sd">def some_fun(a, n):</span>
<span class="sd">    return some_lib.some_fun(a, n - 1) # forward the args, n slightly modified</span>
<span class="sd"> you do this -as a side effect- you loose the original documentation, to avoid this you can use the Registers `wrapped` argument along with the `explanation` argument to clarity the situation</span>
<span class="sd">import some_lib</span>
<span class="sd">some_fun_explanation = &quot;However, it differs in that `n` is automatically subtracted `1`&quot;</span>
<span class="sd">@MyBuilder.Register(&quot;some_lib.&quot;, wrapped=some_lib.some_fun, explanation=some_fun_explanation)</span>
<span class="sd">def some_fun(a, n):</span>
<span class="sd">    return some_lib.some_fun(a, n - 1) # forward the args, n slightly modified</span>
<span class="sd">the documentation for `MyBuilder.some_fun` will be a little bit nicer since it includes the original documentation from `some_lib.some_fun`. This behaviour is specially useful if you are wrapping an entire 3rd party library, you usually automate the process iterating over all the funcitions in a for loop. The `phi.builder.Builder.PatchAt` method lets you register and entire module using a few lines of code, however, something you have to do thing more manually and do the iteration yourself.</span>
<span class="sd">e Also**</span>
<span class="sd">hi.builder.Builder.PatchAt`</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">library_path</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">unpack_error</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterMethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unpack_error</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">library_path</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_RegisterMethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">library_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">register_decorator</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Seq">
    <p>def <span class="ident">Seq</span>(</p><p>self, *sequence, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Seq</code> is used to express function composition. The expression</p>
<div class="codehilite"><pre><span></span>Seq(f, g)
</pre></div>


<p>be equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: g(f(x))
</pre></div>


<p>As you see, its a little different from the mathematical definition. Excecution order flow from left to right, this makes reading and reasoning about code way more easy. This bahaviour is based upon the <code>|&gt;</code> (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</p>
<p>In general, the following rules apply for Seq:</p>
<p><strong>General Sequence</strong></p>
<div class="codehilite"><pre><span></span>Seq(f0, f1, ..., fn-1, fn)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: fn(fn-1(...(f1(f0(x)))))
</pre></div>


<p><strong>Single Function</strong></p>
<div class="codehilite"><pre><span></span>Seq(f)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>f
</pre></div>


<p><strong>Identity</strong></p>
<p>The empty Seq</p>
<div class="codehilite"><pre><span></span>Seq()
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>lambda x: x
</pre></div>


<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Seq</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span> <span class="c1"># ((1 * 2) + 1) ** 2</span>
</pre></div>


<p>The previous example using <code>P.Pipe</code></p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">9</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1">#1 * 2 == 2</span>
    <span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">#2 + 1 == 3</span>
    <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1">#3 ** 2 == 9</span>
<span class="p">)</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Seq', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Seq" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">` is used to express function composition. The expression</span>
<span class="sd">Seq(f, g)</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: g(f(x))</span>
<span class="sd">ou see, its a little different from the mathematical definition. Excecution order flow from left to right, this makes reading and reasoning about code way more easy. This bahaviour is based upon the `|&gt;` (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.</span>
<span class="sd">eneral, the following rules apply for Seq:</span>
<span class="sd">neral Sequence**</span>
<span class="sd">Seq(f0, f1, ..., fn-1, fn)</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: fn(fn-1(...(f1(f0(x)))))</span>
<span class="sd">ngle Function**</span>
<span class="sd">Seq(f)</span>
<span class="sd">quivalent to</span>
<span class="sd">f</span>
<span class="sd">entity**</span>
<span class="sd">empty Seq</span>
<span class="sd">Seq()</span>
<span class="sd">quivalent to</span>
<span class="sd">lambda x: x</span>
<span class="sd">Examples</span>
<span class="sd">from phi import P, Seq</span>
<span class="sd">f = Seq(</span>
<span class="sd">    P * 2,</span>
<span class="sd">    P + 1,</span>
<span class="sd">    P ** 2</span>
<span class="sd">)</span>
<span class="sd">assert f(1) == 9 # ((1 * 2) + 1) ** 2</span>
<span class="sd">previous example using `P.Pipe`</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 9 == P.Pipe(</span>
<span class="sd">    1,</span>
<span class="sd">    P * 2,  #1 * 2 == 2</span>
<span class="sd">    P + 1,  #2 + 1 == 3</span>
<span class="sd">    P ** 2  #3 ** 2 == 9</span>
<span class="sd">)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_parse</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="p">]</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">args</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">fs</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Set">
    <p>def <span class="ident">Set</span>(</p><p>self, *expressions, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Set', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Set" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="o">*</span><span class="n">expressions</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nb">set</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then">
    <p>def <span class="ident">Then</span>(</p><p>self, f, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then(f, ...)</code> is equivalent to <code>ThenAt(1, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n(f, ...)` is equivalent to `ThenAt(1, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then0">
    <p>def <span class="ident">Then0</span>(</p><p>self, f, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then0(f, ...)</code> is equivalent to <code>ThenAt(0, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then0', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then0" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n0(f, ...)` is equivalent to `ThenAt(0, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then1">
    <p>def <span class="ident">Then1</span>(</p><p>self, f, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then(f, ...)</code> is equivalent to <code>ThenAt(1, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then1', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then1" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n(f, ...)` is equivalent to `ThenAt(1, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then2">
    <p>def <span class="ident">Then2</span>(</p><p>self, f, arg1, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then2(f, ...)</code> is equivalent to <code>ThenAt(2, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then2', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then2" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n2(f, ...)` is equivalent to `ThenAt(2, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then3">
    <p>def <span class="ident">Then3</span>(</p><p>self, f, arg1, arg2, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then3(f, ...)</code> is equivalent to <code>ThenAt(3, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then3', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then3" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n3(f, ...)` is equivalent to `ThenAt(3, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then4">
    <p>def <span class="ident">Then4</span>(</p><p>self, f, arg1, arg2, arg3, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then4(f, ...)</code> is equivalent to <code>ThenAt(4, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then4', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then4" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n4(f, ...)` is equivalent to `ThenAt(4, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Then5">
    <p>def <span class="ident">Then5</span>(</p><p>self, f, arg1, arg2, arg3, arg4, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Then5(f, ...)</code> is equivalent to <code>ThenAt(5, f, ...)</code>. Checkout <code>phi.builder.Builder.ThenAt</code> for more information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Then5', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Then5" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Then5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n5(f, ...)` is equivalent to `ThenAt(5, f, ...)`. Checkout `phi.builder.Builder.ThenAt` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.ThenAt">
    <p>def <span class="ident">ThenAt</span>(</p><p>self, n, f, *_args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><code>ThenAt</code> enables you to create a partially apply many arguments to a function, the returned partial expects a single arguments which will be applied at the <code>n</code>th position of the original function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>n</strong>: position at which the created partial will apply its awaited argument on the original function.</li>
<li><strong>f</strong>: function which the partial will be created.</li>
<li><strong>_args &amp; kwargs</strong>: all <code>*_args</code> and <code>**kwargs</code> will be passed to the function <code>f</code>.</li>
<li><code>_return_type = None</code>: type of the returned <code>builder</code>, if <code>None</code> it will return the same type of the current <code>builder</code>. This special kwarg will NOT be passed to <code>f</code>.</li>
</ul>
<p>You can think of <code>n</code> as the position that the value being piped down will pass through the <code>f</code>. Say you have the following expression</p>
<div class="codehilite"><pre><span></span>D == fun(A, B, C)
</pre></div>


<p>all the following are equivalent</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">ThenAt</span>

<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ThenAt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">ThenAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">ThenAt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
</pre></div>


<p>you could also use the shortcuts <code>Then</code>, <code>Then2</code>,..., <code>Then5</code>, which are more readable</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then3</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
</pre></div>


<p>There is a special case not discussed above: <code>n = 0</code>. When this happens only the arguments given will be applied to <code>f</code>, this method it will return a partial that expects a single argument but completely ignores it</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="n">D</span> <span class="o">==</span> <span class="n">Pipe</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Then0</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
</pre></div>


<p><strong>Examples</strong></p>
<p>Max of 6 and the argument:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="mi">6</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Previous is equivalent to</p>
<div class="codehilite"><pre><span></span>assert 6 == max(2, 6)
</pre></div>


<p>Open a file in read mode (<code>'r'</code>)</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;file.txt&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="nb">open</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Previous is equivalent to</p>
<div class="codehilite"><pre><span></span>f = open(&quot;file.txt&quot;, &#39;r&#39;)
</pre></div>


<p>Split a string by whitespace and then get the length of each word</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span>

<span class="k">assert</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;Again hello world&quot;</span><span class="p">,</span>
    <span class="n">P</span><span class="o">.</span><span class="n">Then</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Then2</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>Previous is equivalent to</p>
<div class="codehilite"><pre><span></span>x = &quot;Again hello world&quot;

x = str.split(x, &#39; &#39;)
x = map(len, x)

assert [5, 5, 5] == x
</pre></div>


<p>As you see, <code>Then2</code> was very useful because <code>map</code> accepts and <code>iterable</code> as its <code>2nd</code> parameter. You can rewrite the previous using the <a href="https://cgarciae.github.io/phi/python_builder.m.html">PythonBuilder</a> and the <code>phi.builder.Builder.Obj</code> object</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span>

<span class="k">assert</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;Again hello world&quot;</span><span class="p">,</span>
    <span class="n">Obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span>
    <span class="n">P</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p><strong>Also see</strong></p>
<ul>
<li><code>phi.builder.Builder.Obj</code></li>
<li><a href="https://cgarciae.github.io/phi/python_builder.m.html">PythonBuilder</a></li>
<li><code>phi.builder.Builder.RegisterAt</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.ThenAt', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.ThenAt" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ThenAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">nAt` enables you to create a partially apply many arguments to a function, the returned partial expects a single arguments which will be applied at the `n`th position of the original function.</span>
<span class="sd">guments**</span>
<span class="sd">n**: position at which the created partial will apply its awaited argument on the original function.</span>
<span class="sd">f**: function which the partial will be created.</span>
<span class="sd">_args &amp; kwargs**: all `*_args` and `**kwargs` will be passed to the function `f`.</span>
<span class="sd">return_type = None`: type of the returned `builder`, if `None` it will return the same type of the current `builder`. This special kwarg will NOT be passed to `f`.</span>
<span class="sd">can think of `n` as the position that the value being piped down will pass through the `f`. Say you have the following expression</span>
<span class="sd">D == fun(A, B, C)</span>
<span class="sd">the following are equivalent</span>
<span class="sd">from phi import P, Pipe, ThenAt</span>
<span class="sd">D == Pipe(A, ThenAt(1, fun, B, C))</span>
<span class="sd">D == Pipe(B, ThenAt(2, fun, A, C))</span>
<span class="sd">D == Pipe(C, ThenAt(3, fun, A, B))</span>
<span class="sd">could also use the shortcuts `Then`, `Then2`,..., `Then5`, which are more readable</span>
<span class="sd">from phi import P, Pipe</span>
<span class="sd">D == Pipe(A, P.Then(fun, B, C))</span>
<span class="sd">D == Pipe(B, P.Then2(fun, A, C))</span>
<span class="sd">D == Pipe(C, P.Then3(fun, A, B))</span>
<span class="sd">e is a special case not discussed above: `n = 0`. When this happens only the arguments given will be applied to `f`, this method it will return a partial that expects a single argument but completely ignores it</span>
<span class="sd">from phi import P</span>
<span class="sd">D == Pipe(None, P.ThenAt(0, fun, A, B, C))</span>
<span class="sd">D == Pipe(None, P.Then0(fun, A, B, C))</span>
<span class="sd">amples**</span>
<span class="sd">of 6 and the argument:</span>
<span class="sd">from phi import P</span>
<span class="sd">assert 6 == P.Pipe(</span>
<span class="sd">    2,</span>
<span class="sd">    P.Then(max, 6)</span>
<span class="sd">)</span>
<span class="sd">ious is equivalent to</span>
<span class="sd">assert 6 == max(2, 6)</span>
<span class="sd"> a file in read mode (`&#39;r&#39;`)</span>
<span class="sd">from phi import P</span>
<span class="sd">f = P.Pipe(</span>
<span class="sd">    &quot;file.txt&quot;,</span>
<span class="sd">    P.Then(open, &#39;r&#39;)</span>
<span class="sd">)</span>
<span class="sd">ious is equivalent to</span>
<span class="sd">f = open(&quot;file.txt&quot;, &#39;r&#39;)</span>
<span class="sd">t a string by whitespace and then get the length of each word</span>
<span class="sd">from phi import P</span>
<span class="sd">assert [5, 5, 5] == P.Pipe(</span>
<span class="sd">    &quot;Again hello world&quot;,</span>
<span class="sd">    P.Then(str.split, &#39; &#39;)</span>
<span class="sd">    .Then2(map, len)</span>
<span class="sd">)</span>
<span class="sd">ious is equivalent to</span>
<span class="sd">x = &quot;Again hello world&quot;</span>
<span class="sd">x = str.split(x, &#39; &#39;)</span>
<span class="sd">x = map(len, x)</span>
<span class="sd">assert [5, 5, 5] == x</span>
<span class="sd">ou see, `Then2` was very useful because `map` accepts and `iterable` as its `2nd` parameter. You can rewrite the previous using the [PythonBuilder](https://cgarciae.github.io/phi/python_builder.m.html) and the `phi.builder.Builder.Obj` object</span>
<span class="sd">from phi import P, Obj</span>
<span class="sd">assert [5, 5, 5] == P.Pipe(</span>
<span class="sd">    &quot;Again hello world&quot;,</span>
<span class="sd">    Obj.split(&#39; &#39;),</span>
<span class="sd">    P.map(len)</span>
<span class="sd">)</span>
<span class="sd">so see**</span>
<span class="sd">hi.builder.Builder.Obj`</span>
<span class="sd">ythonBuilder](https://cgarciae.github.io/phi/python_builder.m.html)</span>
<span class="sd">hi.builder.Builder.RegisterAt`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_return_type</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">n_args</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s1">&#39;_return_type&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">_return_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span>
    <span class="nd">@utils.lift</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="n">_args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_args</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">+</span> <span class="n">_args</span><span class="p">[</span><span class="n">n_args</span><span class="p">:]</span> <span class="k">if</span> <span class="n">n_args</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">_args</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_return_type</span><span class="o">=</span><span class="n">_return_type</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Tuple">
    <p>def <span class="ident">Tuple</span>(</p><p>self, *expressions, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Tuple', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Tuple" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="o">*</span><span class="n">expressions</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nb">tuple</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Val">
    <p>def <span class="ident">Val</span>(</p><p>self, val, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>The expression</p>
<div class="codehilite"><pre><span></span>Val(a)
</pre></div>


<p>is equivalent to the constant function</p>
<div class="codehilite"><pre><span></span>lambda x: a
</pre></div>


<p>All expression in this module interprete values that are not functions as constant functions using <code>Val</code>, for example</p>
<div class="codehilite"><pre><span></span>Seq(1, P + 1)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>Seq(Val(1), P + 1)
</pre></div>


<p>The previous expression as a whole is a constant function since it will return <code>2</code> no matter what input you give it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Val', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Val" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">expression</span>
<span class="sd">Val(a)</span>
<span class="sd">quivalent to the constant function</span>
<span class="sd">lambda x: a</span>
<span class="sd">expression in this module interprete values that are not functions as constant functions using `Val`, for example</span>
<span class="sd">Seq(1, P + 1)</span>
<span class="sd">quivalent to</span>
<span class="sd">Seq(Val(1), P + 1)</span>
<span class="sd">previous expression as a whole is a constant function since it will return `2` no matter what input you give it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.With">
    <p>def <span class="ident">With</span>(</p><p>self, context_manager, *body, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>With</strong></p>
<div class="codehilite"><pre><span></span>def With(context_manager, *body):
</pre></div>


<p><strong>Arguments</strong></p>
<ul>
<li><strong>context_manager</strong>: a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> object or valid expression from the DSL that returns a context manager.</li>
<li><strong>*body</strong>: any valid expression of the DSL to be evaluated inside the context. <code>*body</code> is interpreted as a tuple so all expression contained are composed.</li>
</ul>
<p>As with normal python programs you sometimes might want to create a context for a block of code. You normally give a <a href="https://docs.python.org/2/reference/datamodel.html#context-managers">context manager</a> to the <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement">with</a> statemente, in Phi you use <code>P.With</code> or <code>phi.With</code></p>
<p><strong>Context</strong></p>
<p>Python's <code>with</code> statemente returns a context object through <code>as</code> keyword, in the DSL this object can be obtained using the <code>P.Context</code> method or the <code>phi.Context</code> function.</p>
<h3>Examples</h3>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">phi</span> <span class="kn">import</span> <span class="n">P</span><span class="p">,</span> <span class="n">Obj</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">With</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">text</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span>
    <span class="s2">&quot;text.txt&quot;</span><span class="p">,</span>
    <span class="n">With</span><span class="p">(</span> <span class="nb">open</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span>
        <span class="n">Obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>The previous is equivalent to</p>
<div class="codehilite"><pre><span></span>with open(&quot;text.txt&quot;) as f:
    text = f.read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.With', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.With" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">With</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context_manager</span><span class="p">,</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">th**</span>
<span class="sd">def With(context_manager, *body):</span>
<span class="sd">guments**</span>
<span class="sd">context_manager**: a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) object or valid expression from the DSL that returns a context manager.</span>
<span class="sd">*body**: any valid expression of the DSL to be evaluated inside the context. `*body` is interpreted as a tuple so all expression contained are composed.</span>
<span class="sd">ith normal python programs you sometimes might want to create a context for a block of code. You normally give a [context manager](https://docs.python.org/2/reference/datamodel.html#context-managers) to the [with](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement) statemente, in Phi you use `P.With` or `phi.With`</span>
<span class="sd">ntext**</span>
<span class="sd">on&#39;s `with` statemente returns a context object through `as` keyword, in the DSL this object can be obtained using the `P.Context` method or the `phi.Context` function.</span>
<span class="sd">Examples</span>
<span class="sd">from phi import P, Obj, Context, With, Pipe</span>
<span class="sd">text = Pipe(</span>
<span class="sd">    &quot;text.txt&quot;,</span>
<span class="sd">    With( open, Context,</span>
<span class="sd">        Obj.read()</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">previous is equivalent to</span>
<span class="sd">with open(&quot;text.txt&quot;) as f:</span>
<span class="sd">    text = f.read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context_f</span> <span class="o">=</span> <span class="n">_parse</span><span class="p">(</span><span class="n">context_manager</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="n">body_f</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="o">*</span><span class="n">body</span><span class="p">)</span><span class="o">.</span><span class="n">_f</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">context</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">context_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">context</span> <span class="k">as</span> <span class="n">scope</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_WithContextManager</span><span class="p">(</span><span class="n">scope</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">body_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.Write">
    <p>def <span class="ident">Write</span>(</p><p>self, *state_args, **state_dict)</p>
    </div>
    

    
  
    <div class="desc"><p>See <code>phi.dsl.Expression.Read</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.Write', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.Write" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">state_args</span><span class="p">,</span> <span class="o">**</span><span class="n">state_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;See `phi.dsl.Expression.Read`&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please include at-least 1 state variable, got {0} and {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state_args</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please include at-most 1 keyword argument expression, got {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state_dict</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">state_key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">state_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">write_expr</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="n">state_key</span><span class="p">]</span>
        <span class="n">state_args</span> <span class="o">+=</span> <span class="p">(</span><span class="n">state_key</span><span class="p">,)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;&gt;</span> <span class="n">write_expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">update</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">state_args</span> <span class="p">}</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">update</span><span class="p">)</span>
        <span class="c1">#side effect for convenience</span>
        <span class="n">_StateContextManager</span><span class="o">.</span><span class="n">REFS</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">__then__</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.adaptive_clipping_fn">
    <p>def <span class="ident">adaptive_clipping_fn</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.adaptive_clipping_fn(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersadaptive_clipping_fn</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersadaptive_clipping_fn(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.adaptive_clipping_fn(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersadaptive_clipping_fn</strong></p>
<div class="codehilite"><pre><span></span>Adapt the clipping value using statistics on the norms.
</pre></div>


<p>Implement adaptive gradient as presented in section 3.2.1 of
https://arxiv.org/abs/1412.1602.</p>
<p>Keeps a moving average of the mean and std of the log(norm) of the gradient.
if the norm exceeds <code>exp(mean + std_factor*std)</code>, all gradients are rescaled
such that the global norm becomes <code>exp(mean)</code>.</p>
<p>Args:
  std_factor: Python scaler (or tensor).
    <code>max_norm = exp(mean + std_factor*std)</code>
  decay: The smoothing factor of the moving averages.
  static_max_norm: If provided, will threshold the norm to this value as an
    extra safety.
  global_step: Optional global_step. If provided, <code>decay = decay*n/(n+1)</code>.
    This provides a quicker adaptation of the mean for the first steps.
  report_summary: If <code>True</code>, will add histogram summaries of the <code>max_norm</code>.
  epsilon: Small value chosen to avoid zero variance.
  name: The name for this operation is used to scope operations and summaries.</p>
<p>Returns:
  A function for applying gradient clipping.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.adaptive_clipping_fn', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.adaptive_clipping_fn" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.apply_regularization">
    <p>def <span class="ident">apply_regularization</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.apply_regularization(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersapply_regularization</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersapply_regularization(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.apply_regularization(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersapply_regularization</strong></p>
<div class="codehilite"><pre><span></span>Returns the summed penalty by applying `regularizer` to the `weights_list`.
</pre></div>


<p>Adding a regularization penalty over the layer weights and embedding weights
can help prevent overfitting the training data. Regularization over layer
biases is less common/useful, but assuming proper data preprocessing/mean
subtraction, it usually shouldn't hurt much either.</p>
<p>Args:
  regularizer: A function that takes a single <code>Tensor</code> argument and returns
    a scalar <code>Tensor</code> output.
  weights_list: List of weights <code>Tensors</code> or <code>Variables</code> to apply
    <code>regularizer</code> over. Defaults to the <code>GraphKeys.WEIGHTS</code> collection if
    <code>None</code>.</p>
<p>Returns:
  A scalar representing the overall regularization penalty.</p>
<p>Raises:
  ValueError: If <code>regularizer</code> does not return a scalar output, or if we find
      no weights.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.apply_regularization', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.apply_regularization" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.avg_pool2d">
    <p>def <span class="ident">avg_pool2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.avg_pool2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersavg_pool2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersavg_pool2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.avg_pool2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersavg_pool2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D average pooling op.
</pre></div>


<p>It is assumed that the pooling is done per image but not in batch or channels.</p>
<p>Args:
  inputs: A 4-D tensor of shape <code>[batch_size, height, width, channels]</code> if
    <code>data_format</code> is <code>NHWC</code>, and <code>[batch_size, channels, height, width]</code> if
    <code>data_format</code> is <code>NCHW</code>.
  kernel_size: A list of length 2: [kernel_height, kernel_width] of the
    pooling kernel over which the op is computed. Can be an int if both
    values are the same.
  stride: A list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: The padding method, either 'VALID' or 'SAME'.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.avg_pool2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.avg_pool2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.batch_norm">
    <p>def <span class="ident">batch_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.batch_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersbatch_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersbatch_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.batch_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersbatch_norm</strong></p>
<div class="codehilite"><pre><span></span>Adds a Batch Normalization layer from http://arxiv.org/abs/1502.03167.
</pre></div>


<p>"Batch Normalization: Accelerating Deep Network Training by Reducing
  Internal Covariate Shift"</p>
<p>Sergey Ioffe, Christian Szegedy</p>
<p>Can be used as a normalizer function for conv2d and fully_connected.</p>
<p>Note: When is_training is True the moving_mean and moving_variance need to be
updated, by default the update_ops are placed in <code>tf.GraphKeys.UPDATE_OPS</code> so
they need to be added as a dependency to the <code>train_op</code>, example:</p>
<p>update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS)
  if update_ops:
    updates = tf.group(*update_ops)
    total_loss = control_flow_ops.with_dependencies([updates], total_loss)</p>
<p>One can set updates_collections=None to force the updates in place, but that
can have speed penalty, specially in distributed settings.</p>
<p>Args:
  inputs: a tensor with 2 or more dimensions, where the first dimension has
    <code>batch_size</code>. The normalization is over all but the last dimension if
    <code>data_format</code> is <code>NHWC</code> and the second dimension if <code>data_format</code> is
    <code>NCHW</code>.
  decay: decay for the moving average. Reasonable values for <code>decay</code> are close 
    to 1.0, typically in the multiple-nines range: 0.999, 0.99, 0.9, etc. Lower 
    <code>decay</code> value (recommend trying <code>decay</code>=0.9) if model experiences reasonably 
    good training performance but poor validation and/or test performance.
  center: If True, subtract <code>beta</code>. If False, <code>beta</code> is ignored.
  scale: If True, multiply by <code>gamma</code>. If False, <code>gamma</code> is
    not used. When the next layer is linear (also e.g. <code>nn.relu</code>), this can be
    disabled since the scaling can be done by the next layer.
  epsilon: small float added to variance to avoid dividing by zero.
  activation_fn: activation function, default set to None to skip it and
    maintain a linear activation.
  param_initializers: optional initializers for beta, gamma, moving mean and
    moving variance.
  updates_collections: collections to collect the update ops for computation.
    The updates_ops need to be executed with the train_op.
    If None, a control dependency would be added to make sure the updates are
    computed in place.
  is_training: whether or not the layer is in training mode. In training mode
    it would accumulate the statistics of the moments into <code>moving_mean</code> and
    <code>moving_variance</code> using an exponential moving average with the given
    <code>decay</code>. When it is not in training mode then it would use the values of
    the <code>moving_mean</code> and the <code>moving_variance</code>.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional collections for the variables.
  outputs_collections: collections to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see <code>tf.Variable</code>).
  batch_weights: An optional tensor of shape <code>[batch_size]</code>,
    containing a frequency weight for each batch item. If present,
    then the batch normalization uses weighted mean and
    variance. (This can be used to correct for bias in training
    example selection.)
  fused:  Use nn.fused_batch_norm if True, nn.batch_normalization otherwise.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  A <code>Tensor</code> representing the output of the operation.</p>
<p>Raises:
  ValueError: if <code>batch_weights</code> is not None and <code>fused</code> is True.
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.
  ValueError: if the rank of <code>inputs</code> is undefined.
  ValueError: if rank or channels dimension of <code>inputs</code> is undefined.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.batch_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.batch_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.bias_add">
    <p>def <span class="ident">bias_add</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bias_add(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersbias_add</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersbias_add(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bias_add(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersbias_add</strong></p>
<div class="codehilite"><pre><span></span>Adds a bias to the inputs.
</pre></div>


<p>Can be used as a normalizer function for conv2d and fully_connected.</p>
<p>Args:
  inputs: a tensor of with at least rank 2 and value for the last dimension,
    e.g. <code>[batch_size, depth]</code>, <code>[None, None, None, depth]</code>.
  activation_fn: activation function, default set to None to skip it and
    maintain a linear activation.
  initializer: An initializer for the bias, defaults to 0.
  regularizer: A regularizer like the result of
    <code>l1_regularizer</code> or <code>l2_regularizer</code>.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional collections for the variables.
  outputs_collections: collections to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  data_format: A string. 'NHWC' and 'NCHW' are supported.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  a tensor representing the result of adding biases to the inputs.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.
  ValueError: if <code>data_format</code> is <code>NCHW</code> and rank of <code>inputs</code> is not 4.
  ValueError: if the rank of <code>inputs</code> is undefined.
  ValueError: if rank or <code>C</code> dimension of <code>inputs</code> is undefined.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.bias_add', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.bias_add" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.binary_svm_target">
    <p>def <span class="ident">binary_svm_target</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.binary_svm_target(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersbinary_svm_target</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersbinary_svm_target(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.binary_svm_target(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersbinary_svm_target</strong></p>
<div class="codehilite"><pre><span></span>Creates a _TargetColumn for binary classification with SVMs. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-12.
Instructions for updating:
This file will be removed after the deprecation date.Please switch to third_party/tensorflow/contrib/learn/python/learn/estimators/head.py</p>
<p>The target column uses binary hinge loss.</p>
<p>Args:
    label_name: String, name of the key in label dict. Can be null if label
      is a tensor (single headed models).
    weight_column_name: A string defining feature column name representing
      weights. It is used to down weight or boost examples during training. It
      will be multiplied by the loss of the example.</p>
<p>Returns:
    An instance of _TargetColumn.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.binary_svm_target', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.binary_svm_target" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.bow_encoder">
    <p>def <span class="ident">bow_encoder</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bow_encoder(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersbow_encoder</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersbow_encoder(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bow_encoder(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersbow_encoder</strong></p>
<div class="codehilite"><pre><span></span>Maps a sequence of symbols to a vector per example by averaging embeddings.
</pre></div>


<p>Args:
  ids: <code>[batch_size, doc_length]</code> <code>Tensor</code> or <code>SparseTensor</code> of type
    <code>int32</code> or <code>int64</code> with symbol ids.
  vocab_size: Integer number of symbols in vocabulary.
  embed_dim: Integer number of dimensions for embedding matrix.
  sparse_lookup: <code>bool</code>, if <code>True</code>, converts ids to a <code>SparseTensor</code>
      and performs a sparse embedding lookup. This is usually faster,
      but not desirable if padding tokens should have an embedding. Empty rows
      are assigned a special embedding.
  initializer: An initializer for the embeddings, if <code>None</code> default for
      current scope is used.
  regularizer: Optional regularizer for the embeddings.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional string specifying the variable scope for the op, required
      if <code>reuse=True</code>.
  reuse: If <code>True</code>, variables inside the op will be reused.</p>
<p>Returns:
  Encoding <code>Tensor</code> <code>[batch_size, embed_dim]</code> produced by
  averaging embeddings.</p>
<p>Raises:
  ValueError: If <code>embed_dim</code> or <code>vocab_size</code> are not specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.bow_encoder', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.bow_encoder" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.bucketize">
    <p>def <span class="ident">bucketize</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bucketize(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersbucketize</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersbucketize(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bucketize(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersbucketize</strong></p>
<div class="codehilite"><pre><span></span>Bucketizes input_tensor by given boundaries.
</pre></div>


<p>See bucketize_op.cc for more details.</p>
<p>Args:
  input_tensor: A <code>Tensor</code> which will be bucketize.
  boundaries: A list of floats gives the boundaries. It has to be sorted.
  name: A name prefix for the returned tensors (optional).</p>
<p>Returns:
  A <code>Tensor</code> with type int32 which indicates the corresponding bucket for
    each value in <code>input_tensor</code>.</p>
<p>Raises:
  TypeError: If boundaries is not a list.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.bucketize', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.bucketize" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.bucketized_column">
    <p>def <span class="ident">bucketized_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bucketized_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersbucketized_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersbucketized_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.bucketized_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersbucketized_column</strong></p>
<div class="codehilite"><pre><span></span>Creates a _BucketizedColumn for discretizing dense input.
</pre></div>


<p>Args:
  source_column: A _RealValuedColumn defining dense column.
  boundaries: A list of floats specifying the boundaries. It has to be sorted.</p>
<p>Returns:
  A _BucketizedColumn.</p>
<p>Raises:
  ValueError: if 'boundaries' is empty or not sorted.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.bucketized_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.bucketized_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.check_feature_columns">
    <p>def <span class="ident">check_feature_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.check_feature_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerscheck_feature_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerscheck_feature_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.check_feature_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerscheck_feature_columns</strong></p>
<div class="codehilite"><pre><span></span>Checks the validity of the set of FeatureColumns.
</pre></div>


<p>Args:
  feature_columns: A set of instances or subclasses of FeatureColumn.</p>
<p>Raises:
  ValueError: If there are duplicate feature column keys.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.check_feature_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.check_feature_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.conv2d">
    <p>def <span class="ident">conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconv2d</strong></p>
<div class="codehilite"><pre><span></span>Adds an N-D convolution followed by an optional batch_norm layer.
</pre></div>


<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p><code>convolution</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved (actually cross-correlated) with the
<code>inputs</code> to produce a <code>Tensor</code> of activations. If a <code>normalizer_fn</code> is
provided (such as <code>batch_norm</code>), it is then applied. Otherwise, if
<code>normalizer_fn</code> is None and a <code>biases_initializer</code> is provided then a <code>biases</code>
variable would be created and added the activations. Finally, if
<code>activation_fn</code> is not <code>None</code>, it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride/dilation rate equal to <code>rate</code>
if a value &gt; 1 for any dimension of <code>rate</code> is specified.  In this case
<code>stride</code> values != 1 are not supported.</p>
<p>Args:
  inputs: a Tensor of rank N+2 of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  num_outputs: integer, the number of output filters.
  kernel_size: a sequence of N positive integers specifying the spatial
    dimensions of of the filters.  Can be a single integer to specify the same
    value for all spatial dimensions.
  stride: a sequence of N positive integers specifying the stride at which to
    compute output.  Can be a single integer to specify the same value for all
    spatial dimensions.  Specifying any <code>stride</code> value != 1 is incompatible
    with specifying any <code>rate</code> value != 1.
  padding: one of <code>"VALID"</code> or <code>"SAME"</code>.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, currently the only valid value is "NDHWC".
  rate: a sequence of N positive integers specifying the dilation rate to use
    for a'trous convolution.  Can be a single integer to specify the same
    value for all spatial dimensions.  Specifying any <code>rate</code> value != 1 is
    incompatible with specifying any <code>stride</code> value != 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.
  ValueError: both 'rate' and <code>stride</code> are not uniformly 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_in_plane">
    <p>def <span class="ident">conv2d_in_plane</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.conv2d_in_plane(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconv2d_in_plane</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconv2d_in_plane(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.conv2d_in_plane(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconv2d_in_plane</strong></p>
<div class="codehilite"><pre><span></span>Performs the same in-plane convolution to each channel independently.
</pre></div>


<p>This is useful for performing various simple channel-independent convolution
operations such as image gradients:</p>
<p>image = tf.constant(..., shape=(16, 240, 320, 3))
  vert_gradients = layers.conv2d_in_plane(image,
                                          kernel=[1, -1],
                                          kernel_size=[2, 1])
  horz_gradients = layers.conv2d_in_plane(image,
                                          kernel=[1, -1],
                                          kernel_size=[1, 2])</p>
<p>Args:
  inputs: a 4-D tensor with dimensions [batch_size, height, width, channels].
  kernel_size: a list of length 2 holding the [kernel_height, kernel_width] of
    of the pooling. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: the padding type to use, either 'SAME' or 'VALID'.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  A <code>Tensor</code> representing the output of the operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_in_plane', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_in_plane" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_transpose">
    <p>def <span class="ident">conv2d_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.conv2d_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconv2d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconv2d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.conv2d_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconv2d_transpose</strong></p>
<div class="codehilite"><pre><span></span>Adds a convolution2d_transpose with an optional batch normalization layer.
</pre></div>


<p>The function creates a variable called <code>weights</code>, representing the
kernel, that is convolved with the input. If <code>batch_norm_params</code> is <code>None</code>, a
second variable called 'biases' is added to the result of the operation.</p>
<p>Args:
  inputs: A 4-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, height, width, in_channels]</code> for <code>NHWC</code> data format or
    <code>[batch, in_channels, height, width]</code> for <code>NCHW</code> data format.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 holding the [kernel_height, kernel_width] of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same.  Note that presently
    both strides must have the same value.
  padding: one of 'VALID' or 'SAME'.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: whether or not the variables should be trainable or not.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if 'kernel_size' is not a list of length 2.
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.
  ValueError: if <code>C</code> dimension of <code>inputs</code> is None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.conv2d_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.convolution">
    <p>def <span class="ident">convolution</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconvolution</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconvolution(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconvolution</strong></p>
<div class="codehilite"><pre><span></span>Adds an N-D convolution followed by an optional batch_norm layer.
</pre></div>


<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p><code>convolution</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved (actually cross-correlated) with the
<code>inputs</code> to produce a <code>Tensor</code> of activations. If a <code>normalizer_fn</code> is
provided (such as <code>batch_norm</code>), it is then applied. Otherwise, if
<code>normalizer_fn</code> is None and a <code>biases_initializer</code> is provided then a <code>biases</code>
variable would be created and added the activations. Finally, if
<code>activation_fn</code> is not <code>None</code>, it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride/dilation rate equal to <code>rate</code>
if a value &gt; 1 for any dimension of <code>rate</code> is specified.  In this case
<code>stride</code> values != 1 are not supported.</p>
<p>Args:
  inputs: a Tensor of rank N+2 of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  num_outputs: integer, the number of output filters.
  kernel_size: a sequence of N positive integers specifying the spatial
    dimensions of of the filters.  Can be a single integer to specify the same
    value for all spatial dimensions.
  stride: a sequence of N positive integers specifying the stride at which to
    compute output.  Can be a single integer to specify the same value for all
    spatial dimensions.  Specifying any <code>stride</code> value != 1 is incompatible
    with specifying any <code>rate</code> value != 1.
  padding: one of <code>"VALID"</code> or <code>"SAME"</code>.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, currently the only valid value is "NDHWC".
  rate: a sequence of N positive integers specifying the dilation rate to use
    for a'trous convolution.  Can be a single integer to specify the same
    value for all spatial dimensions.  Specifying any <code>rate</code> value != 1 is
    incompatible with specifying any <code>stride</code> value != 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.
  ValueError: both 'rate' and <code>stride</code> are not uniformly 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d">
    <p>def <span class="ident">convolution2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconvolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconvolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconvolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds an N-D convolution followed by an optional batch_norm layer.
</pre></div>


<p>It is required that 1 &lt;= N &lt;= 3.</p>
<p><code>convolution</code> creates a variable called <code>weights</code>, representing the
convolutional kernel, that is convolved (actually cross-correlated) with the
<code>inputs</code> to produce a <code>Tensor</code> of activations. If a <code>normalizer_fn</code> is
provided (such as <code>batch_norm</code>), it is then applied. Otherwise, if
<code>normalizer_fn</code> is None and a <code>biases_initializer</code> is provided then a <code>biases</code>
variable would be created and added the activations. Finally, if
<code>activation_fn</code> is not <code>None</code>, it is applied to the activations as well.</p>
<p>Performs a'trous convolution with input stride/dilation rate equal to <code>rate</code>
if a value &gt; 1 for any dimension of <code>rate</code> is specified.  In this case
<code>stride</code> values != 1 are not supported.</p>
<p>Args:
  inputs: a Tensor of rank N+2 of shape
    <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts
    with "NC".
  num_outputs: integer, the number of output filters.
  kernel_size: a sequence of N positive integers specifying the spatial
    dimensions of of the filters.  Can be a single integer to specify the same
    value for all spatial dimensions.
  stride: a sequence of N positive integers specifying the stride at which to
    compute output.  Can be a single integer to specify the same value for all
    spatial dimensions.  Specifying any <code>stride</code> value != 1 is incompatible
    with specifying any <code>rate</code> value != 1.
  padding: one of <code>"VALID"</code> or <code>"SAME"</code>.
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, currently the only valid value is "NDHWC".
  rate: a sequence of N positive integers specifying the dilation rate to use
    for a'trous convolution.  Can be a single integer to specify the same
    value for all spatial dimensions.  Specifying any <code>rate</code> value != 1 is
    incompatible with specifying any <code>stride</code> value != 1.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is invalid.
  ValueError: both 'rate' and <code>stride</code> are not uniformly 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_in_plane">
    <p>def <span class="ident">convolution2d_in_plane</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution2d_in_plane(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconvolution2d_in_plane</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconvolution2d_in_plane(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution2d_in_plane(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconvolution2d_in_plane</strong></p>
<div class="codehilite"><pre><span></span>Performs the same in-plane convolution to each channel independently.
</pre></div>


<p>This is useful for performing various simple channel-independent convolution
operations such as image gradients:</p>
<p>image = tf.constant(..., shape=(16, 240, 320, 3))
  vert_gradients = layers.conv2d_in_plane(image,
                                          kernel=[1, -1],
                                          kernel_size=[2, 1])
  horz_gradients = layers.conv2d_in_plane(image,
                                          kernel=[1, -1],
                                          kernel_size=[1, 2])</p>
<p>Args:
  inputs: a 4-D tensor with dimensions [batch_size, height, width, channels].
  kernel_size: a list of length 2 holding the [kernel_height, kernel_width] of
    of the pooling. Can be an int if both values are the same.
  stride: a list of length 2 <code>[stride_height, stride_width]</code>.
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: the padding type to use, either 'SAME' or 'VALID'.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  A <code>Tensor</code> representing the output of the operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_in_plane', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_in_plane" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_transpose">
    <p>def <span class="ident">convolution2d_transpose</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution2d_transpose(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersconvolution2d_transpose</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersconvolution2d_transpose(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.convolution2d_transpose(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersconvolution2d_transpose</strong></p>
<div class="codehilite"><pre><span></span>Adds a convolution2d_transpose with an optional batch normalization layer.
</pre></div>


<p>The function creates a variable called <code>weights</code>, representing the
kernel, that is convolved with the input. If <code>batch_norm_params</code> is <code>None</code>, a
second variable called 'biases' is added to the result of the operation.</p>
<p>Args:
  inputs: A 4-D <code>Tensor</code> of type <code>float</code> and shape
    <code>[batch, height, width, in_channels]</code> for <code>NHWC</code> data format or
    <code>[batch, in_channels, height, width]</code> for <code>NCHW</code> data format.
  num_outputs: integer, the number of output filters.
  kernel_size: a list of length 2 holding the [kernel_height, kernel_width] of
    of the filters. Can be an int if both values are the same.
  stride: a list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same.  Note that presently
    both strides must have the same value.
  padding: one of 'VALID' or 'SAME'.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionary containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: whether or not the variables should be trainable or not.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  a tensor representing the output of the operation.</p>
<p>Raises:
  ValueError: if 'kernel_size' is not a list of length 2.
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.
  ValueError: if <code>C</code> dimension of <code>inputs</code> is None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_transpose', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.convolution2d_transpose" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.create_feature_spec_for_parsing">
    <p>def <span class="ident">create_feature_spec_for_parsing</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.create_feature_spec_for_parsing(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerscreate_feature_spec_for_parsing</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerscreate_feature_spec_for_parsing(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.create_feature_spec_for_parsing(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerscreate_feature_spec_for_parsing</strong></p>
<div class="codehilite"><pre><span></span>Helper that prepares features config from input feature_columns.
</pre></div>


<p>The returned feature config can be used as arg 'features' in tf.parse_example.</p>
<p>Typical usage example:</p>
<p>```python</p>
<h1>Define features and transformations</h1>
<p>feature_a = sparse_column_with_vocabulary_file(...)
feature_b = real_valued_column(...)
feature_c_bucketized = bucketized_column(real_valued_column("feature_c"), ...)
feature_a_x_feature_c = crossed_column(
  columns=[feature_a, feature_c_bucketized], ...)</p>
<p>feature_columns = set(
  [feature_b, feature_c_bucketized, feature_a_x_feature_c])
batch_examples = tf.parse_example(
    serialized=serialized_examples,
    features=create_feature_spec_for_parsing(feature_columns))
```</p>
<p>For the above example, create_feature_spec_for_parsing would return the dict:
{
  "feature_a": parsing_ops.VarLenFeature(tf.string),
  "feature_b": parsing_ops.FixedLenFeature([1], dtype=tf.float32),
  "feature_c": parsing_ops.FixedLenFeature([1], dtype=tf.float32)
}</p>
<p>Args:
  feature_columns: An iterable containing all the feature columns. All items
    should be instances of classes derived from _FeatureColumn, unless
    feature_columns is a dict -- in which case, this should be true of all
    values in the dict.
Returns:
  A dict mapping feature keys to FixedLenFeature or VarLenFeature values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.create_feature_spec_for_parsing', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.create_feature_spec_for_parsing" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.crossed_column">
    <p>def <span class="ident">crossed_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.crossed_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerscrossed_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerscrossed_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.crossed_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerscrossed_column</strong></p>
<div class="codehilite"><pre><span></span>Creates a _CrossedColumn for performing feature crosses.
</pre></div>


<p>Args:
  columns: An iterable of _FeatureColumn. Items can be an instance of
    _SparseColumn, _CrossedColumn, or _BucketizedColumn.
  hash_bucket_size: An int that is &gt; 1. The number of buckets.
  combiner: A combiner string, supports sum, mean, sqrtn.
  ckpt_to_load_from: (Optional). String representing checkpoint name/pattern
    to restore the column weights. Required if <code>tensor_name_in_ckpt</code> is not
    None.
  tensor_name_in_ckpt: (Optional). Name of the <code>Tensor</code> in the provided
    checkpoint from which to restore the column weights. Required if
    <code>ckpt_to_load_from</code> is not None.
  hash_key: Specify the hash_key that will be used by the <code>FingerprintCat64</code>
    function to combine the crosses fingerprints on SparseFeatureCrossOp
    (optional).</p>
<p>Returns:
  A _CrossedColumn.</p>
<p>Raises:
  TypeError: if any item in columns is not an instance of _SparseColumn,
    _CrossedColumn, or _BucketizedColumn, or
    hash_bucket_size is not an int.
  ValueError: if hash_bucket_size is not &gt; 1 or
    len(columns) is not &gt; 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.crossed_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.crossed_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.deprecated">
    <p>def <span class="ident">deprecated</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.deprecated(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersdeprecated</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersdeprecated(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.deprecated(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersdeprecated</strong></p>
<div class="codehilite"><pre><span></span>Decorator for marking functions or methods deprecated.
</pre></div>


<p>This decorator logs a deprecation warning whenever the decorated function is
called. It has the following format:</p>
<p><function> (from <module>) is deprecated and will be removed after <date>.
  Instructions for updating:
  <instructions></p>
<p><function> will include the class name if it is a method.</p>
<p>It also edits the docstring of the function: ' (deprecated)' is appended
to the first line of the docstring and a deprecation notice is prepended
to the rest of the docstring.</p>
<p>Args:
  date: String. The date the function is scheduled to be removed. Must be
    ISO 8601 (YYYY-MM-DD).
  instructions: String. Instructions on how to update code using the
    deprecated function.</p>
<p>Returns:
  Decorated function or method.</p>
<p>Raises:
  ValueError: If date is not in ISO 8601 format, or instructions are empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.deprecated', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.deprecated" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.deprecated_arg_values">
    <p>def <span class="ident">deprecated_arg_values</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.deprecated_arg_values(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersdeprecated_arg_values</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersdeprecated_arg_values(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.deprecated_arg_values(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersdeprecated_arg_values</strong></p>
<div class="codehilite"><pre><span></span>Decorator for marking specific function argument values as deprecated.
</pre></div>


<p>This decorator logs a deprecation warning whenever the decorated function is
called with the deprecated argument values. It has the following format:</p>
<p>Calling <function> (from <module>) with <arg>=<value> is deprecated and
  will be removed after <date>. Instructions for updating:
    <instructions></p>
<p><function> will include the class name if it is a method.</p>
<p>It also edits the docstring of the function: ' (deprecated arguments)' is
appended to the first line of the docstring and a deprecation notice is
prepended to the rest of the docstring.</p>
<p>Args:
  date: String. The date the function is scheduled to be removed. Must be
    ISO 8601 (YYYY-MM-DD).
  instructions: String. Instructions on how to update code using the
    deprecated function.
  **deprecated_kwargs: The deprecated argument values.</p>
<p>Returns:
  Decorated function or method.</p>
<p>Raises:
  ValueError: If date is not in ISO 8601 format, or instructions are empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.deprecated_arg_values', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.deprecated_arg_values" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.dropout">
    <p>def <span class="ident">dropout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.dropout(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersdropout</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersdropout(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.dropout(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersdropout</strong></p>
<div class="codehilite"><pre><span></span>Returns a dropout op applied to the input.
</pre></div>


<p>With probability <code>keep_prob</code>, outputs the input element scaled up by
<code>1 / keep_prob</code>, otherwise outputs <code>0</code>.  The scaling is so that the expected
sum is unchanged.</p>
<p>Args:
  inputs: the tensor to pass to the nn.dropout op.
  keep_prob: A scalar <code>Tensor</code> with the same type as x. The probability
    that each element is kept.
  noise_shape: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the
    shape for randomly generated keep/drop flags.
  is_training: A bool <code>Tensor</code> indicating whether or not the model
    is in training mode. If so, dropout is applied and values scaled.
    Otherwise, inputs is returned.
  outputs_collections: collection to add the outputs.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  a tensor representing the output of the operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.dropout', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.dropout" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.embed_sequence">
    <p>def <span class="ident">embed_sequence</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.embed_sequence(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersembed_sequence</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersembed_sequence(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.embed_sequence(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersembed_sequence</strong></p>
<div class="codehilite"><pre><span></span>Maps a sequence of symbols to a sequence of embeddings.
</pre></div>


<p>Typical use case would be reusing embeddings between an encoder and decoder.</p>
<p>Args:
  ids: <code>[batch_size, doc_length]</code> <code>Tensor</code> of type <code>int32</code> or <code>int64</code>
    with symbol ids.
  vocab_size: Integer number of symbols in vocabulary.
  embed_dim: Integer number of dimensions for embedding matrix.
  unique: If <code>True</code>, will first compute the unique set of indices, and then
       lookup each embedding once, repeating them in the output as needed.
  initializer: An initializer for the embeddings, if <code>None</code> default for
      current scope is used.
  regularizer: Optional regularizer for the embeddings.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see <code>tf.Variable</code>).
  scope: Optional string specifying the variable scope for the op, required
      if <code>reuse=True</code>.
  reuse: If <code>True</code>, variables inside the op will be reused.</p>
<p>Returns:
  <code>Tensor</code> of <code>[batch_size, doc_length, embed_dim]</code> with embedded sequences.</p>
<p>Raises:
  ValueError: if <code>embed_dim</code> or <code>vocab_size</code> are not specified when not
    <code>reuse</code> is <code>None</code> or <code>False</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.embed_sequence', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.embed_sequence" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.embedding_column">
    <p>def <span class="ident">embedding_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.embedding_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersembedding_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersembedding_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.embedding_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersembedding_column</strong></p>
<div class="codehilite"><pre><span></span>Creates an `_EmbeddingColumn` for feeding sparse data into a DNN.
</pre></div>


<p>Args:
  sparse_id_column: A <code>_SparseColumn</code> which is created by for example
    <code>sparse_column_with_*</code> or crossed_column functions. Note that <code>combiner</code>
    defined in <code>sparse_id_column</code> is ignored.
  dimension: An integer specifying dimension of the embedding.
  combiner: A string specifying how to reduce if there are multiple entries
    in a single row. Currently "mean", "sqrtn" and "sum" are supported. Each
    of this can be considered an example level normalization on the column:
      * "sum": do not normalize
      * "mean": do l1 normalization
      * "sqrtn": do l2 normalization
    For more information: <code>tf.embedding_lookup_sparse</code>.
  initializer: A variable initializer function to be used in embedding
    variable initialization. If not specified, defaults to
    <code>tf.truncated_normal_initializer</code> with mean 0.0 and standard deviation
    1/sqrt(sparse_id_column.length).
  ckpt_to_load_from: (Optional). String representing checkpoint name/pattern
    to restore the column weights. Required if <code>tensor_name_in_ckpt</code> is not
    None.
  tensor_name_in_ckpt: (Optional). Name of the <code>Tensor</code> in the provided
    checkpoint from which to restore the column weights. Required if
    <code>ckpt_to_load_from</code> is not None.</p>
<p>Returns:
  An <code>_EmbeddingColumn</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.embedding_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.embedding_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.embedding_lookup_unique">
    <p>def <span class="ident">embedding_lookup_unique</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.embedding_lookup_unique(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersembedding_lookup_unique</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersembedding_lookup_unique(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.embedding_lookup_unique(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersembedding_lookup_unique</strong></p>
<div class="codehilite"><pre><span></span>Version of embedding_lookup that avoids duplicate lookups.
</pre></div>


<p>This can save communication in the case of repeated ids.
Same interface as embedding_lookup. Except it supports multi-dimensional <code>ids</code>
which allows to not reshape input/output to fit gather.</p>
<p>Args:
  params: A list of tensors with the same shape and type, or a
    <code>PartitionedVariable</code>. Shape <code>[index, d1, d2, ...]</code>.
  ids: A one-dimensional <code>Tensor</code> with type <code>int32</code> or <code>int64</code> containing
    the ids to be looked up in <code>params</code>. Shape <code>[ids1, ids2, ...]</code>.
  name: A name for this operation (optional).</p>
<p>Returns:
  A <code>Tensor</code> with the same type as the tensors in <code>params</code> and dimension of
  <code>[ids1, ids2, d1, d2, ...]</code>.</p>
<p>Raises:
  ValueError: If <code>params</code> is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.embedding_lookup_unique', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.embedding_lookup_unique" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.experimental">
    <p>def <span class="ident">experimental</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.experimental(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersexperimental</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersexperimental(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.experimental(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersexperimental</strong></p>
<div class="codehilite"><pre><span></span>Decorator for marking functions or methods experimental.
</pre></div>


<p>This decorator logs an experimental warning whenever the decorated function is
called. It has the following format:</p>
<p><function> (from <module>) is experimental and may change or be removed at
  any time, and without warning.</p>
<p><function> will include the class name if it is a method.</p>
<p>It also edits the docstring of the function: ' (experimental)' is appended
to the first line of the docstring and a notice is prepended to the rest of
the docstring.</p>
<p>Args:
  func: A function or method to mark experimental.</p>
<p>Returns:
  Decorated function or method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.experimental', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.experimental" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.flatten">
    <p>def <span class="ident">flatten</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.flatten(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersflatten</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersflatten(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.flatten(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersflatten</strong></p>
<div class="codehilite"><pre><span></span>Flattens the input while maintaining the batch_size.
</pre></div>


<p>Assumes that the first dimension represents the batch.</p>
<p>Args:
  inputs: a tensor of size [batch_size, ...].
  outputs_collections: collection to add the outputs.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  a flattened tensor with shape [batch_size, k].
Raises:
  ValueError: if inputs.shape is wrong.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.flatten', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.flatten" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.fully_connected">
    <p>def <span class="ident">fully_connected</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.fully_connected(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersfully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersfully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.fully_connected(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersfully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds a fully connected layer.
</pre></div>


<p><code>fully_connected</code> creates a variable called <code>weights</code>, representing a fully
connected weight matrix, which is multiplied by the <code>inputs</code> to produce a
<code>Tensor</code> of hidden units. If a <code>normalizer_fn</code> is provided (such as
<code>batch_norm</code>), it is then applied. Otherwise, if <code>normalizer_fn</code> is
None and a <code>biases_initializer</code> is provided then a <code>biases</code> variable would be
created and added the hidden units. Finally, if <code>activation_fn</code> is not <code>None</code>,
it is applied to the hidden units as well.</p>
<p>Note: that if <code>inputs</code> have a rank greater than 2, then <code>inputs</code> is flattened
prior to the initial matrix multiply by <code>weights</code>.</p>
<p>Args:
  inputs: A tensor of with at least rank 2 and value for the last dimension,
    i.e. <code>[batch_size, depth]</code>, <code>[None, None, None, channels]</code>.
  num_outputs: Integer or long, the number of output units in the layer.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: Optional list of collections for all the variables or
    a dictionary containing a different list of collections per variable.
  outputs_collections: collection to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
   the tensor variable representing the result of the series of operations.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.fully_connected', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.fully_connected" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.get_default_binary_metrics_for_eval">
    <p>def <span class="ident">get_default_binary_metrics_for_eval</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.get_default_binary_metrics_for_eval(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersget_default_binary_metrics_for_eval</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersget_default_binary_metrics_for_eval(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.get_default_binary_metrics_for_eval(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersget_default_binary_metrics_for_eval</strong></p>
<div class="codehilite"><pre><span></span>Returns a dictionary of basic metrics for logistic regression. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-12.
Instructions for updating:
This file will be removed after the deprecation date.Please switch to third_party/tensorflow/contrib/learn/python/learn/estimators/head.py</p>
<p>Args:
    thresholds: List of floating point thresholds to use for accuracy,
      precision, and recall metrics. If None, defaults to [0.5].</p>
<p>Returns:
    Dictionary mapping metrics string names to metrics functions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.get_default_binary_metrics_for_eval', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.get_default_binary_metrics_for_eval" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_column">
    <p>def <span class="ident">hashed_embedding_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.hashed_embedding_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layershashed_embedding_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layershashed_embedding_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.hashed_embedding_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layershashed_embedding_column</strong></p>
<div class="codehilite"><pre><span></span>Creates an embedding column of a sparse feature using parameter hashing.
</pre></div>


<p>The i-th embedding component of a value v is found by retrieving an
embedding weight whose index is a fingerprint of the pair (v,i).</p>
<p>Args:
  column_name: A string defining sparse column name.
  size: An integer specifying the number of parameters in the embedding layer.
  dimension: An integer specifying dimension of the embedding.
  combiner: A string specifying how to reduce if there are multiple entries
    in a single row. Currently "mean", "sqrtn" and "sum" are supported. Each
    of this can be thought as example level normalizations on the column:
      * "sum": do not normalize features in the column
      * "mean": do l1 normalization on features in the column
      * "sqrtn": do l2 normalization on features in the column
    For more information: <code>tf.embedding_lookup_sparse</code>.
  initializer: A variable initializer function to be used in embedding
    variable initialization. If not specified, defaults to
    <code>tf.truncated_normal_initializer</code> with mean 0 and standard deviation 0.1.</p>
<p>Returns:
  A _HashedEmbeddingColumn.</p>
<p>Raises:
  ValueError: if dimension or size is not a positive integer; or if combiner
    is not supported.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup">
    <p>def <span class="ident">hashed_embedding_lookup</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.hashed_embedding_lookup(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layershashed_embedding_lookup</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layershashed_embedding_lookup(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.hashed_embedding_lookup(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layershashed_embedding_lookup</strong></p>
<div class="codehilite"><pre><span></span>Looks up embeddings using parameter hashing for each value in `values`.
</pre></div>


<p>The i-th embedding component of a value v in <code>values</code> is found by retrieving
the weight whose index is a fingerprint of the pair (v,i).
The concept is explored as "feature hashing" for model compression in this
paper: http://arxiv.org/pdf/1504.04788.pdf</p>
<p>Feature hashing has the pleasant effect of allowing us to compute an embedding
without needing a pre-determined vocabulary, relieving some amount of process
complexity. It also allows for us to maintain embeddings for possibly
trillions of features with a fixed amount of memory.</p>
<p>Note that this is superior to out-of-vocabulary shared "hash buckets" in that
the embedding is extremely likely to be unique for each token as opposed to
being shared across probably-colliding tokens. The price is that we must
compute a hash once for each scalar in the token's embedding as opposed to
once per token.</p>
<p>If <code>params</code> is a list, it represents a partition of the embedding parameters.
Each tensor in the list should have the same length, except for the first ones
which may have an additional element. For instance 10 parameters can be
partitioned in 4 tensors with length <code>[3, 3, 2, 2]</code>.</p>
<p>Args:
  params: A <code>Tensor</code>, <code>list</code> of <code>Tensors</code>, or <code>PartitionedVariable</code>.
    Each tensor must be of rank 1 with fully-defined shape.
  values: <code>Tensor</code> of values to be embedded.
  dimension: Embedding dimension
  name: An optional name for this op.
  hash_key: Specify the hash_key that will be used by the <code>FingerprintCat64</code>
    function to combine the crosses fingerprints on SparseFeatureCrossOp
    (optional).</p>
<p>Returns:
  A tensor with shape [d0, ..., dn, dimension]
    with shape(values) = [d0, ..., dn]</p>
<p>Raises:
  ValueError: if dimension is not positive or the partition size is invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup_sparse">
    <p>def <span class="ident">hashed_embedding_lookup_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.hashed_embedding_lookup_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layershashed_embedding_lookup_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layershashed_embedding_lookup_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.hashed_embedding_lookup_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layershashed_embedding_lookup_sparse</strong></p>
<div class="codehilite"><pre><span></span>Looks up embeddings of a sparse feature using parameter hashing.
</pre></div>


<p>See <code>tf.contrib.layers.hashed_embedding_lookup</code> for embedding with hashing.</p>
<p>Args:
  params: A <code>Tensor</code>, <code>list</code> of <code>Tensors</code>, or <code>PartitionedVariable</code>.
    Each tensor must be of rank 1 with fully-defined shape.
  sparse_values: A 2-D <code>SparseTensor</code> containing the values to be embedded.
    Some rows may be empty.
  dimension: Embedding dimension
  combiner: A string specifying how to combine embedding results for each
      entry. Currently "mean", "sqrtn" and "sum" are supported, with "mean"
      the default.
  default_value: The value to use for an entry with no features.
  name: An optional name for this op.
  hash_key: Specify the hash_key that will be used by the <code>FingerprintCat64</code>
    function to combine the crosses fingerprints on SparseFeatureCrossOp
    (optional).</p>
<p>Returns:
   Dense tensor with shape [N, dimension] with N the number of rows in
     sparse_values.</p>
<p>Raises:
  TypeError: If sparse_values is not a SparseTensor.
  ValueError: If combiner is not one of {"mean", "sqrtn", "sum"}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.hashed_embedding_lookup_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.infer_real_valued_columns">
    <p>def <span class="ident">infer_real_valued_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.infer_real_valued_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersinfer_real_valued_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersinfer_real_valued_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.infer_real_valued_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersinfer_real_valued_columns</strong></p>
<div class="codehilite"><pre><span></span>None
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.infer_real_valued_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.infer_real_valued_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.input_from_feature_columns">
    <p>def <span class="ident">input_from_feature_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.input_from_feature_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersinput_from_feature_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersinput_from_feature_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.input_from_feature_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersinput_from_feature_columns</strong></p>
<div class="codehilite"><pre><span></span>A tf.contrib.layer style input layer builder based on FeatureColumns.
</pre></div>


<p>Generally a single example in training data is described with feature columns.
At the first layer of the model, this column oriented data should be converted
to a single tensor. Each feature column needs a different kind of operation
during this conversion. For example sparse features need a totally different
handling than continuous features.</p>
<p>Example:</p>
<p><code>python
  # Building model for training
  columns_to_tensor = tf.parse_example(...)
  first_layer = input_from_feature_columns(
      columns_to_tensors=columns_to_tensor,
      feature_columns=feature_columns)
  second_layer = fully_connected(inputs=first_layer, ...)
  ...</code></p>
<p>where feature_columns can be defined as follows:</p>
<p>```python
  sparse_feature = sparse_column_with_hash_bucket(
      column_name="sparse_col", ...)
  sparse_feature_emb = embedding_column(sparse_id_column=sparse_feature, ...)
  real_valued_feature = real_valued_column(...)
  real_valued_buckets = bucketized_column(
      source_column=real_valued_feature, ...)</p>
<p>feature_columns=[sparse_feature_emb, real_valued_buckets]
```</p>
<p>Args:
  columns_to_tensors: A mapping from feature column to tensors. 'string' key
    means a base feature (not-transformed). It can have FeatureColumn as a
    key too. That means that FeatureColumn is already transformed by input
    pipeline. For example, <code>inflow</code> may have handled transformations.
  feature_columns: A set containing all the feature columns. All items in the
    set should be instances of classes derived by FeatureColumn.
  weight_collections: List of graph collections to which weights are added.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  A Tensor which can be consumed by hidden layers in the neural network.</p>
<p>Raises:
  ValueError: if FeatureColumn cannot be consumed by a neural network.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.input_from_feature_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.input_from_feature_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.joint_weighted_sum_from_feature_columns">
    <p>def <span class="ident">joint_weighted_sum_from_feature_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.joint_weighted_sum_from_feature_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersjoint_weighted_sum_from_feature_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersjoint_weighted_sum_from_feature_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.joint_weighted_sum_from_feature_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersjoint_weighted_sum_from_feature_columns</strong></p>
<div class="codehilite"><pre><span></span>A restricted linear prediction builder based on FeatureColumns.
</pre></div>


<p>As long as all feature columns are unweighted sparse columns this computes the
prediction of a linear model which stores all weights in a single variable.</p>
<p>Args:
  columns_to_tensors: A mapping from feature column to tensors. 'string' key
    means a base feature (not-transformed). It can have FeatureColumn as a
    key too. That means that FeatureColumn is already transformed by input
    pipeline. For example, <code>inflow</code> may have handled transformations.
  feature_columns: A set containing all the feature columns. All items in the
    set should be instances of classes derived from FeatureColumn.
  num_outputs: An integer specifying number of outputs. Default value is 1.
  weight_collections: List of graph collections to which weights are added.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  A tuple containing:</p>
<div class="codehilite"><pre><span></span>* A Tensor which represents predictions of a linear model.
* A list of Variables storing the weights.
* A Variable which is used for bias.
</pre></div>


<p>Raises:
  ValueError: if FeatureColumn cannot be used for linear predictions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.joint_weighted_sum_from_feature_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.joint_weighted_sum_from_feature_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.l1_l2_regularizer">
    <p>def <span class="ident">l1_l2_regularizer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.l1_l2_regularizer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersl1_l2_regularizer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersl1_l2_regularizer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.l1_l2_regularizer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersl1_l2_regularizer</strong></p>
<div class="codehilite"><pre><span></span>Returns a function that can be used to apply L1 L2 regularizations.
</pre></div>


<p>Args:
  scale_l1: A scalar multiplier <code>Tensor</code> for L1 regularization.
  scale_l2: A scalar multiplier <code>Tensor</code> for L2 regularization.
  scope: An optional scope name.</p>
<p>Returns:
  A function with signature <code>l1_l2(weights)</code> that applies a weighted sum of
  L1 L2  regularization.</p>
<p>Raises:
  ValueError: If scale is negative or if scale is not a float.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.l1_l2_regularizer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.l1_l2_regularizer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.l1_regularizer">
    <p>def <span class="ident">l1_regularizer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.l1_regularizer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersl1_regularizer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersl1_regularizer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.l1_regularizer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersl1_regularizer</strong></p>
<div class="codehilite"><pre><span></span>Returns a function that can be used to apply L1 regularization to weights.
</pre></div>


<p>L1 regularization encourages sparsity.</p>
<p>Args:
  scale: A scalar multiplier <code>Tensor</code>. 0.0 disables the regularizer.
  scope: An optional scope name.</p>
<p>Returns:
  A function with signature <code>l1(weights)</code> that apply L1 regularization.</p>
<p>Raises:
  ValueError: If scale is negative or if scale is not a float.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.l1_regularizer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.l1_regularizer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.l2_regularizer">
    <p>def <span class="ident">l2_regularizer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.l2_regularizer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersl2_regularizer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersl2_regularizer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.l2_regularizer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersl2_regularizer</strong></p>
<div class="codehilite"><pre><span></span>Returns a function that can be used to apply L2 regularization to weights.
</pre></div>


<p>Small values of L2 can help prevent overfitting the training data.</p>
<p>Args:
  scale: A scalar multiplier <code>Tensor</code>. 0.0 disables the regularizer.
  scope: An optional scope name.</p>
<p>Returns:
  A function with signature <code>l2(weights)</code> that applies L2 regularization.</p>
<p>Raises:
  ValueError: If scale is negative or if scale is not a float.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.l2_regularizer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.l2_regularizer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.layer_norm">
    <p>def <span class="ident">layer_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.layer_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerslayer_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerslayer_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.layer_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerslayer_norm</strong></p>
<div class="codehilite"><pre><span></span>Adds a Layer Normalization layer from https://arxiv.org/abs/1607.06450.
</pre></div>


<p>"Layer Normalization"</p>
<p>Jimmy Lei Ba, Jamie Ryan Kiros, Geoffrey E. Hinton</p>
<p>Can be used as a normalizer function for conv2d and fully_connected.</p>
<p>Args:
  inputs: a tensor with 2 or more dimensions. The normalization
          occurs over all but the first dimension.
  center: If True, subtract <code>beta</code>. If False, <code>beta</code> is ignored.
  scale: If True, multiply by <code>gamma</code>. If False, <code>gamma</code> is
    not used. When the next layer is linear (also e.g. <code>nn.relu</code>), this can be
    disabled since the scaling can be done by the next layer.
  activation_fn: activation function, default set to None to skip it and
    maintain a linear activation.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional collections for the variables.
  outputs_collections: collections to add the outputs.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for <code>variable_scope</code>.</p>
<p>Returns:
  A <code>Tensor</code> representing the output of the operation.</p>
<p>Raises:
  ValueError: if rank or last dimension of <code>inputs</code> is undefined.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.layer_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.layer_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.legacy_fully_connected">
    <p>def <span class="ident">legacy_fully_connected</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.legacy_fully_connected(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerslegacy_fully_connected</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerslegacy_fully_connected(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.legacy_fully_connected(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerslegacy_fully_connected</strong></p>
<div class="codehilite"><pre><span></span>Adds the parameters for a fully connected layer and returns the output.
</pre></div>


<p>A fully connected layer is generally defined as a matrix multiply:
<code>y = f(w * x + b)</code> where <code>f</code> is given by <code>activation_fn</code>. If
<code>activation_fn</code> is <code>None</code>, the result of <code>y = w * x + b</code> is
returned.</p>
<p>If <code>x</code> has shape [\(\text{dim}<em>0, \text{dim}_1, ..., \text{dim}_n\)]
with more than 2 dimensions (\(n &gt; 1\)), then we repeat the matrix
multiply along the first dimensions. The result r is a tensor of shape
[\(\text{dim}_0, ..., \text{dim}</em>{n-1},\) <code>num_output_units</code>],
where \( r_{i_0, ..., i_{n-1}, k} =
\sum_{0 \leq j &lt; \text{dim}<em>n} x</em>{i_0, ... i_{n-1}, j} \cdot w_{j, k}\).
This is accomplished by reshaping <code>x</code> to 2-D
[\(\text{dim}<em>0 \cdot ... \cdot \text{dim}</em>{n-1}, \text{dim}<em>n\)]
before the matrix multiply and afterwards reshaping it to
[\(\text{dim}_0, ..., \text{dim}</em>{n-1},\) <code>num_output_units</code>].</p>
<p>This op creates <code>w</code> and optionally <code>b</code>. Bias (<code>b</code>) can be disabled by setting
<code>bias_init</code> to <code>None</code>.</p>
<p>The variable creation is compatible with <code>tf.variable_scope</code> and so can be
reused with <code>tf.variable_scope</code> or <code>tf.make_template</code>.</p>
<p>Most of the details of variable creation can be controlled by specifying the
initializers (<code>weight_init</code> and <code>bias_init</code>) and in which collections to place
the created variables (<code>weight_collections</code> and <code>bias_collections</code>; note that
the variables are always added to the <code>VARIABLES</code> collection). The output of
the layer can be placed in custom collections using <code>output_collections</code>.
The collections arguments default to <code>WEIGHTS</code>, <code>BIASES</code> and <code>ACTIVATIONS</code>,
respectively.</p>
<p>A per layer regularization can be specified by setting <code>weight_regularizer</code>
and <code>bias_regularizer</code>, which are applied to the weights and biases
respectively, and whose output is added to the <code>REGULARIZATION_LOSSES</code>
collection.</p>
<p>Args:
  x: The input <code>Tensor</code>.
  num_output_units: The size of the output.
  activation_fn: activation function, default set to None to skip it and
    maintain a linear activation.
  weight_init: An optional weight initialization, defaults to
    <code>xavier_initializer</code>.
  bias_init: An initializer for the bias, defaults to 0. Set to <code>None</code> in
    order to disable bias.
  name: The name for this operation is used to name operations and to find
    variables. If specified it must be unique for this scope, otherwise a
    unique name starting with "fully_connected" will be created.  See
    <code>tf.variable_scope</code> for details.
  weight_collections: List of graph collections to which weights are added.
  bias_collections: List of graph collections to which biases are added.
  output_collections: List of graph collections to which outputs are added.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  weight_regularizer: A regularizer like the result of
    <code>l1_regularizer</code> or <code>l2_regularizer</code>. Used for weights.
  bias_regularizer: A regularizer like the result of
    <code>l1_regularizer</code> or <code>l2_regularizer</code>. Used for biases.</p>
<p>Returns:
  The output of the fully connected layer.</p>
<p>Raises:
  ValueError: if x has rank less than 2 or if its last dimension is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.legacy_fully_connected', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.legacy_fully_connected" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.make_all">
    <p>def <span class="ident">make_all</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.make_all(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersmake_all</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersmake_all(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.make_all(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersmake_all</strong></p>
<div class="codehilite"><pre><span></span>Generates `__all__` from the docstring of one or more modules.
</pre></div>


<p>Usage: <code>make_all(__name__)</code> or
<code>make_all(__name__, [sys.modules(__name__), other_module])</code>. The doc string
modules must each a docstring, and <code>__all__</code> will contain all symbols with
<code>@@</code> references, where that symbol currently exists in the module named
<code>module_name</code>.</p>
<p>Args:
  module_name: The name of the module (usually <code>__name__</code>).
  doc_string_modules: a list of modules from which to take docstring.
  If None, then a list containing only the module named <code>module_name</code> is used.</p>
<p>Returns:
  A list suitable for use as <code>__all__</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.make_all', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.make_all" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.make_place_holder_tensors_for_base_features">
    <p>def <span class="ident">make_place_holder_tensors_for_base_features</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.make_place_holder_tensors_for_base_features(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersmake_place_holder_tensors_for_base_features</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersmake_place_holder_tensors_for_base_features(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.make_place_holder_tensors_for_base_features(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersmake_place_holder_tensors_for_base_features</strong></p>
<div class="codehilite"><pre><span></span>Returns placeholder tensors for inference.
</pre></div>


<p>Args:
  feature_columns: An iterable containing all the feature columns. All items
    should be instances of classes derived from _FeatureColumn.
Returns:
  A dict mapping feature keys to SparseTensors (sparse columns) or
  placeholder Tensors (dense columns).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.make_place_holder_tensors_for_base_features', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.make_place_holder_tensors_for_base_features" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.max_pool2d">
    <p>def <span class="ident">max_pool2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.max_pool2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersmax_pool2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersmax_pool2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.max_pool2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersmax_pool2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a 2D Max Pooling op.
</pre></div>


<p>It is assumed that the pooling is done per image but not in batch or channels.</p>
<p>Args:
  inputs: A 4-D tensor of shape <code>[batch_size, height, width, channels]</code> if
    <code>data_format</code> is <code>NHWC</code>, and <code>[batch_size, channels, height, width]</code> if
    <code>data_format</code> is <code>NCHW</code>.
  kernel_size: A list of length 2: [kernel_height, kernel_width] of the
    pooling kernel over which the op is computed. Can be an int if both
    values are the same.
  stride: A list of length 2: [stride_height, stride_width].
    Can be an int if both strides are the same. Note that presently
    both strides must have the same value.
  padding: The padding method, either 'VALID' or 'SAME'.
  data_format: A string. <code>NHWC</code> (default) and <code>NCHW</code> are supported.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p>
<p>Raises:
  ValueError: if <code>data_format</code> is neither <code>NHWC</code> nor <code>NCHW</code>.
  ValueError: If 'kernel_size' is not a 2-D list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.max_pool2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.max_pool2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.multi_class_target">
    <p>def <span class="ident">multi_class_target</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.multi_class_target(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersmulti_class_target</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersmulti_class_target(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.multi_class_target(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersmulti_class_target</strong></p>
<div class="codehilite"><pre><span></span>Creates a _TargetColumn for multi class single label classification. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-12.
Instructions for updating:
This file will be removed after the deprecation date.Please switch to third_party/tensorflow/contrib/learn/python/learn/estimators/head.py</p>
<p>The target column uses softmax cross entropy loss.</p>
<p>Args:
    n_classes: Integer, number of classes, must be &gt;= 2
    label_name: String, name of the key in label dict. Can be null if label
        is a tensor (single headed models).
    weight_column_name: A string defining feature column name representing
      weights. It is used to down weight or boost examples during training. It
      will be multiplied by the loss of the example.</p>
<p>Returns:
    An instance of _MultiClassTargetColumn.</p>
<p>Raises:
    ValueError: if n_classes is &lt; 2</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.multi_class_target', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.multi_class_target" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_column">
    <p>def <span class="ident">one_hot_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.one_hot_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersone_hot_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersone_hot_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.one_hot_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersone_hot_column</strong></p>
<div class="codehilite"><pre><span></span>Creates an `_OneHotColumn` for a one-hot or multi-hot repr in a DNN.
</pre></div>


<p>Args:
    sparse_id_column: A _SparseColumn which is created by
      <code>sparse_column_with_*</code>
      or crossed_column functions. Note that <code>combiner</code> defined in
      <code>sparse_id_column</code> is ignored.</p>
<p>Returns:
  An _OneHotColumn.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_encoding">
    <p>def <span class="ident">one_hot_encoding</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.one_hot_encoding(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersone_hot_encoding</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersone_hot_encoding(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.one_hot_encoding(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersone_hot_encoding</strong></p>
<div class="codehilite"><pre><span></span>Transform numeric labels into onehot_labels using `tf.one_hot`.
</pre></div>


<p>Args:
  labels: [batch_size] target labels.
  num_classes: total number of classes.
  on_value: A scalar defining the on-value.
  off_value: A scalar defining the off-value.
  outputs_collections: collection to add the outputs.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  one hot encoding of the labels.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_encoding', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.one_hot_encoding" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.optimize_loss">
    <p>def <span class="ident">optimize_loss</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.optimize_loss(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersoptimize_loss</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersoptimize_loss(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.optimize_loss(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersoptimize_loss</strong></p>
<div class="codehilite"><pre><span></span>Given loss and parameters for optimizer, returns a training op.
</pre></div>


<p>Various ways of passing optimizers, include:</p>
<ul>
<li>string, name of the optimizer like 'SGD', 'Adam', see OPTIMIZER_CLS_NAMES
    for full list. E.g. <code>optimize_loss(..., optimizer='Adam')</code>.</li>
<li>function, takes learning rate <code>Tensor</code> as argument and must return
    <code>Optimizer</code> instance. E.g. <code>optimize_loss(...,
    optimizer=lambda lr: tf.train.MomentumOptimizer(lr, momentum=0.5))</code>.
  Alternatively, if <code>learning_rate</code> is <code>None</code>, the function takes no
  arguments. E.g. <code>optimize_loss(..., learning_rate=None,
    optimizer=lambda: tf.train.MomentumOptimizer(0.5, momentum=0.5))</code>.</li>
<li>class, subclass of <code>Optimizer</code> that takes only one required argument -
    learning rate, such as AdamOptimizer, AdagradOptimizer.
    E.g. <code>optimize_loss(..., optimizer=tf.train.AdagradOptimizer)</code>.</li>
<li>object, instance of subclass of <code>Optimizer</code>.
    E.g., <code>optimizer_loss(..., optimizer=tf.train.AdagradOptimizer(0.5))</code>.</li>
</ul>
<p>Args:
  loss: Scalar <code>Tensor</code>.
  global_step: Scalar int <code>Tensor</code>, step counter for each update. If not
               supplied, it will be fetched from the default graph (see
               <code>tf.contrib.framework.get_global_step</code> for details). If it's
               not been created, no step will be incremented with each weight
               update. <code>learning_rate_decay_fn</code> requires <code>global_step</code>.
  learning_rate: float or <code>Tensor</code>, magnitude of update per each training
                 step. Can be <code>None</code>.
  optimizer: string, class or optimizer instance, used as trainer.
             string should be name of optimizer, like 'SGD',
               'Adam', 'Adagrad'. Full list in OPTIMIZER_CLS_NAMES constant.
             class should be sub-class of <code>tf.Optimizer</code> that implements
               <code>compute_gradients</code> and <code>apply_gradients</code> functions.
             optimizer instance should be instantiation of <code>tf.Optimizer</code>
               sub-class and have <code>compute_gradients</code> and <code>apply_gradients</code>
               functions.
  gradient_noise_scale: float or None, adds 0-mean normal noise scaled by this
                        value.
  gradient_multipliers: dict of variables or variable names to floats.
                        If present, gradients for specified
                        variables will be multiplied by given constant.
  clip_gradients: float, callable or <code>None</code>. If float, is provided, a global
    clipping is applied to prevent the norm of the gradient to exceed this
    value. Alternatively, a callable can be provided e.g.: adaptive_clipping.
    This callable takes a <code>list</code> of <code>(gradients, variables)</code> <code>tuple</code>s and
    returns the same thing with the gradients modified.
  learning_rate_decay_fn: function, takes <code>learning_rate</code> and <code>global_step</code>
                          <code>Tensor</code>s, returns <code>Tensor</code>.
                          Can be used to implement any learning rate decay
                          functions.
                          For example: <code>tf.train.exponential_decay</code>.
                          Ignored if <code>learning_rate</code> is not supplied.
  update_ops: list of update <code>Operation</code>s to execute at each step. If <code>None</code>,
              uses elements of UPDATE_OPS collection. The order of execution
              between <code>update_ops</code> and <code>loss</code> is non-deterministic.
  variables: list of variables to optimize or
             <code>None</code> to use all trainable variables.
  name: The name for this operation is used to scope operations and summaries.
  summaries: List of internal quantities to visualize on tensorboard. If not
             set only the loss and the learning rate will be reported. The
             complete list is in OPTIMIZER_SUMMARIES.
  colocate_gradients_with_ops: If True, try colocating gradients with the
                               corresponding op.</p>
<p>Returns:
  Training op.</p>
<p>Raises:
  ValueError: if:
      * <code>loss</code> is an invalid type or shape.
      * <code>global_step</code> is an invalid type or shape.
      * <code>learning_rate</code> is an invalid type or value.
      * <code>optimizer</code> is wrong type.
      * <code>clip_gradients</code> is not float or callable.
      * <code>learning_rate</code> and <code>learning_rate_decay_fn</code> are supplied, but no
        <code>global_step</code> is available.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.optimize_loss', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.optimize_loss" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_examples">
    <p>def <span class="ident">parse_feature_columns_from_examples</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.parse_feature_columns_from_examples(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersparse_feature_columns_from_examples</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersparse_feature_columns_from_examples(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.parse_feature_columns_from_examples(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersparse_feature_columns_from_examples</strong></p>
<div class="codehilite"><pre><span></span>Parses tf.Examples to extract tensors for given feature_columns.
</pre></div>


<p>This is a wrapper of 'tf.parse_example'.</p>
<p>Example:</p>
<p>```python
columns_to_tensor = parse_feature_columns_from_examples(
    serialized=my_data,
    feature_columns=my_features)</p>
<h1>Where my_features are:</h1>
<h1>Define features and transformations</h1>
<p>sparse_feature_a = sparse_column_with_keys(
    column_name="sparse_feature_a", keys=["AB", "CD", ...])</p>
<p>embedding_feature_a = embedding_column(
    sparse_id_column=sparse_feature_a, dimension=3, combiner="sum")</p>
<p>sparse_feature_b = sparse_column_with_hash_bucket(
    column_name="sparse_feature_b", hash_bucket_size=1000)</p>
<p>embedding_feature_b = embedding_column(
    sparse_id_column=sparse_feature_b, dimension=16, combiner="sum")</p>
<p>crossed_feature_a_x_b = crossed_column(
    columns=[sparse_feature_a, sparse_feature_b], hash_bucket_size=10000)</p>
<p>real_feature = real_valued_column("real_feature")
real_feature_buckets = bucketized_column(
    source_column=real_feature, boundaries=[...])</p>
<p>my_features = [embedding_feature_b, real_feature_buckets, embedding_feature_a]
```</p>
<p>Args:
  serialized: A vector (1-D Tensor) of strings, a batch of binary
    serialized <code>Example</code> protos.
  feature_columns: An iterable containing all the feature columns. All items
    should be instances of classes derived from _FeatureColumn.
  name: A name for this operation (optional).
  example_names: A vector (1-D Tensor) of strings (optional), the names of
    the serialized protos in the batch.</p>
<p>Returns:
  A <code>dict</code> mapping FeatureColumn to <code>Tensor</code> and <code>SparseTensor</code> values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_examples', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_examples" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_sequence_examples">
    <p>def <span class="ident">parse_feature_columns_from_sequence_examples</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.parse_feature_columns_from_sequence_examples(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersparse_feature_columns_from_sequence_examples</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersparse_feature_columns_from_sequence_examples(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.parse_feature_columns_from_sequence_examples(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersparse_feature_columns_from_sequence_examples</strong></p>
<div class="codehilite"><pre><span></span>Parses tf.SequenceExamples to extract tensors for given `FeatureColumn`s.
</pre></div>


<p>Args:
  serialized: A scalar (0-D Tensor) of type string, a single serialized
    <code>SequenceExample</code> proto.
  context_feature_columns: An iterable containing the feature columns for
    context features. All items should be instances of classes derived from
    <code>_FeatureColumn</code>. Can be <code>None</code>.
  sequence_feature_columns: An iterable containing the feature columns for
    sequence features. All items should be instances of classes derived from
    <code>_FeatureColumn</code>. Can be <code>None</code>.
  name: A name for this operation (optional).
  example_name: A scalar (0-D Tensor) of type string (optional), the names of
    the serialized proto.</p>
<p>Returns:
  A tuple consisting of:
  context_features: a dict mapping <code>FeatureColumns</code> from
    <code>context_feature_columns</code> to their parsed <code>Tensors</code>/<code>SparseTensor</code>s.
  sequence_features: a dict mapping <code>FeatureColumns</code> from
    <code>sequence_feature_columns</code> to their parsed <code>Tensors</code>/<code>SparseTensor</code>s.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_sequence_examples', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.parse_feature_columns_from_sequence_examples" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.pool">
    <p>def <span class="ident">pool</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.pool(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerspool</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerspool(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.pool(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerspool</strong></p>
<div class="codehilite"><pre><span></span>Adds a pooling op.
</pre></div>


<p>Args:
  inputs: Tensor of rank N+2, of shape
    <code>[batch_size] + input_spatial_shape + [num_channels]</code> if data_format does
    not start with "NC" (default), or
    <code>[batch_size, num_channels] + input_spatial_shape</code> if data_format starts
    with "NC".  Pooling happens over the spatial dimensions only.
  kernel_size: Sequence of N ints &gt;= 1.  Can also be a single integer to
    specify the same value for all spatial dimensions.
  pooling_type: Specifies pooling operation, must be "AVG" or "MAX".
  padding: The padding algorithm, must be "SAME" or "VALID".
  data_format: A string or None.  Specifies whether the channel dimension of
    the <code>input</code> and output is the last dimension (default, or if <code>data_format</code>
    does not start with "NC"), or the second dimension (if <code>data_format</code>
    starts with "NC").  For N=1, the valid values are "NWC" (default) and
    "NCW".  For N=2, the valid values are "NHWC" (default) and "NCHW".  For
    N=3, currently the only valid value is "NDHWC".
  dilation_rate: Optional.  Dilation rate.  Sequence of N ints &gt;= 1.  Defaults
    to [1]<em>N.  Can also be a single integer to specify the same value for all
    spatial dimensions.  If any value of dilation_rate is &gt; 1, then all values
    of stride must be 1.
  stride: Optional.  Sequence of N ints &gt;= 1.  Defaults to [1]</em>N.  Can also be
    a single integer to specify the same value for all spatial dimensions.  If
    any value of stride is &gt; 1, then all values of dilation_rate must be 1.
  outputs_collections: The collections to which the outputs are added.
  scope: Optional scope for name_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the results of the pooling operation.</p>
<p>Raises:
  ValueError: if arguments are invalid.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.pool', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.pool" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.real_valued_column">
    <p>def <span class="ident">real_valued_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.real_valued_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersreal_valued_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersreal_valued_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.real_valued_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersreal_valued_column</strong></p>
<div class="codehilite"><pre><span></span>Creates a `_RealValuedColumn` for dense numeric data.
</pre></div>


<p>Args:
  column_name: A string defining real valued column name.
  dimension: An integer specifying dimension of the real valued column.
    The default is 1. The Tensor representing the _RealValuedColumn
    will have the shape of [batch_size, dimension].
  default_value: A single value compatible with dtype or a list of values
    compatible with dtype which the column takes on during tf.Example parsing
    if data is missing. If None, then tf.parse_example will fail if an example
    does not contain this column. If a single value is provided, the same
    value will be applied as the default value for every dimension. If a
    list of values is provided, the length of the list should be equal to the
    value of <code>dimension</code>.
  dtype: defines the type of values. Default value is tf.float32. Must be a
    non-quantized, real integer or floating point type.
  normalizer: If not None, a function that can be used to normalize the value
    of the real valued column after default_value is applied for parsing.
    Normalizer function takes the input tensor as its argument, and returns
    the output tensor. (e.g. lambda x: (x - 3.0) / 4.2).
Returns:
  A _RealValuedColumn.
Raises:
  TypeError: if dimension is not an int
  ValueError: if dimension is not a positive integer
  TypeError: if default_value is a list but its length is not equal to the
    value of <code>dimension</code>.
  TypeError: if default_value is not compatible with dtype.
  ValueError: if dtype is not convertable to tf.float32.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.real_valued_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.real_valued_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.regression_target">
    <p>def <span class="ident">regression_target</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.regression_target(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersregression_target</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersregression_target(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.regression_target(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersregression_target</strong></p>
<div class="codehilite"><pre><span></span>Creates a _TargetColumn for linear regression. (deprecated)
</pre></div>


<p>THIS FUNCTION IS DEPRECATED. It will be removed after 2016-11-12.
Instructions for updating:
This file will be removed after the deprecation date.Please switch to third_party/tensorflow/contrib/learn/python/learn/estimators/head.py</p>
<p>Args:
    label_name: String, name of the key in label dict. Can be null if label
        is a tensor (single headed models).
    weight_column_name: A string defining feature column name representing
      weights. It is used to down weight or boost examples during training. It
      will be multiplied by the loss of the example.
    label_dimension: dimension of the target for multilabels.</p>
<p>Returns:
    An instance of _TargetColumn</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.regression_target', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.regression_target" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.repeat">
    <p>def <span class="ident">repeat</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.repeat(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersrepeat</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersrepeat(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.repeat(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersrepeat</strong></p>
<div class="codehilite"><pre><span></span>Applies the same layer with the same arguments repeatedly.
</pre></div>


<p>```python
  y = repeat(x, 3, conv2d, 64, [3, 3], scope='conv1')
  # It is equivalent to:</p>
<p>x = conv2d(x, 64, [3, 3], scope='conv1/conv1_1')
  x = conv2d(x, 64, [3, 3], scope='conv1/conv1_2')
  y = conv2d(x, 64, [3, 3], scope='conv1/conv1_3')
```</p>
<p>If the <code>scope</code> argument is not given in <code>kwargs</code>, it is set to
<code>layer.__name__</code>, or <code>layer.func.__name__</code> (for <code>functools.partial</code>
objects). If neither <code>__name__</code> nor <code>func.__name__</code> is available, the
layers are called with <code>scope='stack'</code>.</p>
<p>Args:
  inputs: A <code>Tensor</code> suitable for layer.
  repetitions: Int, number of repetitions.
  layer: A layer with arguments <code>(inputs, *args, **kwargs)</code>
  <em>args: Extra args for the layer.
  </em>*kwargs: Extra kwargs for the layer.</p>
<p>Returns:
  a tensor result of applying the layer, repetitions times.
Raises:
  ValueError: if the op is unknown or wrong.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.repeat', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.repeat" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.safe_embedding_lookup_sparse">
    <p>def <span class="ident">safe_embedding_lookup_sparse</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.safe_embedding_lookup_sparse(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssafe_embedding_lookup_sparse</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssafe_embedding_lookup_sparse(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.safe_embedding_lookup_sparse(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssafe_embedding_lookup_sparse</strong></p>
<div class="codehilite"><pre><span></span>Lookup embedding results, accounting for invalid IDs and empty features.
</pre></div>


<p>The partitioned embedding in <code>embedding_weights</code> must all be the same shape
except for the first dimension. The first dimension is allowed to vary as the
vocabulary size is not necessarily a multiple of <code>P</code>.  <code>embedding_weights</code>
may be a <code>PartitionedVariable</code> as returned by using <code>tf.get_variable()</code> with a
partitioner.</p>
<p>Invalid IDs (&lt; 0) are pruned from input IDs and weights, as well as any IDs
with non-positive weight. For an entry with no features, the embedding vector
for <code>default_id</code> is returned, or the 0-vector if <code>default_id</code> is not supplied.</p>
<p>The ids and weights may be multi-dimensional. Embeddings are always aggregated
along the last dimension.</p>
<p>Args:
  embedding_weights:  A list of <code>P</code> float tensors or values representing
      partitioned embedding tensors.  Alternatively, a <code>PartitionedVariable</code>,
      created by partitioning along dimension 0.  The total unpartitioned
      shape should be <code>[e_0, e_1, ..., e_m]</code>, where <code>e_0</code> represents the
      vocab size and <code>e_1, ..., e_m</code> are the embedding dimensions.
  sparse_ids: <code>SparseTensor</code> of shape <code>[d_0, d_1, ..., d_n]</code> containing the
      ids. <code>d_0</code> is typically batch size.
  sparse_weights: <code>SparseTensor</code> of same shape as <code>sparse_ids</code>, containing
      float weights corresponding to <code>sparse_ids</code>, or <code>None</code> if all weights
      are be assumed to be 1.0.
  combiner: A string specifying how to combine embedding results for each
      entry. Currently "mean", "sqrtn" and "sum" are supported, with "mean"
      the default.
  default_id: The id to use for an entry with no features.
  name: A name for this operation (optional).
  partition_strategy: A string specifying the partitioning strategy.
      Currently <code>"div"</code> and <code>"mod"</code> are supported. Default is <code>"div"</code>.
  max_norm: If not None, all embeddings are l2-normalized to max_norm before
      combining.</p>
<p>Returns:
  Dense tensor of shape <code>[d_0, d_1, ..., d_{n-1}, e_1, ..., e_m]</code>.</p>
<p>Raises:
  ValueError: if <code>embedding_weights</code> is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.safe_embedding_lookup_sparse', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.safe_embedding_lookup_sparse" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.separable_conv2d">
    <p>def <span class="ident">separable_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.separable_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersseparable_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersseparable_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.separable_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersseparable_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a depth-separable 2D convolution with optional batch_norm layer.
</pre></div>


<p>This op first performs a depthwise convolution that acts separately on
channels, creating a variable called <code>depthwise_weights</code>. If <code>num_outputs</code>
is not None, it adds a pointwise convolution that mixes channels, creating a
variable called <code>pointwise_weights</code>. Then, if <code>batch_norm_params</code> is None,
it adds bias to the result, creating a variable called 'biases', otherwise
it adds a batch normalization layer. It finally applies an activation function
to produce the end result.</p>
<p>Args:
  inputs: a tensor of size [batch_size, height, width, channels].
  num_outputs: the number of pointwise convolution output filters. If is
    None, then we skip the pointwise convolution stage.
  kernel_size: a list of length 2: [kernel_height, kernel_width] of
    of the filters. Can be an int if both values are the same.
  depth_multiplier: the number of depthwise convolution output channels for
    each input channel. The total number of depthwise convolution output
    channels will be equal to <code>num_filters_in * depth_multiplier</code>.
  stride: a list of length 2: [stride_height, stride_width], specifying the
    depthwise convolution stride. Can be an int if both strides are the same.
  padding: one of 'VALID' or 'SAME'.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: whether or not the variables should be trainable or not.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the output of the operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.separable_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.separable_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.separable_convolution2d">
    <p>def <span class="ident">separable_convolution2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.separable_convolution2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersseparable_convolution2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersseparable_convolution2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.separable_convolution2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersseparable_convolution2d</strong></p>
<div class="codehilite"><pre><span></span>Adds a depth-separable 2D convolution with optional batch_norm layer.
</pre></div>


<p>This op first performs a depthwise convolution that acts separately on
channels, creating a variable called <code>depthwise_weights</code>. If <code>num_outputs</code>
is not None, it adds a pointwise convolution that mixes channels, creating a
variable called <code>pointwise_weights</code>. Then, if <code>batch_norm_params</code> is None,
it adds bias to the result, creating a variable called 'biases', otherwise
it adds a batch normalization layer. It finally applies an activation function
to produce the end result.</p>
<p>Args:
  inputs: a tensor of size [batch_size, height, width, channels].
  num_outputs: the number of pointwise convolution output filters. If is
    None, then we skip the pointwise convolution stage.
  kernel_size: a list of length 2: [kernel_height, kernel_width] of
    of the filters. Can be an int if both values are the same.
  depth_multiplier: the number of depthwise convolution output channels for
    each input channel. The total number of depthwise convolution output
    channels will be equal to <code>num_filters_in * depth_multiplier</code>.
  stride: a list of length 2: [stride_height, stride_width], specifying the
    depthwise convolution stride. Can be an int if both strides are the same.
  padding: one of 'VALID' or 'SAME'.
  activation_fn: activation function, set to None to skip it and maintain
    a linear activation.
  normalizer_fn: normalization function to use instead of <code>biases</code>. If
    <code>normalizer_fn</code> is provided then <code>biases_initializer</code> and
    <code>biases_regularizer</code> are ignored and <code>biases</code> are not created nor added.
    default set to None for no normalizer function
  normalizer_params: normalization function parameters.
  weights_initializer: An initializer for the weights.
  weights_regularizer: Optional regularizer for the weights.
  biases_initializer: An initializer for the biases. If None skip biases.
  biases_regularizer: Optional regularizer for the biases.
  reuse: whether or not the layer and its variables should be reused. To be
    able to reuse the layer scope must be given.
  variables_collections: optional list of collections for all the variables or
    a dictionay containing a different list of collection per variable.
  outputs_collections: collection to add the outputs.
  trainable: whether or not the variables should be trainable or not.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  A <code>Tensor</code> representing the output of the operation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.separable_convolution2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.separable_convolution2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.sequence_input_from_feature_columns">
    <p>def <span class="ident">sequence_input_from_feature_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sequence_input_from_feature_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssequence_input_from_feature_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssequence_input_from_feature_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sequence_input_from_feature_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssequence_input_from_feature_columns</strong></p>
<div class="codehilite"><pre><span></span>Builds inputs for sequence models from `FeatureColumn`s. (experimental)
</pre></div>


<p>THIS FUNCTION IS EXPERIMENTAL. It may change or be removed at any time, and without warning.</p>
<p>See documentation for <code>input_from_feature_columns</code>. The following types of
  <code>FeatureColumn</code> are permitted in <code>feature_columns</code>: <code>_OneHotColumn</code>,
  <code>_EmbeddingColumn</code>, <code>_HashedEmbeddingColumn</code>, <code>_RealValuedColumn</code>,
  <code>_DataFrameColumn</code>. In addition, columns in <code>feature_columns</code> may not be
  constructed using any of the following: <code>HashedEmbeddingColumn</code>,
  <code>BucketizedColumn</code>, <code>CrossedColumn</code>.</p>
<p>Args:
    columns_to_tensors: A mapping from feature column to tensors. 'string' key
      means a base feature (not-transformed). It can have FeatureColumn as a
      key too. That means that FeatureColumn is already transformed by input
      pipeline. For example, <code>inflow</code> may have handled transformations.
    feature_columns: A set containing all the feature columns. All items in the
      set should be instances of classes derived by FeatureColumn.
    weight_collections: List of graph collections to which weights are added.
    trainable: If <code>True</code> also add variables to the graph collection
      <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
    scope: Optional scope for variable_scope.</p>
<p>Returns:
    A Tensor which can be consumed by hidden layers in the neural network.</p>
<p>Raises:
    ValueError: if FeatureColumn cannot be consumed by a neural network.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.sequence_input_from_feature_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.sequence_input_from_feature_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.shared_embedding_columns">
    <p>def <span class="ident">shared_embedding_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.shared_embedding_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersshared_embedding_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersshared_embedding_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.shared_embedding_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersshared_embedding_columns</strong></p>
<div class="codehilite"><pre><span></span>Creates a list of `_EmbeddingColumn` sharing the same embedding.
</pre></div>


<p>Args:
  sparse_id_columns: An iterable of <code>_SparseColumn</code>, such as those created by
    <code>sparse_column_with_*</code> or crossed_column functions. Note that <code>combiner</code>
    defined in each sparse_id_column is ignored.
  dimension: An integer specifying dimension of the embedding.
  combiner: A string specifying how to reduce if there are multiple entries
    in a single row. Currently "mean", "sqrtn" and "sum" are supported. Each
    of this can be considered an example level normalization on the column:
      * "sum": do not normalize
      * "mean": do l1 normalization
      * "sqrtn": do l2 normalization
    For more information: <code>tf.embedding_lookup_sparse</code>.
  shared_embedding_name: (Optional). A string specifying the name of shared
    embedding weights. This will be needed if you want to reference the shared
    embedding separately from the generated <code>_EmbeddingColumn</code>.
  initializer: A variable initializer function to be used in embedding
    variable initialization. If not specified, defaults to
    <code>tf.truncated_normal_initializer</code> with mean 0.0 and standard deviation
    1/sqrt(sparse_id_columns[0].length).
  ckpt_to_load_from: (Optional). String representing checkpoint name/pattern
    to restore the column weights. Required if <code>tensor_name_in_ckpt</code> is not
    None.
  tensor_name_in_ckpt: (Optional). Name of the <code>Tensor</code> in the provided
    checkpoint from which to restore the column weights. Required if
    <code>ckpt_to_load_from</code> is not None.</p>
<p>Returns:
  A tuple of <code>_EmbeddingColumn</code> with shared embedding space.</p>
<p>Raises:
  ValueError: if sparse_id_columns is empty, or its elements are not
    compatible with each other.
  TypeError: if <code>sparse_id_columns</code> is not a sequence or is a string. If at
    least one element of <code>sparse_id_columns</code> is not a <code>SparseTensor</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.shared_embedding_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.shared_embedding_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.softmax">
    <p>def <span class="ident">softmax</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.softmax(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssoftmax</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssoftmax(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.softmax(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssoftmax</strong></p>
<div class="codehilite"><pre><span></span>Performs softmax on Nth dimension of N-dimensional logit tensor.
</pre></div>


<p>For two-dimensional logits this reduces to tf.nn.softmax. The N-th dimension
needs to have a specified number of elements (number of classes).</p>
<p>Args:
  logits: N-dimensional <code>Tensor</code> with logits, where N &gt; 1.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  a <code>Tensor</code> with same shape and type as logits.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.softmax', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.softmax" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_hash_bucket">
    <p>def <span class="ident">sparse_column_with_hash_bucket</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_column_with_hash_bucket(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssparse_column_with_hash_bucket</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssparse_column_with_hash_bucket(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_column_with_hash_bucket(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssparse_column_with_hash_bucket</strong></p>
<div class="codehilite"><pre><span></span>Creates a _SparseColumn with hashed bucket configuration.
</pre></div>


<p>Use this when your sparse features are in string or integer format, but you
don't have a vocab file that maps each value to an integer ID.
output_id = Hash(input_feature_string) % bucket_size</p>
<p>Args:
  column_name: A string defining sparse column name.
  hash_bucket_size: An int that is &gt; 1. The number of buckets.
  combiner: A string specifying how to reduce if the sparse column is
    multivalent. Currently "mean", "sqrtn" and "sum" are supported, with
    "sum" the default:
      * "sum": do not normalize features in the column
      * "mean": do l1 normalization on features in the column
      * "sqrtn": do l2 normalization on features in the column
    For more information: <code>tf.embedding_lookup_sparse</code>.
  dtype: The type of features. Only string and integer types are supported.</p>
<p>Returns:
  A _SparseColumn with hashed bucket configuration</p>
<p>Raises:
  ValueError: hash_bucket_size is not greater than 2.
  ValueError: dtype is neither string nor integer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_hash_bucket', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_hash_bucket" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_integerized_feature">
    <p>def <span class="ident">sparse_column_with_integerized_feature</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_column_with_integerized_feature(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssparse_column_with_integerized_feature</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssparse_column_with_integerized_feature(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_column_with_integerized_feature(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssparse_column_with_integerized_feature</strong></p>
<div class="codehilite"><pre><span></span>Creates an integerized _SparseColumn.
</pre></div>


<p>Use this when your features are already pre-integerized into int64 IDs.
output_id = input_feature</p>
<p>Args:
  column_name: A string defining sparse column name.
  bucket_size: An int that is &gt; 1. The number of buckets. It should be bigger
    than maximum feature. In other words features in this column should be an
    int64 in range [0, bucket_size)
  combiner: A string specifying how to reduce if the sparse column is
    multivalent. Currently "mean", "sqrtn" and "sum" are supported, with
    "sum" the default:
      * "sum": do not normalize features in the column
      * "mean": do l1 normalization on features in the column
      * "sqrtn": do l2 normalization on features in the column
    For more information: <code>tf.embedding_lookup_sparse</code>.
  dtype: Type of features. It should be an integer type. Default value is
    dtypes.int64.</p>
<p>Returns:
  An integerized _SparseColumn definition.</p>
<p>Raises:
  ValueError: bucket_size is not greater than 1.
  ValueError: dtype is not integer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_integerized_feature', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_integerized_feature" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_keys">
    <p>def <span class="ident">sparse_column_with_keys</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_column_with_keys(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssparse_column_with_keys</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssparse_column_with_keys(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_column_with_keys(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssparse_column_with_keys</strong></p>
<div class="codehilite"><pre><span></span>Creates a _SparseColumn with keys.
</pre></div>


<p>Look up logic is as follows:
lookup_id = index_of_feature_in_keys if feature in keys else default_value</p>
<p>Args:
  column_name: A string defining sparse column name.
  keys: a string list defining vocabulary.
  default_value: The value to use for out-of-vocabulary feature values.
    Default is -1.
  combiner: A string specifying how to reduce if the sparse column is
    multivalent. Currently "mean", "sqrtn" and "sum" are supported, with
    "sum" the default:
      * "sum": do not normalize features in the column
      * "mean": do l1 normalization on features in the column
      * "sqrtn": do l2 normalization on features in the column
    For more information: <code>tf.embedding_lookup_sparse</code>.</p>
<p>Returns:
  A _SparseColumnKeys with keys configuration.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_keys', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_column_with_keys" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.sparse_feature_cross">
    <p>def <span class="ident">sparse_feature_cross</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_feature_cross(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssparse_feature_cross</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssparse_feature_cross(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sparse_feature_cross(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssparse_feature_cross</strong></p>
<div class="codehilite"><pre><span></span>Crosses a list of Tensor or SparseTensor objects. (deprecated arguments)
</pre></div>


<p>SOME ARGUMENTS ARE DEPRECATED. They will be removed after 2016-11-20.
Instructions for updating:
The default behavior of sparse_feature_cross is changing, the default
value for hash_key will change to SPARSE_FEATURE_CROSS_DEFAULT_HASH_KEY.
From that point on sparse_feature_cross will always use FingerprintCat64
to concatenate the feature fingerprints. And the underlying
_sparse_feature_cross_op.sparse_feature_cross operation will be marked
as deprecated.</p>
<p>See sparse_feature_cross_kernel.cc for more details.</p>
<p>Args:
    inputs: List of <code>SparseTensor</code> or <code>Tensor</code> to be crossed.
    hashed_output: If true, returns the hash of the cross instead of the string.
      This will allow us avoiding string manipulations.
    num_buckets: It is used if hashed_output is true.
      output = hashed_value%num_buckets if num_buckets &gt; 0 else hashed_value.
    name: A name prefix for the returned tensors (optional).
    hash_key: Specify the hash_key that will be used by the <code>FingerprintCat64</code>
      function to combine the crosses fingerprints on SparseFeatureCrossOp.
      The default value is None, but will become
      SPARSE_FEATURE_CROSS_DEFAULT_HASH_KEY after 2016-11-20 (optional).</p>
<p>Returns:
    A <code>SparseTensor</code> with the crossed features.
    Return type is string if hashed_output=False, int64 otherwise.</p>
<p>Raises:
    TypeError: If the inputs aren't either SparseTensor or Tensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_feature_cross', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.sparse_feature_cross" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.stack">
    <p>def <span class="ident">stack</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.stack(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersstack</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersstack(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.stack(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersstack</strong></p>
<div class="codehilite"><pre><span></span>Builds a stack of layers by applying layer repeatedly using stack_args.
</pre></div>


<p><code>stack</code> allows you to repeatedly apply the same operation with different
arguments <code>stack_args[i]</code>. For each application of the layer, <code>stack</code> creates
a new scope appended with an increasing number. For example:</p>
<p>```python
  y = stack(x, fully_connected, [32, 64, 128], scope='fc')
  # It is equivalent to:</p>
<p>x = fully_connected(x, 32, scope='fc/fc_1')
  x = fully_connected(x, 64, scope='fc/fc_2')
  y = fully_connected(x, 128, scope='fc/fc_3')
```</p>
<p>If the <code>scope</code> argument is not given in <code>kwargs</code>, it is set to
<code>layer.__name__</code>, or <code>layer.func.__name__</code> (for <code>functools.partial</code>
objects). If neither <code>__name__</code> nor <code>func.__name__</code> is available, the
layers are called with <code>scope='stack'</code>.</p>
<p>Args:
  inputs: A <code>Tensor</code> suitable for layer.
  layer: A layer with arguments <code>(inputs, *args, **kwargs)</code>
  stack_args: A list/tuple of parameters for each call of layer.
  **kwargs: Extra kwargs for the layer.</p>
<p>Returns:
  a <code>Tensor</code> result of applying the stacked layers.</p>
<p>Raises:
  ValueError: if the op is unknown or wrong.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.stack', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.stack" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.sum_regularizer">
    <p>def <span class="ident">sum_regularizer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sum_regularizer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssum_regularizer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssum_regularizer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.sum_regularizer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssum_regularizer</strong></p>
<div class="codehilite"><pre><span></span>Returns a function that applies the sum of multiple regularizers.
</pre></div>


<p>Args:
  regularizer_list: A list of regularizers to apply.
  scope: An optional scope name</p>
<p>Returns:
  A function with signature <code>sum_reg(weights)</code> that applies the
  sum of all the input regularizers.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.sum_regularizer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.sum_regularizer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activation">
    <p>def <span class="ident">summarize_activation</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_activation(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssummarize_activation</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssummarize_activation(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_activation(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssummarize_activation</strong></p>
<div class="codehilite"><pre><span></span>Summarize an activation.
</pre></div>


<p>This applies the given activation and adds useful summaries specific to the
activation.</p>
<p>Args:
  op: The tensor to summarize (assumed to be a layer activation).
Returns:
  The summary op created to summarize <code>op</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activation', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activation" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activations">
    <p>def <span class="ident">summarize_activations</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_activations(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssummarize_activations</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssummarize_activations(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_activations(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssummarize_activations</strong></p>
<div class="codehilite"><pre><span></span>Summarize activations, using `summarize_activation` to summarize.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activations', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_activations" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.summarize_collection">
    <p>def <span class="ident">summarize_collection</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_collection(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssummarize_collection</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssummarize_collection(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_collection(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssummarize_collection</strong></p>
<div class="codehilite"><pre><span></span>Summarize a graph collection of tensors, possibly filtered by name.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_collection', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_collection" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensor">
    <p>def <span class="ident">summarize_tensor</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_tensor(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssummarize_tensor</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssummarize_tensor(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_tensor(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssummarize_tensor</strong></p>
<div class="codehilite"><pre><span></span>Summarize a tensor using a suitable summary type.
</pre></div>


<p>This function adds a summary op for <code>tensor</code>. The type of summary depends on
the shape of <code>tensor</code>. For scalars, a <code>scalar_summary</code> is created, for all
other tensors, <code>histogram_summary</code> is used.</p>
<p>Args:
  tensor: The tensor to summarize
  tag: The tag to use, if None then use tensor's op's name.</p>
<p>Returns:
  The summary op created or None for string tensors.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensor', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensor" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensors">
    <p>def <span class="ident">summarize_tensors</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_tensors(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerssummarize_tensors</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerssummarize_tensors(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.summarize_tensors(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerssummarize_tensors</strong></p>
<div class="codehilite"><pre><span></span>Summarize a set of tensors.
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensors', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.summarize_tensors" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.transform_features">
    <p>def <span class="ident">transform_features</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.transform_features(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layerstransform_features</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layerstransform_features(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.transform_features(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layerstransform_features</strong></p>
<div class="codehilite"><pre><span></span>Returns transformed features based on features columns passed in.
</pre></div>


<p>Example:</p>
<p>```python
columns_to_tensor = transform_features(features=features,
                                       feature_columns=feature_columns)</p>
<h1>Where my_features are:</h1>
<h1>Define features and transformations</h1>
<p>sparse_feature_a = sparse_column_with_keys(
    column_name="sparse_feature_a", keys=["AB", "CD", ...])</p>
<p>embedding_feature_a = embedding_column(
    sparse_id_column=sparse_feature_a, dimension=3, combiner="sum")</p>
<p>sparse_feature_b = sparse_column_with_hash_bucket(
    column_name="sparse_feature_b", hash_bucket_size=1000)</p>
<p>embedding_feature_b = embedding_column(
    sparse_id_column=sparse_feature_b, dimension=16, combiner="sum")</p>
<p>crossed_feature_a_x_b = crossed_column(
    columns=[sparse_feature_a, sparse_feature_b], hash_bucket_size=10000)</p>
<p>real_feature = real_valued_column("real_feature")
real_feature_buckets = bucketized_column(
    source_column=real_feature, boundaries=[...])</p>
<p>feature_columns = [embedding_feature_b,
                   real_feature_buckets,
                   embedding_feature_a]
```</p>
<p>Args:
  features: A dictionary of features.
  feature_columns: An iterable containing all the feature columns. All items
    should be instances of classes derived from _FeatureColumn.</p>
<p>Returns:
  A <code>dict</code> mapping FeatureColumn to <code>Tensor</code> and <code>SparseTensor</code> values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.transform_features', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.transform_features" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.unit_norm">
    <p>def <span class="ident">unit_norm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.unit_norm(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersunit_norm</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersunit_norm(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.unit_norm(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersunit_norm</strong></p>
<div class="codehilite"><pre><span></span>Normalizes the given input across the specified dimension to unit length.
</pre></div>


<p>Note that the rank of <code>input</code> must be known.</p>
<p>Args:
  inputs: A <code>Tensor</code> of arbitrary size.
  dim: The dimension along which the input is normalized.
  epsilon: A small value to add to the inputs to avoid dividing by zero.
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  The normalized <code>Tensor</code>.</p>
<p>Raises:
  ValueError: If dim is smaller than the number of dimensions in 'inputs'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.unit_norm', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.unit_norm" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.variance_scaling_initializer">
    <p>def <span class="ident">variance_scaling_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.variance_scaling_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersvariance_scaling_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersvariance_scaling_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.variance_scaling_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersvariance_scaling_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer that generates tensors without scaling variance.
</pre></div>


<p>When initializing a deep network, it is in principle advantageous to keep
the scale of the input variance constant, so it does not explode or diminish
by reaching the final layer. This initializer use the following formula:</p>
<p>```python
  if mode='FAN_IN': # Count only number of input connections.
    n = fan_in
  elif mode='FAN_OUT': # Count only number of output connections.
    n = fan_out
  elif mode='FAN_AVG': # Average number of inputs and output connections.
    n = (fan_in + fan_out)/2.0</p>
<div class="codehilite"><pre><span></span>truncated_normal(shape, 0.0, stddev=sqrt(factor / n))
</pre></div>


<p>```</p>
<ul>
<li>To get <a href="http://arxiv.org/pdf/1502.01852v1.pdf">Delving Deep into Rectifiers</a>, use (Default):<br/>
  <code>factor=2.0 mode='FAN_IN' uniform=False</code></li>
<li>To get <a href="http://arxiv.org/abs/1408.5093">Convolutional Architecture for Fast Feature Embedding</a>, use:<br/>
  <code>factor=1.0 mode='FAN_IN' uniform=True</code></li>
<li>To get <a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Understanding the difficulty of training deep feedforward neural
  networks</a>,
  use:<br/>
  <code>factor=1.0 mode='FAN_AVG' uniform=True.</code></li>
<li>To get <code>xavier_initializer</code> use either:<br/>
  <code>factor=1.0 mode='FAN_AVG' uniform=True</code>, or<br/>
  <code>factor=1.0 mode='FAN_AVG' uniform=False</code>.</li>
</ul>
<p>Args:
  factor: Float.  A multiplicative factor.
  mode: String.  'FAN_IN', 'FAN_OUT', 'FAN_AVG'.
  uniform: Whether to use uniform or normal distributed random initialization.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer that generates tensors with unit variance.</p>
<p>Raises:
  ValueError: if <code>dtype</code> is not a floating point type.
  TypeError: if <code>mode</code> is not in ['FAN_IN', 'FAN_OUT', 'FAN_AVG'].</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.variance_scaling_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.variance_scaling_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sparse_column">
    <p>def <span class="ident">weighted_sparse_column</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.weighted_sparse_column(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersweighted_sparse_column</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersweighted_sparse_column(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.weighted_sparse_column(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersweighted_sparse_column</strong></p>
<div class="codehilite"><pre><span></span>Creates a _SparseColumn by combining sparse_id_column with a weight column.
</pre></div>


<p>Example:</p>
<p><code>python
  sparse_feature = sparse_column_with_hash_bucket(column_name="sparse_col",
                                                  hash_bucket_size=1000)
  weighted_feature = weighted_sparse_column(sparse_id_column=sparse_feature,
                                            weight_column_name="weights_col")</code></p>
<p>This configuration assumes that input dictionary of model contains the
  following two items:
    * (key="sparse_col", value=sparse_tensor) where sparse_tensor is
      a SparseTensor.
    * (key="weights_col", value=weights_tensor) where weights_tensor
      is a SparseTensor.
   Following are assumed to be true:
     * sparse_tensor.indices = weights_tensor.indices
     * sparse_tensor.shape = weights_tensor.shape</p>
<p>Args:
  sparse_id_column: A <code>_SparseColumn</code> which is created by
    <code>sparse_column_with_*</code> functions.
  weight_column_name: A string defining a sparse column name which represents
    weight or value of the corresponding sparse id feature.
  dtype: Type of weights, such as <code>tf.float32</code>
Returns:
  A _WeightedSparseColumn composed of two sparse features: one represents id,
  the other represents weight (value) of the id feature in that example.
Raises:
  ValueError: if dtype is not convertible to float.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sparse_column', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sparse_column" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sum_from_feature_columns">
    <p>def <span class="ident">weighted_sum_from_feature_columns</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.weighted_sum_from_feature_columns(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersweighted_sum_from_feature_columns</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersweighted_sum_from_feature_columns(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.weighted_sum_from_feature_columns(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersweighted_sum_from_feature_columns</strong></p>
<div class="codehilite"><pre><span></span>A tf.contrib.layer style linear prediction builder based on FeatureColumns.
</pre></div>


<p>Generally a single example in training data is described with feature columns.
This function generates weighted sum for each num_outputs. Weighted sum refers
to logits in classification problems. It refers to prediction itself for
linear regression problems.</p>
<p>Example:</p>
<p><code># Building model for training
  feature_columns = (
      real_valued_column("my_feature1"),
      ...
  )
  columns_to_tensor = tf.parse_example(...)
  logits = weighted_sum_from_feature_columns(
      columns_to_tensors=columns_to_tensor,
      feature_columns=feature_columns,
      num_outputs=1)
  loss = tf.nn.sigmoid_cross_entropy_with_logits(logits, labels)</code></p>
<p>Args:
  columns_to_tensors: A mapping from feature column to tensors. 'string' key
    means a base feature (not-transformed). It can have FeatureColumn as a
    key too. That means that FeatureColumn is already transformed by input
    pipeline. For example, <code>inflow</code> may have handled transformations.
  feature_columns: A set containing all the feature columns. All items in the
    set should be instances of classes derived from FeatureColumn.
  num_outputs: An integer specifying number of outputs. Default value is 1.
  weight_collections: List of graph collections to which weights are added.
  trainable: If <code>True</code> also add variables to the graph collection
    <code>GraphKeys.TRAINABLE_VARIABLES</code> (see tf.Variable).
  scope: Optional scope for variable_scope.</p>
<p>Returns:
  A tuple containing:</p>
<div class="codehilite"><pre><span></span>* A Tensor which represents predictions of a linear model.
* A dictionary which maps feature_column to corresponding Variable.
* A Variable which is used for bias.
</pre></div>


<p>Raises:
  ValueError: if FeatureColumn cannot be used for linear predictions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sum_from_feature_columns', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.weighted_sum_from_feature_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer">
    <p>def <span class="ident">xavier_initializer</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.xavier_initializer(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersxavier_initializer</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersxavier_initializer(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.xavier_initializer(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersxavier_initializer</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer performing &quot;Xavier&quot; initialization for weights.
</pre></div>


<p>This function implements the weight initialization from:</p>
<p>Xavier Glorot and Yoshua Bengio (2010):
         Understanding the difficulty of training deep feedforward neural
         networks. International conference on artificial intelligence and
         statistics.</p>
<p>This initializer is designed to keep the scale of the gradients roughly the
same in all layers. In uniform distribution this ends up being the range:
<code>x = sqrt(6. / (in + out)); [-x, x]</code> and for normal distribution a standard
deviation of <code>sqrt(3. / (in + out))</code> is used.</p>
<p>Args:
  uniform: Whether to use uniform or normal distributed random initialization.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer for a weight matrix.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer_conv2d">
    <p>def <span class="ident">xavier_initializer_conv2d</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>THIS METHOD IS AUTOMATICALLY GENERATED</p>
<div class="codehilite"><pre><span></span>LayerBuilder.xavier_initializer_conv2d(*args, **kwargs)
</pre></div>


<p>It accepts the same arguments as <code>tf.contrib.layersxavier_initializer_conv2d</code>. 
However, the 1st argument is omitted, a partial with the rest of the arguments is returned which expects the 1st argument such that</p>
<div class="codehilite"><pre><span></span>tf.contrib.layersxavier_initializer_conv2d(x1, *args, **kwargs)
</pre></div>


<p>is equivalent to</p>
<div class="codehilite"><pre><span></span>LayerBuilder.xavier_initializer_conv2d(*args, **kwargs)(x1)
</pre></div>


<p><strong>tf.contrib.layersxavier_initializer_conv2d</strong></p>
<div class="codehilite"><pre><span></span>Returns an initializer performing &quot;Xavier&quot; initialization for weights.
</pre></div>


<p>This function implements the weight initialization from:</p>
<p>Xavier Glorot and Yoshua Bengio (2010):
         Understanding the difficulty of training deep feedforward neural
         networks. International conference on artificial intelligence and
         statistics.</p>
<p>This initializer is designed to keep the scale of the gradients roughly the
same in all layers. In uniform distribution this ends up being the range:
<code>x = sqrt(6. / (in + out)); [-x, x]</code> and for normal distribution a standard
deviation of <code>sqrt(3. / (in + out))</code> is used.</p>
<p>Args:
  uniform: Whether to use uniform or normal distributed random initialization.
  seed: A Python integer. Used to create random seeds. See
    <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a>
    for behavior.
  dtype: The data type. Only floating point types are supported.</p>
<p>Returns:
  An initializer for a weight matrix.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer_conv2d', this);">Show source &equiv;</a></p>
  <div id="source-tensorbuilder.patches.layers_patch.LayerBuilder.xavier_initializer_conv2d" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_return_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_return_type</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThenAt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
